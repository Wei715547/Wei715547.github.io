<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Leet Code1~500持续更新 | WeiBlog</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://Wei715547.github.io/favicon.ico?v=1614933940513">
<link rel="stylesheet" href="https://Wei715547.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="LeetCode题库
排序查找算法、冒泡/选择/插入/快排/二分查找
/// 
/// 冒泡排序
/// 
/// 
public static void BubbleSort(int [] nums)
{
for (int i = 0; ..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://Wei715547.github.io">
        <img src="https://Wei715547.github.io/images/avatar.png?v=1614933940513" class="site-logo">
        <h1 class="site-title">WeiBlog</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            总览
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/Wei715547" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
          <a class="social-link" href="https://space.bilibili.com/29363247" target="_blank">
            <i class="fab fa-twitter"></i>
          </a>
        
      
        
          <a class="social-link" href="https://weibo.com/u/5612050622" target="_blank">
            <i class="fab fa-weibo"></i>
          </a>
        
      
        
      
        
      
    </div>
    <div class="site-description">
      年月增长，我宜强盛。
用于Unity+开发的技术积累
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://Wei715547.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">Leet Code1~500持续更新</h2>
            <div class="post-date">2021-01-02</div>
            
            <div class="post-content" v-pre>
              <p><a href ="https://leetcode-cn.com/problemset/all/"><strong>LeetCode题库</strong></a><br>
<strong>排序查找算法、冒泡/选择/插入/快排/二分查找</strong><br>
/// <summary><br>
/// 冒泡排序<br>
/// </summary><br>
/// <param name="array"></param><br>
public static void BubbleSort(int [] nums)<br>
{<br>
for (int i = 0; i &lt; nums.Length; i++)<br>
{<br>
for (int j = 0; j &lt; nums.Length-1-i; j++)<br>
{<br>
if (nums[j] &gt; nums[j + 1])<br>
Swap(ref nums[j], ref nums[j + 1]);<br>
}<br>
}<br>
}<br>
/// <summary><br>
/// 选择排序：默认第一个为最小值，在后面找到更小的时就和默认最小的交换。再默认第二个为最小往下循环。<br>
/// </summary><br>
/// <param name="array"></param><br>
static void ChooseSort(int[] array)<br>
{<br>
for (int i = 0; i &lt; array.Length-1; i++)<br>
{<br>
int minnum = array[i];<br>
int minindex = i;<br>
for (int j = i+1; j &lt; array.Length; j++)<br>
{<br>
if(array[j]&lt;minnum)<br>
{<br>
minnum = array[j];<br>
minindex = j;<br>
}<br>
}<br>
if(minindex!=i)<br>
{<br>
int temp = array[i];<br>
array[i] = minnum;<br>
array[minindex] = temp;<br>
}<br>
}<br>
}<br>
/// <summary><br>
/// 直插排序<br>
/// </summary><br>
/// <param name="array"></param><br>
public static void InsertSort2(int[] nums)<br>
{<br>
int index, value;<br>
for (int i = 1; i &lt; nums.Length; i++)<br>
{<br>
value = nums[i];<br>
index = i-1;<br>
while(index&gt;=0&amp;&amp;nums[index]&gt;value)<br>
{<br>
nums[index+1] = nums[index];<br>
index -= 1;<br>
}<br>
nums[index+1] = value;<br>
}<br>
}<br>
//快速排序<br>
static void Qsort(int[] array,int left,int right)<br>
{<br>
if(left&lt;right)<br>
{<br>
int i = left;<br>
int j = right + 1;<br>
int provt = array[i];<br>
do<br>
{<br>
do i++; while (array[i] &lt; provt &amp;&amp; i &lt; array.Length-1);<br>
do j--; while (array[j] &gt; provt &amp;&amp; j &gt;= 0);<br>
if(i&lt;j)<br>
{<br>
Swap(ref array[i], ref array[j]);<br>
}<br>
} while (i&lt;j);<br>
Swap(ref array[left], ref array[j]);<br>
Qsort(array, left, j - 1);<br>
Qsort(array, j + 1, right);<br>
}<br>
}<br>
//二分查找<br>
static int BinarySearch_R(int[] dateArray, int x, int left, int right)<br>
{<br>
if (left &lt;= right)<br>
{<br>
int mind = (left + right) / 2;<br>
if (x &lt; dateArray[mind])<br>
return BinarySearch_R(dateArray, x, left, mind - 1);<br>
else if (x &gt; dateArray[mind])<br>
return BinarySearch_R(dateArray, x, mind + 1, right);<br>
else if (x == dateArray[mind])<br>
return mind;<br>
}<br>
return -1;<br>
}<br>
<strong>/// 三数之和</strong><br>
public static List&lt;List<int>&gt; ThreeSum(int[] nums)<br>
{<br>
List&lt;List<int>&gt; res = new List&lt;List<int>&gt;();//返回值<br>
Array.Sort<int>(nums);//对数组进行排序<br>
if (nums == null || nums[0] &gt;= 0 || nums.Length &lt; 3) return res;//数组为空，排序后最小值大于0，长度小于3，则没有结果返回空列表<br>
for (int i = 0; i &lt; nums.Length-2; i++)//外部总循环次数小于长度减2，由于包含satrt与end两个位置指针<br>
{<br>
if(i<mark>0||nums[i]!=nums[i-1])//首次循环或不重复时执行<br>
{<br>
int start = i + 1;//左指针较小的值，结果小于0时右移<br>
int end = nums.Length - 1;//右指针较大的值，结果大于0时向左移<br>
while(start&lt;end)//内循环左指针小于右指针<br>
{<br>
if (nums[i] + nums[start] + nums[end] == 0)//满足条件将结果加入返回列表<br>
{<br>
res.Add(new List<int> { nums[i], nums[start], nums[end] });<br>
start++;//左指针右移<br>
end--;//右指针左移//寻找其他满足条件的组合<br>
while (start &lt; end &amp;&amp; nums[start] == nums[start - 1])//保证不与之前的值重复<br>
start++;<br>
while (start &lt; end &amp;&amp; nums[end] == nums[end + 1])//保证不与之前的值重复<br>
end--;<br>
}else if(nums[i] + nums[start] + nums[end]&lt;0)//小于0，start右移到更大的数<br>
{<br>
start++;<br>
}else//大于0，end左移到更小的数<br>
{<br>
end--;<br>
}<br>
}<br>
}<br>
}<br>
return res;<br>
}<br>
/// <summary><br>
** /// 19:删除链表d第n个节点**<br>
/// </summary><br>
/// <param name="head"></param><br>
/// <param name="n"></param><br>
/// <returns></returns><br>
public ListNode RemoveNthFromEnd(ListNode head, int n)<br>
{<br>
if (head == null || head.next == null) return null;<br>
ListNode dummy = new ListNode();<br>
dummy.next = head;<br>
ListNode l = dummy;<br>
ListNode r = dummy;<br>
for (int i = 0; i &lt; n; i++)<br>
{<br>
r = r.next;<br>
}<br>
while(r.next!=null)<br>
{<br>
l = l.next;<br>
r = r.next;<br>
}<br>
l.next = l.next.next;<br>
return dummy.next;<br>
}<br>
<strong>20.有效括号(B站面试题)</strong><br>
/// <summary><br>
/// 有效括号<br>
/// </summary><br>
class LeetCode20<br>
{<br>
public static bool IsValid(string s)<br>
{<br>
Stack<char> st = new Stack<char>();<br>
foreach (char c in s)<br>
{<br>
if(c</mark>'('||c=='['||c=='{')<br>
{<br>
st.Push(c);<br>
}else<br>
{<br>
if (st.Count == 0)<br>
return false;<br>
else<br>
{<br>
char temp = st.Pop();<br>
if (c == ')')<br>
{<br>
if (temp != '(')<br>
return false;<br>
}<br>
else if (c == ']')<br>
{<br>
if (temp != '[')<br>
return false;<br>
}<br>
else if (c == '}')<br>
{<br>
if (temp != '{')<br>
return false;<br>
}<br>
}<br>
}<br>
}<br>
return st.Count == 0;<br>
}<br>
}<br>
/// <summary><br>
/// 移除元素：给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。<br>
/// </summary><br>
class LC27<br>
{<br>
//将与val相等的值都移动到数组最右边，<br>
public static int RemoveEle(int [] nums,int value)<br>
{<br>
if (nums == null || nums.Length == 0)<br>
return 0;<br>
int l = 0;<br>
int r = nums.Length - 1;<br>
while(l&lt;r)<br>
{<br>
while(l&lt;r&amp;&amp;nums[l]!=value)//左指针找与val相等的值<br>
{<br>
l++;<br>
}<br>
while(l&lt;r&amp;&amp;nums[r]==value)//右指针找与val不相等的值<br>
{<br>
r--;<br>
}<br>
int temp = nums[l];<br>
nums[l] = nums[r];<br>
nums[r] = temp;<br>
}<br>
return nums[l] == value ? l : l + 1;//最后一个与val相等的值先被左指针找到，左指针位置的索引即移除val后的，前面元素的长度(数组从0开始)。<br>
最后与val相等的值先被右指针找到，则l指向的即是不重复元素的中一个元素，数组索引值比实际长度小1，即返回l+1<br>
}<br>
}<br>
<strong>————————————————————————————————————</strong><br>
<strong>48.旋转图像</strong><br>
class LC48<br>
{<br>
public static void rotate(int[][] matrix)<br>
{<br>
int n = matrix[0].Length;<br>
if (n == 0 || n == 1) return;</p>
<pre><code>        for (int start = 0, end = n - 1; start &lt; end; start++, end--)
        { //控制旋转层数（不断缩小圈的范围）
            int s = start; int e = end;
            while (s &lt; end)
            { //完成一圈的旋转
                int temp = matrix[start][s]; //temp&lt;-左上角值
                matrix[start][s] = matrix[e][start]; //左上角&lt;-左下角
                matrix[e][start] = matrix[end][e];  //左下角&lt;-右下角
                matrix[end][e] = matrix[s][end];  //右下角&lt;-右上角
                matrix[s][end] = temp; //右上角&lt;-temp
                s++; e--; //向右平移该层的圈
            }
        }
    }
}
</code></pre>
<p><strong>————————————————————————————————————</strong><br>
<strong>49.字母异为词分组</strong><br>
class LC49<br>
{<br>
public static List&lt;List<string>&gt; GroupAnagrams(string[] strs)<br>
{<br>
//可变字符串：存储排序后的字符数组转为字符串<br>
StringBuilder key = new StringBuilder();<br>
//字典：键：排序后相同的字符(串有相同字符组成)，值：由相同字符组成的字符串数组<br>
Dictionary&lt;string, List<string>&gt; strsGroupDict = new Dictionary&lt;string, List<string>&gt;();<br>
//遍历字符串数组中每个字符串<br>
foreach (string s in strs)<br>
{<br>
char[] temp = s.ToCharArray();//字符串转为字符数组，用于排序<br>
Array.Sort(temp);//调用数组类静态排序方法<br>
key.Clear();//添加前先请空可变字符串<br>
foreach (char c in temp)//将字符数组的每个字符添加到可变字符串<br>
{<br>
key.Append(c);<br>
}<br>
if (!strsGroupDict.ContainsKey(key.ToString()))//判断字典的键中是否包含此排序后的字符串<br>
{<br>
//不包含则新建键值对，键：此排序后的字符串，值：新建字符串可变数组(存储由相同字符组成的字符串)<br>
strsGroupDict.Add(key.ToString(), new List<string>());<br>
}<br>
//创建后/或已经存在键的情况下，将当前字符添加到可变数组中<br>
strsGroupDict[key.ToString()].Add(s);<br>
}<br>
return new List&lt;List<string>&gt;(strsGroupDict.Values);//返回数组类表，即字典的所有值<br>
}<br>
}<br>
<strong>LC53.最大子数组和</strong><br>
/// <summary><br>
/// 给定一个整数数组 nums ，<br>
/// 找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>
/// </summary><br>
class LC53最大子数组和<br>
{<br>
public int MaxSubArray(int[] nums)<br>
{<br>
if (nums == null || nums.Length == 0)<br>
return 0;</p>
<pre><code>        int res = nums[0];
        int sum = 0;
        foreach (int n in nums)
        {
            if (sum &gt; 0)//都为正数时所有元素和即为最大
                sum += n;//连续数相加的最大值，小于0时说明有负数加入，
            else//都为负数时即得到最大的负数
                sum = n;//出现和小于0有负数加入，找到下一个从正数开始的元素
            res = Math.Max(res, sum);//每次填入一个数时会取res，sum最大的值
        }
        return res;
    }
}
/// &lt;summary&gt;
    /// 动态规划
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;nums&quot;&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public static int Maxsubarray2(int[] nums)
    {
        List&lt;int&gt; memolist = new List&lt;int&gt;();//动态规划列表
        memolist.Add(nums[0]);
        for (int i = 1; i &lt; nums.Length; i++)            
            memolist.Add(Math.Max(nums[i] + memolist[i - 1], nums[i]));//判断当前元素计入子数组和后，与当前元素值比较，取大值决定计入总和还是从当前开始
        memolist.Sort((a, b) =&gt; a &gt; b?-1:1);//取动态规划数组中的最大值返回，避免首位就值最大
        return memolist[0];
    }
</code></pre>
<p><strong>//128.最长连续序列</strong><br>
public static int LongestConsecutive(int[] nums)<br>
{<br>
if (nums == null || nums.Length == 0) return 0;</p>
<pre><code>        Array.Sort(nums);//排序后去重
        HashSet&lt;int&gt; set = new HashSet&lt;int&gt;();//使用集合不要求在原数组中连续
        for (int i = 0; i &lt; nums.Length; i++)
        {
            set.Add(nums[i]);
        }

        List&lt;int&gt; reslist = new List&lt;int&gt;();//结果列表，长度即为返回值
        int res = 1;//数组长度大于0则至少返回1；
        foreach (int n in set)
        {
            if (reslist.Count!=0 &amp;&amp; reslist[reslist.Count - 1] + 1 == n)//不为空且连续时，计入返回列表
            {
                reslist.Add(n);
                res = Math.Max(res, reslist.Count);//取返回列表长度最大值
            }
            else
            {
                reslist.Clear();//不连续时清空，重新计入
                reslist.Add(n);
            }
        }
        return res;
    }
</code></pre>
<p><strong>//134.加油站</strong><br>
public int CanCompleteCircuit(int[] gas, int[] cost)<br>
{<br>
int allgas = 0;<br>
int allcast = 0;<br>
for (int i = 0; i &lt; gas.Length; i++)<br>
{<br>
allgas += gas[i];<br>
allcast += cost[i];<br>
}<br>
if (allgas &lt; allcast) return -1;<br>
int gascurten = 0;<br>
int start = 0;<br>
for (int i = 0; i &lt; gas.Length; i++)<br>
{<br>
gascurten = gascurten + gas[i] - cost[i];<br>
if (gascurten &lt; 0)<br>
{<br>
gascurten = 0;<br>
start = i + 1;<br>
}<br>
}<br>
return start;<br>
}<br>
<strong>//152.乘积最大子数组</strong><br>
public static int MaxSubProduct(int[]nums)<br>
{<br>
List<int> memomax = new List<int>();<br>
List<int> memomin = new List<int>();<br>
memomax.Add(nums[0]);<br>
memomin.Add(nums[0]);<br>
for (int i = 1; i &lt; nums.Length; i++)<br>
{<br>
memomax.Add(Math.Max(Math.Max(nums[i]*memomax[i - 1], nums[i]*memomin[i-1]), nums[i]));<br>
memomin.Add(Math.Min( Math.Min(nums[i] * memomin[i - 1],nums[i]*memomax[i-1]), nums[i]));<br>
}<br>
memomax.Sort();<br>
return memomax[memomax.Count - 1];<br>
}<br>
<strong>// 153. 寻找旋转排序数组中的最小值</strong><br>
:假设按照升序排序的数组在预先未知的某个点上进行了旋转。例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] 。<br>
public int FindMin(int[] nums)<br>
{<br>
//长度为1或未旋转时返回首位<br>
if (nums.Length == 1 || nums[nums.Length - 1] &gt; nums[0]) return nums[0];<br>
//二分查找<br>
int left = 0;<br>
int right = nums.Length - 1;</p>
<pre><code>        while(left&lt;right)
        {
            int mid = left + (right - left) / 2;//中间值索引

            if (nums[mid] &gt; nums[mid + 1])//中间值恰好为旋转前的末尾最大值，则mid+1即为最小值
                return nums[mid + 1];
            else if (nums[mid] &lt; nums[mid - 1])//中间值恰好指向旋转前的最小值，则返回m
                return nums[mid];
            else if (nums[mid] &gt; nums[left])//其他情况mid落在旋转后的两端数组中间时
                left = mid + 1;//mid比left大则落在左半边，最小值在右边
            else
                right = mid - 1;//mid比left小则落在右半边，最小值在左边
        }
        return nums[0];//语法条件返回值无意义
    }
</code></pre>
<p><strong>class LC54螺旋矩阵</strong><br>
{<br>
public List<int> SpiralOrder(int[][] matrix)<br>
{<br>
if (matrix == null || matrix.Length == 0) return new List<int>();</p>
<pre><code>        //数组边界值
        int top = 0,left = 0;
        int bottom = matrix.Length - 1, right = matrix[0].Length - 1;

        int direction = 1;//1,2,3,4：右下左上
        List&lt;int&gt; res = new List&lt;int&gt;();
        while (left &lt;= right &amp;&amp; top &lt;= bottom)
        {
            switch (direction)
            {
                case 1://右移
                        for (int i = left; i &lt;= right; i++)//从左到右遍历
                            res.Add(matrix[top][i]);//第一行从左到右加入返回列表
                        top += 1;//第一行遍历结束加一到下一行
                        direction = 2;
                    break;
                case 2://下移
                        for (int i = top; i &lt;= bottom; i++)//从上到下遍历
                            res.Add(matrix[i][right]);//最后一列从上到下
                        right -= 1;//左后一列遍历后减1，下次遍历前一列
                        direction = 3;
                    break;
                case 3://左移
                        for (int i = right; i &gt;=left ; i--)//从右到左遍历
                            res.Add(matrix[bottom][i]);//最后一行从右到左遍历
                        bottom -= 1;//遍历结束，下次从右到左遍历上一行
                        direction = 4;
                    break;
                case 4://上移
                        for (int i = bottom; i &gt;=top ; i--)//从下到上遍历
                            res.Add(matrix[i][left]);//第一列从下到上遍历，
                        left += 1;//下次从下到上遍历下一列
                        direction = 1;
                    break;
            }
        }
        return res;
    }
}
</code></pre>
<p>** // 55.跳跃游戏** ,贪心算法：maxjunp初始为最大索引，当前一个索引与此数组索引值相加大于maxump时则一定可以到达maxjump,maxjump一道前一个索引位置，最后判断maxjump是否等于0则返回true否则说明中间断开返回false<br>
public bool Jump(int [] nums)<br>
{<br>
int maxjump = nums.Length;<br>
for (int i = nums.Length-2; i &gt;=0 ; i--)<br>
{<br>
if (i + nums[i] &gt;= maxjump)<br>
maxjump = i;<br>
}<br>
return maxjump == 0 ? true : false;<br>
}</p>
<p><strong>class LC62不同路径</strong><br>
{<br>
/// <summary><br>
/// 动态规划，dp[m,n] = dp[m-1,n]+dp[m,n-1];<br>
/// </summary><br>
/// <param name="m"></param><br>
/// <param name="n"></param><br>
/// <returns></returns><br>
public int UniquePaths(int m, int n)<br>
{<br>
int[,] dp = new int[m,n];<br>
dp[0,0] = 1;<br>
for (int i = 0; i &lt; m; i++)<br>
{<br>
for (int j = 0; j &lt; n; j++)<br>
{<br>
if (i - 1 &gt;= 0 &amp;&amp; i - 1 &lt; m)<br>
dp[i, j] += dp[i - 1,j];<br>
if (j - 1 &gt;= 0 &amp;&amp; j - 1 &lt; n)<br>
dp[i, j] += dp[i, j - 1];<br>
}<br>
}<br>
return dp[m - 1, n - 1];</p>
<pre><code>    }
}
public int UniquePath2(int m, int n)
    {
        int[,] dp = new int[m, n];
        for (int i = 0; i &lt; m; i++)
            dp[i, 0] = 1;
        for (int i = 0; i &lt; n; i++)
            dp[0, n] = 1;
        for (int i = 1; i &lt; m; i++)
        {
            for (int j = 1; j &lt; n; j++)
            {
                dp[i, j] = dp[i, j - 1] + dp[i - 1, j];
            }
        }
        return dp[m - 1, n - 1];
    }
</code></pre>
<p><strong>66.加一</strong><br>
public int[] PlusOne(int[] digits)<br>
{<br>
for (int i = digits.Length - 1; i &gt;= 0; i--)<br>
{<br>
if (digits[i] != 9)<br>
{<br>
digits[i] += 1;<br>
return digits;<br>
}<br>
else<br>
digits[i] = 0;<br>
}<br>
List<int> res = new List<int>(digits);<br>
res.Insert(0, 1);<br>
return res.ToArray();<br>
}<br>
<strong>70.爬楼梯</strong><br>
public int ClimbStairs(int n)<br>
{<br>
if (n &lt; 2) return 1;<br>
int[] res = new int[n];<br>
res[0] = 1;<br>
res[1] = 2;<br>
for (int i = 2; i &lt; n; i++)<br>
{<br>
res[i] = res[i - 1] + res[i - 2];<br>
}<br>
return res[n - 1];<br>
}<br>
<strong>//73,矩阵置0</strong><br>
public void SetZeroes(int[][] matrix)<br>
{<br>
bool firstoColContentZero = false;<br>
bool firstoRowContentZero = false;<br>
//检测第一列是否有0<br>
for (int i = 0; i &lt; matrix.Length; i++)<br>
{<br>
if (matrix[i][0] == 0)<br>
firstoColContentZero = true;<br>
}<br>
//检查第一行是否有0<br>
for (int i = 0; i &lt; matrix[0].Length; i++)<br>
{<br>
if (matrix[0][i] == 0)<br>
firstoRowContentZero = true;<br>
}<br>
//使用第一行与第一列标记0<br>
for (int i = 1; i &lt; matrix.Length; i++)<br>
{<br>
for (int j = 1; j &lt; matrix[0].Length; j++)<br>
{<br>
if(matrix[i][j]==0)<br>
{<br>
matrix[i][0] = 0;<br>
matrix[0][j] = 0;<br>
}<br>
}<br>
}<br>
//使用第一行列中的0处理矩阵中的元素<br>
for (int i = 1; i &lt; matrix.Length; i++)<br>
{<br>
for (int j = 1; j &lt; matrix[0].Length; j++)<br>
{<br>
if (matrix[i][0] == 0 || matrix[0][j] == 0)<br>
matrix[i][j] = 0;<br>
}<br>
}<br>
//首行存在0，本行全部置为0<br>
if(firstoRowContentZero)<br>
{<br>
for (int i = 0; i &lt; matrix[0].Length; i++)<br>
{<br>
matrix[0][i] = 0;<br>
}<br>
}<br>
//首列存在0，本列全部置为0<br>
if(firstoColContentZero)<br>
{<br>
for (int i = 0; i &lt; matrix.Length; i++)<br>
{<br>
matrix[i][0] = 0;<br>
}<br>
}<br>
}<br>
<strong>//83.删除链表重复元素</strong><br>
public ListNode DeleteDuplicates(ListNode head)<br>
{<br>
if (head == null) return head;<br>
HashSet<int> set = new HashSet<int>();<br>
ListNode res = new ListNode();<br>
res.next = head;<br>
ListNode pov = new ListNode();<br>
pov.next = head;<br>
while (head != null)<br>
{<br>
if (!set.Contains(head.val))<br>
{<br>
set.Add(head.val);<br>
head = head.next;<br>
pov = pov.next;<br>
}<br>
else<br>
{<br>
pov.next = head.next;<br>
head = head.next;<br>
}<br>
}<br>
return res.next;<br>
}<br>
//链表为排好序的链表<br>
public ListNode DeleteDuplicates2(ListNode head)<br>
{<br>
if (head == null || head.next == null) return head;<br>
ListNode res = new ListNode();<br>
res.next = head;<br>
while (head != null &amp;&amp; head.next != null)<br>
{<br>
if (head.val == head.next.val)<br>
{<br>
head.next = head.next.next;<br>
}<br>
else<br>
head = head.next;<br>
}<br>
return res.next;<br>
}<br>
<strong>class LC74搜索矩阵</strong><br>
{<br>
/// <summary><br>
/// 二分法，一维，二维数组索引转换<br>
/// </summary><br>
/// <param name="matrix"></param><br>
/// <param name="target"></param><br>
/// <returns></returns><br>
public bool SearchMatrix(int[][] matrix, int target)<br>
{<br>
if (matrix == null || matrix.Length == 0) return false;</p>
<pre><code>        int row = matrix.Length;
        int col = matrix[0].Length;
        int l = 0;
        int r = row * col - 1;
        while(l&lt;=r)
        {
            int mid = l + (r - l) / 2;
            int ele = matrix[mid / col][mid % col];//一维索引二维
            if (ele == target)
                return true;
            else if (ele &gt; target)
                r = mid;
            else
                l = mid + 1;
        }
        return false;
    }
}
</code></pre>
<p><strong>————————————————————————————————————</strong><br>
<strong>78/90.子集</strong><br>
/// <summary><br>
/// 子集<br>
/// </summary><br>
class LC78<br>
{<br>
/// <summary><br>
/// SubsetI<br>
/// </summary><br>
/// <param name="nums"></param><br>
/// <returns></returns><br>
public static List&lt;List<int>&gt; Subset(int[] nums)<br>
{<br>
List&lt;List<int>&gt; res = new List&lt;List<int>&gt;();<br>
res.Add(new List<int> { });<br>
foreach (int  n in nums)<br>
{<br>
int resLength = res.Count;<br>
for (int i = 0; i &lt; resLength; i++)<br>
{<br>
List<int> cur = new List<int>(res[i]);<br>
cur.Add(n);<br>
res.Add(cur);<br>
}<br>
}<br>
return res;<br>
}<br>
/// <summary><br>
/// SubsetII<br>
/// </summary><br>
/// <param name="nums"></param><br>
/// <returns></returns><br>
public static List&lt;List<int >&gt; SubsetsWithDup(int [] nums)<br>
{<br>
List&lt;List<int>&gt; res = new List&lt;List<int>&gt;();<br>
res.Add(new List<int> {});<br>
Array.Sort<int>(nums);<br>
foreach (int n in nums)<br>
{<br>
int resLength = res.Count;<br>
for (int i = 0; i &lt; resLength; i++)<br>
{<br>
List<int> cur = new List<int>(res[i]);<br>
cur.Add(n);<br>
res.Add(cur);<br>
}<br>
}<br>
List&lt;List<int>&gt; resLast = new List&lt;List<int>&gt;();</p>
<pre><code>        foreach (List&lt;int&gt; list in res)
        {
            if (!Contants(resLast, list))
            {
                resLast.Add(list);
            }
        }
        return resLast;

    }
    public static bool Contants(List&lt;List&lt;int&gt;&gt; res,List&lt;int&gt; slist)
    {
        if (res.Count == 0) return false;
        bool conts = false;
        foreach (var item in res)
        {
            if (CpList(item, slist))
                conts = true;
        }
        return conts;
    }

    public static bool CpList(List&lt;int&gt; l1,List&lt;int&gt; l2)
    {
        bool res = true;
        if (l1.Count != l2.Count)
            return false;
        else
        {                
            for (int i = 0; i &lt; l1.Count; i++)
            {
                if (l1[i] != l2[i])
                    res = false;
            }
        }

        return res;
    }
}
</code></pre>
<p><strong>//121.买股票的最佳时机</strong><br>
public int MaxProfit(int[] prices)<br>
{<br>
if (prices == null || prices.Length == 0) return 0;<br>
int minp = prices[0];<br>
int maxp = 0;<br>
for (int i = 1; i &lt; prices.Length; i++)<br>
{<br>
if (prices[i] &lt; minp)<br>
minp = prices[i];<br>
else if (prices[i] - minp &gt; maxp)<br>
maxp = prices[i] - minp;<br>
}<br>
return maxp;<br>
}<br>
<strong>//122.买股票的最佳时机II</strong><br>
public static int MaxProfitII(int[] prices)<br>
{<br>
if (prices == null || prices.Length == 0) return 0;</p>
<pre><code>        int allprice = 0;
        int lop = prices[0], top = prices[0];
        int i = 0;
        while(i&lt;prices.Length-1)
        {
            while (i&lt;prices.Length-1 &amp;&amp; prices[i] &gt;= prices[i + 1])
                i += 1;
            lop = i;
            while (i &lt; prices.Length - 1 &amp;&amp; prices[i] &lt; prices[i + 1])
                i += 1;
            top = i;
            allprice += prices[top] - prices[lop];
        }
        return allprice;
    }
</code></pre>
<p><strong>class _141环形链表</strong><br>
{<br>
public bool HasCycle(ListNode head)<br>
{<br>
if (head == null || head.next == null)<br>
{<br>
return false;<br>
}</p>
<pre><code>        ListNode slow = head;
        ListNode fast = head.next;
        while (slow != fast)
        {
            if (fast == null || fast.next == null)
            {
                return false;
            }
            slow = slow.next;
            fast = fast.next.next;
        }
        return true;
    }
}
</code></pre>
<p><strong>//160.相交链表</strong><br>
public ListNode GetIntersectionNode(ListNode headA, ListNode headB)<br>
{<br>
if (headA == null || headB == null) return null;<br>
HashSet<ListNode> list = new HashSet<ListNode>();<br>
while(headA!=null)<br>
{<br>
list.Add(headA);<br>
headA = headA.next;<br>
}<br>
while(headB!=null)<br>
{<br>
if (!list.Contains(headB))<br>
{<br>
list.Add(headB);<br>
headB = headB.next;<br>
}<br>
else<br>
return headB;<br>
}<br>
return null;<br>
}<br>
<strong>class LC162寻找峰值</strong><br>
{<br>
/// <summary><br>
/// 峰值元素是指其值大于左右相邻值的元素。二分法<br>
/// </summary><br>
/// <param name="nums"></param><br>
/// <returns></returns><br>
public static int FindPeakElement(int[] nums)<br>
{<br>
if (nums == null || nums.Length == 0) return -1;</p>
<pre><code>        int l = 0;
        int r = nums.Length - 1;
        while (l&lt;r)
        {
            int mid = (r + l) / 2;
            //中间值右边的数小于mid则极值在左边，反之极值在右边
            if (nums[mid] &gt; nums[mid + 1])
                r = mid;
            else 
                l = mid + 1;
        }
        return l;
    }
}
</code></pre>
<p>#region 查找最大重复值<br>
//static Dictionary&lt;int, int&gt; dic = new Dictionary&lt;int, int&gt;();</p>
<pre><code>    //方法1：利用字典统计数组元素出现的次数。元素作为键，值存储数显次数。
    static int SearchMaxRepet1(int[] array)
    {
        Dictionary&lt;int, int&gt; dic = new Dictionary&lt;int, int&gt;();
        int hrefLength = array.Length / 2;

        for (int i = 0; i &lt; array.Length; i++)
        {
            if (!dic.ContainsKey(array[i]))
                dic.Add(array[i], 0);
        }

        for (int i = 0; i &lt; array.Length; i++)
        {
            dic[array[i]] += 1;
        }
        foreach (int k in dic.Keys)
        {
            if (dic[k] &gt; hrefLength)
                return k;
        }
        return -1;
    }
    //方法2：排序发，排序后重复最多的值补丁集中在数组中间。
    static int SearchMaxRepet2(int[] array)
    {
        QSort(new List&lt;int&gt;(array),0,array.Length-1);
        return array[array.Length / 2];
    }
    //分治法
    static int SearchMaxRepet3(int[] nums)
    {
        return GetMajority(nums, 0, nums.Length - 1);
    }
    /// &lt;summary&gt;
    /// 分治法，获取众数
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;nums&quot;&gt;&lt;/param&gt;
    /// &lt;param name=&quot;left&quot;&gt;&lt;/param&gt;
    /// &lt;param name=&quot;right&quot;&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    static int GetMajority(int [] nums,int left,int right)
    {
        if (left == right)//分为只有衣蛾元素时返回
            return nums[left];

        int mid = left + (right - left) / 2;//师爷咱们还是对半分
        int leftMajority = GetMajority(nums, 0, mid);//左半边的中数
        int rightMajority = GetMajority(nums, mid+1, right);//右半边的中数

        if (leftMajority == rightMajority)//左右众数相同 则返回其中任意一个
            return leftMajority;
        //不相同则，则遍历数组统计该递归层左右那边众数出现的次数多
        int leftCount = 0;
        int rightCount = 0;
        for (int i = left; i &lt;=right; i++)
        {
            if (nums[i] == leftMajority)
                leftCount++;
            else if (nums[i] == rightMajority)
                rightCount++;
        }

        return leftCount &gt; rightCount ? leftMajority : rightMajority;
    }
    #endregion
</code></pre>
<p><strong>————————————————————————————————————</strong><br>
<strong>179.最大数(网易面试题)</strong><br>
/// <summary><br>
///179： 给定一组非负整数 nums，重新排列它们每个数字的顺序（每个数字不可拆分）使之组成一个最大的整数。<br>
/// 用List对string进行排序<br>
/// </summary><br>
/// <param name="nums"></param><br>
/// <returns></returns><br>
public static string LargestNum2(int[] nums)<br>
{<br>
if (nums == null) return &quot;&quot;;<br>
if (nums.Length == 1) return nums[0].ToString();</p>
<pre><code>        List&lt;string&gt; numsList = new List&lt;string&gt;();
        for (int i = 0; i &lt; nums.Length; i++)
        {
            numsList.Add(nums[i].ToString());
        }                       
        numsList.Sort((a, b) =&gt; { return (b + a).CompareTo(a + b); });
    
        if (numsList[0].Equals(&quot;0&quot;)) return &quot;0&quot;;
        else return  string.Join(&quot;&quot;,numsList.ToArray());
    }
</code></pre>
<p>/// </summary><br>
///字符依次前后相加对比，结果大的放在前面<br>
/// <param name="nums"></param><br>
/// <returns></returns><br>
/// <summary><br>
<strong>179.普通方法</strong><br>
public static string LargestNum(int[] nums)<br>
{<br>
if (nums == null) return &quot;&quot;;<br>
if (nums.Length == 1) return nums[0].ToString();<br>
string[] st = new string[nums.Length];<br>
//StringBuilder s = new StringBuilder();<br>
for (int i = 0; i &lt; nums.Length; i++)<br>
{<br>
st[i] = nums[i].ToString();<br>
}<br>
for (int i = 0; i &lt; st.Length; i++)<br>
{<br>
for (int j = i+1; j &lt; st.Length; j++)<br>
{<br>
if((st[i]+st[j]).CompareTo(st[j]+st[i])&lt;0)<br>
//s1.CompareTo(s2):<br>
//s1&gt;s2: 1<br>
//s1=s2: 0<br>
//s1&lt;s2: -1<br>
{<br>
Swap(ref st[i], ref st[j]);<br>
}<br>
}<br>
}<br>
/<em>foreach (string item in st)<br>
{<br>
s.Append(item);<br>
}<br>
return s.ToString();</em>/<br>
if (nums[0].Equals(&quot;0&quot;)) return &quot;0&quot;;<br>
else return string.Join(&quot;-&quot;, st);//使用字符连接字符串数组，返回连接后的字符<br>
}<br>
<strong>187.重复的DNA序列</strong><br>
public static List<string> FindRepeatedDnaSequences2(string s)<br>
{<br>
List<string> res = new List<string>();<br>
if (s == null || s.Length &lt; 11) return res;<br>
Dictionary&lt;string, int&gt; dic = new Dictionary&lt;string, int&gt;();<br>
//StringBuilder ele = new StringBuilder();<br>
int i = 0;<br>
while(i+10&lt;=s.Length)<br>
{<br>
/<em>ele.Clear();<br>
ele.Append(s.Substring(i, 10));</em>/<br>
string ele = s.Substring(i, 10);<br>
if (!dic.ContainsKey(ele.ToString()))<br>
dic.Add(ele.ToString(), 1);<br>
else if(!res.Contains(ele))<br>
res.Add(ele.ToString());<br>
i++;<br>
}<br>
return res;<br>
}<br>
<strong>//200.岛屿数量</strong><br>
/// <summary><br>
/// 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。<br>
/// </summary><br>
/// <param name="grid"></param><br>
/// <returns> 岛屿数量，遍历二维数值，找到1后岛屿数量加1，然后深度优先DFS将与1上下左右相连的1递归变为0。之后继续遍历数组找1</returns><br>
public static int CountIsland(char[][]grid)<br>
{<br>
if (grid == null || grid.Length == 0)<br>
return 0;<br>
int row = grid.Length;<br>
int col = grid[0].Length;<br>
int count = 0;<br>
for (int i = 0; i &lt; row; i++)<br>
{<br>
for (int j = 0; j &lt; col; j++)<br>
{<br>
if (grid[i][j] == '1')<br>
{<br>
count++;<br>
DFS(grid, i, j);<br>
}<br>
}<br>
}<br>
return count;<br>
}<br>
static void DFS(char[][] grid,int i,int j)<br>
{<br>
if(i&lt;0||j&lt;0||i&gt;=grid.Length||j&gt;=grid[0].Length||grid[i][j]=='0')<br>
{<br>
return;<br>
}<br>
grid[i][j] = '0';<br>
DFS(grid, i + 1, j);<br>
DFS(grid, i - 1, j);<br>
DFS(grid, i, j + 1);<br>
DFS(grid, i, j - 1);<br>
}<br>
<strong>//695.岛屿最大面积</strong><br>
public int MaxIsLandAre(int[][]grid)<br>
{<br>
if (grid == null || grid.Length == 0)<br>
return 0;<br>
int res = 0;<br>
for (int i = 0; i &lt; grid.Length; i++)<br>
{<br>
for (int j = 0; j &lt; grid[0].Length; j++)<br>
{<br>
if(grid[i][j]==1)<br>
{<br>
int curentAre = DFS2(grid,i,j);<br>
res = Math.Max(res, curentAre);<br>
}<br>
}<br>
}<br>
return res;<br>
}<br>
public int DFS2(int[][]grid,int i,int j)<br>
{<br>
if (i &lt; 0 || j &lt; 0 || i &gt;= grid.Length || j &gt;= grid[0].Length || grid[i][j] ==0)<br>
{<br>
return 0;<br>
}<br>
grid[i][j] = 0;<br>
int are = 1;<br>
are += DFS2(grid, i + 1, j);<br>
are += DFS2(grid, i , j+1);<br>
are += DFS2(grid, i - 1, j);<br>
are += DFS2(grid, i , j-1);<br>
return are;</p>
<pre><code>    }
}
</code></pre>
<p>//219：重复元素2：数组中存在相同元素，且索引值之差绝对值之多为k(小于等于)<br>
public bool ContainsNearbyDuplicate(int[] nums, int k)<br>
{<br>
Dictionary&lt;int, int&gt; dic = new Dictionary&lt;int, int&gt;();<br>
for (int i = 0; i &lt; nums.Length; i++)<br>
{<br>
if (dic.ContainsKey(nums[i]) &amp;&amp; (i - dic[nums[i]] &lt;= k))<br>
return true;<br>
else<br>
dic[nums[i]] = i;<br>
}<br>
return false;<br>
}<br>
//198<br>
public int Rob(int[] nums)<br>
{<br>
if (nums.Length == 0) return 0;<br>
if (nums.Length == 1) return nums[0];</p>
<pre><code>        int p2 = nums[0];
        int p1 = Math.Max(nums[0], nums[1]);
        for (int i = 2; i &lt; nums.Length; i++)
        {
            int temp = Math.Max(nums[i] + p2,p1);
            p2 = p1;
            p1 = temp;
        }
        return p1;
    }
</code></pre>
<p><strong>206.反转链表</strong><br>
class LC206<br>
{<br>
public static ListNode ReversList(ListNode head)<br>
{<br>
ListNode dummy = new ListNode();<br>
dummy.next = head;<br>
while(head!=null||head.next!=null)<br>
{<br>
ListNode next = head.next;<br>
ListNode temp = dummy.next;<br>
head.next = head.next.next;<br>
dummy.next = next;<br>
next.next = temp;<br>
}<br>
return dummy.next;</p>
<pre><code>    }
    public static ListNode ReversList2(ListNode head)
    {
        if (head == null || head.next == null)
            return head;
        //返回末尾节点
        ListNode res = ReversList2(head.next);
        //节点指向反转：递归栈先入后出，先返回最后递归层的末尾节点
        head.next.next = head;
        head.next = null;

        return res;
    }
}
</code></pre>
<p><strong>————————————————————————————————————</strong><br>
/// <summary><br>
<strong>209.长度最小的子数组</strong><br>
/// 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，<br>
/// 并返回其长度。如果不存在符合条件的子数组，返回 0。<br>
/// </summary><br>
class LC209<br>
{<br>
/// <summary><br>
/// 暴力法，可能输出的值即为1~数组最大长度，长度为n时如存在连续n个数的和&gt;=s，则返回长度n<br>
/// </summary><br>
/// <param name="s"></param><br>
/// <param name="nums"></param><br>
/// <returns></returns><br>
public static int MinSubArrayLen1(int s, int[] nums)<br>
{<br>
if (nums == null || nums.Length == 0)<br>
return 0;<br>
int size = 1;<br>
while(size&lt;=nums.Length)<br>
{<br>
for (int i = 0; i &lt; nums.Length-size+1;i++)<br>
{<br>
int total = 0;<br>
for (int j = i; j &lt; i+size; j++)<br>
{<br>
total += nums[j];<br>
}<br>
if (total &gt;= s)<br>
return size;<br>
}<br>
size++;<br>
}<br>
return 0;<br>
}<br>
/// <summary><br>
/// 滑动窗口法/双指针法<br>
/// </summary><br>
/// <param name="s"></param><br>
/// <param name="nums"></param><br>
/// <returns></returns><br>
public static int MinSubArrayLen2(int s, int[] nums)<br>
{<br>
if (nums == null || nums.Length == 0)<br>
return 0;<br>
int i = 0;//左指针<br>
int j = 0;//右指针<br>
int result = nums.Length + 1;//返回结果默不可能比数组长度长，不变则不存在返回0<br>
int total = 0;//窗口内数字的和<br>
while (j&lt;nums.Length)<br>
{<br>
total += nums[j];//计算窗口内数字和<br>
j++;//右指针滑动<br>
while(total&gt;=s)//当窗口内数字和&gt;=给定值时，更新返回值取最小长度<br>
{<br>
result = Math.Min(result, j - i);</p>
<pre><code>                total -= nums[i];//左指针开始移动，
                i++;
                //和仍大于等于给定时时继续移动，小于则退出循环，移动有指针
            }
        }//j移动到末尾时循环结束
        return result == nums.Length + 1 ? 0 : result;//长度未更新则不存在返回0，更新则为最小值
    }
}
</code></pre>
<p><strong>————————————————————————————————————</strong><br>
<strong>217.重复元素</strong><br>
/// <summary><br>
/// 给定一个整数数组，判断是否存在重复元素。<br>
/// 如果任意一值在数组中出现至少两次，函数返回 true 。<br>
/// 如果数组中每个元素都不相同，则返回 false<br>
/// </summary><br>
class LC217重复元素<br>
{<br>
/// <summary><br>
/// 排序法，排序后存在两个相邻的数相同即存在重复的数<br>
/// </summary><br>
/// <param name="nums"></param><br>
/// <returns></returns><br>
public static bool ContainsDuplicate(int[] nums)<br>
{<br>
if (nums == null || nums.Length == 0)<br>
return false;<br>
Array.Sort(nums);<br>
//方式1<br>
/<em>int i = 0;<br>
int j = i + 1;<br>
while(j&lt;nums.Length)<br>
{<br>
if (nums[i] == nums[j])<br>
return true;<br>
i++;<br>
j++;<br>
}</em>/<br>
//方式2<br>
int prev = nums[0];<br>
for (int i = 1; i &lt; nums.Length; i++)<br>
{<br>
if (nums[i] == prev)<br>
return true;<br>
else<br>
prev = nums[i];<br>
}<br>
return false;<br>
}</p>
<pre><code>    /// &lt;summary&gt;
    /// Set法，集合无法添加重复的元素，
    /// 添加完成后集合长度与原数组长度不相等即存在重复的元素
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;nums&quot;&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public static bool ContainsDuplicate2(int [] nums)
    {
        HashSet&lt;int&gt; set = new HashSet&lt;int&gt;(nums);
        return nums.Length == set.Count ? false : true;
    }
    /// &lt;summary&gt;
    /// 字典法，通过字典统计各元素出现的次数，存在次数大于1,
    /// 即有值重复出现
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;nums&quot;&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public static bool ContainsDuplicate3(int[] nums)
    {
        Dictionary&lt;int, int&gt; dic = new Dictionary&lt;int, int&gt;();
        foreach (int  n in nums)
        {
            if(!dic.ContainsKey(n))
            {
                dic.Add(n, 1);
            }else
            {
                dic[n] += 1;
            }
        }
        foreach (var item in dic.Values)
        {
            if (item &gt; 1)
                return true;
        }
        return false;
    }
}
</code></pre>
<p><strong>//125.回文字符串</strong><br>
public static bool IsPalindrome(string s)<br>
{<br>
string str = Regex.Replace(s, &quot;[^A-Za-z0-9]&quot;, &quot;&quot;).ToLower();<br>
Console.WriteLine(str);<br>
char[] array = str.ToCharArray();<br>
Array.Reverse(array);<br>
return str.Equals(new string(array));<br>
}<br>
<strong>————————————————————————————————————</strong><br>
<strong>234.回文链表</strong><br>
/// <summary><br>
/// 请判断一个链表是否为回文链表。回文正反相同的，1；121；1221.<br>
/// </summary><br>
class LC234回文链表<br>
{<br>
/// <summary><br>
/// 双指针法，由于链表中不能向前移动，所以先将链表中的数，加到数组中<br>
/// 然后左右指针向中间一定进行对比<br>
/// </summary><br>
/// <param name="head"></param><br>
/// <returns></returns><br>
public static bool IsPalindrome(ListNode head)<br>
{<br>
if (head == null || head.next == null)<br>
return true;<br>
List<int> list = new List<int>();<br>
while (head != null)<br>
{<br>
list.Add(head.val);<br>
head = head.next;<br>
}<br>
int l = 0;<br>
int r = list.Count - 1;<br>
while(l&lt;r)<br>
{<br>
if (!list[l].Equals(list[r]))//Equals比较的是值==比较的是索引可能不同<br>
return false;<br>
l++;<br>
r--;<br>
}<br>
return true;<br>
}</p>
<pre><code>    /// &lt;summary&gt;
    /// 递归双指针法，全局变量指向头结点，递归到最后一个节点，
    /// 比较最后一个节点与当前p指向的头结点，不想同则返回false，相同p向后移动，返回true
    /// 回到上一层递归对比最后一个节点之前的节点，与当前p值不同则返回false，相同p继续向后移返回true
    /// 继续回到上一层递归及其没有出现不等则返回true
    /// &lt;/summary&gt;
    static ListNode p = new ListNode();
    public static bool IsPalindrome2(ListNode head)
    {
        p = head;
        return Recursion(head);
    }
    public static bool Recursion(ListNode head)
    {
        if (head == null)
            return true;
        if (!Recursion(head.next))
            return false;

        if (p.val != head.val)
            return false;
        p = p.next;
        return true;
    }
    /// &lt;summary&gt;
    /// 栈，将链表节点压入栈，弹出反序链表对比正序链表值是否一致。
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;head&quot;&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public static bool IsPalindrome3(ListNode head)
    {
        if (head == null || head.next == null)
            return true;
        ListNode temp = head;
        Stack&lt;int&gt; stack = new Stack&lt;int&gt;();
        while(temp!=null)//链表节点压入栈
        {
            stack.Push(temp.val);
            temp = temp.next;
        }
        while (head != null &amp;&amp; stack.Count != 0)//正反序对比
        {
            if (head.val != stack.Pop())
                return false;
            head = head.next;
        }
        return true;
    }
}
</code></pre>
<p><strong>238.除自身外数组的乘积</strong><br>
class LC238除自身外数组的乘积<br>
{<br>
public int[] ProductExceptSelf(int[] nums)<br>
{<br>
int[] res = new int[nums.Length];</p>
<pre><code>        int pr = 1;
        for (int i = 0; i &lt; nums.Length; i++)
        {
            res[i] = pr;//返回数组保存除当前索引值外左边所有元素的乘积  
            pr *= nums[i];
        }
        pr = 1;
        for (int i = nums.Length-1; i &gt;=0; i--)
        {
            res[i] *= pr;//返回数组当前索引值(即除自身外所有元素乘积=左边所有元素乘积*右边所有元素乘积)
            pr *= nums[i];
        }
        return res;


    }
}
</code></pre>
<p><strong>———————————————————————————————————————</strong><br>
<strong>268丢失的数字</strong><br>
/// <summary><br>
/// 给定一个包含 [0, n] 中 n 个数的数组 nums ，<br>
/// 找出 [0, n] 这个范围内没有出现在数组中的那个数。<br>
/// </summary><br>
class LC268丢失的数字<br>
{<br>
/// <summary><br>
/// 排序法 [0,n]，排序后数组与索引值不相等即，缺失索引位置的值<br>
/// </summary><br>
/// <param name="nums"></param><br>
/// <returns></returns><br>
public int MissingNumber(int[] nums)<br>
{<br>
Array.Sort(nums);<br>
for (int i = 0; i &lt; nums.Length; i++)<br>
{<br>
if (i != nums[i])<br>
return i;<br>
}<br>
return nums.Length;<br>
}<br>
/// <summary><br>
/// 集合法，加入集合后，直接遍历判断集合不包含[0,n]中的那个值，<br>
/// </summary><br>
/// <param name="nums"></param><br>
/// <returns></returns><br>
public static int MissingNumber2(int[] nums)<br>
{<br>
HashSet<int> set = new HashSet<int>();<br>
foreach (int  n in nums)<br>
set.Add(n);<br>
for (int i = 0; i &lt; nums.Length; i++)<br>
{<br>
if (!set.Contains(i))<br>
return i;<br>
}<br>
return nums.Length;<br>
}<br>
/// <summary><br>
/// 数学法，[0,n]之和为“n*(n+1)/2“减去数组之和即为等于缺失的数值<br>
/// </summary><br>
/// <param name="nums"></param><br>
/// <returns></returns><br>
public int MissingNumber3(int[] nums)<br>
{<br>
int sum = 0;<br>
for (int i = 0; i &lt; nums.Length; i++)<br>
{<br>
sum += nums[i];<br>
}<br>
return (nums.Length * (nums.Length + 1)) / 2 - sum;<br>
}<br>
}<br>
<strong>class LC283移动0</strong><br>
{<br>
public static void MoveZeroes(int [] nums)<br>
{<br>
int index = 0;<br>
for (int i = 0; i &lt; nums.Length; i++)//遍历数组将不为0的数放在前面<br>
{<br>
if(nums[i]!=0)<br>
{<br>
nums[index] = nums[i];<br>
index++;<br>
}<br>
}<br>
//以上遍历完成后index后面的元素都应该是0<br>
for (int i = index; i &lt; nums.Length; i++)<br>
{<br>
nums[i] = 0;<br>
}<br>
}<br>
}<br>
<strong>//328.奇偶链表</strong><br>
public ListNode OddEvenList(ListNode head)<br>
{<br>
if (head == null||head.next==null) return head;</p>
<pre><code>        ListNode odd = head;
        ListNode even = head.next;
        ListNode evenHead = head.next;
        while (even != null&amp;&amp;even.next!=null)
        {
            odd.next = odd.next.next;
            odd = odd.next;
            even.next = even.next.next;
            even = even.next;
        }
        odd.next = evenHead;
        return head;
    }
</code></pre>
<p><strong>344.反转字符串</strong><br>
/// <summary><br>
///系统函数<br>
/// </summary><br>
/// <param name="s"></param><br>
public void ReverseString(char[] s)<br>
{<br>
Array.Reverse<char>(s);<br>
}<br>
/// <summary><br>
/// 双指针<br>
/// </summary><br>
/// <param name="s"></param><br>
public void ReverseString2(char[] s)<br>
{<br>
if (s == null || s.Length == 0) return;</p>
<pre><code>        int l = 0;
        int r = s.Length - 1;
        while(l&lt;r)
        {
            char temp = s[l];
            s[l] = s[r];
            s[r] = temp;
            l += 1;
            r -= 1;
        }
    }
    /// &lt;summary&gt;
    /// 递归法
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;s&quot;&gt;&lt;/param&gt;
    public void ReverseString3(char[] s)
    {
        if (s == null || s.Length == 0) return;//为空或长度为0返回

        Recursion(s, 0, s.Length - 1);//递归函数

    }
    private void Recursion(char[] s,int l,int r)
    {
        if (l &gt;= r) return;//左右指针相等或相交时返回

        Recursion(s, l + 1, r - 1);//左右两端对称的字符在同一递归层中，
        //递归返回时，交换同递归层中的左右字符完成反转
        char temp = s[l];
        s[l] = s[r];
        s[r] = temp;            
    }
</code></pre>
<p><strong>class LC349相交数组</strong><br>
{<br>
public int[] Intersection(int[] nums1, int[] nums2)<br>
{<br>
List<int> res = new List<int>();<br>
if (nums1 == null || nums1 == null || nums1.Length == 0 || nums2.Length == 0) return res .ToArray();<br>
HashSet<int> set1 = new HashSet<int>(nums1);<br>
HashSet<int> set2 = new HashSet<int>(nums2);</p>
<pre><code>        foreach (var item in set1)
        {
            if (set2.Contains(item))
                res.Add(item);
        }
        return res.ToArray();            
    }        
}
</code></pre>
<p><strong>class LC485.最大连续1的个数</strong><br>
{<br>
public static int FindMaxConsecutiveOnes(int [] nums)<br>
{<br>
int res = 0;<br>
int count = 0;<br>
for (int i = 0; i &lt; nums.Length; i++)<br>
{<br>
if (nums[i] == 1)<br>
count++;<br>
else<br>
{<br>
res = Math.Max(res, count);<br>
count = 0;<br>
}<br>
}<br>
return Math.Max(res,count);<br>
}<br>
}<br>
<strong>496.下一个更大元素_I</strong><br>
/// <summary><br>
/// 给定两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。<br>
/// 找到 nums1 中每个元素在 nums2 中的下一个比其大的值。<br>
/// 输入: nums1 = [4,1,2], nums2 = [1,3,4,2].<br>
/// 输出: [-1,3,-1]<br>
/// </summary><br>
class LC496下一个更大元素_I<br>
{<br>
public int[] NextGreaterElement(int[] nums1, int[] nums2)<br>
{<br>
List<int> res = new List<int>();<br>
Stack<int> stack = new Stack<int>();//nums2栈<br>
for (int i = 0; i &lt; nums2.Length; i++)//nums2装入栈中<br>
{<br>
stack.Push(nums2[i]);<br>
}</p>
<pre><code>        foreach (int n in nums1)//遍历数组1
        {
            Stack&lt;int&gt; temp = new Stack&lt;int&gt;();//临时栈，储存nums2弹出的元素
            bool isFind = false;//默认是否在nums2中找到nums1中的目标值
            int max = -1;//默认右边未找到比n大的值
            while(stack.Count!=0&amp;&amp;!isFind)//nums2不为空并且还2未找到n，进入循环
            {
                int top = stack.Pop();//栈顶元素(最右边的元素)
                if (top &gt; n)//弹出值比目标n大，更新最大值
                    max = top;
                else if (top == n)//与n相等则找到了n
                    isFind = true;
                temp.Push(top);//临时栈中存储nums2弹出的值，最后在返回给nums2栈，保持其不变
            }                
            res.Add(max);//max加入返回数组，未更新则右边没有比n大的值，更新则max保存的即是右边第一个比n大的值
            while (temp.Count != 0)//将临时栈的元素返还给nums2栈，使其保持不变，用于选择下一个num1中比n大的值
                stack.Push(temp.Pop());
        }
        return res.ToArray();//遍历完nums1后返回结果类表转数组
    }
    
}
</code></pre>
<p><strong>class LC509斐波那契数</strong><br>
{<br>
/// <summary><br>
/// 斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。<br>
/// 该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：<br>
/// </summary><br>
/// <param name="n"></param><br>
/// <returns></returns><br>
public int Fib(int n)<br>
{<br>
if (n &lt; 2) return n == 1 ? 1 : 0;</p>
<pre><code>        int sum = Fib(n - 1) + Fib(n - 2);
        return sum;
    }
    /// &lt;summary&gt;
    /// 动态规划：
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;n&quot;&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public int Fib2(int n)
    {
        if (n &lt; 2) return n == 1 ? 1 : 0;

        int[] res = new int[n + 1];
        res[0] = 0;
        res[1] = 1;
        for (int i = 2; i &lt; res.Length; i++)
        {
            res[i] = res[i - 1] + res[i - 2];
        }
        return res[n];
    }
    //动态规划，空间复杂度优化
    public int Fib3(int n)
    {
        if (n &lt;= 1) return n;

        int prev1 = 0;
        int prev2 = 1;
        int res = 0;
        for (int i = 2; i &lt;= n; i++)
        {
            res = prev1 + prev2;
            prev1 = prev2;
            prev2 = res;
        }
        return res;
    }
}
</code></pre>
<p><strong>//680.回文字符串II,允许删除一个字符实现回文字符串</strong><br>
public static bool IsPalindrome2(string s)<br>
{<br>
int left = 0;<br>
int right = s.Length - 1;<br>
while(left&lt;right)<br>
{<br>
if(s[left]!=s[right])<br>
{<br>
return IsPs(s.Remove(left,1)) || IsPs(s.Remove(right,1));<br>
}<br>
left++;<br>
right--;<br>
}<br>
return true;<br>
}<br>
public static bool IsPs(string s)<br>
{<br>
/<em>int left = 0;<br>
int right = s.Length - 1;<br>
while (left &lt; right)<br>
{<br>
if (s[left] != s[right])<br>
{<br>
return false;<br>
}<br>
left++;<br>
right--;<br>
}<br>
return true;</em>/</p>
<pre><code>        char[] sarray = s.ToCharArray();
        Array.Reverse(sarray);

        return s.Equals(new string(sarray));
    }
</code></pre>
<p><strong>class LC720词典中最长的单词</strong><br>
{<br>
/// <summary><br>
/// 暴力法，<br>
/// </summary><br>
/// <param name="words"></param><br>
/// <returns></returns><br>
public static string LongestWord(string[] words)<br>
{<br>
//边界条件<br>
if (words == null || words.Length == 0) return &quot;&quot;;</p>
<pre><code>        string res = &quot;&quot;;//返回值
        //将字符串数组存入集合方便快速查找
        HashSet&lt;string&gt; wordset = new HashSet&lt;string&gt;(words);
        //遍历集合
        foreach (string  word in wordset)
        {
            //如果当前单词的长度大于，预存的结果。或长度相同时排序较小，这可能成为新的res
            if (word.Length &gt; res.Length||(word.Length==res.Length&amp;&amp;word.CompareTo(res)&lt;0))
            {
                bool isword = true;//默认可以是新的res
                for (int i = 0; i &lt; word.Length; i++)//遍历新word的每个word[0~i+1]顺序组合都在字典中存在
                {
                    if(!wordset.Contains(word.Substring(0,i+1)))//有不存在的则不能成为新res，退出循环
                    {
                        isword = false;
                        break;
                    }
                }
                if (isword==true)//遍历后认为true则瞒住条件
                    res = word;//替换当前res
            }                    
        }
        return res;//返回res
    }
}
</code></pre>
<p><strong>881.救生艇</strong><br>
/// <summary><br>
/// 第 i 个人的体重为 people[i]，每艘船可以承载的最大重量为 limit。<br>
/// 每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。<br>
/// 返回载到每一个人所需的最小船数。(保证每个人都能被船载)。<br>
/// </summary><br>
class LC881救生艇<br>
{<br>
public int NumRescueBoats(int[] people, int limit)<br>
{<br>
if (people == null || people.Length == 0) return 0;</p>
<pre><code>        Array.Sort&lt;int&gt;(people);
        int res = 0;
        int l = 0;
        int r = people.Length - 1;
        while(l&lt;=r)
        {
            if (people[l] + people[r] &lt;= limit)
                l += 1;
            r -= 1;
            res += 1;
        }
        return res;
    }
}
</code></pre>
<p><strong>989数组形式的整数加法</strong><br>
public static List<int> AddToArrayForm(int[] A, int K)<br>
{<br>
int ans = 0;<br>
for (int i = 0; i &lt; A.Length; i++)<br>
{<br>
ans = ans * 10 + A[i];<br>
}<br>
ans += K;<br>
List<int> res = new List<int>();<br>
while(ans&gt;0)<br>
{<br>
res.Add(ans % 10);<br>
ans /= 10;<br>
}<br>
res.Reverse();<br>
return res;<br>
}<br>
<strong>——————————————————————————————————</strong><br>
<strong>class LC1456定长子串中元音最大的数目</strong><br>
{<br>
/// <summary><br>
/// 滑动窗口法<br>
/// </summary><br>
/// <param name="s"></param><br>
/// <param name="k"></param><br>
/// <returns></returns><br>
public int MaxVowels(string s, int k)<br>
{<br>
if (s == null || s.Length == 0||s.Length&lt;k) return -1;<br>
HashSet<char> set = new HashSet<char>(new char[] { 'a', 'e', 'i', 'o', 'u' });<br>
int res = 0;<br>
int count = 0;<br>
for (int i = 0; i &lt; k; i++)<br>
{<br>
if (set.Contains(s[i]))<br>
count += 1;<br>
}<br>
res = Math.Max(res, count);<br>
for (int i = k; i &lt; s.Length; i++)<br>
{<br>
if (set.Contains(s[i - k]))<br>
count -= 1;<br>
if (set.Contains(s[i]))<br>
count += 1;<br>
res = Math.Max(res, count);<br>
}<br>
return res;<br>
}<br>
}</p>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://Wei715547.github.io/post/cyou-xi-fu-wu-qi-ke-hu-duan-googleprotobuf-xiao-xi-jie-xi/">
                  <h3 class="post-title">
                    C#游戏服务器/客户端(TCP/UDP无连接转发位置同步)/Google.Protobuf消息解析
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>





  </body>
</html>
