<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>数据存储-序列化/反序列化 | Weiwei的个人网站</title>
<link rel="shortcut icon" href="https://Wei715547.github.io/favicon.ico?v=1590478473989">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://Wei715547.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="数据存储-序列化/反序列化 | Weiwei的个人网站 - Atom Feed" href="https://Wei715547.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="二进制方法（Binary Formatter）
序列化：新建或打开一个二进制文件，通过二进制格式器将对象写入该二进制文件。
反序列化：打开待反序列化的二进制文件，通过二进制格式器将文件解析成对象。
XML：扩展标记语言，用于标记电子文件使其..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://Wei715547.github.io">
  <img class="avatar" src="https://Wei715547.github.io/images/avatar.png?v=1590478473989" alt="">
  </a>
  <h1 class="site-title">
    Weiwei的个人网站
  </h1>
  <p class="site-description">
    7
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              数据存储-序列化/反序列化
            </h2>
            <div class="post-info">
              <span>
                2020-05-05
              </span>
              <span>
                6 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>二进制方法（Binary Formatter）<br>
序列化：新建或打开一个二进制文件，通过二进制格式器将对象写入该二进制文件。<br>
反序列化：打开待反序列化的二进制文件，通过二进制格式器将文件解析成对象。</p>
<p>XML：扩展标记语言，用于标记电子文件使其具有结构性的标记语言。<br>
可以用来标记数据、定义数据类型。<br>
序列化与反序列化的方式与二进制方法十分类似。<br>
http://blog.csdn.net/y1196645376/article/details/52541882</p>
<p>JSON：是一种语言无关的发送和接收数据的常用格式。可以使用它来跨平台的传输数据。<br>
JSON序列化：对象           JSON<br>
JSON反序列化：JSON           对象</p>
<p>对比<br>
二进制方法：简单，但可读性差。<br>
XML：可读性强，但是文件庞大，冗余信息多。<br>
JSON：数据格式比较简单，易于读写，但是不直观，可读性比XML差</p>
<p>using System.Runtime.Serialization.Formatters.Binary;<br>
using System.IO;<br>
//二进制<br>
private void SaveByBin()<br>
{<br>
//要储存的类<br>
Save save = SaveDate();<br>
//创建二进制序列化程序<br>
BinaryFormatter bf = new BinaryFormatter();<br>
//创建文件流<br>
FileStream filestream = File.Create(Application.dataPath + &quot;/Savemaster&quot; + &quot;/Bin.txt&quot;);<br>
//用二进制序列化程序的序列化方法来序列化Save类对象，参数（文件流，需要序列化的类对象）<br>
bf.Serialize(filestream, save);<br>
//关闭流<br>
filestream.Close();<br>
if (File .Exists (Application.dataPath + &quot;/Savemaster&quot; + &quot;/Bin.txt&quot;))<br>
{<br>
UIManage.Instance . ShowMessage(&quot;保存成功&quot;);<br>
}</p>
<pre><code>}

private void  LoadByBin()
{
    if (File.Exists(Application.dataPath + &quot;/Savemaster&quot; + &quot;/Bin.txt&quot;))
    {
        Save save = new Save();
        BinaryFormatter bf = new BinaryFormatter();
        FileStream fs = File.Open(Application.dataPath + &quot;/Savemaster&quot; + &quot;/Bin.txt&quot;, FileMode.Open);
        save = (Save)bf.Deserialize(fs);
        fs.Close();
        LoadDate(save);
        //UIManage.Instance.ShowMessage(&quot;加载成功&quot;);
        UIPanle.Instance.OnStartButtonDown();
    }
    else
        UIManage.Instance.ShowMessage(&quot;无存档记录&quot;);
}
</code></pre>
<p>private void SaveByXML()<br>
{<br>
Save save = SaveDate();<br>
//创建Xml文件存储路径<br>
string filePath = Application .dataPath + &quot;/Savemaster&quot; + &quot;/byXml.txt&quot;;<br>
//创建Xml文档<br>
XmlDocument xmlDoc = new XmlDocument();<br>
//创建根节点<br>
XmlElement root = xmlDoc.CreateElement(&quot;save&quot;);<br>
//设置根节点中的值<br>
root.SetAttribute(&quot;name&quot;, &quot;saveFile1&quot;);</p>
<pre><code>    //创建XmlElement
    XmlElement target;
    XmlElement targetPosition;
    XmlElement monsterType;

    //通过遍历save中存储的数据，将数据转换正Xml格式。
    for (int i = 0; i &lt; save .livingTargetPos .Count ; i++)
    {
        target = xmlDoc.CreateElement(&quot;target&quot;);
        targetPosition = xmlDoc.CreateElement(&quot;targetPosition&quot;);
        //设置节点的值
        targetPosition.InnerText = save.livingTargetPos[i].ToString();
        monsterType = xmlDoc.CreateElement(&quot;monsterType&quot;);
        monsterType.InnerText = save.monsterType[i].ToString();

        //设置节点中的层级关系 root -- target -- (targetPosition,monsterType)
        target.AppendChild(targetPosition);
        target.AppendChild(monsterType);
        root.AppendChild(target);
    }

    //设置射击数和分数节点，并设置成绩关系。root -- （target(targetPosition,monsterType) -- shootNum -- scoreNum）
    XmlElement shootNum = xmlDoc.CreateElement(&quot;shootNum&quot;);
    shootNum.InnerText = save.shootNum.ToString ();
    root.AppendChild(shootNum);

    XmlElement scoreNum = xmlDoc.CreateElement(&quot;scoreNum&quot;);
    scoreNum.InnerText = save.scoreNum.ToString();
    root.AppendChild(scoreNum);

    //根目录添加的Xml文档
    xmlDoc.AppendChild(root);
    //保存Xml文档
    xmlDoc.Save(filePath);

    if (File.Exists(Application.dataPath + &quot;/Savemaster&quot; + &quot;/byXml.txt&quot;))
    {
        UIManage.Instance.ShowMessage(&quot;保存成功&quot;);
    }

}
</code></pre>
<p>//Xml<br>
using System.Xml;<br>
private void LoadByXML()<br>
{</p>
<pre><code>    //创建Xml文件存储路径
    string filePath = Application.dataPath + &quot;/Savemaster&quot; + &quot;/byXml.txt&quot;;
    if (File.Exists(filePath))
    {
        Save save = SaveDate();
        //加载Xml文档
        XmlDocument xmlDoc = new XmlDocument();
        xmlDoc.Load(filePath);
        //通过节点名称获取元素，结果为XmlNodeList类型
        XmlNodeList targets = xmlDoc.GetElementsByTagName(&quot;target&quot;);
        //遍历所有的target节点，并获得子节点和节点的InnerText
        if (targets!=null)
        {
            foreach (XmlNode target in targets )
            {
                XmlNode targetPosition = target.ChildNodes[0];
                int targetPositionIndex =int.Parse ( targetPosition.InnerText);
                //把得到的值存到save中
                save.livingTargetPos.Add(targetPositionIndex);

                XmlNode monsterType = target.ChildNodes[1];
                int monsterTypeIndex = int.Parse(monsterType.InnerText);
                //把得到的值存到save中
                save.monsterType.Add(monsterTypeIndex);
            }
        }

        //得到存储的射击数和分数。
        XmlNodeList shootNum = xmlDoc.GetElementsByTagName(&quot;shootNum&quot;);
        int shootNumCount = int.Parse (shootNum[0].InnerText);
        save.shootNum = shootNumCount;

        XmlNodeList scoreNum = xmlDoc.GetElementsByTagName(&quot;scoreNum&quot;);
        int scoreNumCount = int.Parse(scoreNum[0].InnerText);
        save.scoreNum = scoreNumCount;

        LoadDate(save);

        UIPanle.Instance.OnStartButtonDown();
    }
    else
        UIManage.Instance.ShowMessage(&quot;无存档记录&quot;);
}
</code></pre>
<p>using LitJson;<br>
//Json<br>
private void SaveByJson()<br>
{<br>
Save save = SaveDate();<br>
//路径<br>
string filePath = Application.dataPath + &quot;/Savemaster&quot; + &quot;/ByJson.json&quot;;<br>
//利用JsonMapper将save对象转换为Json字符串<br>
string saveJsonMapper = JsonMapper.ToJson(save);<br>
//创建StreamWriter,并将字符串写入文件<br>
StreamWriter sw = new StreamWriter(filePath);<br>
sw.Write(saveJsonMapper);<br>
//关闭StreamWriter<br>
sw.Close();</p>
<pre><code>    UIManage.Instance.ShowMessage(&quot;保存成功&quot;);
}

private void LoadByJson()
{
    string filePath = Application.dataPath + &quot;/Savemaster&quot; + &quot;/ByJson.json&quot;;
    if(File .Exists (filePath ))
    {
        //创建StreamReader，读取流
        StreamReader sr = new StreamReader(filePath);
        //读取流赋值给jsonStr，并关闭流
        string jsonStr = sr.ReadToEnd();
        sr.Close();
        //将jsonStr转换为对象
        Save save = JsonMapper.ToObject&lt;Save&gt;(jsonStr);
        LoadDate(save);
        UIPanle.Instance.OnStartButtonDown();
    }
    else
    {
        UIManage.Instance.ShowMessage(&quot;无存档记录&quot;);
    }
}
</code></pre>

              </div>
              <div class="toc-container">
                
              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://Wei715547.github.io/post/jing-tai/">
              <h3 class="post-title">
                静态
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://Wei715547.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
