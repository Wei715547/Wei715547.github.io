<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>C++泛型/STL | WeiBlog</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://Wei715547.github.io/favicon.ico?v=1606825484715">
<link rel="stylesheet" href="https://Wei715547.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="函数模板
与普通函数区别：
1.普通函数调用存在隐式类型转换
2.自动类型推导调用时，不发生隐式类型转换
3.显示指定类型调用可以发生隐式类型转换
与普通函数重名时：
1,.默认调用普通函数
2.通过空模板参数类表(Max&lt;&gt;)..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://Wei715547.github.io">
        <img src="https://Wei715547.github.io/images/avatar.png?v=1606825484715" class="site-logo">
        <h1 class="site-title">WeiBlog</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            总览
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/Wei715547" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
          <a class="social-link" href="https://space.bilibili.com/29363247" target="_blank">
            <i class="fab fa-twitter"></i>
          </a>
        
      
        
          <a class="social-link" href="https://weibo.com/u/5612050622" target="_blank">
            <i class="fab fa-weibo"></i>
          </a>
        
      
        
      
        
      
    </div>
    <div class="site-description">
      年月增长，我宜强盛。
用于Unity+开发的技术积累
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://Wei715547.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">C++泛型/STL</h2>
            <div class="post-date">2020-11-28</div>
            
            <div class="post-content" v-pre>
              <p><strong>函数模板</strong><br>
与普通函数区别：<br>
1.普通函数调用存在隐式类型转换<br>
2.自动类型推导调用时，不发生隐式类型转换<br>
3.显示指定类型调用可以发生隐式类型转换<br>
与普通函数重名时：<br>
1,.默认调用普通函数<br>
2.通过空模板参数类表(Max&lt;&gt;)强制调用函数模板<br>
3.函数模板可发生重载(参数个数不同)<br>
4.函数模板可产生更好的匹配时优先调用函数模板<br>
例：普通函数：void Fun(int a,int b){}<br>
函数模板：template<class T> viod Fun (T a,T b){};<br>
调用Fun(a,b)//a,b为char类型时普通函数需隐式转换int为char，函数模板只需将T制定为char类型，即优先调用函数模板。<br>
模板局限性：如自定义类型对比（解决方法1.在自定义类型中重置内置运算符，2.利用具体化模板实现代码）=&gt;template &lt;&gt; bool Compare(Person p1,Person p2)<br>
{<br>
if(p1.name ==p2.name&amp;&amp;p1.age == p2.age)<br>
return true;<br>
else<br>
return false;<br>
};<br>
声明格式：<br>
template <class T>//或写成<typename T>与class无区别<br>
//需要不同类型参数时&lt;typename T1,typename T2&gt;u77<br>
返回值 函数名 （形参表）<br>
{<br>
函数体；<br>
}<br>
template <class T><br>
T Max(T Inpute1, T Inpuet2)<br>
{<br>
return (Inpute1 &gt; Inpute2) ? Inpute1 : Inpute2;<br>
}<br>
使用：<br>
1.自动类型推导<br>
Max(a,b);<br>
2.显示指定类型<br>
Max<int>(a,b);<br>
<strong>类模板</strong>//与函数模板区别：1.没有自动类型推导，<br>
2.在模板参数列表中可以有默认参数template <typename T = int>//未指定类型是默认为int</p>
<p>template <typename T><br>
class 类名<br>
{<br>
类定义；<br>
}<br>
template &lt;class T1,class T2&gt;<br>
class Person<br>
{<br>
public:<br>
Person(T1 name,T2 age)<br>
{<br>
this-&gt;Name = name;<br>
this-&gt;Age =age;<br>
}<br>
void ShowPerson(T1 name,T2 age);<br>
private:<br>
T1 Name;<br>
T2 Age;<br>
}<br>
在类外定义成员函数时：<br>
template <typename T><br>
返回值类型 类名<T>::函数名(T x,T y)<br>
{<br>
函数体；<br>
}<br>
template &lt;typename T1, typenme T2&gt;<br>
void Person&lt;T1,T2&gt;::ShowPerson(T1 name,T2 age)<br>
{<br>
cout&lt;&lt;name&lt;&lt;age&lt;&lt;endl;<br>
}<br>
类模板声明对象：<br>
类名&lt;泛型数据类型&gt; 对象名；<br>
Person&lt;string,int&gt; p (&quot;Wei&quot;,17);</p>
<p><strong>类模板对象作为函数参数</strong><br>
1.指定传入类型<br>
void PrintPerson(Person&lt;string ,int&gt; &amp;p)<br>
{<br>
p.ShowPerson(p.name,p.age);<br>
}<br>
2.参数模板化<br>
template &lt;class T1,class T2&gt;<br>
void PrintPerson(Person&lt;T1 ,T3&gt; &amp;p)<br>
{<br>
p.ShowPerson(p.name,p.age);<br>
}<br>
3.整个类模板化<br>
template <class T><br>
void PrintPerson(T &amp;p)<br>
{<br>
p.ShowPerson(p.name,p.age);<br>
}</p>
<p><strong>类模板与继承</strong><br>
1.当子类继承的父类为一个类模板时，子类在声明时必须指定父类中T的类型。<br>
template <class T><br>
class Base<br>
{<br>
T m;<br>
}<br>
class Son :public Base<int>//指定父类T类型<br>
{</p>
<p>};<br>
2.如果不指定 ，编译器无法为子类分配内存。<br>
3.如想灵活指定父类T类型，则需将子类也定义为类模板。<br>
template &lt;class T1, class T2&gt;//子类也定义为类模板<br>
class Son :public Base<T2><br>
{<br>
T1 obj;<br>
};<br>
Son&lt;int,char&gt; s1;</p>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://Wei715547.github.io/post/cyun-suan-fu-chong-zai/">
                  <h3 class="post-title">
                    C++运算符重载
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>





  </body>
</html>
