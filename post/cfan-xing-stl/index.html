<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>C++泛型/STL | WeiBlog</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://Wei715547.github.io/favicon.ico?v=1607956037712">
<link rel="stylesheet" href="https://Wei715547.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="函数模板
与普通函数区别：
1.普通函数调用存在隐式类型转换
2.自动类型推导调用时，不发生隐式类型转换
3.显示指定类型调用可以发生隐式类型转换
与普通函数重名时：
1,.默认调用普通函数
2.通过空模板参数类表(Max&lt;&gt;)..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://Wei715547.github.io">
        <img src="https://Wei715547.github.io/images/avatar.png?v=1607956037712" class="site-logo">
        <h1 class="site-title">WeiBlog</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            总览
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/Wei715547" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
          <a class="social-link" href="https://space.bilibili.com/29363247" target="_blank">
            <i class="fab fa-twitter"></i>
          </a>
        
      
        
          <a class="social-link" href="https://weibo.com/u/5612050622" target="_blank">
            <i class="fab fa-weibo"></i>
          </a>
        
      
        
      
        
      
    </div>
    <div class="site-description">
      年月增长，我宜强盛。
用于Unity+开发的技术积累
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://Wei715547.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">C++泛型/STL</h2>
            <div class="post-date">2020-11-28</div>
            
            <div class="post-content" v-pre>
              <p><strong>函数模板</strong><br>
与普通函数区别：<br>
1.普通函数调用存在隐式类型转换<br>
2.自动类型推导调用时，不发生隐式类型转换<br>
3.显示指定类型调用可以发生隐式类型转换<br>
与普通函数重名时：<br>
1,.默认调用普通函数<br>
2.通过空模板参数类表(Max&lt;&gt;)强制调用函数模板<br>
3.函数模板可发生重载(参数个数不同)<br>
4.函数模板可产生更好的匹配时优先调用函数模板<br>
例：普通函数：void Fun(int a,int b){}<br>
函数模板：template<class T> viod Fun (T a,T b){};<br>
调用Fun(a,b)//a,b为char类型时普通函数需隐式转换int为char，函数模板只需将T制定为char类型，即优先调用函数模板。<br>
模板局限性：如自定义类型对比（解决方法1.在自定义类型中重置内置运算符，2.利用具体化模板实现代码）=&gt;template &lt;&gt; bool Compare(Person p1,Person p2)<br>
{<br>
if(p1.name ==p2.name&amp;&amp;p1.age == p2.age)<br>
return true;<br>
else<br>
return false;<br>
};<br>
声明格式：<br>
template <class T>//或写成<typename T>与class无区别<br>
//需要不同类型参数时&lt;typename T1,typename T2&gt;u77<br>
返回值 函数名 （形参表）<br>
{<br>
函数体；<br>
}<br>
template <class T><br>
T Max(T Inpute1, T Inpuet2)<br>
{<br>
return (Inpute1 &gt; Inpute2) ? Inpute1 : Inpute2;<br>
}<br>
使用：<br>
1.自动类型推导<br>
Max(a,b);<br>
2.显示指定类型<br>
Max<int>(a,b);<br>
<strong>类模板</strong>//与函数模板区别：1.没有自动类型推导，<br>
2.在模板参数列表中可以有默认参数template <typename T = int>//未指定类型是默认为int</p>
<p>template <typename T><br>
class 类名<br>
{<br>
类定义；<br>
}<br>
template &lt;class T1,class T2&gt;<br>
class Person<br>
{<br>
public:<br>
Person(T1 name,T2 age)<br>
{<br>
this-&gt;Name = name;<br>
this-&gt;Age =age;<br>
}<br>
void ShowPerson(T1 name,T2 age);<br>
private:<br>
T1 Name;<br>
T2 Age;<br>
}<br>
在类外定义成员函数时：<br>
template <typename T><br>
返回值类型 类名<T>::函数名(T x,T y)<br>
{<br>
函数体；<br>
}<br>
template &lt;typename T1, typenme T2&gt;<br>
void Person&lt;T1,T2&gt;::ShowPerson(T1 name,T2 age)<br>
{<br>
cout&lt;&lt;name&lt;&lt;age&lt;&lt;endl;<br>
}<br>
类模板声明对象：<br>
类名&lt;泛型数据类型&gt; 对象名；<br>
Person&lt;string,int&gt; p (&quot;Wei&quot;,17);</p>
<p><strong>类模板对象作为函数参数</strong><br>
1.指定传入类型<br>
void PrintPerson(Person&lt;string ,int&gt; &amp;p)<br>
{<br>
p.ShowPerson(p.name,p.age);<br>
}<br>
2.参数模板化<br>
template &lt;class T1,class T2&gt;<br>
void PrintPerson(Person&lt;T1 ,T3&gt; &amp;p)<br>
{<br>
p.ShowPerson(p.name,p.age);<br>
}<br>
3.整个类模板化<br>
template <class T><br>
void PrintPerson(T &amp;p)<br>
{<br>
p.ShowPerson(p.name,p.age);<br>
}</p>
<p><strong>类模板与继承</strong><br>
1.当子类继承的父类为一个类模板时，子类在声明时必须指定父类中T的类型。<br>
template <class T><br>
class Base<br>
{<br>
T m;<br>
}<br>
class Son :public Base<int>//指定父类T类型<br>
{</p>
<p>};<br>
2.如果不指定 ，编译器无法为子类分配内存。<br>
3.如想灵活指定父类T类型，则需将子类也定义为类模板。<br>
template &lt;class T1, class T2&gt;//子类也定义为类模板<br>
class Son :public Base<T2><br>
{<br>
T1 obj;<br>
};<br>
Son&lt;int,char&gt; s1;<br>
——————————————————————————————————————<br>
<strong>STL</strong></p>
<p><strong>Vector</strong>:单端数组，动态拓展：开辟一块更大的空间拷贝数据，释放原来空间。<br>
迭代器：v.begin()//指向容器首位置<br>
v.end()//指向容器最后一位的下一个位置<br>
v.rend()//首位的前一位置<br>
v.rbegin()//指向最后一位元素<br>
支持随机访问<br>
构造函数：<br>
vector<T> v;//              默认构造函数<br>
vector(v.begin(),v.end())//         将v的首末拷贝到本身<br>
vector(n,elem)//            将n个elem拷贝给本身<br>
vector(const vector &amp;vec)//         拷贝构造函数<br>
赋值操作：<br>
operator=<br>
v.assign(v1.begin(), v1.end())<br>
v.assign(n,elem);<br>
容量大小方法：<br>
empty()//判断容易是否为空；<br>
capacity()//容器容量<br>
size()//容器中元素的个数<br>
resize(int num)//重新制定容易的长度为num<br>
resize(int num elem)//重新定义容器长度，并默认以elem填充<br>
插入/删除方法：<br>
push_back(ele);//在尾部插入数据<br>
pop_back()//在尾部删除数据<br>
insert(const_iterator  pos, ele)//在迭代器所指向位置插入ele<br>
insert(const_iterator  pos, int count, ele)//在迭代器所指向位置插入count个ele<br>
erase(const_iterator pos);//删除迭代器所指向的元素<br>
erase(const_iterator start, const_iterator end)//清除迭代器s-e之间的元素<br>
clear();//清空元素</p>
<p>#include <iostream><br>
#include &quot;pch.cpp&quot;<br>
#include<vector><br>
#include<algorithm><br>
using namespace std;</p>
<p>int main()<br>
{<br>
//cout &lt;&lt; &quot;WEI&quot; &lt;&lt; endl;<br>
Fun1();<br>
return 0;</p>
<p>}<br>
void Fun1()<br>
{<br>
//创建Vector容器<br>
vector<int> v;</p>
<pre><code>//向容器中插入数据
v.push_back(10);
v.push_back(20);
v.push_back(30);
v.push_back(40);
v.push_back(50);

////通过迭代器访问容器中的数据
//vector&lt;int &gt;::iterator itBegin = v.begin();//起始迭代器，指向容器第一个元素
//vector&lt;int &gt;::iterator itEnd = v.end();//结束迭代器，指向最后一个元素的下一个位置

////遍历方式
//while (itBegin != itEnd)
//{
//	cout &lt;&lt; *itBegin &lt;&lt; endl;
//	itBegin++;
//}

//遍历方式二
for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)
{
	cout &lt;&lt; *it &lt;&lt; endl;
}

//第三种 STL提供的遍历算法
for_each (v.begin(), v.end(), MyPrint);
</code></pre>
<p>}<br>
void MyPrint(int var)<br>
{<br>
cout &lt;&lt; var &lt;&lt; endl;<br>
}</p>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://Wei715547.github.io/post/cyun-suan-fu-chong-zai/">
                  <h3 class="post-title">
                    C++运算符重载
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>





  </body>
</html>
