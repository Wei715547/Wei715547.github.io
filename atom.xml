<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Wei715547.github.io</id>
    <title>WeiBlog</title>
    <updated>2020-10-29T09:14:04.995Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Wei715547.github.io"/>
    <link rel="self" href="https://Wei715547.github.io/atom.xml"/>
    <subtitle>年月增长，我宜强盛。
用于Unity+开发的技术积累</subtitle>
    <logo>https://Wei715547.github.io/images/avatar.png</logo>
    <icon>https://Wei715547.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, WeiBlog</rights>
    <entry>
        <title type="html"><![CDATA[C指针]]></title>
        <id>https://Wei715547.github.io/post/c-zhi-zhen/</id>
        <link href="https://Wei715547.github.io/post/c-zhi-zhen/">
        </link>
        <updated>2020-10-29T07:25:10.000Z</updated>
        <content type="html"><![CDATA[<p>定义：type * p_address; (type:数据类型)<br>
p_address = &amp; valu; (&amp;取引用)<br>
*p_address； 表示地址中的值（解引用）</p>
<p>值帧/数组  int array[3] = [7,1,5];<br>
int* p_array = array;<br>
(int类型(4字节)数组array所指向的是array[0]的地址，即&amp;array[0],<br>
一旦将array赋值给p_array，此时array和p_array都指向数组的第一个元素的地址，可以通过指针像数组一样操作数组，p_array[0] , array[0]含义相同)<br>
指针运算：p_array++ 和p_array+1都指向数组的下一个元素（int类型占4个字节+1地址偏移4位(C++不会进行数组越界检测)）<br>
如上所有数组索引表达式可以写成指针镓屁啊你量形式：<br>
array[1] 与 <em>(p_array+1)相同<br>
数组声明：type array [n];<br>
array含义1：代表这个数组其类型时type[n];<br>
array含义2：代表一个“常量”指针，指针类型时type</em> ,指向的类型是type，指向的存区域是数组第一个元素(0号单元)，该指针占有单独的内存区域，指针值不可修改，即类似array++的表达式错误。<br>
指针与引用：声明：double x = 7.5;<br>
double*  = &amp;x;<br>
//引用声明 （引用声明时必须指定引用对象，且绑定关系不可改变）<br>
double&amp; y = x;<br>
上述“&amp;”“<em>”为定义引用与指针，非取址与解引用。通过</em>p与y都可对x值进行更改；<br>
指针与函数：指针作为函数参数<br>
void swap (int * a ,int * b)//<br>
{<br>
int temp = *a;<br>
*a = *b;<br>
*b = temp;<br>
}<br>
int a = 10;<br>
int b - 20;<br>
swap(&amp;a,&amp;b); //C#,ref<br>
指针指向函数：<br>
void (*funcp)()//声明一个无参数无返回值的函数指针<br>
funcp = &amp;TheFunction;//<br>
funcp = TheFunction；//函数指针赋值<br>
funcp();//与函数调用书写方式无异，下式表示更明确<br>
(<em>funcp)()；//间接调用<br>
动态内存分配：（在“堆”区开辟空间，由程序员管理，开辟/释放）new typr,（new返回type类型的指针）<br>
int</em> p_int;<br>
p_int = new int ;//或p_int = new(int)<br>
delete p_int</p>
<p>int* p_arrayint ;<br>
p_arrayint - new int[10]//声明数组内存空间，不能分配时返回NULL<br>
delete[] p_arrayint;<br>
分配到的内存系统不会自动回收，需要调用delete[] p_arrayint;来释放内存。<br>
不释放则导致内存泄漏。<br>
C++内存分区模型：<br>
代码区：存放函数体的二进制代码，有系统进行管理。<br>
全局区：存放全局变量和静态变量以及常量。<br>
栈区：由编译器自动分配释放，存放函数参数值，局部变量等。<br>
堆区：由程序员分配释放，若不释放，程序结束时由系统进行回收。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[洗牌算法，洪水填充算法，重置内置运算符]]></title>
        <id>https://Wei715547.github.io/post/xi-pai-suan-fa/</id>
        <link href="https://Wei715547.github.io/post/xi-pai-suan-fa/">
        </link>
        <updated>2020-10-12T02:57:36.000Z</updated>
        <content type="html"><![CDATA[<p>public class Utilities<br>
{<br>
/// <summary><br>
/// 洗牌算法，<br>
/// </summary><br>
/// <param name="dateArray">随机重排的数组</param><br>
/// <returns></returns><br>
public static Coord[] ShuffleCoords(Coord[] dateArray)<br>
{<br>
for (int i = 0; i &lt; dateArray.Length; i++)<br>
{<br>
//将每次随机到的元素放到首位，第二次随机从“队首+1~最后元素”开始随机，这样每次随机到的即不为同一元素<br>
int random = Random.Range(i, dateArray.Length);<br>
//SWAP<br>
Coord temp = dateArray[random];<br>
dateArray[random] = dateArray[i];<br>
dateArray[i] = temp;<br>
}<br>
return dateArray;<br>
}<br>
}<br>
//应用程序<br>
<img src="https://Wei715547.github.io/post-images/1602493526529.PNG" alt="" loading="lazy"><br>
shuffleCoords = new Queue<Coord>(Utilities.ShuffleCoords(allTilesCoord.ToArray()));<br>
public Coord GetRandomCoord()<br>
{<br>
Coord randomCoord = shuffleCoords.Dequeue();<br>
shuffleCoords.Enqueue(randomCoord);<br>
return randomCoord;<br>
}<br>
——————————————————————————————————————————————————<br>
/// <summary><br>
/// 洪水填充算法<br>
/// </summary><br>
/// <param name="_mapObstacles">地图上的位置是否存在障碍物</param><br>
/// <param name="_currentObsCount">应该时候能承担障碍物数量</param><br>
/// <returns>是否可以在此处生成障碍物</returns><br>
public bool MapIsFullyAccessible(bool[,] _mapObstacles, int _currentObsCount)<br>
{<br>
bool[,] mapFlag = new bool[_mapObstacles.GetLength(0), _mapObstacles.GetLength(1)];<br>
Queue<Coord> queue = new Queue<Coord>();//存储所有筛选后的坐标<br>
queue.Enqueue(mapCenter);<br>
mapFlag[mapCenter.x, mapCenter.y] = true;//中心点标记为已检测<br>
int accessibleCount = 1;//可以行走的格子数量<br>
while(queue.Count&gt;0)<br>
{<br>
Coord currentTile = queue.Dequeue();<br>
for (int x = -1; x &lt;=1; x++)<br>
{<br>
for (int y = -1; y &lt;=1; y++)<br>
{<br>
int neighborX = currentTile.x + x;<br>
int neighborY = currentTile.y + y;</p>
<pre><code>                if (x==0||y==0)//检测上下左右四个相邻的位置是否可行
                {
                    if(neighborX &gt;=0&amp;&amp;neighborX&lt;_mapObstacles.GetLength(0)
                        &amp;&amp; neighborY&gt;=0&amp;&amp;neighborY&lt;_mapObstacles.GetLength(1))//范围限定在地图范围内
                    {
                        //该位置未检测，且不存在障碍物时
                        if(!mapFlag[neighborX,neighborY]&amp;&amp;!_mapObstacles[neighborX,neighborY])
                        {
                            mapFlag[neighborX, neighborY] = true;
                            accessibleCount++;
                            queue.Enqueue(new Coord(neighborX, neighborY));
                        }
                    }
                }
            }
        }
    }
    int walkableCount = (int)(mapSize.x * mapSize.y - _currentObsCount);//地图上应该可行走位置的数量
    return accessibleCount == walkableCount;//联通路径总的可行走数量与目标值相同时则可依据_mapObstacles中位置生成障碍物
}
------------------------重置内置运算符“operator”--------------------------
public struct Coord
</code></pre>
<p>{<br>
public int x;<br>
public int y;</p>
<pre><code>public Coord(int _x, int _y)
{
    this.x = _x;
    this.y = _y;
}
//operator：重置内置运算符，C#要求成对重载比较运算符
public static bool operator !=(Coord _c1,Coord _c2)
{
    return !(_c1 == _c2);
}
public static bool operator ==(Coord _c1,Coord _c2)
{
    return (_c1.x == _c2.x &amp;&amp; _c1.y == _c2.y);
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DgR]]></title>
        <id>https://Wei715547.github.io/post/dgr/</id>
        <link href="https://Wei715547.github.io/post/dgr/">
        </link>
        <updated>2020-10-03T10:54:03.000Z</updated>
        <content type="html"><![CDATA[<p>1.单一职责原则：类的职责要单一，不能将太多的职责放到一个类中。<br>
2.开闭原则：软件实体对扩展时开放的，但对修改是关闭的，即在不修改一个软件实体的基础上去扩展器功能。<br>
3.里转转换原则：在软件系统中一个可以接受基类对象的地方必然可以接受其子类对象（父类中装入子类）<br>
4.依赖倒转原则：要针对抽象对象编程，而不是对具体类编程。<br>
5.接口隔离原则：使用多个专门的接口 来取代一个统一的接口。<br>
6.合成复用原则：在系统中应多使用组合聚合关系，尽量少使用或不使用继承关系。<br>
7.迪米特法则：一个软件实体对其他实体的引用越少越好，或者说如果两个类不必彼此自黑通信，那么，两个类就不应当直接发生作用，而是通过引入中间体发生间接交互。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AStar-Base]]></title>
        <id>https://Wei715547.github.io/post/astar-base/</id>
        <link href="https://Wei715547.github.io/post/astar-base/">
        </link>
        <updated>2020-09-30T02:50:05.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://Wei715547.github.io/post-images/1601434274880.jpg" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1601434281055.jpg" alt="" loading="lazy"></p>
<p>//节点类<br>
//节点类型枚举<br>
public enum NodeTyp<br>
{<br>
//可用格子<br>
Able,<br>
//不可用格子<br>
Unable<br>
}<br>
public class AStartNode<br>
{<br>
//格子坐标<br>
public int x;<br>
public int y;</p>
<pre><code>//寻路消耗
public float f;

//起点距离
public float g;
//终点距离
public float h;

//父对象
public AStartNode father;
//格子类型
public NodeTyp type;

public AStartNode(int x,int y, NodeTyp type)
{
    this.x = x;
    this.y = y;
    this.type = type;
}
</code></pre>
<p>}</p>
<p>//单例基类<br>
public class BaseManager<T><br>
where T:new()//限定T有一个无参数的构造函数<br>
{<br>
private static T instence;</p>
<pre><code>public static T Instence
{
    get
    {
        if (instence == null)
            instence = new T();
        return instence;
    }
}
</code></pre>
<p>}</p>
<p>//管理器类（单例）<br>
public class AStartManager :BaseManager<AStarManager><br>
{<br>
/*private static AStartManager instence;<br>
public static AStartManager Instence<br>
{<br>
get<br>
{<br>
if (instence == null)<br>
instence = new AStartManager();<br>
return instence;<br>
}<br>
}<br>
*/<br>
//地图大小<br>
private int mapw;<br>
private int maph;<br>
//所有格子容器<br>
public AStartNode[,] nodes;<br>
//开启类表<br>
private List<AStartNode> openList = new List<AStartNode>();<br>
//关闭类表<br>
private List<AStartNode> closeList = new List<AStartNode>();<br>
/// <summary><br>
/// 初始化地图信息<br>
/// </summary><br>
/// <param name="mapw"></param><br>
/// <param name="maph"></param><br>
public void InitMapInfo(int mapw, int maph)<br>
{<br>
this.mapw = mapw;<br>
this.maph = maph;<br>
nodes = new AStartNode[mapw, maph];<br>
for (int i = 0; i &lt; mapw; i++)<br>
{<br>
for (int j = 0; j &lt; maph; j++)<br>
{<br>
//格子20%概率为阻挡<br>
AStartNode node = new AStartNode(i, j, Random.Range(0, 101) &lt; 20 ? NodeTyp.Unable : NodeTyp.Able);<br>
nodes[i, j] = node;<br>
}<br>
}<br>
}</p>
<pre><code>/// &lt;summary&gt;
/// 寻路方法
/// &lt;/summary&gt;
/// &lt;param name=&quot;startPos&quot;&gt;&lt;/param&gt;
/// &lt;param name=&quot;endPos&quot;&gt;&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public List&lt;AStartNode&gt; FindPath(Vector2 startPos, Vector2 endPos)
{

    /*/判断传入顶点是否合法*/
    //1.1传入顶点噪mapz范围内
    if (startPos.x &lt; 0 || startPos.x &gt;= mapw || startPos.y &lt; 0 || startPos.y &gt;= maph
       || endPos.x &lt; 0 || endPos.x &gt;= mapw || endPos.y &lt; 0 || endPos.y &gt;= maph)
    {
        Debug.Log(&quot;OutRange&quot;);
        return null;
    }
    AStartNode start = nodes[(int)startPos.x, (int)startPos.y];
    AStartNode end = nodes[(int)endPos.x, (int)endPos.y];
    //2.传入顶点不为阻挡
    //不合法则返回null
    if (start.type == NodeTyp.Unable ||
       end.type == NodeTyp.Unable)
    {
        Debug.Log(&quot;非法位置&quot;);
        return null;
    }

    //清空上一次相关数据，避免影响此次计算

    //清空开始/关闭类表
    openList.Clear();
    closeList.Clear();

    //把开始点放入关闭类表中
    start.father = null;
    start.g = 0;
    start.h = 0;
    start.f = 0;
    closeList.Add(start);
    while (true)
    {
        //从起点开始寻找周围的点
        //左上
        FindNearlyNodeToOpenList(start.x - 1, start.y - 1, 1.4f, start, end);
        //上
        FindNearlyNodeToOpenList(start.x, start.y - 1, 1f, start, end);
        //右上
        FindNearlyNodeToOpenList(start.x + 1, start.y - 1, 1.4f, start, end);
        //左
        FindNearlyNodeToOpenList(start.x - 1, start.y, 1f, start, end);
        //右
        FindNearlyNodeToOpenList(start.x + 1, start.y, 1f, start, end);
        //左下
        FindNearlyNodeToOpenList(start.x - 1, start.y + 1, 1.4f, start, end);
        //下
        FindNearlyNodeToOpenList(start.x, start.y + 1, 1f, start, end);
        //右下
        FindNearlyNodeToOpenList(start.x + 1, start.y + 1, 1.4f, start, end);
        //判断周围的点是否合法，是否在开启或关闭类表，不是则放入开始了表

        //死路判定：开启类表为空时中非那不可达
        if (openList.Count == 0)
        {
            Debug.Log(&quot;死路&quot;);
            return null;
        }
        //选出开启类表中寻路消耗最小的点
        openList.Sort(SortOpenList);//排序后openList[0]为f值最小的点
                                    //放入关闭类表中然后从开始了表中移除
        closeList.Add(openList[0]);
        //找到的点作为下一次寻找开始的起点
        start = openList[0];
        openList.RemoveAt(0);
        //如果这个点是终点则返回出去
        //不是终点则继续寻找
        if (start == end)
        {
            List&lt;AStartNode&gt; path = new List&lt;AStartNode&gt;();
            path.Add(end);
            while (end.father != null)
            {
                path.Add(end.father);
                end = end.father;
            }
            path.Reverse();
            return path;
        }

    }
}
/// &lt;summary&gt;
/// 排序函数
/// &lt;/summary&gt;
/// &lt;param name=&quot;a&quot;&gt;&lt;/param&gt;
/// &lt;param name=&quot;b&quot;&gt;&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
private int SortOpenList(AStartNode a, AStartNode b)
{
    if (a.f &gt; b.f)
        return 1;
    else if (a.f == b.f)
        return 1;
    else
        return -1;
}
/// &lt;summary&gt;
/// 把临近点放入开启类表中的函数
/// &lt;/summary&gt;
/// &lt;param name=&quot;x&quot;&gt;&lt;/param&gt;
/// &lt;param name=&quot;y&quot;&gt;&lt;/param&gt;
private void FindNearlyNodeToOpenList(int x, int y, float g, AStartNode fatherNode, AStartNode endNode)
{
    //边界判定
    if (x &lt; 0 || x &gt;= mapw ||
        y &lt; 0 || y &gt;= maph)
        return;
    //在map范围内在取点
    AStartNode node = nodes[x, y];
    if (node == null || node.type == NodeTyp.Unable
        || openList.Contains(node) || closeList.Contains(node))
        return;

    //计算f值：f=g+h
    //记录父对象
    node.father = fatherNode;
    //计算g（距离起点距离）值：父对象里欠点距离+距离父对象距离
    node.g = fatherNode.g + g;
    //计算h值（距离终点距离）：曼哈顿街区算法二维坐标差值
    node.h = Mathf.Abs(endNode.x - node.x) + Mathf.Abs(endNode.y - node.y);
    node.f = node.g + node.h;
    //通过验证则存入开始了表中
    openList.Add(node);
}
</code></pre>
<p>}</p>
<p><img src="https://Wei715547.github.io/post-images/1601435509787.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1601435519694.PNG" alt="" loading="lazy"><br>
//测试脚本<br>
public class TextA : MonoBehaviour<br>
{<br>
public int beginX = -2;<br>
public int beginY = -2;</p>
<pre><code>public int offSetX = 2;
public int OffSetY = 2;

public int mapW = 5;
public int mapY = 5;

public Material bnary;
public Material start;
public Material path;
public Material normal;

//存储格子容器（x_y,GameObject）
private Dictionary&lt;string, GameObject&gt; cubes = new Dictionary&lt;string, GameObject&gt;();

private Vector2 beginPos = Vector2.right * -1;
private Vector2 endPos;

//存储路径节点
List&lt;AStartNode&gt; pathList = new List&lt;AStartNode&gt;();

// Start is called before the first frame update
void Start()
{
    AStartManager.Instence.InitMapInfo(mapW, mapY);
    for (int i = 0; i &lt; mapW; i++)
    {
        for (int j = 0; j &lt; mapY; j++)
        {
            GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Cube);
            obj.transform.position = new Vector3(beginX + i * offSetX, beginY + j * OffSetY, 0);
            obj.name = i + &quot;_&quot; + j;
            cubes.Add(obj.name, obj);
            //判断格子是否阻挡
            AStartNode node = AStartManager.Instence.nodes[i, j];
            if(node.type == NodeTyp.Unable)
            {
                obj.GetComponent&lt;MeshRenderer&gt;().material= bnary ;
                Debug.Log(&quot;Br&quot;);
            }
        }
    }
}

// Update is called once per frame
void Update()
{
    if(Input.GetMouseButtonDown(0))
    {
        //射线检测返回值
        RaycastHit hit;
        //相机视角从鼠标位置发出的射线
        Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
        //射线检测，检测到物体返回true
        if (Physics.Raycast(ray, out hit, 1000))
        {
            //得到点击到的立方体
            //hit.collider.gameObject;
            //记录开始点与结束点
            if(beginPos == Vector2.right*-1)
            {
                //清理上一次路径
                if (pathList != null)
                {
                    for (int i = 0; i &lt; pathList.Count; i++)
                    {
                        cubes[pathList[i].x + &quot;_&quot; + pathList[i].y].GetComponent&lt;MeshRenderer&gt;().material = normal;
                    }
                }

                string[] str = hit.collider.gameObject.name.Split('_');
                beginPos = new Vector2(int.Parse(str[0]), int.Parse(str[1]));
                hit.collider.gameObject.GetComponent&lt;MeshRenderer&gt;().material = start;
            }
            else
            {
                string[] str = hit.collider.gameObject.name.Split('_');
                endPos = new Vector2(int.Parse(str[0]), int.Parse(str[1]));
                //hit.collider.gameObject.GetComponent&lt;MeshRenderer&gt;().material = end;

                pathList = AStartManager.Instence.FindPath(beginPos, endPos);
                if(pathList !=null)
                {
                    for (int i = 0; i &lt; pathList.Count; i++)
                    {
                        cubes[pathList[i].x + &quot;_&quot; + pathList[i].y].GetComponent&lt;MeshRenderer&gt;().material = path;
                    }
                }
                //清除开始点
                beginPos = Vector2.right * -1;
            }
        }
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[24.]]></title>
        <id>https://Wei715547.github.io/post/24/</id>
        <link href="https://Wei715547.github.io/post/24/">
        </link>
        <updated>2020-09-25T15:20:11.000Z</updated>
        <content type="html"><![CDATA[<p>class SL<br>
{<br>
public bool JudgePoint24(int[] nums)<br>
{<br>
List<double> list = new List<double>();<br>
foreach (int i in nums) list.Add((double)i); //为dfs做准备<br>
return dfs(list);<br>
}<br>
private bool dfs(List<double> list)<br>
{<br>
if (list.Count == 1)<br>
{//一个数时判断相等<br>
if (Math.Abs(list[0] - 24.0) &lt; 0.001) return true; //考虑除法造成的小数点<br>
return false;<br>
}<br>
for (int i = 0; i &lt; list.Count; ++i)<br>
{<br>
for (int j = i + 1; j &lt; list.Count; ++j)<br>
{<br>
foreach (double c in generatePossibleResults(list[i], list[j]))<br>
{<br>
List<double> nextRound = new List<double>();<br>
nextRound.Add(c); //遍历两个数的所有可能性<br>
for (int k = 0; k &lt; list.Count; ++k)<br>
{ //添加剩余项到next round<br>
if (k == i || k == j) continue;<br>
nextRound.Add(list[k]);<br>
}<br>
if (dfs(nextRound)) return true;<br>
}<br>
}<br>
}<br>
return false;<br>
}<br>
//生成两个数所有的组合<br>
private List<double> generatePossibleResults(double a, double b)<br>
{<br>
List<double> res = new List<double>();<br>
res.Add(a + b);<br>
res.Add(a - b);<br>
res.Add(b - a);<br>
res.Add(a * b);<br>
res.Add(a / b);<br>
res.Add(b / a);<br>
return res;<br>
}<br>
}</p>
<pre><code>C#改JAVA
</code></pre>
<p>class Solution<br>
{<br>
public boolean judgePoint24(int[] nums)<br>
{<br>
ArrayList<Double> list = new ArrayList&lt;&gt;();<br>
for (int n:nums)<br>
{<br>
list.add((double)n);<br>
}<br>
return Prm(list);<br>
}<br>
public boolean Prm(ArrayList<Double> list)<br>
{<br>
if (list.size() == 1)<br>
{<br>
return Math.abs(list.get(0) - 24) &lt; 1e-6;<br>
}<br>
for (int i = 0; i &lt; list.size(); i++)<br>
{<br>
for (int j = i + 1; j &lt; list.size(); j++)<br>
{<br>
for (double k:AllTowRes(list.get(i), list.get(j)))<br>
{<br>
ArrayList<Double> nextRound = new ArrayList&lt;&gt;();<br>
nextRound.add(k);<br>
for (int v = 0; v &lt; list.size(); v++)<br>
{<br>
if (v == i || v == j) continue;<br>
nextRound.add(list.get(v));<br>
}<br>
if (Prm(nextRound)) return true;<br>
}<br>
}<br>
}<br>
return false;<br>
}<br>
public ArrayList<Double> AllTowRes(double a, double b)<br>
{<br>
ArrayList<Double> res = new ArrayList&lt;&gt;();<br>
res.add(a + b);<br>
res.add(a - b);<br>
res.add(b - a);<br>
if (b != 0) res.add(a / b);<br>
if (a != 0) res.add(b / a);<br>
return res;<br>
}<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DGT]]></title>
        <id>https://Wei715547.github.io/post/dgt/</id>
        <link href="https://Wei715547.github.io/post/dgt/">
        </link>
        <updated>2020-09-22T09:56:23.000Z</updated>
        <content type="html"><![CDATA[<p>1.//变量插值方法<br>
DOTween.To(() =&gt; dtV, x =&gt; dtV = x, new Vector3(10, 10, 10), 2);//            DoTween.To(表达式1()目标变量，表达式2(目标变量=变量，变量值)，变化时间，)<br>
//当前位置到世界坐标下移动<br>
bgt.transform.DOMove(s, 0.5f, true ).OnComplete(() =&gt;<br>
{<br>
UM.bagPanel.SetActive(false);<br>
UM.UI_btns.SetActive(true);<br>
});<br>
2.//当前位置到局部坐标下移动<br>
bgt.transform.DOLocalMove(s, 0.5f, true ).OnComplete(() =&gt;<br>
{<br>
UM.bagPanel.SetActive(false);<br>
UM.UI_btns.SetActive(true);<br>
});<br>
3.//DGT倒放<br>
bgt.transform.DOMove(e, 0.25f, true );<br>
//Tweener对象保存DG返回的动画，设置动画不被销毁时可倒叙播放<br>
Tweener tweener = bgg.transform.DOMove(pe, 0.5f, true);//重复执行时会创建多个动画对象耗费性能，（不接收动画对象直接运行）<br>
tweener.SetAutoKill(false);<br>
tweener.Pause();//暂停<br>
//bgt.transform.DOPlayForward();//+<br>
bgt.transform.DOPlayBackwards();//-<br>
4.//From()<br>
bgt.transform.DOMoveX(5, 1f)//默认从初始位置移动到5，<br>
bgt.transform.DOMoveX(5, 1f).From();//添加From()从5移动到初始位置<br>
bgt.transform.DOMoveX(5, 1f).From(true);//填入参数时：从相“对位”置移动到初始位置<br>
5.//曲线/事件函数<br>
Tweener//DG返回对象<br>
tweener.SetEase(Ease.InBack);//设置曲线(枚举类型)<br>
public enum Ease<br>
{<br>
Unset = 0,<br>
Linear = 1,<br>
InSine = 2,<br>
OutSine = 3,<br>
InOutSine = 4,<br>
InQuad = 5,<br>
OutQuad = 6,<br>
InOutQuad = 7,<br>
InCubic = 8,<br>
OutCubic = 9,<br>
InOutCubic = 10,<br>
InQuart = 11,<br>
OutQuart = 12,<br>
InOutQuart = 13,<br>
InQuint = 14,<br>
OutQuint = 15,<br>
InOutQuint = 16,<br>
InExpo = 17,<br>
OutExpo = 18,<br>
InOutExpo = 19,<br>
InCirc = 20,<br>
OutCirc = 21,<br>
InOutCirc = 22,<br>
InElastic = 23,<br>
OutElastic = 24,<br>
InOutElastic = 25,<br>
InBack = 26,<br>
OutBack = 27,<br>
InOutBack = 28,<br>
InBounce = 29,<br>
OutBounce = 30,<br>
InOutBounce = 31,<br>
Flash = 32,<br>
InFlash = 33,<br>
OutFlash = 34,<br>
InOutFlash = 35,<br>
INTERNAL_Zero = 36,<br>
INTERNAL_Custom = 37<br>
}<br>
tweener.SetLoops(2);//设置循环次数<br>
tweener.OnComplete(() =&gt;//表达式形式在大括号中直接写入语句/或直接传入“方法”<br>
{<br>
UM.bagPanel.SetActive(false);<br>
UM.UI_btns.SetActive(true);<br>
});<br>
6.//生命周期//与其他脚本语言相似常用OnComplete()<br>
7.//文字动画<br>
text.DOText(&quot;文字动画&quot;,2f)/参数：文本动画时间<br>
8.//相机震动<br>
transform.DOShakePosition(1);//参数震动强度<br>
transform.DOShakePosition(1,new Vector3(1,1,0));//参数震动强度，方向约束Vector3(3,3,0)约束的值也可以控制强度<br>
9.//颜色/阿尔法通道(UI)<br>
text.DOColor(Color.cyan, 1f);<br>
text.DOFade(1, 1f);</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Lua面向对象实现]]></title>
        <id>https://Wei715547.github.io/post/lua-mian-xiang-dui-xiang-shi-xian/</id>
        <link href="https://Wei715547.github.io/post/lua-mian-xiang-dui-xiang-shi-xian/">
        </link>
        <updated>2020-09-16T09:28:03.000Z</updated>
        <content type="html"><![CDATA[<p><cood>print(&quot;<strong><strong><strong><strong><strong><strong>封装</strong></strong></strong></strong></strong></strong>__&quot;)<br>
Object = {}<br>
Object.ID = 1<br>
function Object:Text()--&quot;:&quot;自动传入调用这个函数的对象，作为第一个参数传入方法<br>
print(self.ID)--“self”代表默认传入的第一个参数<br>
end</p>
<p>function Object:new( )--类用于创建对象的方法--构造函数<br>
--function Object:new(o)--充当构造函数，返回空表，将本身设为空表的原表来继承类的属性与函数<br>
--local obj= o or {}--o填写时在填入子类的属性/函数基础上创建对象，不填时为空继承父类默认所有属性/函数创建对象（）p1 = Object:new(weight = 100) 或 p1 = Object:new()<br>
local obj = {}<br>
--原表的__index指向自身<br>
self.__index =self--__index:当在自己的表中找不到目标属性时，就会在元表的__index中寻找<br>
setmetatable(obj ,self)<br>
--setmetatable (obj,{__index=self})--与上两句作用相同<br>
return obj<br>
end</p>
<p>local myObj = Object:new()<br>
print(myObj)<br>
print(myObj.ID)<br>
myObj:Text()--myObj调用则传入myObj</p>
<p>print(&quot;_<strong><strong><strong><strong><strong><strong><strong><strong>继承</strong></strong></strong></strong></strong></strong></strong></strong>&quot;)</p>
<p>--构造用于继承的方法<br>
function Object:subClass(className)--声明类的方法<br>
--_G表存储所有的全局变量<br>
_G[className] = {}<br>
local obj = _G[className]<br>
self.__index = self<br>
--为子类定义一个父类属性base<br>
obj.base = self<br>
setmetatable(obj,self)<br>
end</p>
<p>Object:subClass(&quot;Person&quot;)<br>
--print(Person)--此时是通过类名访问属性，类似静态变量<br>
--Person:Text()<br>
--通过对象访问属性<br>
local p1 = Person:new ()--Person继承自Object的new方法。self使Person为第一变量传入<br>
p1:Text()--原表中不存在，会继续查找原表的原表</p>
<p>print(&quot;____________多态————————————————————————————&quot;)</p>
<p>Object:subClass(&quot;GameObject&quot;)--声明游戏对象类<br>
GameObject.posX = 0<br>
GameObject.posY = 0<br>
function GameObject:Move()<br>
self .posX = self.posX+1<br>
self.posY = self.posY+1<br>
print(self.posX)<br>
print(self.posX)</p>
<p>end</p>
<p>GameObject:subClass(&quot;Player&quot;)--声明角色类</p>
<p>function Player:Move()--与父类方法“重名&quot;即相当于重写方法<br>
--此时base指GameObject类，使用“：”调用相当于把基类作为第一参数传入方法中，则此时创建pl2时会输出2，2<br>
--self.base:Move()<br>
--因此为了避免把基类表传入方法中，不使用“：”调用<br>
self.base.Move(self)--使用.进行调用自行填入第一个传入的参数<br>
print(&quot;子类重写&quot;)<br>
end</p>
<p>local pl1 = Player:new()--角色类对象<br>
pl1:Move()</p>
<p>local pl2 = Player:new()<br>
pl2:Move()<cood></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Grass批量生成]]></title>
        <id>https://Wei715547.github.io/post/grass-pi-liang-sheng-cheng/</id>
        <link href="https://Wei715547.github.io/post/grass-pi-liang-sheng-cheng/">
        </link>
        <updated>2020-09-14T15:09:33.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://Wei715547.github.io/post-images/1600096518618.PNG" alt="" loading="lazy"><br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
[ExecuteInEditMode]<br>
public class ProceduralGrass : MonoBehaviour<br>
{<br>
#region Terrain Data<br>
[Range(0, 1000)]<br>
public int terrainSize = 250;          //地形大小<br>
[Range(0, 100f)]<br>
public float terrainHeight = 10f;          //地形高度<br>
public Material terrainMat;          //地形材质</p>
<pre><code>private float xOffset;
private float zOffset;

[Range(1f, 100f)]
public float scaleFatter = 10f;          //地形缩放
[Range(1f, 100f)]
public float offsetFatter = 10f;          //地形偏移

List&lt;Vector3&gt; vertexs = new List&lt;Vector3&gt;();          //顶点列表，存储网格顶点信息
List&lt;int&gt; triangles = new List&lt;int&gt;();          //三角形面列表，存储网格三角形信息
float[,] perlinNoise;          //存储每个顶点的高度值

Vector3[] terrainNormals;          //存储地形的顶点法线的一维数组
Vector3[,] terrainNormals2D;          //存储地形的顶点法线的二维数组
#endregion 
//___________________________________________________________________________
#region Grass Data
[Range(0, 100)]
public int grassRowCount = 50;          //草根集,定义草的广度
[Range(1, 1000)]
public int grassCountPerPatch = 100;          //定义每一堆 草根集 的草密度
public Material grassMat;           //草的材质
public Mesh grassMesh;          //草的网格
List&lt;Vector3&gt; grassVerts = new List&lt;Vector3&gt;();          //存储草的顶点

Vector3[] grassNormals;          //存储草的顶点法线
List&lt;Vector3&gt; grassNormalList = new List&lt;Vector3&gt;();          //存储草的顶点法线列表
#endregion

void Start()
{
    xOffset = transform.position.x;
    zOffset = transform.position.z;
    terrainNormals = new Vector3[terrainSize * terrainSize];//顶点法线数组容量250*250
    terrainNormals2D = new Vector3[terrainSize, terrainSize];//2D顶点法线数组容量250*250
    perlinNoise = new float[terrainSize, terrainSize];//顶点高度数组容量250*250
    GenerateTerrain();//生成地形

    GenerateGrassArea(grassRowCount, grassCountPerPatch);//生成草地（广度，密度）

    
}

void CreateVertsAndTris()
{
    //遍历每一个顶点，并用列表 vertexs 和 triangles 存储
    for (int i = 0; i &lt; terrainSize; i++)
    {
        for (int j = 0; j &lt; terrainSize; j++)
        {
            float noiseHeight = GeneratePerlinNoise(i, j);//顶点随机高度
            perlinNoise[i, j] = noiseHeight;//该坐标下的顶点高度存入数组

            vertexs.Add(new Vector3(i, noiseHeight * terrainHeight, j));//顶点坐标（x,y,z）

            //不算上坐标轴的顶点
            if (i == 0 || j == 0)
                continue;

            //每三个顶点作为一个索引建立三角形
            triangles.Add(terrainSize * i + j);
            triangles.Add(terrainSize * i + j - 1);
            triangles.Add(terrainSize * (i - 1) + j - 1);
            triangles.Add(terrainSize * (i - 1) + j - 1);
            triangles.Add(terrainSize * (i - 1) + j);
            triangles.Add(terrainSize * i + j);
        }
    }

    //清空grassVerts的数据    
    grassVerts.Clear();
}

//生成地形高度的随机 Perlin 值
float GeneratePerlinNoise(int i, int j)
{
    float xCoord = (float)(i + xOffset) / terrainSize * scaleFatter + offsetFatter;
    float zCoord = (float)(j + zOffset) / terrainSize * scaleFatter + offsetFatter;

    return Mathf.PerlinNoise(xCoord, zCoord);
}

//生成地形网格数据
void GenerateTerrain()
{
    CreateVertsAndTris();

    //计算UV(二维向量-顶点坐标作为法线方向)
    Vector2[] uvs = new Vector2[vertexs.Count];
    for (int i = 0; i &lt; vertexs.Count; i++)
    {
        uvs[i] = new Vector2(vertexs[i].x, vertexs[i].z);
    }

    //添加一个 MyTerrain 的物体，并添加 MeshFilter / MeshRenderer 两个组件
    //MeshFilter 存储物体的网格信息
    //MeshRenderer 负责接收这些信息并把这些信息渲染出来
    GameObject Myterrain = new GameObject(&quot;Terrain0&quot;);
    Myterrain.transform.position = this.gameObject.transform.position;
    Myterrain.AddComponent&lt;MeshFilter&gt;();
    MeshRenderer renderer = Myterrain.AddComponent&lt;MeshRenderer&gt;();
    //开启地面的阴影投射和接受
    renderer.receiveShadows = true;
    renderer.shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.On;
    //添加Mesh Collider
    MeshCollider collider = Myterrain.AddComponent&lt;MeshCollider&gt;();

    //添加材质
    renderer.sharedMaterial = terrainMat;

    //创建一个 Mesh 网格
    Mesh groundMesh = new Mesh//网格构造函数
    {
        //输入网格顶点数据
        vertices = vertexs.ToArray(),
        //输入网格三角面数据
        triangles = triangles.ToArray(),
        uv = uvs
    };

    //为了得到正确的光照需要重新计算得到正确的法线信息
    groundMesh.RecalculateNormals();
    terrainNormals = groundMesh.normals;

    //将存储地形法线数组从一维数组转为二维，便于索引
    for (int i = 0; i &lt; terrainSize; i++)
    {
        for (int j = 0; j &lt; terrainSize; j++)
        {
            terrainNormals2D[i, j] = terrainNormals[i * terrainSize + j];
        }
    }
    //网格赋值到渲染器/碰撞体
    Myterrain.GetComponent&lt;MeshFilter&gt;().mesh = groundMesh;
    collider.sharedMesh = groundMesh;
}

void GenerateGrassArea(int rowCount, int perPatchSize)
{
    //最大顶点数为 65000
    List&lt;int&gt; indices = new List&lt;int&gt;();
    for (int i = 0; i &lt; 65000; i++)
    {
        indices.Add(i);
    }

    //初始位置
    Vector3 currentPos = transform.position;
    //草根集 每一次循环偏移的距离
    Vector3 patchSize = new Vector3(terrainSize / rowCount, 0, terrainSize / rowCount);

    //每一堆 草根集 进行循环
    for (int i = 0; i &lt; rowCount; i++)
    {
        for (int j = 0; j &lt; rowCount; j++)
        {
            GenerateGrass(currentPos, patchSize, perPatchSize);
            currentPos.x += patchSize.x;
        }
        currentPos.x = transform.position.x;
        currentPos.z += patchSize.z;
    }

    //生成 GrassLayerGruop 来成为父级管理物理
    GameObject grassLayerGroup1 = new GameObject(&quot;GrassLayerGroup1&quot;);
    //生成 GrassLayer 物体来存储草数据
    GameObject grassLayer;
    MeshFilter grassMeshFilter;
    //Mesh grassMesh;
    MeshRenderer grassMeshRenderer;
    int a = 0;

    //当 grassVerts.Count 的数量即草的全部顶点数超过 65000 个时
    //创立多个网格处理
    while (grassVerts.Count &gt; 65000)
    {
        Debug.Log(&quot;More65000&quot;);
        grassMesh = new Mesh();
        grassMesh.vertices = grassVerts.GetRange(0, 65000).ToArray();
        //存储每个草顶点的法线（当顶点超过 65000个）
        grassNormals = new Vector3[65000];
        grassNormalList.GetRange(0, 65000);
        for (int i = 0; i &lt; 65000; i++)
        {
            grassNormals[i] = grassNormalList[i];
        }

        //设置子网格的索引缓冲区,相关官方文档：https://docs.unity3d.com/ScriptReference/Mesh.SetIndices.html
        //每一个创建的网格的顶点数目不会超过 65000 个
        grassMesh.SetIndices(indices.ToArray(), MeshTopology.Points, 0);

        //创建一个新的 GameObject 来承载这些点
        grassLayer = new GameObject(&quot;GrassLayer &quot; + a++);
        grassLayer.transform.SetParent(grassLayerGroup1.transform);
        grassMeshFilter = grassLayer.AddComponent&lt;MeshFilter&gt;();
        grassMeshRenderer = grassLayer.AddComponent&lt;MeshRenderer&gt;();
        //关闭草地的阴影投射和接受
        grassMeshRenderer.receiveShadows = false;
        grassMeshRenderer.shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.Off;
        grassMeshRenderer.sharedMaterial = grassMat;
        grassMesh.normals = grassNormals;
        grassMeshFilter.mesh = grassMesh;
        //移除前 65000 个顶点
        grassVerts.RemoveRange(0, 65000);
        grassNormalList.RemoveRange(0, 65000);
    }
    #region 草的数量少于6500时
    //当 grassVerts.Count 的数量即草的全部顶点数没有超过 65000 个时
    grassLayer = new GameObject(&quot;GrassLayer&quot; + a);
    grassLayer.transform.SetParent(grassLayerGroup1.transform);
    grassMeshFilter = grassLayer.AddComponent&lt;MeshFilter&gt;();
    grassMeshRenderer = grassLayer.AddComponent&lt;MeshRenderer&gt;();
    
    //关闭草地的阴影投射和接受
    grassMeshRenderer.receiveShadows = false;
    grassMeshRenderer.shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.Off;
    grassMesh = new Mesh
    {
        vertices = grassVerts.ToArray()
    };

    //存储每个草顶点的法线（当顶点没有超过 65000个）
    grassNormals = new Vector3[grassMesh.vertexCount];
    grassNormalList.GetRange(0, grassMesh.vertexCount);
    for (int i = 0; i &lt; grassMesh.vertexCount; i++)
    {
        grassNormals[i] = grassNormalList[i];
    }
    grassMesh.normals = grassNormals;
    //设立子网格数据
    grassMesh.SetIndices(indices.GetRange(0, grassVerts.Count).ToArray(), MeshTopology.Points, 0);

    grassMeshFilter.mesh = grassMesh;
    grassMeshRenderer.sharedMaterial = grassMat;
    #endregion
}

//生成草
void GenerateGrass(Vector3 vertPos, Vector3 patchSize, int grassCountPerPatch)
{
    //每一堆 草根集 里的草进行循环
    for (int i = 0; i &lt; grassCountPerPatch; i++)
    {
        //Random.value 返回 0~1 之间的随机值
        //得到在两个 草根集 之间的草的随机位置并用索引值
        float randomX = Random.value * patchSize.x;
        float randomZ = Random.value * patchSize.z;

        int indexX = (int)((vertPos.x - transform.position.x) + randomX);
        int indexZ = (int)((vertPos.z - transform.position.z) + randomZ);

        //防止草种出地形
        if (indexX &gt;= terrainSize)
        {
            Debug.Log(&quot;Full&quot;);
            indexX = (int)terrainSize - 1;
        }

        if (indexZ &gt;= terrainSize)
        {
            Debug.Log(&quot;Full&quot;);
            indexZ = (int)terrainSize - 1;
        }

        //添加每一个草的顶点位置到 grassVert 列表里
        grassVerts.Add(new Vector3(vertPos.x + randomX, perlinNoise[indexX, indexZ] * terrainHeight, vertPos.z + randomZ));//包括草地Mesh网格顶点高度值

        //添加每一个草的顶点法线到 grassNormalList 列表里
        grassNormalList.Add(terrainNormals2D[indexX, indexZ]);//草地Mesh网格顶点法线，与同坐标的地面网格法线相同
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unet局域网连接]]></title>
        <id>https://Wei715547.github.io/post/unet-ju-yu-wang-lian-jie/</id>
        <link href="https://Wei715547.github.io/post/unet-ju-yu-wang-lian-jie/">
        </link>
        <updated>2020-09-12T03:14:28.000Z</updated>
        <content type="html"><![CDATA[<p>NetWorkManager:<br>
<img src="https://Wei715547.github.io/post-images/1599881098982.PNG" alt="" loading="lazy"></p>
<p>Player:<br>
<img src="https://Wei715547.github.io/post-images/1599881197525.PNG" alt="" loading="lazy"><br>
PlayerCT Cood:<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.Networking;</p>
<p>//[System.Obsolete]<br>
public class PlayerCT : NetworkBehaviour<br>
{</p>
<pre><code>public int rotateSpeed = 120;
public int moveSpeed = 3;

public GameObject Bullet;
public Transform firePoint;

// Update is called once per frame
void Update()
{
    if (isLocalPlayer == false)//控制本地角色
        return;
    float h = Input.GetAxis(&quot;Horizontal&quot;);
    float v = Input.GetAxis(&quot;Vertical&quot;);

    transform.Rotate(Vector3.up * h * rotateSpeed * Time.deltaTime); 
    transform.Translate(Vector3.forward * v * moveSpeed * Time.deltaTime);

    if (Input.GetKeyDown(KeyCode.Space))
    {
        CmdFire();
    }

}
[Command]//客户端发起调用，服务端执行
void CmdFire()//服务端调用的方法以Cmd开头
{
    GameObject bullet = Instantiate(Bullet, firePoint.position, firePoint.rotation);
    bullet.GetComponent&lt;Rigidbody&gt;().velocity = transform.forward * 10;//Bulet预制体添加Network Transform监测刚体组件（初始监测一次施加速度）
    Destroy(bullet, 2f);//2s后销毁

    NetworkServer.Spawn(bullet);//服务端执行同步到客户端
}

public override void OnStartLocalPlayer()//回调函数：加角色时执行
{
    GetComponent&lt;MeshRenderer&gt;().material.color = Color.blue;
    //firePoint = transform.Find(&quot;FirePoint&quot;).GetComponent&lt;Transform&gt;();
}
</code></pre>
<p>}</p>
<hr>
<p>Player Health Cood:<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.UI;<br>
using UnityEngine.Networking;</p>
<p>[System.Obsolete]<br>
public class Health : NetworkBehaviour<br>
{<br>
private Slider hpSl;<br>
public const int hp = 100;<br>
[SyncVar(hook =&quot;OnChangeHealth&quot;)]//特性：变量数据同步到客户端，变量变化时调用方法“方法名”<br>
private int currentHp = hp;<br>
private void Start()<br>
{<br>
hpSl = transform.Find(&quot;Canvas/HpSlider&quot;).GetComponent <Slider >();</p>
<pre><code>}
public void TakeDamage(int damege)
{
    if (isServer == false)//服务端执行，同步到客户端
        return;
    currentHp -= damege;
    if (currentHp &lt;=0)
    {
        currentHp = hp;
        Debug.Log(&quot;Dead&quot;);
        //Destroy(this.gameObject);
        RpcRespown();//角色复位
    }
    
}
void OnChangeHealth(int health)//[SyncVar hook=&quot;方法&quot;]特性标记的变量值发生变化时执行
{
    hpSl.value = health / (float)hp;
}
[ClientRpc]//客户端调用
void RpcRespown()//客户端调用以Rpc开头
{
    if (isLocalPlayer == false)//本地角色执行
        return;
    transform.position = Vector3.zero;
}
</code></pre>
<p>}</p>
<hr>
<p><img src="https://Wei715547.github.io/post-images/1599881655946.PNG" alt="" loading="lazy"><br>
Bullet Cood:<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class Bullet : MonoBehaviour<br>
{<br>
[System.Obsolete]<br>
private void OnCollisionEnter(Collision collision)<br>
{<br>
GameObject hit = collision.gameObject;<br>
Health health = hit.GetComponent<Health>();<br>
if (health !=null)<br>
{<br>
health.TakeDamage(Random.Range(10, 21));<br>
Destroy(this.gameObject);<br>
}<br>
}<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shader,屏幕后处理(Post Effect)]]></title>
        <id>https://Wei715547.github.io/post/shaderping-mu-hou-chu-li-post-effect/</id>
        <link href="https://Wei715547.github.io/post/shaderping-mu-hou-chu-li-post-effect/">
        </link>
        <updated>2020-09-08T07:34:21.000Z</updated>
        <content type="html"><![CDATA[<p>挂在主相机上的脚本：<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
[ExecuteInEditMode]//在编译器下执行脚本（不用点击开始即执行）<br>
public class Post : MonoBehaviour<br>
{<br>
public Material EffectMat;//承载后处理Shader的材质</p>
<pre><code>private void OnRenderImage(RenderTexture source, RenderTexture destination)//该函数在所有的渲染完成后由monobehavior自动调用。
//官方解释：该函数允许我们使用着色器滤波操作来修改最终的图像，输入原图像source，输出的图像放在desitination里。
{
    if (EffectMat !=null)
    {
        Graphics.Blit(source, destination, EffectMat);//该函数的作用就是通过一个shader将原图的像素放置到destionation中。
    }
}
</code></pre>
<p>}<br>
——————————————————————————————————————<br>
<img src="https://Wei715547.github.io/post-images/1599552275469.PNG" alt="" loading="lazy"><br>
Shader1画面溶解流动效果：<br>
Shader &quot;Shader104/Distortion&quot;<br>
{<br>
Properties<br>
{<br>
_MainTex(&quot;Texture&quot;, 2D) = &quot;white&quot; {}<br>
_DisplaceTex(&quot;Displacement Texture&quot;, 2D) = &quot;white&quot; {}<br>
_Magnitude(&quot;Magnitude&quot;, Range(0,0.1)) = 1</p>
<pre><code>}

SubShader
{
    Tags
    {
        &quot;Queue&quot; = &quot;Transparent&quot;
    }

    Pass{
        Blend SrcAlpha OneMinusSrcAlpha

        CGPROGRAM
        #pragma vertex vert
        #pragma fragment frag

        #include &quot;UnityCG.cginc&quot;

        struct appdata
        {
            float4 vertex : POSITION;
            float2 uv : TEXCOORD0;
        };

        struct v2f
        {
            float4 vertex : SV_POSITION;
            float2 uv : TEXCOORD0;
        };

        v2f vert(appdata v)
        {
            v2f o;
            o.vertex = UnityObjectToClipPos(v.vertex);
            o.uv = v.uv;
            return o;
        };

        sampler2D _MainTex;
        sampler2D _DisplaceTex;//噪波贴图
        float _Magnitude;

        float4 frag(v2f i): SV_Target//画面流动效果
        {
            float2 distuv = float2(i.uv.x + _Time.x * 2, i.uv.y + _Time.x * 2);
            float2 disp = tex2D(_DisplaceTex, distuv).xy;//噪波贴图的.rg
            disp = ((disp * 2) - 1) * _Magnitude;
            float4 col = tex2D(_MainTex, i.uv + disp);
            return col;
        }
        ENDCG
    }
}
</code></pre>
<p>}<br>
————————————————————————————————————————<br>
<img src="https://Wei715547.github.io/post-images/1599552284677.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1599552463055.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1599553049020.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1599553279813.PNG" alt="" loading="lazy"><br>
Shader2屏幕黑白、反色、RGB分离、像素效果：<br>
Shader &quot;Shader104/GreyScale&quot;<br>
{<br>
Properties<br>
{<br>
_MainTex(&quot;Texture&quot;, 2D) = &quot;white&quot; {}<br>
_Slider(&quot;Slider&quot;,Range(0,1)) = 0.5<br>
}</p>
<pre><code>SubShader
{
	Tags
	{
		&quot;PreviewType&quot; = &quot;Plane&quot;
	}
	Pass
	{
		CGPROGRAM
		#pragma vertex vert
		#pragma fragment frag

		#include &quot;UnityCG.cginc&quot;

		struct appdata
		{
			float4 vertex : POSITION;
			float2 uv: TEXCOORD0;
		};

		struct v2f
		{
			float4 vertex : SV_POSITION;
			float2 uv: TEXCOORD0;
		};

		sampler2D _MainTex;
		float _Slider;

		v2f vert(appdata v)
		{
			v2f o;
			o.vertex = UnityObjectToClipPos(v.vertex);
			o.uv = v.uv;
			return o;
		}

		float4 frag(v2f i) : SV_Target
		{
            /*pixelate像素效果对UV进行变换
            float2 uv = i.uv;
            uv.x *= _PixelateAmt;
            uv.y *= _PixelateAmt;
            uv.x = round(uv.x);
            uv.y = round(uv.y);
            uv.x /= _PixelateAmt;
            uv.y /= _PixelateAmt;*/
			float4 color = tex2D(_MainTex,i.uv);//默认混合颜色(白色)：不进行后处理
			float average = 0.212 * color.r + 0.7152 * color.g + 0.0722 * color.b;//颜色黑白化
			if (i.uv.x &gt; _Slider)//大于Slidr的部分进行后处理
				return float4(average, average, average, 1);
                //return float4(1-color.r, 1-color.g, 1-color.b, 1);//反色
			else
				return color;
             /*chromatic aberration RGB分离
            float4 red = tex2D(_MainTex , i.uv - _Offset);           
            float4 green = tex2D(_MainTex, i.uv);
            float4 blue = tex2D(_MainTex, i.uv + _Offset);
            float4 color = float4(red.r,green.g,blue.b,1);
            return color;*/
		}
		ENDCG
	}
}
</code></pre>
<p>}<br>
————————————————————————————————————————<br>
<img src="https://Wei715547.github.io/post-images/1599552847954.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1599553788615.PNG" alt="" loading="lazy"><br>
Shader3Kernal矩阵边缘检测、渐变着色:<br>
Shader &quot;Shader104/Kernal&quot;<br>
{<br>
Properties<br>
{<br>
_MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}<br>
_Matrix00 (&quot;Matrix00&quot;,float) = 1<br>
_Matrix01 (&quot;Matrix01&quot;,float) = 1<br>
_Matrix02 (&quot;Matrix02&quot;,float) = 1<br>
_Matrix10 (&quot;Matrix10&quot;,float) = 1<br>
_Matrix11 (&quot;Matrix11&quot;,float) = -8<br>
_Matrix12 (&quot;Matrix12&quot;,float) = 1<br>
_Matrix20 (&quot;Matrix20&quot;,float) = 1<br>
_Matrix21 (&quot;Matrix21&quot;,float) = 1<br>
_Matrix22 (&quot;Matrix22&quot;,float) = 1<br>
_Slider(&quot;Slider&quot;,Range(0,1)) = 0.5<br>
_Threshold(&quot;_Threshold&quot;,Range(0,1)) = 0.1<br>
_EdgeColor(&quot;_EdgeColor&quot;,Color) = (1,1,1,1)<br>
_BackColor(&quot;_BackColor&quot;,Color) = (0,0,0,0)</p>
<pre><code>}
SubShader
{
    Tags
    {
        &quot;PreviewType&quot; = &quot;Plane&quot;
    }

    Pass
    {
        CGPROGRAM
        #pragma vertex vert
        #pragma fragment frag
        
        #include &quot;UnityCG.cginc&quot;

        struct appdata
        {
            float4 vertex : POSITION;
            float2 uv : TEXCOORD0;
        };

        struct v2f
        {
            float2 uv : TEXCOORD0;
            float4 vertex : SV_POSITION;
        };

        v2f vert (appdata v)
        {
            v2f o;
            o.vertex = UnityObjectToClipPos(v.vertex);
            o.uv = v.uv;
            return o;
        }
        
        sampler2D _MainTex;
        float4 _MainTex_TexelSize;
        float _Matrix00;
        float _Matrix01;
        float _Matrix02;
        float _Matrix10;
        float _Matrix11;
        float _Matrix12;
        float _Matrix20;
        float _Matrix21;
        float _Matrix22;
        float _Slider;
        float _Threshold;
        float4 _EdgeColor;//边缘色
        float4 _BackColor;//背景色

        float4 box(sampler2D tex, float2 uv, float4 size)//检测函数
        {
            float4 c = tex2D(tex, uv + float2(-size.x, size.y))*_Matrix00 + tex2D(tex, uv + float2(0, size.y))*_Matrix01 
            + tex2D(tex, uv + float2(size.x, size.y)) *_Matrix02 + tex2D(tex, uv + float2(-size.x, 0)) * _Matrix10
            + tex2D(tex, uv + float2(0, 0))*_Matrix11 + tex2D(tex, uv + float2(size.x, 0))*_Matrix12 
            + tex2D(tex, uv + float2(-size.x, -size.y))*_Matrix20 + tex2D(tex, uv + float2(0, -size.y))*_Matrix21
            + tex2D(tex, uv + float2(size.x, -size.y))*_Matrix22;

            return c / (_Matrix00+_Matrix01+_Matrix02+_Matrix10+_Matrix11+_Matrix12+_Matrix20+_Matrix21+_Matrix22);
        }

        float4 frag (v2f i) : SV_Target
        {
            float4 color = tex2D(_MainTex, i.uv);
            if(i.uv.x&gt;_Slider)
			{//边缘检测
                color = box(_MainTex, i.uv, _MainTex_TexelSize);
                if (color.r &lt;= _Threshold &amp;&amp; color.g &lt;= _Threshold &amp;&amp; color.b &lt;= _Threshold)//渐变着色
                    return _EdgeColor;
                else
                    return _BackColor;
            }
            else
                if (color.r &lt;= _Threshold &amp;&amp; color.g &lt;= _Threshold &amp;&amp; color.b &lt;= _Threshold)//渐变着色
                    return color;
                else
                    return float4(1, 1, 1, 1);//未上色部分为白色
        }
        ENDCG
    }
}
</code></pre>
<p>}<br>
————————————————————————————————————<br>
<img src="https://Wei715547.github.io/post-images/1599556756456.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1599556177672.PNG" alt="" loading="lazy"><br>
Shader深度值渲染/范围扫描：<br>
相机脚本：<br>
using UnityEngine;<br>
using System.Collections;<br>
using System.Collections.Generic;</p>
<p>[ExecuteInEditMode]<br>
public class ReplacementShaderEffect : MonoBehaviour<br>
{<br>
public Color color;<br>
public float slider;<br>
public Shader ReplacementShader;</p>
<pre><code>void OnValidate()
{
    Shader.SetGlobalColor(&quot;_Color_1&quot;, color);//获取Shader中未公开的全局变量
}

private void Update()
{
    Shader.SetGlobalFloat(&quot;_Temp&quot;, slider);//获取Shader中未公开的全局变量
}

void OnEnable()
{
    if (ReplacementShader != null)
        GetComponent&lt;Camera&gt;().SetReplacementShader(ReplacementShader, &quot;&quot;);
}

void OnDisable()
{
    GetComponent&lt;Camera&gt;().ResetReplacementShader();
}
</code></pre>
<p>}<br>
————————————————————————————————<br>
Shader程序：<br>
Shader &quot;Shader102/Depth&quot;<br>
{<br>
SubShader<br>
{<br>
Tags<br>
{<br>
&quot;RenderType&quot; = &quot;Opaque&quot;<br>
}</p>
<pre><code>	ZWrite On


	Pass
	{
		CGPROGRAM
		#pragma vertex vert
		#pragma fragment frag

		#include &quot;UnityCG.cginc&quot;

		struct appdata
		{
			float4 vertex : POSITION;
		};

		struct v2f
		{
			float4 vertex : SV_POSITION;
			float depth : DEPTH;
		};

		v2f vert(appdata v)
		{
			v2f o;
			o.vertex = UnityObjectToClipPos(v.vertex);
			o.depth = -(mul(UNITY_MATRIX_MV, v.vertex).z) * _ProjectionParams.w;//相机坐标空间下的深度值
			return o;
		}
		//未公开的全局变量
		float4 _Color_1;
		float _Temp;
        //根据深度值切换渲染方式
		/*fixed4 frag(v2f i) : SV_Target
		{
			float invert = 1 - i.depth;//近处颜色为白色

		if (i.depth &lt;_Temp / 2)//不同深度下实现不同的渲染方式
			return fixed4(invert, invert, invert, 1);
		else
			return fixed4(invert*1.5, 0.3, 0.3,1) ;
		}*/
        //范围扫描
        fixed4 frag(v2f i) : SV_Target
		{
			float invert = 1 - i.depth;//近处颜色为白色

		if (abs(i.depth- _Temp / 2)&lt;0.005)//深度范围绝对值内扫描的渲染方式
			return fixed4(invert*2, 0.2, 0.2, 1);
		else//正常渲染方式
			return fixed4(invert, 0.3, 0.3,1) ;
		}
		ENDCG
	}
}
</code></pre>
<p>}<br>
数值动画/代码：<br>
timer += Time.deltaTime;<br>
if (timer &gt;2.0f)<br>
{<br>
ht += Time.deltaTime*(1/5f);<br>
slider = Mathf.Lerp(0f, 10f, 0.5f * ht);<br>
if (ht&gt;=1f)<br>
{<br>
ht = 0;<br>
slider = 0;<br>
timer = 0;<br>
}<br>
}</p>
]]></content>
    </entry>
</feed>