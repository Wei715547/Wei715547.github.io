<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Wei715547.github.io</id>
    <title>Wei: Development technology accumulation</title>
    <updated>2020-08-07T15:49:19.141Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Wei715547.github.io"/>
    <link rel="self" href="https://Wei715547.github.io/atom.xml"/>
    <subtitle>年月增长，我宜强盛。
用于Unity+开发的技术积累</subtitle>
    <logo>https://Wei715547.github.io/images/avatar.png</logo>
    <icon>https://Wei715547.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Wei: Development technology accumulation</rights>
    <entry>
        <title type="html"><![CDATA[框架标签]]></title>
        <id>https://Wei715547.github.io/post/kuang-jia-biao-qian/</id>
        <link href="https://Wei715547.github.io/post/kuang-jia-biao-qian/">
        </link>
        <updated>2020-08-07T15:44:36.000Z</updated>
        <content type="html"><![CDATA[<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>无标题文档</title>
</head>
<frameset rows="15%,*">
<frame src="top.html" noresize="noresize" />
<frameset cols="50%s,*">
<frame src="left.html"  name="left"/> 
<frame src="right.html"/>
</frameset>
</frameset><noframes></noframes>
</html>
————————————————————————————————————
LEFT
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>无标题文档</title>
</head>
<body bgcolor="#66FFFF">
LEFT
<a href="https://wei715547.github.io">WEI</a>
</body>
</html>
_____________________________________________________________________________
RIGHT
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>无标题文档</title>
</head>
<body bgcolor="#FFCC00">
RIGHT
<a href="http://www.bilibili.com" target="left">哔哩哔哩</a>
</body>
</html>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTML]]></title>
        <id>https://Wei715547.github.io/post/html/</id>
        <link href="https://Wei715547.github.io/post/html/">
        </link>
        <updated>2020-08-04T14:13:47.000Z</updated>
        <content type="html"><![CDATA[<p>基本结构</p>
<hr>
<html>
        <head>
               <title>网页标题</title>
        </head>
        <body>
                    网页内容
        </body>
</html>
—————————————————————————————————
class1：
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>HTML</title>
</head>
<body>
	<p>喵啊</p><!--段落-->
    <p>妙&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;啊</p><!--空格：&nbsp;-->
    <h1>我是标题</h1>
    <h2>我是标题</h2>
    <h3>我是标题</h3>
    <h4>我是标题</h4>
<h5>我是标题</h5>
    <img src="2.jpg" width="720" height="1280" border ="5px" title="漂亮" alt="Mays"/>
    <!--属性名=值
    src:要显示的图片路径
    width：宽度（px）
    heigh:高度
    border:边框宽度
    title:鼠标悬停时显示的字符
    alt:图片丢失时所显示的备份文字
    -->
    <p><b>Hello Word</b></p>
    <hr/><!--分割线-->
    <p>Hello Word</p>
<p>Hello Word</p>
    <p>Hello Word</p>
    <p>Hello Word</p>
    <hr/>
    Hello Word<br/><!--换行-->
    Hello Word<br/>
    5&gt;3<br/> <!--大于：&gt; 小于:&lt; &:&amp;-->
    3&lt;5 &amp;&amp;&amp;<br/>
    <font size="5" color="#FF0000" face="Comic Sans MS, cursive">每单只需</font> <font size="7" color="#66FFFF">8888元</font>
    <!--以代码形式显示-->
    <pre>
    <code>
    		for(i=0;i<100;i++)
            {
            	print("WEI");
            }
     </code>
     </pre>
     <!--图片滑行-->
     <marquee direction="right"  behavior="slide" ><img src="2.jpg"  width="720" height="1280" /></marquee>
     <br/>     
     <a  name="C1" href="class2.html#C2">C2</a>
</body>
</html>
![](https://Wei715547.github.io/post-images/1596552695480.jpg)
![](https://Wei715547.github.io/post-images/1596553108815.PNG)
<p>——————————————————————————————————————————</p>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Class2</title>
</head>
<body>
<a href="http://www.bilibili.com"  target="_blank">哔哩哔哩</a> <br/>
<a href="mailto:1941071686@qq.com">发送邮件到WEI</a><br/>
<a name="C2" href="Base_Tag.html#C1"> C1</a><br/>
<a name="TOP" href="#DOWN">回到底端</a>
<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>
<a name="DOWN"  href="#TOP">回到顶端</a>
</body>
</html>
![](https://Wei715547.github.io/post-images/1596554028605.jpg)
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>body中的属性</title>
</head>
<body text="blue" link="#00FFFF" alink="red" bgcolor="#FFD0E0" background="2.jpg">
妙啊
<a href="#">超链接</a>
<a href="#">超链接</a>
<a href="#">超链接</a>
<a href="#">超链接</a>
<a href="#">超链接</a>
<br/>
<!--列表-->
<u1 type="square">
	<li>第一行</li>
    <li>第2行</li>
    <li>第3行</li>
    <li>第4行</li>
    <li>第5行</li>    
</u1>
<hr/>
<ol type="a">
	<li>第一行</li>
    <li>第一行</li>
    <li>第一行</li>
    <li>第一行</li>
    <li>第一行</li>
</ol><br/>
<dl>
	<dt>面向对象</dt>
    <dd>封装</dd>
    <dd>继承</dd>
    <dd>多态</dd>
</dl>
<br/>
<table border="5px" cellspacing="5px" cellpadding="5px">
	<tr>
    <td colspan="3"> html表格</td><!--跨行-->
    </tr>
	<tr>
    <td rowspan="2"><a href="www.bilibili.com">哔哩哔哩</a></td><!--跨列-->
    <td>WEI</td>
    <td>ZL</td>
    </tr>
    <tr>
<pre><code>&lt;td&gt;www&lt;/td&gt;
&lt;td&gt;zzz&lt;/td&gt;
&lt;/tr&gt;
</code></pre>
</table>
</body>
</html>
————————————————————————————————————
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>表单</title>
</head>
<body>
	<form action="www.baidu.com" method="get">
    用户名：<input type="text"  name="txtName"/><br />
    密码：<input type="password"  name="txtPassword"/><br />
    <input type="submit"  value="提交"/>
    <input type="reset"  value="重置"/><br />
    <fieldset>
    <legend>性别</legend>
    <input type="radio" name="sex"/>男<br />
    <input type="radio" name="sex" />女<br />
    </fieldset>
    <fieldset>
    <legend>婚姻状况</legend>
    <input type="radio" name="married"/>yh<br />
    <input type="radio" name="married" />wh<br />
    </fieldset>
<pre><code>&lt;select size=&quot;1&quot;&gt;
	&lt;optgroup label = &quot;中国&quot;&gt;
	&lt;option&gt;辽宁&lt;/option&gt;
    &lt;option&gt;浙江&lt;/option&gt;
    &lt;option&gt;上海&lt;/option&gt;
    &lt;option&gt;重庆&lt;/option&gt;
    &lt;option&gt;广东&lt;/option&gt;
   &lt;/optgroup&gt;
   &lt;optgroup label = &quot;米国&quot;&gt;
	&lt;option&gt;洛杉矶&lt;/option&gt;
    &lt;option&gt;旧金山&lt;/option&gt;
    &lt;option&gt;芝加哥&lt;/option&gt;
    &lt;option&gt;华盛顿&lt;/option&gt;
    &lt;option&gt;曼哈顿&lt;/option&gt;
   &lt;/optgroup&gt;
&lt;/select&gt;&lt;br /&gt;
&lt;input type=&quot;file&quot; /&gt;&lt;br /&gt;
&lt;textarea cols=&quot;50&quot; rows=&quot;20&quot;&gt;
wxqdwexqwcq wecq qs qs  q 
qs q
 qw q qw
 
&lt;/textarea&gt;

&lt;/form&gt;&lt;br /&gt;

&lt;form action=&quot;http://www.bilibili.com&quot; method=&quot;get&quot;&gt;
	&lt;table  border=&quot;5px&quot;&gt;
    	&lt;tr&gt;
    	&lt;td&gt;用户名&lt;/td&gt;
        &lt;td&gt;&lt;input type=&quot;text&quot;  name=&quot;txtname&quot;/&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;密码&lt;/td&gt;
        &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;txtPsw&quot; /&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;验证码&lt;/td&gt;
        &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;txtJude&quot; /&gt;&lt;!--&lt;img src=&quot;2.jpg&quot; height=&quot;1220&quot; /&gt;--&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;txtRem&quot; /&gt;记住密码&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;input type=&quot;submit&quot; /&gt;&lt;input type=&quot;reset&quot; /&gt;&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
</code></pre>
</form>
<div style="background:#6FF; height:50px; width:1000px">DIV独占一层，用于布局</div>
<span>Span标签修饰字体</span>
</body>
</html>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TCP/IP模型]]></title>
        <id>https://Wei715547.github.io/post/tcpip-mo-xing/</id>
        <link href="https://Wei715547.github.io/post/tcpip-mo-xing/">
        </link>
        <updated>2020-08-01T05:58:14.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://Wei715547.github.io/post-images/1596261613930.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1596261986768.PNG" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OSI参考模型]]></title>
        <id>https://Wei715547.github.io/post/osi-can-kao-mo-xing/</id>
        <link href="https://Wei715547.github.io/post/osi-can-kao-mo-xing/">
        </link>
        <updated>2020-08-01T05:24:30.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://Wei715547.github.io/post-images/1596259676351.jpg" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1596259685462.PNG" alt="" loading="lazy"><br>
下层为上层服务<br>
7：应用层：<br>
6：表示层：1.数据格式变换。2.数据加密解密。3.数据压缩与恢复<br>
5：会话层：ASP,ADSP<br>
进程下建立连接，管理，终止会话。<br>
大文件传输使用校验点可使会话在通信失效时从校验点/同步点继续恢复通信，实现数据同步<br>
4：传输层：进程间的通信，端到端，以报文/数据报形式传输 TCP,UDP协议<br>
1.可靠传输（分段发送），不可靠传输<br>
2.差错控制<br>
3.流量控制 依据接收速度控制发射速度<br>
4.复用分用<br>
3：网络层：把分组从源端传输到目的端，为分组交换网上的不同主机提供通信服务，以数据包传输<br>
IP协议         1.路由选择<br>
2.流量控制<br>
3.差错控制.<br>
4.拥塞控制<br>
2.数据链路层：将网络层传下来的数据包组装呈帧（字节流）<br>
1.成帧（定义帧的开始及结束）<br>
2.差错控制 帧错，位错<br>
3.流量控制<br>
4。访问接入控制，控制对信道的访问<br>
1.物理层：传输比特流 透明传输 byte-电信号 --Rj45,802.3协议<br>
1.定义接口特性<br>
2.定义传输模式，单工，半双工，双工<br>
3.定义传输速率<br>
4.比特同步<br>
5.比特编码</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GDI生成随机验证码]]></title>
        <id>https://Wei715547.github.io/post/gdi-sheng-cheng-sui-ji-yan-zheng-ma/</id>
        <link href="https://Wei715547.github.io/post/gdi-sheng-cheng-sui-ji-yan-zheng-ma/">
        </link>
        <updated>2020-07-31T15:20:10.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://Wei715547.github.io/post-images/1596208934558.PNG" alt="" loading="lazy"><br>
/// <summary><br>
/// 生成验证码<br>
/// </summary><br>
/// <param name="sender"></param><br>
/// <param name="e"></param><br>
private void pictureBox1_Click(object sender, EventArgs e)<br>
{<br>
//产生随机数数组<br>
Random r = new Random();<br>
string str = null;<br>
for (int i = 0; i &lt; 5; i++)<br>
{</p>
<pre><code>            int rnumber = r.Next(0, 10);
            str += rnumber;
        }

        //创建图像与GDI对象
        Bitmap bmp = new Bitmap(150,40);
        Graphics g = Graphics.FromImage(bmp);

        //将字符随机字体及颜色画到图片上
        for (int i = 0; i &lt; 5; i++)
        {
            Point p = new Point(i * 20, 0);
            string[] font = { &quot;微软雅黑&quot;, &quot;宋体&quot;, &quot;黑体&quot;, &quot;隶书&quot;, &quot;仿宋&quot; };
            Color[] colors = { Color.Red, Color.Blue, Color.Green, Color.DarkOliveGreen, Color.Cyan };
            g.DrawString(str[i].ToString(),new Font(font[r.Next (0,5)],15,FontStyle.Bold),new SolidBrush(colors[r.Next(0,5)]),p);
        }

        //随机线条
        for (int i = 0; i &lt; 25; i++)
        {
            Point p1 = new Point (r.Next(0,bmp.Width),r.Next(0,bmp.Height));
            Point p2 = new Point (r.Next(0,bmp.Width),r.Next(0,bmp.Height));
            g.DrawLine(new Pen(Brushes.Green), p1, p2);
        }

        //随机像素点
        for (int i = 0; i &lt; 500; i++)
        {
            Point p = new Point(r.Next(0, bmp.Width), r.Next(0, bmp.Height));
            bmp.SetPixel(p.X, p.Y, Color.Black);
        }

        //将图片嵌入到PcBox中
        pictureBox1.Image = bmp;

    }</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Socket-服务器向客户端发送小文件/抖动]]></title>
        <id>https://Wei715547.github.io/post/socket-fu-wu-qi-xiang-ke-hu-duan-fa-song-xiao-wen-jian-dou-dong/</id>
        <link href="https://Wei715547.github.io/post/socket-fu-wu-qi-xiang-ke-hu-duan-fa-song-xiao-wen-jian-dou-dong/">
        </link>
        <updated>2020-07-30T11:30:49.000Z</updated>
        <content type="html"><![CDATA[<p>服务器端：<br>
/// <summary><br>
/// 选择文件按钮<br>
/// </summary><br>
/// <param name="sender"></param><br>
/// <param name="e"></param><br>
private void btn_Choose_Click(object sender, EventArgs e)<br>
{<br>
OpenFileDialog opf = new OpenFileDialog();<br>
opf.Title = &quot;请选择文件&quot;;<br>
opf.InitialDirectory = @&quot;C:\Users\qweasd\Pictures\Mays\Vt&quot;;<br>
//opf.Multiselect = true;<br>
opf.Filter = &quot;所有文件|<em>.</em>;&quot;;<br>
opf.ShowDialog();<br>
textBox1.Text = opf.FileName;//返回选择文件的全路径<br>
}<br>
/// <summary><br>
/// 发送文件按钮<br>
/// </summary><br>
/// <param name="sender"></param><br>
/// <param name="e"></param><br>
private void btn_SendFile_Click(object sender, EventArgs e)<br>
{<br>
string path = textBox1.Text;<br>
//文件流读取<br>
using (FileStream fs = new FileStream (path,FileMode.OpenOrCreate,FileAccess.Read))<br>
{<br>
byte[] date = new byte[1024 * 1024 * 5];<br>
int r = fs.Read(date, 0, date.Length);<br>
//配置标记位<br>
List<byte> list = new List<byte>();<br>
list.Add(1);//在文件的字节数组前添加标记位用来判断其文件类型<br>
list.AddRange(date);<br>
byte[] newdate = list.ToArray();<br>
dicSocket[comboBox1.SelectedItem.ToString()].Send(newdate, 0, r + 1, SocketFlags.None);//从0 开始多传输1位数据</p>
<pre><code>        }
    }

    private void btn_DJ_Click(object sender, EventArgs e)
    {
        byte[] date = new byte[1];
        date[0] = 2;//震动标记为2
        dicSocket[comboBox1.SelectedItem.ToString()].Send(date);
    }
</code></pre>
<p>客户端：<br>
在接收服务器端数据的方法中进行判断<br>
private void Receive()<br>
{<br>
while (true)<br>
{<br>
try<br>
{<br>
byte[] buffer = new byte[1023 * 1023 * 2];<br>
int r = socketSend.Receive(buffer);<br>
if (r == 0)<br>
break;<br>
//通过第一个标记位来判断文件类型（简单协议）<br>
if (buffer[0] == 0)//标志位为0时，发送的是普通文本<br>
{<br>
string str = Encoding.UTF8.GetString(buffer, 1, r-1);<br>
ShowMsg(socketSend.RemoteEndPoint + &quot;:&quot; + str);</p>
<pre><code>                }else if (buffer[0]==1)
                {
                    SaveFileDialog sfd = new SaveFileDialog();
                    sfd.InitialDirectory = @&quot;C:\Users\qweasd\Pictures\Mays\Vt\Soc&quot;;
                    sfd.Title = &quot;选择要保存到文件&quot;;
                    sfd.Filter = &quot;所有文件|*.*&quot;;
                    sfd.ShowDialog(this);
                    string path = sfd.FileName;
                    using (FileStream fs = new FileStream (path,FileMode.OpenOrCreate,FileAccess.Write))
                    {
                        fs.Write(buffer, 1, r - 1);
                    }
                }
                else if (buffer[0]==2)
                {
                    Shork();
                }

                
            }
            catch
            { }
        }
    }
    /// &lt;summary&gt;
    /// 震动
    /// &lt;/summary&gt;
    private void Shork()
    {
        for (int i = 0; i &lt; 500; i++)
        {
            this.Location = new Point(this.Location.X + 50, this.Location.Y + 50);
            this.Location = new Point(this.Location.X - 50, this.Location.Y - 50);
        }
    }</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Winform-Socket客户端]]></title>
        <id>https://Wei715547.github.io/post/winform-socket-ke-hu-duan/</id>
        <link href="https://Wei715547.github.io/post/winform-socket-ke-hu-duan/">
        </link>
        <updated>2020-07-30T09:06:19.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://Wei715547.github.io/post-images/1596100018787.PNG" alt="" loading="lazy"><br>
using System;<br>
using System.Collections.Generic;<br>
using System.ComponentModel;<br>
using System.Data;<br>
using System.Drawing;<br>
using System.Linq;<br>
using System.Net;<br>
using System.Net.Sockets;<br>
using System.Text;<br>
using System.Threading;<br>
using System.Threading.Tasks;<br>
using System.Windows.Forms;</p>
<p>namespace Socket客户端<br>
{<br>
public partial class Form1 : Form<br>
{<br>
public Form1()<br>
{<br>
InitializeComponent();<br>
}<br>
Socket socketSend;//负责通信的Socket<br>
/// <summary><br>
/// 连接服务器按钮<br>
/// </summary><br>
/// <param name="sender"></param><br>
/// <param name="e"></param><br>
private void btn_Cont_Click(object sender, EventArgs e)<br>
{<br>
try<br>
{<br>
//创建负责通信的Socket<br>
socketSend = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);<br>
//获取远程要连接的服务器的IP地址以及端口号<br>
IPAddress ipaddress = IPAddress.Parse(textIP.Text);//可以将一个字符串的IP地址转化为IPaddress的对象<br>
EndPoint point = new IPEndPoint(ipaddress, Convert.ToInt32(textPort.Text));//(ip地址，字符转端口号方法)<br>
//连接服务器<br>
socketSend.Connect(point);<br>
ShowMsg(&quot;连接成功&quot;);<br>
//开启一个子线程接收服务器发来的消息<br>
Thread th = new Thread(Receive);<br>
th.IsBackground = true;<br>
th.Start();<br>
}catch<br>
{ }</p>
<pre><code>    }
    /// &lt;summary&gt;
    /// 不停接收服务器发来的消息
    /// &lt;/summary&gt;
    private void Receive()
    {
        try
        {
            while (true)
            {
                byte[] buffer = new byte[1023 * 1023 * 2];
                int r = socketSend.Receive(buffer);
                if (r == 0)
                    break;
                string str = Encoding.UTF8.GetString(buffer, 0, r);
                ShowMsg(socketSend.RemoteEndPoint + &quot;:&quot; + str);

            }
        }
        catch
        { }
    }

    private void ShowMsg(string str)
    {
        textLog.AppendText(str + &quot;\r\n&quot;);
    }

    /// &lt;summary&gt;
    /// 客户端向服务器发送消息
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt;
    /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt;
    private void btn_Send_Click(object sender, EventArgs e)
    {
        string str = textMsg.Text.Trim();
        byte[] date = Encoding.UTF8.GetBytes(str);
        socketSend.Send(date);
    }

    private void Form1_Load(object sender, EventArgs e)
    {
        Control.CheckForIllegalCrossThreadCalls = false;
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Winform-Socket服务器]]></title>
        <id>https://Wei715547.github.io/post/winform-socket-fu-wu-qi/</id>
        <link href="https://Wei715547.github.io/post/winform-socket-fu-wu-qi/">
        </link>
        <updated>2020-07-30T09:02:08.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://Wei715547.github.io/post-images/1596121054593.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1596099971910.PNG" alt="" loading="lazy"><br>
using System;<br>
using System.Collections.Generic;<br>
using System.ComponentModel;<br>
using System.Data;<br>
using System.Drawing;<br>
using System.Linq;<br>
using System.Net;<br>
using System.Net.Sockets;<br>
using System.Text;<br>
using System.Threading;<br>
using System.Threading.Tasks;<br>
using System.Windows.Forms;</p>
<p>namespace Socket服务端<br>
{<br>
public partial class Form1 : Form<br>
{<br>
public Form1()<br>
{<br>
InitializeComponent();<br>
}</p>
<pre><code>    //存储客户端IP与Socket的键值对集合
    Dictionary&lt;string, Socket&gt; dicSocket = new Dictionary&lt;string, Socket&gt;();
    /// &lt;summary&gt;
    /// 开始监听按钮
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt;
    /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt;
    private void button1_Click(object sender, EventArgs e)
    {
        try
        {
            //1.创建一个监听的Socket
            Socket socketWatch = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            
            //2.创建IP地址和端口号对象
            IPAddress ip = IPAddress./*Any;//*/Parse(textIP.Text);
            IPEndPoint point = new IPEndPoint(ip, Convert.ToInt32(textPort.Text));
            
            //3.让负责监听的Socket绑定IP以及端口号
            socketWatch.Bind(point);
            ShowMdg(&quot;监听成功&quot;);
            
            //4.监听队列
            socketWatch.Listen(10);
            
            //5.创建负责监听的Socket,来接受客户端的连接， 创建与客户端通信的Socket (需要在子线程中循环执行)
            Thread th = new Thread(Listen);
            th.IsBackground = true;
            th.Start(socketWatch);
        }
        catch
        { }

    }
    /// &lt;summary&gt;
    ///监听方法
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;o&quot;&gt;主进程中创建的负责监听的Socket以object形式传入&lt;/param&gt;
    private void Listen(object o)
    {
        //转为Socket类的对象(里式转换)
        Socket socketWatch = o as Socket;
        while (true)//循环监听客户端的接入，为其创建负责与之通信的Socket对象，并以IP,Socket对象的键值对形式将其加入列表
        {
            try
            {
                Socket socketSend = socketWatch.Accept();//5.次方法会一直等待客户端进行连接需在子线程中执行
                dicSocket.Add(socketSend.RemoteEndPoint.ToString(), socketSend);//客户端连接到服务器时将其IP地址与负责通信的Socket存入字典集合
                //将远程客户端的IP地址端口号存到下拉菜单中
                comboBox1.Items.Add(socketSend.RemoteEndPoint.ToString());
                ShowMdg(socketSend.RemoteEndPoint.ToString() + &quot;连接成功&quot;);//显示远程客户端及端口号

                //6.客户端连接成功后，服务器接收客户端发来的消息 (子线程中循环执行)
                Thread th = new Thread(Receive);
                th.IsBackground = true;
                th.Start(socketSend);
            }catch
            { }
        }
    }
    /// &lt;summary&gt;
    /// 服务器端不停接收客户端发来的消息
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;o&quot;&gt;子线程中创建的负责与此客户端收发数据的Socket对象&lt;/param&gt;
    private void Receive(object o)
    {
        Socket socketSend = o as Socket;
        while (true)//不断接受客户端发来的消息
        {
            try
            {
                byte[] date = new byte[1024 * 1024 * 2];//字节数组容器：接收发来的消息
                int r = socketSend.Receive(date);
                if (r == 0)//客户端退出收到的字节数为0时结束循环，不再接收此客户端消息
                    break;
                string s = Encoding.UTF8.GetString(date, 0, r);
                ShowMdg(socketSend.RemoteEndPoint.ToString() + &quot;:&quot; + s);
            }
            catch
            { }//为空：出现异常时不进行反馈
        }
    }

    private void ShowMdg(string date)
    {
        textLog.AppendText(date + &quot;\r\n&quot;);
    }

    private void Form1_Load(object sender, EventArgs e)
    {
        Control.CheckForIllegalCrossThreadCalls=false;//取消跨线程检测
    }
    /// &lt;summary&gt;
    /// 服务器向客户端发送消息
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt;
    /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt;
    private void btn_Send_Click(object sender, EventArgs e)
    {
        string message = textMsg.Text;//向客户端传输的信息
        byte[] data = Encoding.UTF8.GetBytes(message);//对一个字符串做编码，转为字节数组
        //获取用户在下拉菜单中选中的IP地址(服务器给指定客户端发送消息)
        string ip = comboBox1.SelectedItem.ToString();
        dicSocket[ip].Send(data);

        //向每个客户端发送消息
        /*foreach (KeyValuePair&lt;string ,Socket&gt; soc in dicSocket)
        {
            soc.Value.Send(data);
        }*/
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Winform控件]]></title>
        <id>https://Wei715547.github.io/post/winform-kong-jian/</id>
        <link href="https://Wei715547.github.io/post/winform-kong-jian/">
        </link>
        <updated>2020-07-28T02:03:35.000Z</updated>
        <content type="html"><![CDATA[<p>控件：<br>
1.属性：Name--后台获取前台对象，需要使用的属性。<br>
visible--是否显示控件<br>
Enable--是否可用控件<br>
2.事件: 注册事件<br>
触发事件<br>
3.在Program-Main函数中创建的窗口为主窗口程序，次窗口关闭时整个应用程序庀</p>
<pre><code>5.TextBox控件 WordWrap:指示文本框是否换行
                        PasswordChar:文本框输入时显示固定字符
                        SoocllBar:是否显示滚动条
                        事件：TextChange:文本框内容发生改变时调用方法
6.Timer 事件：Enable默认为False,启用更改为True; Tick:每隔固定时间调用方法

7.RadioButton：多选按钮--存在多个时只可选一个，使用GroupBox分组可选择多个

8.MenuStrip：菜单栏（多组按钮）
MDI窗口设计：主窗体MDI属性设置为True，
                        子窗体  from.MdiParent(from1);-设置父窗体。
                        子窗体排列：在主窗体方法中调用--LayoutMdi(MdiLayout.TileHorizontal);(横向排列）
                        LayoutMdi(MdiLayout.TileVertical);(纵向排列）
9.ListBox：listBox1.Items.Add()--列表项，listBox1.SelectedIndex--当前所选中列表中项目的索引
事件:
    private void listBox1_DoubleClick(object sender, EventArgs e)
    {
        SoundPlayer sp = new SoundPlayer();//多媒体音乐播放器类
        sp.SoundLocation = musicFullPath[listBox1.SelectedIndex];//音乐文件的全路径
        sp.Play();
    }
10.打开文件：private void btn_Openfile_Click(object sender, EventArgs e)
    {
        OpenFileDialog opf = new OpenFileDialog();
        opf.Title = &quot;请选择文件&quot;;
        opf.InitialDirectory = @&quot;C:\Users\qweasd\Music&quot;;
        opf.Multiselect = true;
        opf.Filter = &quot;音乐文件|*.wav|所有文件|*.*;&quot;;
        opf.ShowDialog();
        //获得在该文件夹下选择的所有文件的全路径
        string[] musicFiles = opf.FileNames;
        for (int i = 0; i &lt; musicFiles.Length; i++)
        {
            listBox1.Items.Add(Path.GetFileName(musicFiles[i]));//从全路径中截取文件名方法，将文件名显示在ListBox中
            musicFullPath.Add(musicFiles[i]);//所有选中音乐的全文件路径列表
        }

    }

Winform线程：窗体加载时不开启跨线程检测
private void Form1_Load(object sender, EventArgs e)
    {
        //允许不同线程间进行数据访问
        Control.CheckForIllegalCrossThreadCalls = false;
    }

    private void Form1_FormClosing(object sender, FormClosingEventArgs e)
    {
        if(th!=null)
        {
            //子线程不为空时，随主线程关闭同时关闭子线程
            th.Abort();
        }
    }

Thread th = new Thread(StartRun);//此线程执行的方法/或传入委托/表达式
th.IsBackground = true;//后台运行
th.Start();//方法需要传递参数时可写在Start中“objecr”参数在方法中转为子类对象
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MD5加密]]></title>
        <id>https://Wei715547.github.io/post/md5-jia-mi/</id>
        <link href="https://Wei715547.github.io/post/md5-jia-mi/">
        </link>
        <updated>2020-07-27T08:52:16.000Z</updated>
        <content type="html"><![CDATA[<p>class Program<br>
{<br>
static void Main(string[] args)<br>
{<br>
Console.WriteLine(GetMd5(&quot;123&quot;));<br>
//202cb962ac5975b964b7152d234b70<br>
}</p>
<pre><code>    public static string GetMd5(string str)
    {
        MD5 md5 = MD5.Create();
        byte[] strbf = Encoding.Default.GetBytes(str);
        byte[] md5bf = md5.ComputeHash(strbf);
        //字节数组--字符串
        //1.按照编码格式解析
        //2.ToString()
        //3.将数组元素的每个元素ToString();
        //return Encoding.Default.GetString(md5bf);
        string strec = &quot;&quot;;
        for (int i = 0; i &lt; md5bf.Length; i++)
        {
            strec += md5bf[i].ToString (&quot;x&quot;);//默认10进制&quot;x&quot;:十六进制

        }
        return strec;
    }
}</code></pre>
]]></content>
    </entry>
</feed>