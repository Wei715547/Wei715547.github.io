<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Wei715547.github.io</id>
    <title>Wei开发日志</title>
    <updated>2020-05-31T15:50:07.808Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Wei715547.github.io"/>
    <link rel="self" href="https://Wei715547.github.io/atom.xml"/>
    <subtitle>年月增长，我宜强盛。
用于Unity+开发的技术积累</subtitle>
    <logo>https://Wei715547.github.io/images/avatar.png</logo>
    <icon>https://Wei715547.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Wei开发日志</rights>
    <entry>
        <title type="html"><![CDATA[Thread类开启线程]]></title>
        <id>https://Wei715547.github.io/post/thread-lei-kai-qi-xian-cheng/</id>
        <link href="https://Wei715547.github.io/post/thread-lei-kai-qi-xian-cheng/">
        </link>
        <updated>2020-05-31T15:49:26.000Z</updated>
        <content type="html"><![CDATA[<p>using System;<br>
using System.Threading;<br>
using System.Threading.Tasks;<br>
namespace 线程_通过Thread类开启<br>
{<br>
class Program<br>
{<br>
static void Downloading(object fileName)<br>
{<br>
Console.WriteLine(&quot;startDownloadong&quot;+Thread .CurrentThread .ManagedThreadId +fileName );<br>
Thread.Sleep(2000);<br>
Console.WriteLine(&quot;END&quot;);<br>
}<br>
static void Main(string[] args)<br>
{<br>
//方式1.直接赋值一个方法引用<br>
/<em>Thread t = new Thread(Downloading);<br>
t.Start();//开始执行线程<br>
Console.WriteLine(&quot;Main&quot;);</em>/</p>
<pre><code>        //开启方式2。赋值一个表达式（匿名方法）
        /*Thread t = new Thread(() =&gt;
       {
           Console.WriteLine(&quot;startDownloadong&quot; + Thread.CurrentThread.ManagedThreadId);
           Thread.Sleep(2000);
           Console.WriteLine(&quot;END&quot;);
       });
        t.Start();*/

        /*//方式1.传递参数
        Thread t = new Thread(Downloading);
        t.Start(&quot;XXX&quot;);//开始执行线程
        Console.WriteLine(&quot;Main&quot;);*/

        //2.创建一个对象，将要传递的数据放到对象里进行传递
        Mythread my = new Mythread(&quot;wei7&quot;, &quot;github.io&quot;);
        Thread t = new Thread(my.DownloadFile);//以类里的普通方法作为线程方法
        t.Start();//开启线程
        Console.ReadKey();
    }
}
</code></pre>
<p>}</p>
<p>//用来传递参数的类<br>
using System;<br>
using System.Collections.Generic;<br>
using System.Text;<br>
using System.Threading;</p>
<p>namespace 线程_通过Thread类开启<br>
{<br>
class Mythread<br>
{<br>
private string filename;<br>
private string filepath;</p>
<pre><code>    public Mythread(string name,string path)
    {
        this.filename = name;
        this.filepath = path;
    }
    public void DownloadFile()
    {
        Console.WriteLine(&quot;开始下载&quot;+filepath+filename);
        Thread.Sleep(2000);
        Console.WriteLine(&quot;下载完成&quot;);
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[委托开启线程]]></title>
        <id>https://Wei715547.github.io/post/wei-tuo-kai-qi-xian-cheng/</id>
        <link href="https://Wei715547.github.io/post/wei-tuo-kai-qi-xian-cheng/">
        </link>
        <updated>2020-05-31T15:05:12.000Z</updated>
        <content type="html"><![CDATA[<p>using System;<br>
using System.Threading;</p>
<p>namespace 线程_委托线程<br>
{<br>
class Program<br>
{<br>
public static int Test1(int i,string str)<br>
{<br>
Console.WriteLine(&quot;Test1&quot;+i+str );<br>
Thread.Sleep(100);//线程休眠 单位ms<br>
return 100;<br>
}<br>
static void Main(string[] args)<br>
{<br>
Func&lt;int,string ,int &gt; a = Test1;<br>
IAsyncResult ar = a.BeginInvoke(100,&quot;wei&quot;,null,null);//VS运行异常<br>
Console.WriteLine(&quot;main&quot;);<br>
while (ar .IsCompleted ==false )//线程是否结束<br>
{<br>
Console.WriteLine(&quot;.&quot;);<br>
}<br>
int res = a.EndInvoke(ar);//异步线程返回值<br>
Console.ReadKey();</p>
<pre><code>        //检测线程结束
        bool isEnd = ar.AsyncWaitHandle.WaitOne(1000);//1000毫秒表示超时，如果等待了1000ms线程还没有结束的时，这个方法会返回false。
        //如在10001ms内结束了则返回的为true。
        if (isEnd )
        {
            int r = a.EndInvoke(ar);
            Console.WriteLine(r);
        }
        Console.ReadKey();
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自定义特性]]></title>
        <id>https://Wei715547.github.io/post/zi-ding-yi-te-xing/</id>
        <link href="https://Wei715547.github.io/post/zi-ding-yi-te-xing/">
        </link>
        <updated>2020-05-30T07:34:50.000Z</updated>
        <content type="html"><![CDATA[<p>using System;<br>
using System.Collections.Generic;<br>
using System.Text;</p>
<p>namespace 自定义特性<br>
{<br>
//1.也行类的后缀以Attribute结尾<br>
//2.需要继承自:System.Attribute<br>
//3.一般情况下声明为 sealed(不需要被继承)<br>
//4.一般情况下特性类用来表示目标结构的一些状态（定义一些字段/属性，一般不需要定义方法）<br>
[AttributeUsage(AttributeTargets.Class)]//表示特性类的使用目标,(表示特性类可以应用到程序的那些结构)<br>
sealed class MyTestAttribute :System.Attribute<br>
{<br>
public string Description { get; set; }<br>
public string VersionNumber { get; set; }<br>
public int ID { get; set; }</p>
<pre><code>    public MyTestAttribute(string des)
    {
        Description = des;
    }
}
</code></pre>
<p>}<br>
//---------------------------------使用---------------------<br>
using System;</p>
<p>namespace 自定义特性<br>
{<br>
[MyTest(&quot;自定义特性类&quot;,ID = 100)]<br>
class Program<br>
{<br>
static void Main(string[] args)<br>
{<br>
Type type = typeof(Program);//通过typeof+类名，获取类的type对象<br>
object[] array = type.GetCustomAttributes(false);//获取类的所有特性（false）不包括父类的<br>
MyTestAttribute mytest = array[0] as MyTestAttribute;<br>
Console.WriteLine(mytest.Description);<br>
Console.WriteLine(mytest .ID );<br>
}<br>
}<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Conditional特性(方法)，调用者信息特性(字段/属性)，DebuggerStepThrough(方法）)]]></title>
        <id>https://Wei715547.github.io/post/conditional-te-xing/</id>
        <link href="https://Wei715547.github.io/post/conditional-te-xing/">
        </link>
        <updated>2020-05-30T06:39:19.000Z</updated>
        <content type="html"><![CDATA[<p>//#define Istest //定义一个宏</p>
<p>using System;<br>
using System.Diagnostics;</p>
<p>namespace Contional特性//禁用方法<br>
{<br>
class Program<br>
{<br>
[Conditional(&quot;IsTest&quot;)]//宏被定义时，方法才可被调用(方法仍会被编译放入程序集当中)<br>
static void Text1()<br>
{<br>
Console.WriteLine(&quot;Text1&quot;);<br>
}</p>
<pre><code>    static void Text2()
    {
        Console.WriteLine(&quot;Text2&quot;);
    }
</code></pre>
<p>//调用者信息特性，DebuggerStepThrough特性<br>
[DebuggerStepThrough]//可以跳过Debugger的单步调试 调试时略过该方法(确定该方法无错误是可以使用)<br>
static void PrintOut(string str,<br>
[CallerFilePath]string fileName=&quot;&quot;,[CallerLineNumber]int lineNumber=0,[CallerMemberName]string methodName=&quot;&quot;)<br>
{<br>
Console.WriteLine(str);<br>
Console.WriteLine(fileName);//调用者文件路径<br>
Console.WriteLine(lineNumber);//调用行<br>
Console.WriteLine(methodName);//调用方法名<br>
}</p>
<pre><code>    static void Main(string[] args)
    {
        Text1();
        Text1();
        Text2();

        PrintOut(&quot;123&quot;);//断点
    }
}
</code></pre>
<p>}<br>
<img src="https://Wei715547.github.io/post-images/1590822404207.jpg" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1590822413420.jpg" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[反射特性]]></title>
        <id>https://Wei715547.github.io/post/fan-she-te-xing/</id>
        <link href="https://Wei715547.github.io/post/fan-she-te-xing/">
        </link>
        <updated>2020-05-30T03:57:11.000Z</updated>
        <content type="html"><![CDATA[<p>using System;<br>
using System.Reflection;</p>
<p>namespace 反射与特性<br>
{<br>
class Program<br>
{<br>
[Obsolete(&quot;过时的方法，请使用新的方法&quot;)]//弃用标记特性 Obsolete<br>
static void OldNethod()<br>
{<br>
Console.WriteLine(&quot;OM&quot;);<br>
}<br>
static void Main(string[] args)<br>
{<br>
MyClass my = new MyClass();<br>
Type type = my.GetType();<br>
Console.WriteLine(type .Name);//类的名字<br>
Console.WriteLine(type .Namespace);//类峰命名空间<br>
Console.WriteLine(type .Assembly );//类峰程序集命名空间</p>
<pre><code>        FieldInfo[] array = type.GetFields();//获取类的字段
        foreach (FieldInfo info in array )
        {
            Console.WriteLine(info .Name+&quot; &quot;);
        }

        PropertyInfo[] array2 = type.GetProperties();//获取类属性
        foreach (PropertyInfo info in array2 )
        {
            Console.WriteLine(info .Name +&quot; &quot;);
        }

        MethodInfo[] array3 = type.GetMethods();//获取类的方法
        foreach (MethodInfo info in array3)
        { 
            Console.WriteLine(info .Name +&quot; &quot;);
        }
</code></pre>
<p>//-----------------------------------------------------------------------------<br>
MyClass my = new MyClass();<br>
Assembly assem = my.GetType().Assembly;//通过类的Type对象，获取它所在的抽象集 Assembly<br>
Console.WriteLine(assem.FullName);<br>
Type[] types = assem.GetTypes();//程序集中所有类的Type对象<br>
foreach (var type in types)<br>
{<br>
Console.WriteLine(type);//利用Type对象输出程序集中所有类名字<br>
}<br>
//OldNethod();<br>
}<br>
}<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[泛型类/方法/委托]]></title>
        <id>https://Wei715547.github.io/post/fan-xing-lei-fang-fa-wei-tuo/</id>
        <link href="https://Wei715547.github.io/post/fan-xing-lei-fang-fa-wei-tuo/">
        </link>
        <updated>2020-05-30T02:55:40.000Z</updated>
        <content type="html"><![CDATA[<p>using System;<br>
using System.Collections.Generic;<br>
using System.Text;</p>
<p>namespace 泛型类<br>
{<br>
//泛型类<br>
class ClassA<T><br>
{<br>
private T a;<br>
private T b;</p>
<pre><code>    public ClassA (T a,T b)
    {
        this.a = a;
        this.b = b;
    }

    public string Show()
    {
        return a +&quot; &quot;+ b;
    }

}
</code></pre>
<h2 id="">}</h2>
<p>/*using System;</p>
<p>namespace 泛型类<br>
{<br>
class Program<br>
{<br>
public static string  GetSum&lt;T,T2,T3&gt;(T a,T b)//泛型方法,可指定多个泛型，在调用是指定类型<br>
{<br>
return a +&quot; &quot;+ b;<br>
}</p>
<pre><code>    static void Main(string[] args)
    {

        var o1 = new ClassA &lt;int&gt;(22,53);

        Console.WriteLine(  o1.Show());

        var s1 = new ClassA&lt;string&gt;(&quot;wei&quot;, &quot;715&quot;);

        Console.WriteLine(s1.Show());

        Console.WriteLine(GetSum &lt;int ,int ,int &gt;(123,314));//有多个泛型时，调用要指定所有类型
        Console.WriteLine( GetSum&lt;string ,string ,string &gt; (&quot;da&quot;,&quot;werr&quot;));


        //Console.ReadKey();

    }
}
</code></pre>
<p>}*/<br>
using System;<br>
using System.Collections.Generic;</p>
<p>//泛型委托<br>
delegate T NumberChanger<T>(T n);//返回值与参数类型为T<br>
namespace GenericDelegateAppl<br>
{<br>
class TestDelegate<br>
{<br>
static int num = 10;<br>
public static int AddNum(int p)<br>
{<br>
num += p;<br>
return num;<br>
}</p>
<pre><code>    public static int MultNum(int q)
    {
        num *= q;
        return num;
    }
    public static int getNum()
    {
        return num;
    }

    static void Main(string[] args)
    {
        // 创建委托实例
        //NumberChanger&lt;int&gt; nc1 = new NumberChanger&lt;int&gt;(AddNum);
        NumberChanger&lt;int&gt; nc1 = AddNum;//上一行简写
        NumberChanger&lt;int&gt; nc2 = new NumberChanger&lt;int&gt;(MultNum);
        // 使用委托对象调用方法
        nc1(25);
        Console.WriteLine(&quot;Value of Num: {0}&quot;, getNum());
        nc2(5);
        Console.WriteLine(&quot;Value of Num: {0}&quot;, getNum());
        Console.ReadKey();
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[长按/下蹲状态跳跃增量]]></title>
        <id>https://Wei715547.github.io/post/chang-an-xia-dun-zhuang-tai-tiao-yue-zeng-liang/</id>
        <link href="https://Wei715547.github.io/post/chang-an-xia-dun-zhuang-tai-tiao-yue-zeng-liang/">
        </link>
        <updated>2020-05-29T14:58:33.000Z</updated>
        <content type="html"><![CDATA[<p>public void MidAirMovement()<br>
{<br>
if (jumpPressed&amp;&amp;isOnground &amp;&amp;!isJump )//普通状态--在地面上，非跳跃状态，按下跳跃键<br>
{<br>
if (isCrouch)//下蹲状态，增量<br>
{<br>
StandUp();<br>
playerRGB.AddForce(Vector2.up * crouchJumpBoost, ForceMode2D.Impulse);//F1+F2<br>
}<br>
isOnground = false;<br>
isJump = true;<br>
jumpTime = Time.time + jumpHodeDuration;<br>
playerRGB.AddForce(Vector2.up * jumpForce, ForceMode2D.Impulse);//F1<br>
}<br>
else if (isJump )//长按状态<br>
{<br>
if (jumpHeld)//长按跳跃键<br>
playerRGB.AddForce(Vector2.up * jumpHpdeFpoce, ForceMode2D.Impulse);//F1+F3<br>
if (jumpTime &lt; Time.time)<br>
isJump = false;<br>
}<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[冒泡排序+(泛型/委托)]]></title>
        <id>https://Wei715547.github.io/post/mou-pao-pai-xu-fan-xing-wei-tuo/</id>
        <link href="https://Wei715547.github.io/post/mou-pao-pai-xu-fan-xing-wei-tuo/">
        </link>
        <updated>2020-05-28T15:53:37.000Z</updated>
        <content type="html"><![CDATA[<p>using System;</p>
<p>namespace int类冒泡排序<br>
{<br>
class Program<br>
{<br>
static void Sort(int[] sortArray)<br>
{<br>
bool isChang = true;<br>
do<br>
{<br>
isChang = false;<br>
for (int i = 0; i &lt; sortArray.Length - 1; i++)<br>
{<br>
if (sortArray[i] &lt; sortArray[i + 1])<br>
{<br>
int temp = sortArray[i];<br>
sortArray[i] = sortArray[i + 1];<br>
sortArray[i + 1] = temp;<br>
isChang = true;<br>
}<br>
}<br>
} while (isChang);<br>
}</p>
<pre><code>    static void CommonSort&lt;T&gt;(T[] sortArray, Func&lt;T, T, bool&gt; compart)
    {
        bool isChang = true;
        do
        {
            isChang = false;
            for (int i = 0; i &lt; sortArray.Length - 1; i++)
            {
                if (compart(sortArray[i], sortArray[i + 1]))
                {
                    T temp = sortArray[i];
                    sortArray[i] = sortArray[i + 1];
                    sortArray[i + 1] = temp;
                    isChang = true;
                }
            }
        } while (isChang);
    }

    static void Main(string[] args)
    {
        /*int[] array = { 31, 423, 543, 35, 24, 454,6 };
        Sort(array);
        foreach (int i in array)
        {
            Console.WriteLine(i);
        }*/

        /*Employee e1 = new Employee(&quot;wei&quot;, 12000);
        Employee e2 = new Employee(&quot;zz&quot;, 10000);
        Employee e3 = new Employee(&quot;zh&quot;, 11000);
        Employee[] earray = { e1, e2, e3 };*/
        //组类声明
        Employee[] earray = new Employee[]
        {
            new Employee(&quot;wei&quot;, 12000),
            new Employee(&quot;zz&quot;, 10000),
            new Employee(&quot;h&quot;, 11000)
        };

        CommonSort&lt;Employee&gt;(earray, Employee.Compare);
        foreach (Employee e in earray)
        {
            Console.WriteLine(e);
        }

    }
}
</code></pre>
<p>}</p>
<p>//泛型类<br>
using System;<br>
using System.Collections.Generic;<br>
using System.Text;</p>
<p>namespace int类冒泡排序<br>
{<br>
class Employee<br>
{<br>
public override string ToString()<br>
{<br>
return this .Name +&quot;:&quot;+this .Salary;<br>
}</p>
<pre><code>    public string Name { get; private set; }
    public int Salary { get; private set; }

    public Employee(string name ,int salary)
    {
        this.Name = name;
        this.Salary = salary;
    }

    public static bool Compare(Employee e1,Employee e2)
    {
        if (e1.Salary &gt; e2.Salary) return true;
        return false;
    }

}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Bool交替执行]]></title>
        <id>https://Wei715547.github.io/post/bool-jiao-ti-zhi-xing/</id>
        <link href="https://Wei715547.github.io/post/bool-jiao-ti-zhi-xing/">
        </link>
        <updated>2020-05-28T06:32:17.000Z</updated>
        <content type="html"><![CDATA[<p>private bool bagShow;<br>
private void Awake()<br>
{<br>
myBagPanel.SetActive(false);<br>
}<br>
private void Update()<br>
{<br>
if (Input .GetKeyDown (KeyCode.B ))<br>
{<br>
bagShow = !bagShow;<br>
myBagPanel.SetActive(bagShow);</p>
<pre><code>    }
}</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2D Bag System]]></title>
        <id>https://Wei715547.github.io/post/2d-bag-system/</id>
        <link href="https://Wei715547.github.io/post/2d-bag-system/">
        </link>
        <updated>2020-05-27T02:45:24.000Z</updated>
        <content type="html"><![CDATA[<p>以本地资源类(ScriptableObject)实现数据存储/读取<br>
//背包资源类<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
[CreateAssetMenu(fileName = &quot;New Item&quot;, menuName = &quot;Inventory/Inventory&quot;)]<br>
//背包类<br>
public class Inventory : ScriptableObject<br>
{<br>
#region<br>
/<em>public static Inventory GetInventory()<br>
{<br>
return Resources.Load<Inventory>(&quot;Mybag&quot;);<br>
}</em>/<br>
#endregion</p>
<pre><code>//物品类列表
public List&lt;Items&gt; itemList = new List&lt;Items&gt;();
</code></pre>
<p>}</p>
<p>//物品类<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
[CreateAssetMenu(fileName = &quot;New Item&quot; ,menuName = &quot;Inventory/New Item&quot;)]<br>
//物品类<br>
public class Items : ScriptableObject<br>
{<br>
public string  itemName ;//物品名称<br>
public Sprite ItemImage;//物品图标<br>
public int ItemHild;//物品数量<br>
[TextArea]//文本框，存储多字符串<br>
public string ItemInfo;//物品信息<br>
public bool equip;//可可装备属性<br>
}<br>
<img src="https://Wei715547.github.io/post-images/1590550667528.PNG" alt="" loading="lazy"></p>
<p>//UI预制件<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.UI;</p>
<p>public class Slot : MonoBehaviour<br>
{<br>
public int slotID;//空格的ID<br>
//public Items slotItem;<br>
public Image slotImage;//物品图标<br>
public Text slotNum;//物品数量<br>
private Button itemButton;//可点击物体按钮<br>
public GameObject itemInSlot;//物品整体UI<br>
public string slotInfo;//物品信息</p>
<pre><code>private void Awake()
{
    itemButton = this.gameObject.GetComponentInChildren&lt;Button&gt;();
    itemButton.onClick.AddListener(ItemOnClecked);
}

public void ItemOnClecked()
{
    InventoryManager.UpdateItemInfo(slotInfo );//点击时显示物品信息，
    //（物品位置交换后UI预制件中仍存储原来物品的信息，调用的也是创建时赋值的信息）场景重新加载 时UI预制件中的信息得到更新
}

public void SetupSlot (Items item)//刷新背包时传过来的本地资源中的物品对象
{
    if(item == null )//本地背包列表中物品为空时吟唱空白的物品对象，然后返回
    {
        itemInSlot.SetActive(false);
        return;
    }
    //不为空时对UI预制件进行赋值
    slotImage.sprite = item.ItemImage;//图标
    slotNum.text = item.ItemHild.ToString();//数量
    slotInfo = item.ItemInfo;//物品信息
}
</code></pre>
<p>}<br>
<img src="https://Wei715547.github.io/post-images/1590550908057.PNG" alt="" loading="lazy"></p>
<p>//世界中的物品<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>//世界中的物品脚本<br>
public class ItemOnWord : MonoBehaviour<br>
{<br>
public Items thisItem;//物品种类<br>
public Inventory platerInventer;//要加入的背包</p>
<pre><code>private void OnTriggerEnter2D(Collider2D collision)
{
    if (collision.gameObject .CompareTag (&quot;Player&quot;))//Tag相同时返回TRUE,
    {
        AddItems();
    }
    Destroy(this.gameObject);
}

public void AddItems()
{
    if (!platerInventer.itemList.Contains (thisItem ))//List方法包含此元素时返回TRUE,不包含返回FALSE
    {
        for (int i = 0; i &lt; platerInventer.itemList.Count; i++)//背包中没有该物品时遍历
        {
            if (platerInventer .itemList[i]==null) //将物品添加到第一个空位置
            {
                platerInventer.itemList[i] = thisItem;
                break;//跳出循环
            }
        }
    }else
    {
        thisItem.ItemHild += 1;//背包中有该物品时数量加一
    }
    InventoryManager.RefreshItem();//刷新背包
}
</code></pre>
<p>}<br>
<img src="https://Wei715547.github.io/post-images/1590552509280.PNG" alt="" loading="lazy"></p>
<p>//背包管理脚本<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.UI;<br>
//背包管理脚本<br>
public class InventoryManager : MonoBehaviour<br>
{<br>
public static InventoryManager instance;</p>
<pre><code>public Inventory myBag;
public GameObject parentPanle;
//public Slot slotPrefab;
public GameObject prefab;
public Text itemInfromation;

//运行时的物品List,与本地数据保持一致
public List&lt;GameObject&gt; slot = new List&lt;GameObject&gt;();


private void Awake()//单例模式
{
    if (instance != null)
        Destroy(this);
    instance = this;
}

private void OnEnable()//启用时刷新一次
{
    //print(&quot;refs&quot;);
    //print(parentPanle.transform.childCount);
    RefreshItem();
    instance.itemInfromation.text = &quot; &quot;;
}

public static void UpdateItemInfo(string ItemInfo)
{
    instance.itemInfromation.text = ItemInfo;
}

public static void RefreshItem()
{
    //清空背包
    ClearBag();
    //清空后，再根据本地资源类重新生成UI预制件设置其中的Items相关属性
    for (int i=0;i&lt; instance.myBag.itemList.Count;i++)
    {
        //CreateNewItem(item);
        instance.slot.Add(Instantiate(instance.prefab));
        instance.slot[i].transform.SetParent(instance.parentPanle.transform);
        instance.slot[i].GetComponent&lt;Slot&gt;().slotID = i;
        instance.slot[i].GetComponent&lt;Slot&gt;().SetupSlot(instance.myBag.itemList[i]);

    }
}
//清空UI中背包所有物品的方法
public static void ClearBag()
{
    if (instance.parentPanle.transform.childCount == 0)
        return;
    for (int i = 0; i &lt; instance .parentPanle .transform .childCount ; i++)
    {
        Destroy(instance.parentPanle.transform.GetChild(i).gameObject);
        instance.slot.Clear();
    }
}
</code></pre>
<p>}<br>
<img src="https://Wei715547.github.io/post-images/1590552901698.PNG" alt="" loading="lazy"></p>
<p>//------------------------物品拖拽/交换位置-----------------------------------//<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.EventSystems;<br>
using UnityEngine.UI;<br>
public class ItemOnnDrag : MonoBehaviour, IBeginDragHandler, IDragHandler, IEndDragHandler//拖拽接口<br>
{<br>
public Transform originatParent;<br>
public Inventory myBag;<br>
private int currentItemID;</p>
<pre><code>public void OnBeginDrag(PointerEventData eventData)//按下时
{
    originatParent = transform.parent;//记录初始所在父物体
    currentItemID = originatParent.GetComponent&lt;Slot&gt;().slotID;//记录初始父物体在界面/本地数据List中位置
    transform.SetParent(transform.parent.parent);//点击后将物体UI的父物体设置为与抽屉的父物体同级，方便显示
    transform.position = eventData.position;//物体UI位置跟随屏幕滚光标
    GetComponent&lt;CanvasGroup&gt;().blocksRaycasts = false;//隐藏物品图标屏幕射线检测，使射线可检测到下层父级物体
}

public void OnDrag(PointerEventData eventData)//拖拽时
{
    transform.position = eventData.position;//拖拽时物体UI根数屏幕光标
    print(eventData.pointerCurrentRaycast.gameObject.name);//屏幕射线检测到的物体名称
}

public void OnEndDrag(PointerEventData eventData)//拖拽结束时
{
    if (eventData.pointerCurrentRaycast.gameObject != null)//如果屏幕射线检测到的物体不为空时
    {
        if (eventData.pointerCurrentRaycast.gameObject.name == &quot;Item Image&quot;)//物品栏有物品时，物品未隐藏可被检测到（物品UI的图标）
        {
            //原物体UI移动到背包中目标物体UI位置
            transform.SetParent(eventData.pointerCurrentRaycast.gameObject.transform.parent.parent);//物品UI图标的父级的父级（Slot）
            transform.position = eventData.pointerCurrentRaycast.gameObject.transform.parent.parent.position;
            //将目标物体UI移动到原物体UI位置
            eventData.pointerCurrentRaycast.gameObject.transform.parent.SetParent(originatParent);
            eventData.pointerCurrentRaycast.gameObject.transform.parent.position = originatParent.position;

            //交换本地数据中物体的存储位置
            var temp = myBag.itemList[currentItemID];//本地数据中原物体保存为中间值
            //本地数据中原物体移动到目标物体位置
            myBag.itemList[currentItemID] = myBag.itemList[eventData.pointerCurrentRaycast.gameObject.GetComponentInParent&lt;Slot&gt;().slotID];
            //本地数据中目标物体位置变为中间值（原物体）
            myBag.itemList[eventData.pointerCurrentRaycast.gameObject.GetComponentInParent&lt;Slot&gt;().slotID] = temp;
            //交换存储位置

            GetComponent&lt;CanvasGroup&gt;().blocksRaycasts = true;//交换完成开启屏幕射线检测，可再次拖拽
            return;//目标栏有物体，交换完成退出方法
        }
        if (eventData.pointerCurrentRaycast.gameObject.name == &quot;Slot(Clone)&quot;)//目标栏为空时（检测到的是抽屉）
        {
            //原物体之间放入目标抽屉
            transform.SetParent(eventData.pointerCurrentRaycast.gameObject.transform);
            transform.position = eventData.pointerCurrentRaycast.gameObject.transform.position;
            //将本地数据中的空物体赋值为，本地数据库中的目标物体
            myBag.itemList[eventData.pointerCurrentRaycast.gameObject.GetComponentInParent&lt;Slot&gt;().slotID] = myBag.itemList[currentItemID];
            //如果如表抽屉不是原来的抽屉时执行
            if (eventData.pointerCurrentRaycast.gameObject.GetComponent&lt;Slot&gt;().slotID != currentItemID)
                myBag.itemList[currentItemID] = null;//之后本地数据中的目标物体设为空

            GetComponent&lt;CanvasGroup&gt;().blocksRaycasts = true;//交换完成开启屏幕射线检测，可再次拖拽
            return;//目标栏有物体，交换完成退出方法
        }
    }
    //其他任何位置返回原位(非UI元素时)
    transform.SetParent(originatParent);
    transform.position = originatParent.position;
    GetComponent&lt;CanvasGroup&gt;().blocksRaycasts = true;
}
</code></pre>
<p>}<br>
<img src="https://Wei715547.github.io/post-images/1590553039734.PNG" alt="" loading="lazy"></p>
]]></content>
    </entry>
</feed>