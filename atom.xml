<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Wei715547.github.io</id>
    <title>Weiwei的个人网站</title>
    <updated>2020-04-12T04:30:55.578Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Wei715547.github.io"/>
    <link rel="self" href="https://Wei715547.github.io/atom.xml"/>
    <subtitle>7</subtitle>
    <logo>https://Wei715547.github.io/images/avatar.png</logo>
    <icon>https://Wei715547.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Weiwei的个人网站</rights>
    <entry>
        <title type="html"><![CDATA[EventSystems]]></title>
        <id>https://Wei715547.github.io/post/eventsystems/</id>
        <link href="https://Wei715547.github.io/post/eventsystems/">
        </link>
        <updated>2020-04-12T04:17:55.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.EventSystems;<br>
public class DIalogDrag : MonoBehaviour, IPointerDownHandler,IDragHandler,IPointerClickHandler<br>
{<br>
private RectTransform parentRTF;<br>
private void Start()<br>
{<br>
//设置UI长宽<br>
RectTransform rtf = GetComponent<RectTransform>();<br>
rtf.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, 700);<br>
rtf.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, 400);</p>
<pre><code>    parentRTF = this.transform.parent as RectTransform;
}
private Vector3 siftVector;
//按下时执行
public void OnPointerDown(PointerEventData eventData)
{
    //记录按下点到中心点偏移量

    Vector3 wordPoint;
    //屏幕坐标--&gt;世界坐标
    //(父物体的变换组件，屏幕坐标，摄像机，out 世界坐标)
    RectTransformUtility.ScreenPointToWorldPointInRectangle(parentRTF, eventData.position, eventData.pressEventCamera, out wordPoint);
    siftVector = this.transform.position - wordPoint;
}
//拖拽时执行
public void OnDrag(PointerEventData eventData)
{
    Vector3 wordPoint;
    //屏幕坐标--&gt;世界坐标
    //(父物体的变换组件，屏幕坐标，摄像机，out 世界坐标)
    RectTransformUtility.ScreenPointToWorldPointInRectangle(parentRTF, eventData.position, eventData.pressEventCamera, out wordPoint);
    this.transform.position = wordPoint + siftVector ;
    
}

public void OnPointerClick(PointerEventData eventData)
{
    if (eventData.clickCount == 2)
        Destroy (this .gameObject );
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HP-Attack-Shell]]></title>
        <id>https://Wei715547.github.io/post/hp-attack-shell/</id>
        <link href="https://Wei715547.github.io/post/hp-attack-shell/">
        </link>
        <updated>2020-04-07T09:57:39.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.UI;<br>
/// <summary><br>
/// HP，HP受损方法<br>
/// </summary><br>
public class TankHealth : MonoBehaviour<br>
{<br>
public int hp = 100;<br>
public GameObject tankExplosion;<br>
public AudioClip tankExplositionAudio;<br>
public Slider hpSlider;<br>
private int hpTotal;<br>
// Use this for initialization<br>
void Start()<br>
{<br>
hpTotal = hp;<br>
}</p>
<pre><code>// Update is called once per frame
void Update()
{

}
void TankDamage()
{
    if (hp &lt;= 0) return;
    hp -= Random.Range(10, 20);
    hpSlider.value = (float)hp / hpTotal;
    if (hp &lt;= 0)
    {
        AudioSource.PlayClipAtPoint(tankExplositionAudio, transform.position);
        GameObject.Instantiate(tankExplosion, transform.position + Vector3.up, transform.rotation);
        GameObject.Destroy(this.gameObject);
    }
}
</code></pre>
<p>}</p>
<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
/// <summary><br>
/// 按下攻击，发射子弹向FirePoint前方飞进<br>
/// </summary><br>
public class TankAttack : MonoBehaviour<br>
{</p>
<pre><code>public GameObject shellPrefab;
public KeyCode fireKey = KeyCode.Space;
private Transform firePosition;
public float shellSpeed = 10;
public AudioClip shoutAudio;
// Use this for initialization
void Start()
{
    firePosition = transform.Find(&quot;FirePosition&quot;);
}

// Update is called once per frame
void Update()
{
    if (Input.GetKeyDown(fireKey))
    {
        AudioSource.PlayClipAtPoint(shoutAudio, transform.position);
        GameObject go = GameObject.Instantiate(shellPrefab, firePosition.position, firePosition.rotation)as GameObject;
        go.GetComponent&lt;Rigidbody&gt;().velocity = go.transform.forward * shellSpeed;
    }
}
</code></pre>
<p>}</p>
<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
/// <summary><br>
/// 子弹出发检测，（两物体都有触发器，其中一个有刚体组件，其中一个触发器勾选Is Tirgger）<br>
///打中目标，调用目标受损方法<br>
/// </summary><br>
public class Shell : MonoBehaviour<br>
{</p>
<pre><code>public GameObject shellExplosionPrefab;
public  AudioClip shellExplosionAudio;


public void OnTriggerEnter(Collider collider)
{
    AudioSource.PlayClipAtPoint(shellExplosionAudio,transform.position);
    GameObject.Instantiate(shellExplosionPrefab, transform.position, transform.rotation);
    GameObject.Destroy(this.gameObject);
    if (collider.tag == &quot;Tank&quot;)
    {
        collider.SendMessage(&quot;TankDamage&quot;);
    }

}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[俯视较移动旋转]]></title>
        <id>https://Wei715547.github.io/post/fu-shi-jiao-yi-dong-xuan-zhuan/</id>
        <link href="https://Wei715547.github.io/post/fu-shi-jiao-yi-dong-xuan-zhuan/">
        </link>
        <updated>2020-04-05T05:57:42.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class Move : MonoBehaviour<br>
{<br>
public float speed = 5;<br>
private void Update()<br>
{<br>
float v = Input.GetAxis(&quot;Vertical&quot;);<br>
float h = Input.GetAxis(&quot;Horizontal&quot;);<br>
if (v != 0 || h != 0)<br>
Movement(v, h);<br>
}<br>
private void Movement(float v, float h)<br>
{<br>
this.transform.Translate(0, 0, speed*Time .deltaTime );<br>
Quaternion dir = Quaternion.LookRotation(new Vector3(h, 0, v));<br>
this.transform.rotation =<br>
Quaternion.Lerp(this.transform.rotation, dir, 0.1f);<br>
}<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Boom向量/三角函数应用]]></title>
        <id>https://Wei715547.github.io/post/boom-xiang-liang-san-jiao-han-shu-ying-yong/</id>
        <link href="https://Wei715547.github.io/post/boom-xiang-liang-san-jiao-han-shu-ying-yong/">
        </link>
        <updated>2020-04-04T14:34:23.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class Boom : MonoBehaviour<br>
{<br>
public GameObject player;<br>
private Vector3 dp;<br>
//private Vector3 ldp;<br>
private Vector3 liftdp;<br>
private Vector3 rightdp;<br>
private float dt;<br>
private float sin;<br>
private float rd;<br>
// Start is called before the first frame update<br>
void Start()<br>
{<br>
rd = player.GetComponent<CapsuleCollider>().radius ;<br>
}</p>
<pre><code>// Update is called once per frame
void Update()
{
    Draw();
}

private void VectorCt()
{
    
    dp = player.transform.position - this.transform.position;
    dt = dp.magnitude;
    sin = Mathf.Rad2Deg * Mathf.Asin(rd / dt);
    //ldp = Quaternion.Euler(0, sin, 0) *dp.normalized * dt * Mathf.Cos(sin);
    liftdp = this.transform.position + Quaternion.Euler(0, sin, 0) * dp;
   
    rightdp = this.transform.position + Quaternion.Euler(0, -sin, 0) * dp;
    
}

private void CalculateTangent()
{
    Vector3 playerToBoom = this.transform.position - player.transform.position;
    Vector3 playerToExplpsionDirection = playerToBoom.normalized * rd;
    float angle = Mathf.Acos(rd / playerToBoom.magnitude) * Mathf.Rad2Deg;
    liftdp = player.transform.position + Quaternion.Euler(0, -angle , 0) * playerToExplpsionDirection;
    rightdp = player.transform.position + Quaternion.Euler(0, angle, 0) * playerToExplpsionDirection;

}

private void Draw()
{
    //VectorCt();
    CalculateTangent();
    Debug.DrawLine(this.transform.position, player.transform.position);
    Debug.DrawLine(this.transform.position, liftdp,Color .blue );
    Debug.DrawLine(this.transform.position, rightdp,Color .red );
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[四元数API]]></title>
        <id>https://Wei715547.github.io/post/si-yuan-shu-api/</id>
        <link href="https://Wei715547.github.io/post/si-yuan-shu-api/">
        </link>
        <updated>2020-04-04T14:33:23.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class QuaternionAPI : MonoBehaviour<br>
{<br>
public Transform  tf;<br>
public AnimationCurve a;<br>
private float x;</p>
<pre><code>private void OnGUI()
{
    if (GUILayout.Button (&quot;&quot;))
    {
        //1.欧拉角转换为四元数
        //Quaternion.Euler(欧拉角);

        //2/四元数转欧拉角
        Quaternion qt = this.transform.rotation;
        Vector3 auler = qt.eulerAngles;

        //3.轴/角
        //Quaternion.Euler(0, 50, 0);
        this .transform .rotation = Quaternion.AngleAxis(50, Vector3.up);

    }
    
    if (GUILayout.Button(&quot;LookRotation&quot;))
    {
        //4.注视旋转
        //Z轴指向一个方向
        //当前物体注视 tf 旋转
        Vector3 dir = tf.position - this.transform.position;
        this.transform.rotation  = Quaternion.LookRotation (dir);
        //this.transform.LookAt(tf);//效果与上两行代码相同----下一帧立即执行

    }

    if (GUILayout.RepeatButton(&quot;LookRotationLerp&quot;))
    {
        //5.插值旋转
        x += Time.deltaTime;
        Quaternion dir = Quaternion.LookRotation(tf.position - this.transform.position);            
        this .transform .rotation = Quaternion.Lerp(this.transform.rotation, dir, a.Evaluate (x));

        //6.匀速旋转
        //this.transform.rotation = Quaternion.RotateTowards(this.transform.rotation, dir, 0.1f);//匀速朝向旋转
    }

    if (GUILayout.RepeatButton(&quot;AngleR90&quot;))
    {
        Quaternion dir = Quaternion.Euler(0, 90, 0);
        this.transform.rotation =
            Quaternion.Lerp(this.transform.rotation, dir, 0.1f);
        //7.如果当前旋转角度 接近目标旋转角度
        if (Quaternion .Angle (this .transform .rotation ,dir )&lt;10)
        {
            this.transform.rotation = dir;
        }
    }

    if (GUILayout.RepeatButton(&quot;Right&quot;))
    {
        //8.x轴注视旋转 t1
        //this.transform.right = tf.position - this.transform.position;
        //x正方向---注视目标物体方向
        Quaternion dir = Quaternion.FromToRotation(Vector3 .right  , tf.position - this.transform.position);
        //this.transform.rotation = dir;
        this.transform.rotation = Quaternion.Lerp(this.transform.rotation, dir, 0.1f);


    }
}

// Update is called once per frame
void Update()
{
    
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[向量API]]></title>
        <id>https://Wei715547.github.io/post/xiang-liang-api/</id>
        <link href="https://Wei715547.github.io/post/xiang-liang-api/">
        </link>
        <updated>2020-04-04T14:33:02.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class VectorAPI : MonoBehaviour<br>
{<br>
public AnimationCurve cuver;<br>
private float x;<br>
public  float psTime=3;<br>
private Vector3 targetPoint = new Vector3 (0, 0, 10);<br>
private void OnGUI()<br>
{<br>
if (GUILayout.RepeatButton (&quot;Move&quot;))<br>
{<br>
//将物体移动至（0，0,10）<br>
//匀速移动<br>
this.transform.position = Vector3.MoveTowards(this.transform.position,targetPoint , 2);<br>
//先快后慢--终点与比例固定<br>
this.transform.position = Vector3.Lerp (this.transform.position, targetPoint , 2 );</p>
<pre><code>    }
    if (GUILayout.RepeatButton(&quot;Lerp&quot;))
    {
        x += Time.deltaTime/psTime ;
        //自然变化，起点，终点固定，比例根据曲线变化
        this.transform.position =
            Vector3.LerpUnclamped (Vector3.zero, targetPoint, cuver.Evaluate(x));
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第一人称镜头旋转]]></title>
        <id>https://Wei715547.github.io/post/di-yi-ren-cheng-jing-tou-xuan-zhuan/</id>
        <link href="https://Wei715547.github.io/post/di-yi-ren-cheng-jing-tou-xuan-zhuan/">
        </link>
        <updated>2020-04-04T14:31:08.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
/// <summary><br>
/// 控制摄像机随鼠标旋转<br>
/// </summary><br>
public class DoRotation : MonoBehaviour<br>
{<br>
public float rotateSpeed = 1;<br>
private void FixedUpdate()<br>
{<br>
float x = Input.GetAxis(&quot;Mouse X&quot;);<br>
float y = Input.GetAxis(&quot;Mouse Y&quot;);</p>
<pre><code>    if (x!=0||y!=0)
    RotateView(x, y);
}

private void RotateView(float x, float y)
{
    x *= rotateSpeed;
    y *= rotateSpeed;

    this.transform.Rotate(0, x, 0, Space.World);//左右旋转按照世界坐标
    //this.transform.Rotate(-y, 0, 0, Space.Self);//上下旋转按自身坐标
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[镜头缩放]]></title>
        <id>https://Wei715547.github.io/post/jing-tou-suo-fang/</id>
        <link href="https://Wei715547.github.io/post/jing-tou-suo-fang/">
        </link>
        <updated>2020-04-04T14:30:16.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
/// <summary><br>
/// 镜头缩放<br>
/// </summary><br>
public class CareamZoom : MonoBehaviour<br>
{<br>
public bool isDown;<br>
public bool keyDown;<br>
public bool cvDown;<br>
public Transform l1;</p>
<pre><code>public bool isFar = true;
private Camera camera;

public int[] zoomLevel;
private int index;
private Vector3 lo;
private Quaternion ro;



private void Start()
{
    camera = GetComponent&lt;Camera&gt;();
    lo = this.transform.position;
    ro = this.transform.rotation;
}

private void Update()
{
    isDown = Input.GetMouseButton(0);//左键

    keyDown = Input.GetKey(KeyCode.Q);

    CamerPosition();

    if (keyDown)
        Zoom4();


    cvDown = Input.GetKey(KeyCode.C) &amp;&amp; Input.GetKey(KeyCode.V);


}

private void CamerPosition()
{

    if (keyDown)
    {
        this.transform.position = this.transform.parent.position;
        this.transform.rotation = this.transform.parent.rotation;
    }
    else
    {
        this.transform.position = l1.position;
        this.transform.rotation = l1.rotation;
        index = 0;
        camera.fieldOfView = zoomLevel[index ];
    }
}

private void Zoom1()
{
    if (Input.GetMouseButtonDown(1))
    {
        //拉近：10
        isFar = !isFar;

        if (isFar)
        {
            camera.fieldOfView = 50;
            //拉远：50
        }
        else
        {
            camera.fieldOfView = 10;
        }

    }
}

private void Zoom2()
{
    if (Input.GetMouseButtonDown(1))
    {
        isFar = !isFar;
    }
    if (isFar)
    {
        if (camera.fieldOfView &lt; 50)
            camera.fieldOfView += 2;
        //拉远：10--&gt;50
    }
    else
    {
        //拉近：50--&gt;10
        if (camera.fieldOfView &gt; 10)
            camera.fieldOfView -= 2;
    }
}

private void Zoom3()//先快后慢 Lerp (起点，终点，比例0.1)第一次返回起点到终点0.1的值
{
    if (Input.GetMouseButtonDown(1))
    {
        isFar = !isFar;
    }
    if (isFar)
    {
        //拉远：10--&gt;50
        camera.fieldOfView = Mathf.Lerp(camera.fieldOfView, 50, 0.1f);//无限接近50，不等于
        if (Mathf.Abs(camera.fieldOfView - 50) &lt; 0.1) camera.fieldOfView = 50;//使无限接近时，等于
    }
    else
    {
        //拉近：50--&gt;10
        camera.fieldOfView = Mathf.Lerp(camera.fieldOfView, 10, 0.1f);
        if (Mathf.Abs(camera.fieldOfView - 10) &lt; 0.1) camera.fieldOfView = 10;
    }
}

private void Zoom4()//
{
    if (Input.GetMouseButtonDown(1))
    {
        //index = index &lt; zoomLevel.Length - 1 ? index + 1 : 0;
        index = (index + 1) % zoomLevel.Length;
        //index++;
        //if (index &gt;= zoomLevel.Length)
        //index = 0;
    }

    camera.fieldOfView = Mathf.Lerp(camera.fieldOfView, zoomLevel[index], 0.1f);//无限接近50，不等于
    if (Mathf.Abs(camera.fieldOfView - zoomLevel[index]) &lt; 0.1) camera.fieldOfView = zoomLevel[index];//使无限接近时，等于

}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Time类]]></title>
        <id>https://Wei715547.github.io/post/time-lei/</id>
        <link href="https://Wei715547.github.io/post/time-lei/">
        </link>
        <updated>2020-04-04T14:29:07.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class TimeDemo : MonoBehaviour<br>
{<br>
public float deltatime;<br>
public float unscaledeltatime;<br>
public float time;<br>
public float unscaledtime;<br>
public float c;<br>
public float speed = 100;<br>
private void Update()<br>
{<br>
deltatime = Time.deltaTime;//受TimeScale影响的每帧间隔时间<br>
unscaledeltatime = Time.unscaledDeltaTime;//不受TimeScale影响每帧间隔时间</p>
<pre><code>    time = Time.time;//受TimeScale影响的游戏运行时间
    unscaledtime = Time.unscaledTime;//不受TimeScale影响的游戏运行时间
    c = Time.realtimeSinceStartup;//实际的游戏运行时间

    //每渲染帧 执行1次，旋转1度
    //this.transform.Rotate(0, 1, 0);
    //1秒旋转 ？度
    //帧多 1秒旋转速度快        希望1帧旋转量小
    //少     慢                     大
    //this.transform.Rotate(0, speed *Time .deltaTime, 0);
    //当旋移动/转速度*每帧消耗时间，可以保证旋转速度不受机器性能，及渲染影响。

    //个别物体不受影响 代码要放到updata中 spee * Time.unscaledDeltaTime 不受缩放影响的每帧间隔
    this.transform.Rotate(0, speed * Time.unscaledDeltaTime , 0);

}
//固定0.02s 执行一次，与渲染无关，受TimeScale影响
public void FixedUpdate()
{
    //this.transform.Rotate(0, speed, 0);
}

//游戏暂停  个别物体不受影响  代码要放到updata中

private void OnGUI()
{
    if (GUILayout .Button (&quot;暂停游戏&quot;))
    {
        Time.timeScale = 0;
    }

    if(GUILayout.Button(&quot;继续游戏&quot;))
    {
        Time.timeScale = 1;
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[获取同类物体]]></title>
        <id>https://Wei715547.github.io/post/huo-qu-tong-lei-wu-ti/</id>
        <link href="https://Wei715547.github.io/post/huo-qu-tong-lei-wu-ti/">
        </link>
        <updated>2020-04-04T14:28:03.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class FindEnemyDeom : MonoBehaviour<br>
{</p>
<pre><code>private void OnGUI()
{
    if (GUILayout .Button (&quot;查找血量最低的敌人&quot;))
    {
        //查找场景中所有Enemy类型的引用
        Enemy[] allEnemy = Object.FindObjectsOfType&lt;Enemy&gt;();
        //获取血量最低的对象的引用
        Enemy min = FindEnemyByMinHp(allEnemy);
        //根据Enemy类型的引用 获取其他组件类型引用
        min.GetComponent&lt;MeshRenderer&gt;().material.color = Color.blue;
    }
    if (GUILayout.Button (&quot;层级位置获取子物体&quot;))
    {
        var childTF = TransformHelper.GetChild(this.transform , &quot;Cube3&quot;);
        childTF.GetComponent&lt;MeshRenderer&gt;().material.color = Color.blue;
        //print(childTF.name);
        
    }
}

public Enemy FindEnemyByMinHp(Enemy [] allEnemy)
{
    Enemy min = allEnemy[0];

    for (int i = 1; i &lt; allEnemy .Length ; i++)
    {
        if (min.Hp &gt; allEnemy[i].Hp)
            min = allEnemy[i];
    }
    return min;

}
</code></pre>
<p>}</p>
]]></content>
    </entry>
</feed>