<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Wei715547.github.io</id>
    <title>Weiwei的个人网站</title>
    <updated>2020-04-13T04:30:10.695Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Wei715547.github.io"/>
    <link rel="self" href="https://Wei715547.github.io/atom.xml"/>
    <subtitle>7</subtitle>
    <logo>https://Wei715547.github.io/images/avatar.png</logo>
    <icon>https://Wei715547.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Weiwei的个人网站</rights>
    <entry>
        <title type="html"><![CDATA[碰撞，触发]]></title>
        <id>https://Wei715547.github.io/post/peng-zhuang-hong-fa/</id>
        <link href="https://Wei715547.github.io/post/peng-zhuang-hong-fa/">
        </link>
        <updated>2020-04-13T04:29:47.000Z</updated>
        <content type="html"><![CDATA[<pre><code>//都有碰撞器组件
//运动的物体有刚体组件
private void OnCollisionEnter(Collision other )
{
    print(other.collider.name);
    
}


//都有碰撞器组件
//其中一个勾选IsTriggger
//其中一个有刚体组件
private void OnTriggerEnter(Collider other)//触发开始执行 other碰撞到的物体
{
    
    float a = other.GetComponent&lt;Enemy&gt;().Hp;
    print(other.name+a);
    other.GetComponent&lt;Enemy&gt;().Hp -= Random .Range (5,10);
    print(other.name + other.GetComponent&lt;Enemy&gt;().Hp);
    
}

private void OnTriggerStay(Collider other)//触发后每帧执行
{
    other.GetComponent&lt;MeshRenderer&gt;().material.color = Color.red;
    if (other.GetComponent&lt;Enemy&gt;().Hp &lt;= 0)
        Destroy(other.gameObject);
}

private void OnTriggerExit(Collider other)//触发结束时执行
{
    other.GetComponent&lt;MeshRenderer&gt;().material.color = Color.white;
}</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2D Jump]]></title>
        <id>https://Wei715547.github.io/post/2d-jump/</id>
        <link href="https://Wei715547.github.io/post/2d-jump/">
        </link>
        <updated>2020-04-12T05:00:07.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class JumpBox : MonoBehaviour<br>
{<br>
[Range(0, 10)] public float jumpVelocity = 5f;<br>
public LayerMask mask;<br>
public float boxHeight;<br>
private Vector2 playerSize;<br>
private Vector2 boxSize;<br>
private bool jumpRequest;<br>
private bool grounded;<br>
public float fallMultiplier = 2.5f;<br>
public float LowJumpMultiplier = 2f;<br>
private Rigidbody2D _rigidbody2D;</p>
<pre><code>// Start is called before the first frame update
void Start()
{
    _rigidbody2D = GetComponent&lt;Rigidbody2D&gt;();
    playerSize = GetComponent&lt;SpriteRenderer&gt;().bounds.size;
    boxSize = new Vector2(playerSize.x * 0.8f, boxHeight);

}

// Update is called once per frame
void Update()
{
    if (Input.GetButtonDown(&quot;Jump&quot;) &amp;&amp; grounded)
    {
        jumpRequest = true;
    }
}
private void FixedUpdate()
{
    //自然重力
    Gud();

    if (jumpRequest)
    {
        _rigidbody2D.AddForce(Vector2.up * jumpVelocity, ForceMode2D.Impulse);
        jumpRequest = false;
        grounded = false;
    }
    else
    {
        Vector2 boxCenter = (Vector2)transform.position + (Vector2.down * playerSize.y * 0.5f);
        if (Physics2D.OverlapBox(boxCenter, boxSize, 0, mask) != null)
        {
            grounded = true;
        }
        else
        {
            grounded = false;
        }
    }
}

private void Gud()
{
    if (_rigidbody2D.velocity.y &lt; 0)
    {
        _rigidbody2D.gravityScale = fallMultiplier;
    }
    else if (_rigidbody2D.velocity.y &gt; 0 &amp;&amp; !Input.GetButton(&quot;Jump&quot;))
    {
        _rigidbody2D.gravityScale = LowJumpMultiplier;
    }
    else
    {
        _rigidbody2D.gravityScale = 1f;
    }
}

private void OnDrawGizmos()
{
    if (grounded)
    {
        Gizmos.color = Color.red;
    }
    else
    {
        Gizmos.color = Color.green;
    }

    Vector2 boxCenter = (Vector2)transform.position + (Vector2.down * playerSize.y * 0.5f);
    Gizmos.DrawWireCube(boxCenter, boxSize);
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[EventSystems]]></title>
        <id>https://Wei715547.github.io/post/eventsystems/</id>
        <link href="https://Wei715547.github.io/post/eventsystems/">
        </link>
        <updated>2020-04-12T04:17:55.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.EventSystems;<br>
public class DIalogDrag : MonoBehaviour, IPointerDownHandler,IDragHandler,IPointerClickHandler<br>
{<br>
private RectTransform parentRTF;<br>
private void Start()<br>
{<br>
//设置UI长宽<br>
RectTransform rtf = GetComponent<RectTransform>();<br>
rtf.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, 700);<br>
rtf.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, 400);</p>
<pre><code>    parentRTF = this.transform.parent as RectTransform;
}
private Vector3 siftVector;
//按下时执行
public void OnPointerDown(PointerEventData eventData)
{
    //记录按下点到中心点偏移量

    Vector3 wordPoint;
    //屏幕坐标--&gt;世界坐标
    //(父物体的变换组件，屏幕坐标，摄像机，out 世界坐标)
    RectTransformUtility.ScreenPointToWorldPointInRectangle(parentRTF, eventData.position, eventData.pressEventCamera, out wordPoint);
    siftVector = this.transform.position - wordPoint;
}
//拖拽时执行
public void OnDrag(PointerEventData eventData)
{
    Vector3 wordPoint;
    //屏幕坐标--&gt;世界坐标
    //(父物体的变换组件，屏幕坐标，摄像机，out 世界坐标)
    RectTransformUtility.ScreenPointToWorldPointInRectangle(parentRTF, eventData.position, eventData.pressEventCamera, out wordPoint);
    this.transform.position = wordPoint + siftVector ;
    
}

public void OnPointerClick(PointerEventData eventData)
{
    if (eventData.clickCount == 2)
        Destroy (this .gameObject );
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HP-Attack-Shell]]></title>
        <id>https://Wei715547.github.io/post/hp-attack-shell/</id>
        <link href="https://Wei715547.github.io/post/hp-attack-shell/">
        </link>
        <updated>2020-04-07T09:57:39.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.UI;<br>
/// <summary><br>
/// HP，HP受损方法<br>
/// </summary><br>
public class TankHealth : MonoBehaviour<br>
{<br>
public int hp = 100;<br>
public GameObject tankExplosion;<br>
public AudioClip tankExplositionAudio;<br>
public Slider hpSlider;<br>
private int hpTotal;<br>
// Use this for initialization<br>
void Start()<br>
{<br>
hpTotal = hp;<br>
}</p>
<pre><code>// Update is called once per frame
void Update()
{

}
void TankDamage()
{
    if (hp &lt;= 0) return;
    hp -= Random.Range(10, 20);
    hpSlider.value = (float)hp / hpTotal;
    if (hp &lt;= 0)
    {
        AudioSource.PlayClipAtPoint(tankExplositionAudio, transform.position);
        GameObject.Instantiate(tankExplosion, transform.position + Vector3.up, transform.rotation);
        GameObject.Destroy(this.gameObject);
    }
}
</code></pre>
<p>}</p>
<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
/// <summary><br>
/// 按下攻击，发射子弹向FirePoint前方飞进<br>
/// </summary><br>
public class TankAttack : MonoBehaviour<br>
{</p>
<pre><code>public GameObject shellPrefab;
public KeyCode fireKey = KeyCode.Space;
private Transform firePosition;
public float shellSpeed = 10;
public AudioClip shoutAudio;
// Use this for initialization
void Start()
{
    firePosition = transform.Find(&quot;FirePosition&quot;);
}

// Update is called once per frame
void Update()
{
    if (Input.GetKeyDown(fireKey))
    {
        AudioSource.PlayClipAtPoint(shoutAudio, transform.position);
        GameObject go = GameObject.Instantiate(shellPrefab, firePosition.position, firePosition.rotation)as GameObject;
        go.GetComponent&lt;Rigidbody&gt;().velocity = go.transform.forward * shellSpeed;
    }
}
</code></pre>
<p>}</p>
<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
/// <summary><br>
/// 子弹出发检测，（两物体都有触发器，其中一个有刚体组件，其中一个触发器勾选Is Tirgger）<br>
///打中目标，调用目标受损方法<br>
/// </summary><br>
public class Shell : MonoBehaviour<br>
{</p>
<pre><code>public GameObject shellExplosionPrefab;
public  AudioClip shellExplosionAudio;


public void OnTriggerEnter(Collider collider)
{
    AudioSource.PlayClipAtPoint(shellExplosionAudio,transform.position);
    GameObject.Instantiate(shellExplosionPrefab, transform.position, transform.rotation);
    GameObject.Destroy(this.gameObject);
    if (collider.tag == &quot;Tank&quot;)
    {
        collider.SendMessage(&quot;TankDamage&quot;);
    }

}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[俯视较移动旋转]]></title>
        <id>https://Wei715547.github.io/post/fu-shi-jiao-yi-dong-xuan-zhuan/</id>
        <link href="https://Wei715547.github.io/post/fu-shi-jiao-yi-dong-xuan-zhuan/">
        </link>
        <updated>2020-04-05T05:57:42.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class Move : MonoBehaviour<br>
{<br>
public float speed = 5;<br>
private void Update()<br>
{<br>
float v = Input.GetAxis(&quot;Vertical&quot;);<br>
float h = Input.GetAxis(&quot;Horizontal&quot;);<br>
if (v != 0 || h != 0)<br>
Movement(v, h);<br>
}<br>
private void Movement(float v, float h)<br>
{<br>
this.transform.Translate(0, 0, speed*Time .deltaTime );<br>
Quaternion dir = Quaternion.LookRotation(new Vector3(h, 0, v));<br>
this.transform.rotation =<br>
Quaternion.Lerp(this.transform.rotation, dir, 0.1f);<br>
}<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Boom向量/三角函数应用]]></title>
        <id>https://Wei715547.github.io/post/boom-xiang-liang-san-jiao-han-shu-ying-yong/</id>
        <link href="https://Wei715547.github.io/post/boom-xiang-liang-san-jiao-han-shu-ying-yong/">
        </link>
        <updated>2020-04-04T14:34:23.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class Boom : MonoBehaviour<br>
{<br>
public GameObject player;<br>
private Vector3 dp;<br>
//private Vector3 ldp;<br>
private Vector3 liftdp;<br>
private Vector3 rightdp;<br>
private float dt;<br>
private float sin;<br>
private float rd;<br>
// Start is called before the first frame update<br>
void Start()<br>
{<br>
rd = player.GetComponent<CapsuleCollider>().radius ;<br>
}</p>
<pre><code>// Update is called once per frame
void Update()
{
    Draw();
}

private void VectorCt()
{
    
    dp = player.transform.position - this.transform.position;
    dt = dp.magnitude;
    sin = Mathf.Rad2Deg * Mathf.Asin(rd / dt);
    //ldp = Quaternion.Euler(0, sin, 0) *dp.normalized * dt * Mathf.Cos(sin);
    liftdp = this.transform.position + Quaternion.Euler(0, sin, 0) * dp;
   
    rightdp = this.transform.position + Quaternion.Euler(0, -sin, 0) * dp;
    
}

private void CalculateTangent()
{
    Vector3 playerToBoom = this.transform.position - player.transform.position;
    Vector3 playerToExplpsionDirection = playerToBoom.normalized * rd;
    float angle = Mathf.Acos(rd / playerToBoom.magnitude) * Mathf.Rad2Deg;
    liftdp = player.transform.position + Quaternion.Euler(0, -angle , 0) * playerToExplpsionDirection;
    rightdp = player.transform.position + Quaternion.Euler(0, angle, 0) * playerToExplpsionDirection;

}

private void Draw()
{
    //VectorCt();
    CalculateTangent();
    Debug.DrawLine(this.transform.position, player.transform.position);
    Debug.DrawLine(this.transform.position, liftdp,Color .blue );
    Debug.DrawLine(this.transform.position, rightdp,Color .red );
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[四元数API]]></title>
        <id>https://Wei715547.github.io/post/si-yuan-shu-api/</id>
        <link href="https://Wei715547.github.io/post/si-yuan-shu-api/">
        </link>
        <updated>2020-04-04T14:33:23.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class QuaternionAPI : MonoBehaviour<br>
{<br>
public Transform  tf;<br>
public AnimationCurve a;<br>
private float x;</p>
<pre><code>private void OnGUI()
{
    if (GUILayout.Button (&quot;&quot;))
    {
        //1.欧拉角转换为四元数
        //Quaternion.Euler(欧拉角);

        //2/四元数转欧拉角
        Quaternion qt = this.transform.rotation;
        Vector3 auler = qt.eulerAngles;

        //3.轴/角
        //Quaternion.Euler(0, 50, 0);
        this .transform .rotation = Quaternion.AngleAxis(50, Vector3.up);

    }
    
    if (GUILayout.Button(&quot;LookRotation&quot;))
    {
        //4.注视旋转
        //Z轴指向一个方向
        //当前物体注视 tf 旋转
        Vector3 dir = tf.position - this.transform.position;
        this.transform.rotation  = Quaternion.LookRotation (dir);
        //this.transform.LookAt(tf);//效果与上两行代码相同----下一帧立即执行

    }

    if (GUILayout.RepeatButton(&quot;LookRotationLerp&quot;))
    {
        //5.插值旋转
        x += Time.deltaTime;
        Quaternion dir = Quaternion.LookRotation(tf.position - this.transform.position);            
        this .transform .rotation = Quaternion.Lerp(this.transform.rotation, dir, a.Evaluate (x));

        //6.匀速旋转
        //this.transform.rotation = Quaternion.RotateTowards(this.transform.rotation, dir, 0.1f);//匀速朝向旋转
    }

    if (GUILayout.RepeatButton(&quot;AngleR90&quot;))
    {
        Quaternion dir = Quaternion.Euler(0, 90, 0);
        this.transform.rotation =
            Quaternion.Lerp(this.transform.rotation, dir, 0.1f);
        //7.如果当前旋转角度 接近目标旋转角度
        if (Quaternion .Angle (this .transform .rotation ,dir )&lt;10)
        {
            this.transform.rotation = dir;
        }
    }

    if (GUILayout.RepeatButton(&quot;Right&quot;))
    {
        //8.x轴注视旋转 t1
        //this.transform.right = tf.position - this.transform.position;
        //x正方向---注视目标物体方向
        Quaternion dir = Quaternion.FromToRotation(Vector3 .right  , tf.position - this.transform.position);
        //this.transform.rotation = dir;
        this.transform.rotation = Quaternion.Lerp(this.transform.rotation, dir, 0.1f);


    }
}

// Update is called once per frame
void Update()
{
    
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[向量API]]></title>
        <id>https://Wei715547.github.io/post/xiang-liang-api/</id>
        <link href="https://Wei715547.github.io/post/xiang-liang-api/">
        </link>
        <updated>2020-04-04T14:33:02.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class VectorAPI : MonoBehaviour<br>
{<br>
public AnimationCurve cuver;<br>
private float x;<br>
public  float psTime=3;<br>
private Vector3 targetPoint = new Vector3 (0, 0, 10);<br>
private void OnGUI()<br>
{<br>
if (GUILayout.RepeatButton (&quot;Move&quot;))<br>
{<br>
//将物体移动至（0，0,10）<br>
//匀速移动<br>
this.transform.position = Vector3.MoveTowards(this.transform.position,targetPoint , 2);<br>
//先快后慢--终点与比例固定<br>
this.transform.position = Vector3.Lerp (this.transform.position, targetPoint , 2 );</p>
<pre><code>    }
    if (GUILayout.RepeatButton(&quot;Lerp&quot;))
    {
        x += Time.deltaTime/psTime ;
        //自然变化，起点，终点固定，比例根据曲线变化
        this.transform.position =
            Vector3.LerpUnclamped (Vector3.zero, targetPoint, cuver.Evaluate(x));
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第一人称镜头旋转]]></title>
        <id>https://Wei715547.github.io/post/di-yi-ren-cheng-jing-tou-xuan-zhuan/</id>
        <link href="https://Wei715547.github.io/post/di-yi-ren-cheng-jing-tou-xuan-zhuan/">
        </link>
        <updated>2020-04-04T14:31:08.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
/// <summary><br>
/// 控制摄像机随鼠标旋转<br>
/// </summary><br>
public class DoRotation : MonoBehaviour<br>
{<br>
public float rotateSpeed = 1;<br>
private void FixedUpdate()<br>
{<br>
float x = Input.GetAxis(&quot;Mouse X&quot;);<br>
float y = Input.GetAxis(&quot;Mouse Y&quot;);</p>
<pre><code>    if (x!=0||y!=0)
    RotateView(x, y);
}

private void RotateView(float x, float y)
{
    x *= rotateSpeed;
    y *= rotateSpeed;

    this.transform.Rotate(0, x, 0, Space.World);//左右旋转按照世界坐标
    //this.transform.Rotate(-y, 0, 0, Space.Self);//上下旋转按自身坐标
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[镜头缩放]]></title>
        <id>https://Wei715547.github.io/post/jing-tou-suo-fang/</id>
        <link href="https://Wei715547.github.io/post/jing-tou-suo-fang/">
        </link>
        <updated>2020-04-04T14:30:16.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
/// <summary><br>
/// 镜头缩放<br>
/// </summary><br>
public class CareamZoom : MonoBehaviour<br>
{<br>
public bool isDown;<br>
public bool keyDown;<br>
public bool cvDown;<br>
public Transform l1;</p>
<pre><code>public bool isFar = true;
private Camera camera;

public int[] zoomLevel;
private int index;
private Vector3 lo;
private Quaternion ro;



private void Start()
{
    camera = GetComponent&lt;Camera&gt;();
    lo = this.transform.position;
    ro = this.transform.rotation;
}

private void Update()
{
    isDown = Input.GetMouseButton(0);//左键

    keyDown = Input.GetKey(KeyCode.Q);

    CamerPosition();

    if (keyDown)
        Zoom4();


    cvDown = Input.GetKey(KeyCode.C) &amp;&amp; Input.GetKey(KeyCode.V);


}

private void CamerPosition()
{

    if (keyDown)
    {
        this.transform.position = this.transform.parent.position;
        this.transform.rotation = this.transform.parent.rotation;
    }
    else
    {
        this.transform.position = l1.position;
        this.transform.rotation = l1.rotation;
        index = 0;
        camera.fieldOfView = zoomLevel[index ];
    }
}

private void Zoom1()
{
    if (Input.GetMouseButtonDown(1))
    {
        //拉近：10
        isFar = !isFar;

        if (isFar)
        {
            camera.fieldOfView = 50;
            //拉远：50
        }
        else
        {
            camera.fieldOfView = 10;
        }

    }
}

private void Zoom2()
{
    if (Input.GetMouseButtonDown(1))
    {
        isFar = !isFar;
    }
    if (isFar)
    {
        if (camera.fieldOfView &lt; 50)
            camera.fieldOfView += 2;
        //拉远：10--&gt;50
    }
    else
    {
        //拉近：50--&gt;10
        if (camera.fieldOfView &gt; 10)
            camera.fieldOfView -= 2;
    }
}

private void Zoom3()//先快后慢 Lerp (起点，终点，比例0.1)第一次返回起点到终点0.1的值
{
    if (Input.GetMouseButtonDown(1))
    {
        isFar = !isFar;
    }
    if (isFar)
    {
        //拉远：10--&gt;50
        camera.fieldOfView = Mathf.Lerp(camera.fieldOfView, 50, 0.1f);//无限接近50，不等于
        if (Mathf.Abs(camera.fieldOfView - 50) &lt; 0.1) camera.fieldOfView = 50;//使无限接近时，等于
    }
    else
    {
        //拉近：50--&gt;10
        camera.fieldOfView = Mathf.Lerp(camera.fieldOfView, 10, 0.1f);
        if (Mathf.Abs(camera.fieldOfView - 10) &lt; 0.1) camera.fieldOfView = 10;
    }
}

private void Zoom4()//
{
    if (Input.GetMouseButtonDown(1))
    {
        //index = index &lt; zoomLevel.Length - 1 ? index + 1 : 0;
        index = (index + 1) % zoomLevel.Length;
        //index++;
        //if (index &gt;= zoomLevel.Length)
        //index = 0;
    }

    camera.fieldOfView = Mathf.Lerp(camera.fieldOfView, zoomLevel[index], 0.1f);//无限接近50，不等于
    if (Mathf.Abs(camera.fieldOfView - zoomLevel[index]) &lt; 0.1) camera.fieldOfView = zoomLevel[index];//使无限接近时，等于

}
</code></pre>
<p>}</p>
]]></content>
    </entry>
</feed>