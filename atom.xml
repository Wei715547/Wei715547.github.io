<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Wei715547.github.io</id>
    <title>Wei: Development technology accumulation</title>
    <updated>2020-06-08T07:43:50.502Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Wei715547.github.io"/>
    <link rel="self" href="https://Wei715547.github.io/atom.xml"/>
    <subtitle>年月增长，我宜强盛。
用于Unity+开发的技术积累</subtitle>
    <logo>https://Wei715547.github.io/images/avatar.png</logo>
    <icon>https://Wei715547.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Wei: Development technology accumulation</rights>
    <entry>
        <title type="html"><![CDATA[Post Process Effect/Camer Shake]]></title>
        <id>https://Wei715547.github.io/post/post-process-effectcamer-shake/</id>
        <link href="https://Wei715547.github.io/post/post-process-effectcamer-shake/">
        </link>
        <updated>2020-06-07T07:05:12.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://Wei715547.github.io/post-images/1591513702359.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1591513708909.PNG" alt="" loading="lazy"></p>
<p><img src="https://Wei715547.github.io/post-images/1591514562757.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1591514569006.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1591514575527.PNG" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C#中调用Lua程序]]></title>
        <id>https://Wei715547.github.io/post/czhong-diao-yong-lua-cheng-xu/</id>
        <link href="https://Wei715547.github.io/post/czhong-diao-yong-lua-cheng-xu/">
        </link>
        <updated>2020-06-07T04:56:04.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using XLua;<br>
public class HW2 : MonoBehaviour<br>
{<br>
// Start is called before the first frame update<br>
void Start()<br>
{<br>
//1.通过资源加载执行Lua程序<br>
/<em>TextAsset ta = Resources.Load<TextAsset>(&quot;面向对象实现.lua&quot;);<br>
//print(ta);<br>
LuaEnv env = new LuaEnv();<br>
env.DoString(ta.text);<br>
env.Dispose();</em>/</p>
<pre><code>    //2.通过require 'XXX'执行Lua程序
    LuaEnv env = new LuaEnv();
    env.DoString(&quot;require '面向对象实现'&quot;);
    //访问Lua中的全局变量
    /*int num = env.Global.Get&lt;int&gt;(&quot;num1&quot;);
    print(num);
    string s = env.Global.Get&lt;string&gt;(&quot;str&quot;);
    print(s);
    bool t = env.Global.Get&lt;bool&gt;(&quot;isOn&quot;);
    print(t);*/
    //env.Dispose();

    //映射到类
    /*Person p = env.Global.Get&lt;Person&gt;(&quot;person&quot;);//值拷贝，耗费性能，
    print(p.name + &quot;-&quot; + p.age);
    p.name = &quot;ZZ&quot;;
    env.DoString(&quot;print(person.name)&quot;);//不改变Lua中的变量值*/

    //映射到接口
    IPerson p = env.Global.Get&lt;IPerson&gt;(&quot;person&quot;);//引用拷贝，可改变Lua中的值
    print(p.name + &quot;-&quot; + p.age);
    p.name = &quot;ZL&quot;;
    env.DoString(&quot;print(person.name)&quot;);

    env.Dispose();

}

//将Lua中的table映射到类（耗费性能）
class Person
{
    public string name;
    public int age;
}

//将Lua中的变量映射到接口
[CSharpCallLua]
interface IPerson
{
    string name { get; set; }
    int age { get; set; }

}
</code></pre>
<p>}</p>
<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using System.IO;<br>
using UnityEngine;<br>
using XLua;<br>
public class Loader : MonoBehaviour<br>
{<br>
// Start is called before the first frame update<br>
void Start()<br>
{<br>
LuaEnv env = new LuaEnv();</p>
<pre><code>    env.AddLoader(MyLoader);//先执行自定义的Loader，自定义Loader中有返回Lua程序时，将不再执行系统加载的Lua程序
    env.DoString(&quot;require 'text01'&quot;);//加载的文件会传递给Lodader
    env.Dispose();
}
</code></pre>
<p>//自定义Loader<br>
private byte [] MyLoader(ref string filePath)<br>
{<br>
print(filePath);</p>
<pre><code>    //通过自定义Loader返回Lua程序
    //string s = &quot;print(123)&quot;;
    //return System .Text .Encoding.UTF8 .GetBytes (s);

    print(Application.streamingAssetsPath);

    //通过路径读取返回Lua程序
    string absPath = Application.streamingAssetsPath + &quot;/&quot; + filePath + &quot;.lua.txt&quot;;
    return System.Text.Encoding.UTF8.GetBytes(File.ReadAllText( absPath));
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[生命周期]]></title>
        <id>https://Wei715547.github.io/post/sheng-ming-zhou-qi/</id>
        <link href="https://Wei715547.github.io/post/sheng-ming-zhou-qi/">
        </link>
        <updated>2020-06-06T08:23:03.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://Wei715547.github.io/post-images/1591431791506.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[视角缩放/跟随]]></title>
        <id>https://Wei715547.github.io/post/shi-jiao-suo-fang-gen-sui/</id>
        <link href="https://Wei715547.github.io/post/shi-jiao-suo-fang-gen-sui/">
        </link>
        <updated>2020-06-06T05:34:56.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class CamerCT : MonoBehaviour<br>
{<br>
public Transform target;<br>
public Vector3 offset;</p>
<pre><code>//视角范围，缩放速度
public float zoomSpeed = 4f;
public float minZoom = 5f;
public float maxZoom = 10f;

public float pitch=2f;//视角高度值

private float currentZoom = 10f;//焦距

public float YawSpeed = 100f;//旋转速度
private float currentYaw = 0f;//旋转角度

// Update is called once per frame
void Update()
{
    currentZoom -= Input.GetAxis(&quot;Mouse ScrollWheel&quot;)*zoomSpeed *Time .deltaTime;
    currentZoom = Mathf.Clamp(currentZoom, minZoom, maxZoom);//限定缩放范围

    currentYaw += Input.GetAxis(&quot;Horizontal&quot;) * YawSpeed * Time.deltaTime;

}

private void LateUpdate()
{
    transform.position = target.position - offset * currentZoom;
    transform.LookAt(target.position + Vector3.up*pitch);

    transform.RotateAround(target.position, Vector3.up, currentYaw);
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自动寻路]]></title>
        <id>https://Wei715547.github.io/post/zi-dong-xun-lu/</id>
        <link href="https://Wei715547.github.io/post/zi-dong-xun-lu/">
        </link>
        <updated>2020-06-06T04:58:09.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.AI;</p>
<p>public class PlayerCT : MonoBehaviour<br>
{</p>
<pre><code>public LayerMask movementMask;
NavMeshAgent navMeshAgent;

// Start is called before the first frame update
void Start()
{
    animator = this.transform.GetComponent&lt;Animator&gt;();
    navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();
}

// Update is called once per frame
void Update()
{
    if (Input.GetMouseButtonDown(1))
    {
        Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
        RaycastHit hit;
        if (!Physics.Raycast(ray, out hit,100,movementMask))
        {
            //hit.collider .gameObject //射线打到的物体
            return;
        }
        navMeshAgent.destination = hit.point;
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[File类，R/W]]></title>
        <id>https://Wei715547.github.io/post/file-lei-rw/</id>
        <link href="https://Wei715547.github.io/post/file-lei-rw/">
        </link>
        <updated>2020-06-03T15:48:34.000Z</updated>
        <content type="html"><![CDATA[<p>using System;<br>
using System.IO;</p>
<p>namespace FileClass_Read_and_Wright<br>
{<br>
class Program<br>
{<br>
static void Main(string[] args)<br>
{<br>
/<em>string[] strarray = File.ReadAllLines(&quot;TextFile1.txt&quot;);//读取文件，把每一行文本文件读取成一个字符串，<br>
//最后主城一个字符串数组<br>
foreach (var s in strarray )<br>
{<br>
Console.WriteLine(s);<br>
}</em>/</p>
<pre><code>        /*string s = File.ReadAllText(&quot;TextFile1.txt&quot;);
        Console.WriteLine(s);*/

        byte[] byteArray = File.ReadAllBytes(&quot;20191103200554.jpg&quot;);
        foreach (var b in byteArray)
        {
            Console.Write(b);
        }

        /*File.WriteAllText(&quot;TextFile2.txt&quot;, &quot;WEI&quot;);

        File.WriteAllLines(&quot;TextFile3.txt&quot;, new string[] { &quot;wei&quot;, &quot;zzz&quot; });*/

        //读取文件二进制数据
        //byte[] data = File.ReadAllBytes(&quot;20191103200554.jpg&quot;);
        //写入文件二进制数据（复制）
        //File.WriteAllBytes(&quot;1.png&quot;, data);

    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Socket客户端端口]]></title>
        <id>https://Wei715547.github.io/post/socket-ke-hu-duan-duan-kou/</id>
        <link href="https://Wei715547.github.io/post/socket-ke-hu-duan-duan-kou/">
        </link>
        <updated>2020-06-02T05:45:10.000Z</updated>
        <content type="html"><![CDATA[<p>using System;<br>
using System.Net;<br>
using System.Net.Sockets;<br>
using System.Text;</p>
<p>namespace Socket客户端<br>
{<br>
class Program<br>
{<br>
static void Main(string[] args)<br>
{<br>
//1.创建Socket<br>
Socket tcpClient = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);//网咯、数据流形式、Tcp协议</p>
<pre><code>        //2.发起建立连接的请求
        IPAddress ipaddress = IPAddress.Parse(&quot;192.168.137.1&quot;);//可以将一个字符串的IP地址转化为IPaddress的对象
        EndPoint point = new IPEndPoint(ipaddress, 7788);
        //连接方法
        tcpClient.Connect(point);//通过ip:端口号，定位连接到目标服务器
        
        //接收来自服务器的数据（接收方法）
        byte[] data = new byte[1024]; //创建一个byte数组,(用来接收数据)
         int length = tcpClient.Receive(data);//传递一个byte数组,(用来接收数据)、返回值表示接收了多少字符串
        string message = Encoding.UTF8.GetString(data,0,length);//0~length的字节数据转化为字符串（把接收到的数据转化为字符串）
        Console.WriteLine(message);

        //向服务器端发送消息
        string messagec = Console.ReadLine();//读取用户的输入
        //发送方法
        tcpClient.Send(Encoding.UTF8.GetBytes(messagec));//把字符串转化为byte数组发送到服务器端

        Console.ReadKey();
    }
}
</code></pre>
<p>}<br>
<img src="https://Wei715547.github.io/post-images/1591076933494.PNG" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Socket服务器端口]]></title>
        <id>https://Wei715547.github.io/post/socket-fu-wu-qi-duan-kou/</id>
        <link href="https://Wei715547.github.io/post/socket-fu-wu-qi-duan-kou/">
        </link>
        <updated>2020-06-02T05:40:59.000Z</updated>
        <content type="html"><![CDATA[<p>using System;<br>
using System.Net;<br>
using System.Net.Sockets;<br>
using System.Text;</p>
<p>namespace Socket服务器端<br>
{<br>
class Program<br>
{<br>
static void Main(string[] args)<br>
{<br>
//创建Socket<br>
Socket tcpServer = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);//网络、数据流形式、Tcp协议</p>
<pre><code>        //1.绑定IP端口号
        //IPAddress ipaddress = new IPAddress(new byte[] { 192,168,137,1 });
        IPAddress ipaddress = IPAddress.Parse(&quot;192.168.137.1&quot;);//可以将一个字符串的IP地址转化为IPaddress的对象、同上一行代码
        EndPoint point = new IPEndPoint(ipaddress,7788);//IPEndPoint:IP端口的一层封装类
        //申请方法
        tcpServer.Bind(point);//向系统申请一个可用的ip根端口号，用来做通信
        
        //2.开始监听客户端连接
        //监听方法
        tcpServer.Listen(100);//开始监听等待客户端连接、允许（100）个客户端连接进来。
        Console.WriteLine(&quot;开始监听连接&quot;);

        //使用返回的Socket做通信

        //3.接收客户端的连接//接收连接方法
        //客户端的Socket对象的引用、用来收发客户端的数据
        Socket clientSocket = tcpServer.Accept();//暂停当前线程，直到有一个客户端连接进来，之后进行下面的代码。
        Console.WriteLine(&quot;一个客户端连接&quot;);

        //4.客户端连接后向客户端发送一个消息
        string message = &quot;欢迎接入Socket&quot;;//向客户端传输的信息
        byte[] data = Encoding.UTF8.GetBytes(message);//对一个字符串做编码，转为字节数组
        clientSocket.Send(data);
        Console.WriteLine(&quot;向客户端发送了一条数据&quot;);

        //5.接收客户端的数据
        byte[] datac = new byte[1024];//创建一个字节数组用来接收客户端发过来的数据
        int length = clientSocket.Receive(datac);
        string messagec = Encoding.UTF8.GetString(datac, 0, length);//0~length的字节数据转化为字符串（只把接收到的数据转化为字符串）
        Console.WriteLine(&quot;接收到一条从客户端发来的消息&quot;+messagec);


        Console.ReadKey();
    }
}
</code></pre>
<p>}<br>
<img src="https://Wei715547.github.io/post-images/1591076704544.PNG" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程池/Task类开启线程]]></title>
        <id>https://Wei715547.github.io/post/xian-cheng-chi/</id>
        <link href="https://Wei715547.github.io/post/xian-cheng-chi/">
        </link>
        <updated>2020-06-01T05:11:19.000Z</updated>
        <content type="html"><![CDATA[<p>using System;<br>
using System.Threading;</p>
<p>namespace 线程池<br>
{<br>
class Program<br>
{<br>
static void ThreadMethod(object state)<br>
{<br>
Console.WriteLine(&quot;线程开始&quot;+Thread .CurrentThread .ManagedThreadId);<br>
Thread.Sleep(2000);<br>
Console.WriteLine(&quot;线程结束&quot;);<br>
}</p>
<pre><code>    static void Main(string[] args)
    {
        ThreadPool.QueueUserWorkItem(ThreadMethod);//开启一个工作线程（适合耗时较短的任务）
        ThreadPool.QueueUserWorkItem(ThreadMethod);
        ThreadPool.QueueUserWorkItem(ThreadMethod);
        ThreadPool.QueueUserWorkItem(ThreadMethod);
        ThreadPool.QueueUserWorkItem(ThreadMethod);
        Console.ReadKey();


    }
}
</code></pre>
<p>}<br>
//-------------------------------------------------------------------------<br>
using System;<br>
using System.Threading;<br>
using System.Threading.Tasks;</p>
<p>namespace Task类开启线程<br>
{<br>
class Program<br>
{<br>
static void ThreadMethod()<br>
{<br>
Console.WriteLine(&quot;线程开始&quot; + Thread.CurrentThread.ManagedThreadId);<br>
Thread.Sleep(2000);<br>
Console.WriteLine(&quot;线程结束&quot;);<br>
}</p>
<pre><code>    static void Main(string[] args)
    {
        //1.开启方式
        /*Task t = new Task(ThreadMethod);
        t.Start();*/

        //2.开启方式
        /*TaskFactory tf = new TaskFactory();
        Task t = tf.StartNew(ThreadMethod);*/

        Console.WriteLine(&quot;Main&quot;);
        Console.ReadKey();
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Thread类开启线程]]></title>
        <id>https://Wei715547.github.io/post/thread-lei-kai-qi-xian-cheng/</id>
        <link href="https://Wei715547.github.io/post/thread-lei-kai-qi-xian-cheng/">
        </link>
        <updated>2020-05-31T15:49:26.000Z</updated>
        <content type="html"><![CDATA[<p>using System;<br>
using System.Threading;<br>
using System.Threading.Tasks;<br>
namespace 线程_通过Thread类开启<br>
{<br>
class Program<br>
{<br>
static void Downloading(object fileName)<br>
{<br>
Console.WriteLine(&quot;startDownloadong&quot;+Thread .CurrentThread .ManagedThreadId +fileName );<br>
Thread.Sleep(2000);<br>
Console.WriteLine(&quot;END&quot;);<br>
}<br>
static void Main(string[] args)<br>
{<br>
//方式1.直接赋值一个方法引用<br>
/<em>Thread t = new Thread(Downloading);<br>
t.Start();//开始执行线程<br>
Console.WriteLine(&quot;Main&quot;);</em>/</p>
<pre><code>        //开启方式2。赋值一个表达式（匿名方法）
        /*Thread t = new Thread(() =&gt;
       {
           Console.WriteLine(&quot;startDownloadong&quot; + Thread.CurrentThread.ManagedThreadId);
           Thread.Sleep(2000);
           Console.WriteLine(&quot;END&quot;);
       });
        t.Start();*/

        /*//方式1.传递参数
        Thread t = new Thread(Downloading);
        t.Start(&quot;XXX&quot;);//开始执行线程
        Console.WriteLine(&quot;Main&quot;);*/

        //2.创建一个对象，将要传递的数据放到对象里进行传递
        Mythread my = new Mythread(&quot;wei7&quot;, &quot;github.io&quot;);
        Thread t = new Thread(my.DownloadFile);//以类里的普通方法作为线程方法
        t.Start();//开启线程
        Console.ReadKey();
    }
}
</code></pre>
<p>}</p>
<p>//用来传递参数的类<br>
using System;<br>
using System.Collections.Generic;<br>
using System.Text;<br>
using System.Threading;</p>
<p>namespace 线程_通过Thread类开启<br>
{<br>
class Mythread<br>
{<br>
private string filename;<br>
private string filepath;</p>
<pre><code>    public Mythread(string name,string path)
    {
        this.filename = name;
        this.filepath = path;
    }
    public void DownloadFile()
    {
        Console.WriteLine(&quot;开始下载&quot;+filepath+filename);
        Thread.Sleep(2000);
        Console.WriteLine(&quot;下载完成&quot;);
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
</feed>