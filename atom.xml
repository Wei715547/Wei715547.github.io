<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Wei715547.github.io</id>
    <title>Wei: Development technology accumulation</title>
    <updated>2020-06-15T10:15:10.146Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Wei715547.github.io"/>
    <link rel="self" href="https://Wei715547.github.io/atom.xml"/>
    <subtitle>年月增长，我宜强盛。
用于Unity+开发的技术积累</subtitle>
    <logo>https://Wei715547.github.io/images/avatar.png</logo>
    <icon>https://Wei715547.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Wei: Development technology accumulation</rights>
    <entry>
        <title type="html"><![CDATA[创建AssetBundles/从AssetBundles中加载文件到场景]]></title>
        <id>https://Wei715547.github.io/post/chuang-jian-assetbundles/</id>
        <link href="https://Wei715547.github.io/post/chuang-jian-assetbundles/">
        </link>
        <updated>2020-06-15T09:21:12.000Z</updated>
        <content type="html"><![CDATA[<p>//此脚本放在“Asset/Editor”<br>
using System.IO;<br>
using UnityEditor;</p>
<p>public class CreateAB<br>
{<br>
[MenuItem(&quot;Assets/Build AssetBundles&quot;)]<br>
static void BuildAllAssetBuundles()<br>
{<br>
string dir = &quot;AssetBundles&quot;;<br>
if (Directory.Exists (dir)==false)<br>
{<br>
Directory.CreateDirectory(dir);<br>
}<br>
BuildPipeline.BuildAssetBundles(dir, BuildAssetBundleOptions.None, BuildTarget.StandaloneWindows64);<br>
}<br>
}</p>
<p>////////////////////////////////////////////////////////<br>
//加载<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class LoadFormFile : MonoBehaviour<br>
{<br>
private void Start()<br>
{<br>
AssetBundle ab = AssetBundle.LoadFromFile(&quot;AssetBundles/tree&quot;);//文件路径<br>
GameObject tree = ab.LoadAsset<GameObject>(&quot;Tree 02&quot;);//预制件名称<br>
GameObject go = Instantiate(tree);<br>
go.transform.SetParent(this.transform );</p>
<pre><code>    //遍历生成AB报中所有物体并生成
    /*Object[] obj = ab.LoadAllAssets();
    foreach (Object item in obj)
    {
        Instantiate(item);
    }*/
}  
</code></pre>
<p>}<br>
<img src="https://Wei715547.github.io/post-images/1592216098868.jpg" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1592216105421.jpg" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Save Point]]></title>
        <id>https://Wei715547.github.io/post/save-point/</id>
        <link href="https://Wei715547.github.io/post/save-point/">
        </link>
        <updated>2020-06-13T08:06:34.000Z</updated>
        <content type="html"><![CDATA[<p>//Prefab脚本<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class SavePoint : MonoBehaviour<br>
{<br>
private LayerMask player;<br>
private Light signlLight;<br>
// Start is called before the first frame update<br>
void Start()<br>
{<br>
player = LayerMask.NameToLayer(&quot;Player&quot;);<br>
signlLight = GetComponentInChildren<Light>();<br>
}</p>
<pre><code>//玩家触碰到Point时调用GM中的方法
private void OnTriggerEnter2D(Collider2D collision)
{
    if (collision.gameObject .layer ==player )
    {
        signlLight.color = Color.green;
        this.gameObject.GetComponent&lt;SpriteRenderer&gt;().material.color = Color.green;
        Debug.Log(&quot;Save&quot;);
        
        GameManager.instance.SavePoint();
    }
}
</code></pre>
<p>}</p>
<p>//GameManager<br>
public Vector2 playerPos ;//存储玩家位置，(通关/返回主界面时职位Vector2.zero<br>
//instance.playerPos = Vector2.zero;//通关后位置初始化)<br>
/存档点位置更新<br>
public void SavePoint()<br>
{<br>
instance.playerPos = instance.playerMove.transform.position;//玩家位置赋值给GM中的Pos<br>
}<br>
//GM中的Save/Load<br>
public GameData Save()<br>
{<br>
GameData date = new GameData();<br>
date.scence = SceneManager.GetActiveScene().buildIndex;<br>
date.deathCount = instance.deathCount;<br>
date.bgmValue = UIManager.instence.GetBGMValue();<br>
date.fxValue = UIManager.instence.GetFXValue();</p>
<pre><code>    if (instance.playerPos == Vector2.zero)
    {
        date.posx = 0;
        date.posy = 0;
    }

    else
    {
        date.posx = instance.playerPos.x;
        date.posy = instance.playerPos.y;
    }

    return date;

}

public void Load(GameData date)
{
    instance.playerPos = new Vector2(date.posx, date.posy);

    SceneManager.LoadScene(date .scence );
    //UIManager.instence.ShowLoadPanel(date.scence);
    instance.deathCount = date.deathCount;
    UIManager.UpdataDeathUI(instance.deathCount);
    GameManager.instance.time = 0;
    UIManager.instence.SetBGMValue(date.bgmValue);
    UIManager.instence.SetFXValue(date.fxValue);
}

//Player控制脚本
Start
{
//玩家未接触到存档点GM中默认Pos=0；此时将默认未值赋值给GM中的Pos。
    //（通关之后GM中的Pos会被PlayerWin()方法赋值为默认值）
    if ( GameManager.instance.playerPos==Vector2.zero)
    {
        GameManager.instance.playerPos = playerPos;
    }else//玩家触碰到存档点时，将GM中的位置赋值给玩家物体的Pos。
    {
        transform.position = GameManager.instance.playerPos;
    }
    }</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[单例]]></title>
        <id>https://Wei715547.github.io/post/dan-li/</id>
        <link href="https://Wei715547.github.io/post/dan-li/">
        </link>
        <updated>2020-06-12T08:02:53.000Z</updated>
        <content type="html"><![CDATA[<p>3.单例模式---在被调用的脚本中，公开声明一个静态的该脚本实例，在初始化时使&quot;实例=this&quot;<br>
便于在其他脚本中直接调用该脚本与其中的方法。<br>
<img src="https://Wei715547.github.io/post-images/1589271341241.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1589271396945.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1589963622098.PNG" alt="" loading="lazy"></p>
<p>两脚本有碰撞，触发关系时可直接利用<br>
(碰撞)collsion.gameObject.GetComponent&lt;被调用脚本名&gt;().方法名();<br>
(触发)collsion.GetComponent&lt;被调用脚本名&gt;().方法名();<br>
或SendMessage（以”方法名“调用物体中继承 MonoBehaviour 脚本的方法.）<br>
(碰撞)collision.gameObject.SendMessage(&quot;方法名&quot;);<br>
(触发)collsion.SendMessage(&quot;方法名&quot;);<br>
调用对方脚本中的方法<br>
<img src="https://Wei715547.github.io/post-images/1589272112653.PNG" alt="" loading="lazy"></p>
<p>//4.单例模式<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.SceneManagement;<br>
public class GameManager : MonoBehaviour<br>
{<br>
public static GameManager instance;<br>
SceneFader fader;<br>
// Start is called before the first frame update<br>
void Awake()<br>
{<br>
if (instance!=null )<br>
{<br>
Destroy(gameObject);<br>
return;<br>
}<br>
instance = this;<br>
DontDestroyOnLoad(gameObject);</p>
<pre><code>}

//在外部将其他脚本通过此静态方法注册到GameManager中的变量（引用），（可在GameManager中调用其他脚本中的方法）
 /*   void Awake()//被调用的脚本
{
    ani = GetComponent&lt;Animator&gt;();
    FaderID = Animator.StringToHash(&quot;Fade&quot;);
    ////将脚本指定为GameManager的变量，使其中的方法可以在gamemanager中调用
    GameManager.RegisterCceneFader(this);
}*/
public static void RegisterCceneFader(SceneFader obj)
{
    instance.fader = obj;
}

public static void PlayerDied()
{
    instance.fader.FadeOut();//调用其他脚本中的方法
    instance.Invoke(&quot;RestartScence&quot;, 1.5f);
}

public void RestartScence()
{
    SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);
    
}
</code></pre>
<p>}</p>
<p>复杂时可使用事件的广播，监听</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next Scence Don't Destroy]]></title>
        <id>https://Wei715547.github.io/post/next-scence-dont-destroy/</id>
        <link href="https://Wei715547.github.io/post/next-scence-dont-destroy/">
        </link>
        <updated>2020-06-11T08:38:18.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class CanvasDS : MonoBehaviour<br>
{<br>
//声明单例，判断其在场景中是否已存在（被赋值）<br>
public static CanvasDS instance;</p>
<pre><code>void Awake()
{
    if (instance != null)
    {
        Destroy(gameObject);//已存在与场景中时销毁此对象，保证场景中只有一个此类对象
        return;
    }
    instance = this;
    DontDestroyOnLoad(this);
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Audio Mixer]]></title>
        <id>https://Wei715547.github.io/post/audio-mixer/</id>
        <link href="https://Wei715547.github.io/post/audio-mixer/">
        </link>
        <updated>2020-06-11T02:36:35.000Z</updated>
        <content type="html"><![CDATA[<p>void Awake()<br>
{<br>
//Nomal Slider Ct<br>
Vo.value = FindObjectOfType<AudioSource>().volume;</p>
<pre><code>    //Pvo = transform.Find(&quot;Player_Slider&quot;).GetComponent&lt;Slider&gt;();

    auM.GetFloat(&quot;MainVolume&quot;,out float v);
    Pvo.value = v;//Audio Mixer output value  to Slider
}

private void Update()
{
    //Panel enable update the value
    FindObjectOfType&lt;AudioSource&gt;().volume = Vo.value;
    auM .SetFloat(&quot;MainVolume&quot;, Pvo.value);
}
</code></pre>
<p><img src="https://Wei715547.github.io/post-images/1591860911716.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1591860919096.PNG" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UI图标冷却]]></title>
        <id>https://Wei715547.github.io/post/ui-tu-biao-leng-que/</id>
        <link href="https://Wei715547.github.io/post/ui-tu-biao-leng-que/">
        </link>
        <updated>2020-06-11T02:23:02.000Z</updated>
        <content type="html"><![CDATA[<p>private void FixedUpdate()<br>
{<br>
coodTime += Time.deltaTime;</p>
<pre><code>    if (Input.GetKeyDown(KeyCode.Z) &amp;&amp; coodTime &gt; setcoodtime)
    {
        au.PlayOneShot(russ, 1f);
        Russing();
        coodTime = 0;
    }
}

// Update is called once per frame
void Update()
{
    //UI显示
    if (coodTime &gt; setcoodtime)
    {
        coodUI.fillAmount = 0;
    }else
    {
        coodUI.fillAmount = 1-coodTime/setcoodtime ;
    }
}
![](https://Wei715547.github.io/post-images/1591842421156.PNG)</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Post Process Effect/Camer Shake]]></title>
        <id>https://Wei715547.github.io/post/post-process-effectcamer-shake/</id>
        <link href="https://Wei715547.github.io/post/post-process-effectcamer-shake/">
        </link>
        <updated>2020-06-07T07:05:12.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://Wei715547.github.io/post-images/1591513702359.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1591513708909.PNG" alt="" loading="lazy"></p>
<p><img src="https://Wei715547.github.io/post-images/1591514562757.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1591514569006.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1591514575527.PNG" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C#中调用Lua程序]]></title>
        <id>https://Wei715547.github.io/post/czhong-diao-yong-lua-cheng-xu/</id>
        <link href="https://Wei715547.github.io/post/czhong-diao-yong-lua-cheng-xu/">
        </link>
        <updated>2020-06-07T04:56:04.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using XLua;<br>
public class HW2 : MonoBehaviour<br>
{<br>
// Start is called before the first frame update<br>
void Start()<br>
{<br>
//1.通过资源加载执行Lua程序<br>
/<em>TextAsset ta = Resources.Load<TextAsset>(&quot;面向对象实现.lua&quot;);<br>
//print(ta);<br>
LuaEnv env = new LuaEnv();<br>
env.DoString(ta.text);<br>
env.Dispose();</em>/</p>
<pre><code>    //2.通过require 'XXX'执行Lua程序
    LuaEnv env = new LuaEnv();
    env.DoString(&quot;require '面向对象实现'&quot;);
    //访问Lua中的全局变量
    /*int num = env.Global.Get&lt;int&gt;(&quot;num1&quot;);
    print(num);
    string s = env.Global.Get&lt;string&gt;(&quot;str&quot;);
    print(s);
    bool t = env.Global.Get&lt;bool&gt;(&quot;isOn&quot;);
    print(t);*/
    //env.Dispose();

    //映射到类
    /*Person p = env.Global.Get&lt;Person&gt;(&quot;person&quot;);//值拷贝，耗费性能，
    print(p.name + &quot;-&quot; + p.age);
    p.name = &quot;ZZ&quot;;
    env.DoString(&quot;print(person.name)&quot;);//不改变Lua中的变量值*/

    //映射到接口
    IPerson p = env.Global.Get&lt;IPerson&gt;(&quot;person&quot;);//引用拷贝，可改变Lua中的值
    print(p.name + &quot;-&quot; + p.age);
    p.name = &quot;ZL&quot;;
    env.DoString(&quot;print(person.name)&quot;);

    env.Dispose();

}

//将Lua中的table映射到类（耗费性能）
class Person
{
    public string name;
    public int age;
}

//将Lua中的变量映射到接口
[CSharpCallLua]
interface IPerson
{
    string name { get; set; }
    int age { get; set; }

}
</code></pre>
<p>}</p>
<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using System.IO;<br>
using UnityEngine;<br>
using XLua;<br>
public class Loader : MonoBehaviour<br>
{<br>
// Start is called before the first frame update<br>
void Start()<br>
{<br>
LuaEnv env = new LuaEnv();</p>
<pre><code>    env.AddLoader(MyLoader);//先执行自定义的Loader，自定义Loader中有返回Lua程序时，将不再执行系统加载的Lua程序
    env.DoString(&quot;require 'text01'&quot;);//加载的文件会传递给Lodader
    env.Dispose();
}
</code></pre>
<p>//自定义Loader<br>
private byte [] MyLoader(ref string filePath)<br>
{<br>
print(filePath);</p>
<pre><code>    //通过自定义Loader返回Lua程序
    //string s = &quot;print(123)&quot;;
    //return System .Text .Encoding.UTF8 .GetBytes (s);

    print(Application.streamingAssetsPath);

    //通过路径读取返回Lua程序
    string absPath = Application.streamingAssetsPath + &quot;/&quot; + filePath + &quot;.lua.txt&quot;;
    return System.Text.Encoding.UTF8.GetBytes(File.ReadAllText( absPath));
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[生命周期]]></title>
        <id>https://Wei715547.github.io/post/sheng-ming-zhou-qi/</id>
        <link href="https://Wei715547.github.io/post/sheng-ming-zhou-qi/">
        </link>
        <updated>2020-06-06T08:23:03.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://Wei715547.github.io/post-images/1591431791506.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[视角缩放/跟随]]></title>
        <id>https://Wei715547.github.io/post/shi-jiao-suo-fang-gen-sui/</id>
        <link href="https://Wei715547.github.io/post/shi-jiao-suo-fang-gen-sui/">
        </link>
        <updated>2020-06-06T05:34:56.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class CamerCT : MonoBehaviour<br>
{<br>
public Transform target;<br>
public Vector3 offset;</p>
<pre><code>//视角范围，缩放速度
public float zoomSpeed = 4f;
public float minZoom = 5f;
public float maxZoom = 10f;

public float pitch=2f;//视角高度值

private float currentZoom = 10f;//焦距

public float YawSpeed = 100f;//旋转速度
private float currentYaw = 0f;//旋转角度

// Update is called once per frame
void Update()
{
    currentZoom -= Input.GetAxis(&quot;Mouse ScrollWheel&quot;)*zoomSpeed *Time .deltaTime;
    currentZoom = Mathf.Clamp(currentZoom, minZoom, maxZoom);//限定缩放范围

    currentYaw += Input.GetAxis(&quot;Horizontal&quot;) * YawSpeed * Time.deltaTime;

}

private void LateUpdate()
{
    transform.position = target.position - offset * currentZoom;
    transform.LookAt(target.position + Vector3.up*pitch);

    transform.RotateAround(target.position, Vector3.up, currentYaw);
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
</feed>