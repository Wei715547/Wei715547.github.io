<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Wei715547.github.io</id>
    <title>Weiwei的个人网站</title>
    <updated>2020-05-06T12:02:52.512Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Wei715547.github.io"/>
    <link rel="self" href="https://Wei715547.github.io/atom.xml"/>
    <subtitle>7</subtitle>
    <logo>https://Wei715547.github.io/images/avatar.png</logo>
    <icon>https://Wei715547.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Weiwei的个人网站</rights>
    <entry>
        <title type="html"><![CDATA[接口-简单案例]]></title>
        <id>https://Wei715547.github.io/post/jie-kou-jian-dan-an-li/</id>
        <link href="https://Wei715547.github.io/post/jie-kou-jian-dan-an-li/">
        </link>
        <updated>2020-05-06T12:01:05.000Z</updated>
        <content type="html"><![CDATA[<p>using System;<br>
using System.Collections.Generic;<br>
using System.Text;</p>
<p>namespace 接口<br>
{<br>
class UDisk : IUSB<br>
{<br>
/// <summary><br>
/// 存储内容<br>
/// </summary><br>
private string content;</p>
<pre><code>    public void Read()
    {
        Console.WriteLine(content);
    }

    public void Write(string s)
    {
        content = s;
    }
}
</code></pre>
<p>}</p>
<p>using System;<br>
using System.Collections.Generic;<br>
using System.Text;</p>
<p>namespace 接口<br>
{<br>
class UDisk : IUSB<br>
{<br>
/// <summary><br>
/// 存储内容<br>
/// </summary><br>
private string content;</p>
<pre><code>    public void Read()
    {
        Console.WriteLine(content);
    }

    public void Write(string s)
    {
        content = s;
    }
}
</code></pre>
<p>}</p>
<p>using System;<br>
using System.Collections.Generic;<br>
using System.Text;</p>
<p>namespace 接口<br>
{<br>
class HardDisk:IUSB<br>
{<br>
private string content;</p>
<pre><code>    public void Read()
    {
        Console.WriteLine(content);
    }

    public void Write(string s)
    {
        content = s;
    }
}
</code></pre>
<p>}</p>
<p>//程序<br>
using System;</p>
<p>namespace 接口<br>
{</p>
<pre><code>class Program
{
    static void Main(string[] args)
    {
        UDisk u1 = new UDisk();
        u1.Write(&quot;Wei的U盘&quot;);
        u1.Read();

        HardDisk h = new HardDisk();
        h.Write(&quot;Wei的硬盘&quot;);
        h.Read();
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多态（3）接口（多继承接口，提供“大量”特殊功能）]]></title>
        <id>https://Wei715547.github.io/post/duo-tai-3jie-kou-duo-ji-cheng-jie-kou-ti-gong-te-shu-gong-neng/</id>
        <link href="https://Wei715547.github.io/post/duo-tai-3jie-kou-duo-ji-cheng-jie-kou-ti-gong-te-shu-gong-neng/">
        </link>
        <updated>2020-05-06T11:54:33.000Z</updated>
        <content type="html"><![CDATA[<p>using System;<br>
using System.Collections.Generic;<br>
using System.Text;</p>
<p>namespace 接口<br>
{<br>
//Interface 没有class关键字 一般使用&quot;IXxxx&quot;命名书写</p>
<pre><code>/// &lt;summary&gt;
/// 注意事项
/// 1.接口中所有方法都是抽象方法，所有接口不能被实例化
/// 2.一个类可以实现多个接口，被实现的接口之间用”逗号，“隔开
/// 3.一个接口可以继承多个接口（类只能单继承），接口之间也用逗号分隔
/// &lt;/summary&gt;

interface IFly
{
    //接口中不能包含“字段”
    //private string s;

    //但可以包含属性--(自动属性）
    //public string Id { get; set; }
    //string Id { get; set; }

    //接口中的方法不能有“方法体”，全部都是抽象方法，但不需要abstract修饰。
    void Fly();

    //public void Hello();
    //接口中的成员不允许添加访问修饰符，默认全是public。



}
</code></pre>
<p>}</p>
<p>using System;<br>
using System.Collections.Generic;<br>
using System.Text;</p>
<p>namespace 接口<br>
{<br>
class Car<br>
{<br>
private string brand;</p>
<pre><code>    public string Brand
    {
        get { return brand; }
        set { brand = value; }
    }

    /*public Car()
    {

    }*/

    public Car (string brand)
    {
        this.brand = brand;
    }

    public void Run()
    {
        Console.WriteLine(&quot;{0}品牌的汽车在奔跑&quot;, brand );
    }
}
</code></pre>
<p>}</p>
<p>using System;<br>
using System.Collections.Generic;<br>
using System.Text;</p>
<p>namespace 接口<br>
{</p>
<pre><code>class Batmobile:Car ,IFly   //接口（为子类提供父类没有的“附加功能”。
{
    public Batmobile(string brand) : base(brand)
    {

    }

    public void Fly()
    {
        Console.WriteLine(&quot;{0}正在飞行&quot;, base.Brand);
    }
}
</code></pre>
<p>}</p>
<p>//程序<br>
using System;</p>
<p>namespace 接口<br>
{</p>
<pre><code>class Program
{
    static void Main(string[] args)
    {
        BMWCar c1 = new BMWCar(&quot;750&quot;);
        c1.Run();

        Batmobile bat = new Batmobile(&quot;BatMan&quot;);
        bat.Run();
        bat.Fly();
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多态（2）抽象类（在子类中复写所继承的抽象类中的抽象方法）]]></title>
        <id>https://Wei715547.github.io/post/duo-tai-2chou-xiang-lei-zai-zi-lei-zhong-fu-xie-suo-ji-cheng-de-chou-xiang-lei-zhong-de-chou-xiang-fang-fa/</id>
        <link href="https://Wei715547.github.io/post/duo-tai-2chou-xiang-lei-zai-zi-lei-zhong-fu-xie-suo-ji-cheng-de-chou-xiang-lei-zhong-de-chou-xiang-fang-fa/">
        </link>
        <updated>2020-05-06T11:44:13.000Z</updated>
        <content type="html"><![CDATA[<p>using System;<br>
using System.Collections.Generic;<br>
using System.Text;</p>
<p>namespace 抽象类应用<br>
{<br>
/// <summary><br>
/// NPC类型枚举<br>
/// </summary><br>
public enum NPCType<br>
{<br>
Task,<br>
Shop,<br>
Fod<br>
}<br>
/// <summary><br>
/// 定义一个抽象类<br>
/// </summary><br>
/// 抽象类不能被实例化，因为抽象类中有抽象方法（无方法体），<br>
/// 如果真能实例化抽象对象，调用这些方法体的方法无任何意义。<br>
abstract class NPCs<br>
{<br>
private string name;<br>
private NPCType type;</p>
<pre><code>    public string Name { get { return name; } set { name = value; } }
    public NPCType  Type { get { return type ; } set { type  = value; } }

    public NPCs (string name ,NPCType type)
    {
        Name = name;
        Type = type;
    }

    /// 抽象类中不一定要有抽象方法，但抽象方法必须要定义在抽象类中
    /// 抽象方法的方法体为空
    public abstract void Speek();
    
}
</code></pre>
<p>}</p>
<p>using System;<br>
using System.Collections.Generic;<br>
using System.Text;</p>
<p>namespace 抽象类应用<br>
{<br>
class TaskNPC : NPCs<br>
{<br>
private string taskInfo;</p>
<pre><code>    public TaskNPC (string taskInfo,string name,NPCType type)
        :base (name ,type )
    {
        this.taskInfo = taskInfo;
    }

    //继承抽象类，“必须”实现抽象类中的抽象方法。否则程序无法运行。
    public override void Speek()
    {
        Console .WriteLine (&quot;NPC:{0},任务：{1}&quot; ,Name,taskInfo );
    }
}
</code></pre>
<p>}</p>
<p>using System;<br>
using System.Collections.Generic;<br>
using System.Text;</p>
<p>namespace 抽象类应用<br>
{<br>
class ShopNPC : NPCs<br>
{<br>
private string item;</p>
<pre><code>    public ShopNPC (string item, string name, NPCType type)
       : base(name, type)
    {
        this.item  = item ;
    }

    public override void Speek()
    {
        Console.WriteLine(&quot;NPC:{0},贩卖{1}产品&quot;, base.Name, item);
    }
}
</code></pre>
<p>}</p>
<p>//程序实现<br>
using System;</p>
<p>namespace 抽象类应用<br>
{<br>
class Program<br>
{<br>
static void Main(string[] args)<br>
{<br>
//NPCs n = new NPCs(&quot;灰太狼&quot;, NPCType.Shop);//抽象类不能被实例化，</p>
<pre><code>        TaskNPC t1 = new TaskNPC(&quot;让你去挖大头菜&quot;,&quot;老八&quot;, NPCType.Task);
        t1.Speek();

        ShopNPC s1 = new ShopNPC(&quot;喜洋洋&quot;, &quot;灰太狼&quot;, NPCType.Shop);
        s1.Speek();   
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多态（1）虚函数(复写所继承类中的虚方法）]]></title>
        <id>https://Wei715547.github.io/post/duo-tai-1xu-han-shu/</id>
        <link href="https://Wei715547.github.io/post/duo-tai-1xu-han-shu/">
        </link>
        <updated>2020-05-06T11:28:12.000Z</updated>
        <content type="html"><![CDATA[<p>using System;<br>
using System.Collections.Generic;<br>
using System.Text;</p>
<p>namespace 多态<br>
{<br>
class TrafficTool<br>
{<br>
public virtual void Run()<br>
{<br>
Console.WriteLine(&quot;启动&quot;);<br>
}<br>
public virtual void Stop()<br>
{<br>
Console.WriteLine(&quot;停止&quot;);<br>
}</p>
<pre><code>    public void Break()
    {
        Console.WriteLine(&quot;抛锚&quot;);
    }
}
</code></pre>
<p>}</p>
<p>using System;<br>
using System.Collections.Generic;<br>
using System.Text;</p>
<p>namespace 多态<br>
{<br>
class Car:TrafficTool<br>
{<br>
public override void Run()<br>
{<br>
base.Run();<br>
Console.WriteLine(&quot;汽车启动&quot;);</p>
<pre><code>    }

    public override void Stop()
    {
        base.Stop();
        Console.WriteLine(&quot;汽车停下&quot;);
    }
    public void Break()
    {
        Console.WriteLine(&quot;刹车&quot;);
    }
}
</code></pre>
<p>}</p>
<p>using System;<br>
using System.Collections.Generic;<br>
using System.Text;</p>
<p>namespace 多态<br>
{<br>
class AipPlan:TrafficTool<br>
{<br>
public override void Run()<br>
{<br>
base.Run();<br>
Console.WriteLine(&quot;飞机启动&quot;);</p>
<pre><code>    }

    public override void Stop()
    {
        base.Stop();
        Console.WriteLine(&quot;飞机停下&quot;);
    }
}
</code></pre>
<p>}</p>
<p>//程序实现<br>
using System;</p>
<p>namespace 多态<br>
{<br>
class Program<br>
{<br>
static void Main(string[] args)<br>
{<br>
/*Car s = new Car();<br>
AipPlan a = new AipPlan();<br>
Driver d1 = new Driver();<br>
d1.Drive(s);</p>
<pre><code>        d1.Drive(a);*/

        TrafficTool t3 = new Car();
        TrafficTool t4 = new AipPlan();
        //基于“虚方法”的多态
        t3.Run();//启动汽车启动
        t4.Run();//启动飞机启动

        //里式转换
        TrafficTool t1 = new TrafficTool();
        TrafficTool t2 = new Car();//父类引用指向子类对象，
        t1.Break();//父类方法
        t2.Break();//父类方法

        //父类需要调用子类方法时，将父类转为子类（
        //父类引用指向子类对象时才能够转换）
        //ar c1 = (Car )t2;//强转
        bool r = t2 is Car;//可以转换返回真/不能转返回假
        Car c1 = t2 as Car;//可以转返回子类对象/不能转返回Null

        t1.Break();//父类方法
        c1.Break();//子类方法
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C#基础-类/结构]]></title>
        <id>https://Wei715547.github.io/post/cji-chu-lei-jie-gou/</id>
        <link href="https://Wei715547.github.io/post/cji-chu-lei-jie-gou/">
        </link>
        <updated>2020-05-06T11:20:46.000Z</updated>
        <content type="html"><![CDATA[<p>using System;<br>
using System.Collections.Generic;<br>
using System.Text;</p>
<p>namespace 类_对象<br>
{<br>
class Person<br>
{<br>
//字段<br>
private  string   name;//外部都可访问</p>
<pre><code>    /*private int age;//本身内可以访问
    protected bool sx;//本身/子类可以访问*/
    
    //手写属性------保护字段
    public string Name
    {               //属性实质---两个方法-对字段进行读取写入
        get
        { return name; }
        set
        { this.name = value ; }
    }
    //手写属性-两个“方法”的特殊封装


    //自动属性------同时创建字段与属性（C#编译器字段提供一个对应的字段）
    public int Ft { get; set; }
    private int Age { get; set; }
    protected bool Sx{get ;set;}


    //构建函数 创建类的方法（类被加载时调用）  可重载        
    public Person () //public确保类在外部可被创建
    {
        Name = &quot;人&quot;;
        Ft = 2333;
        Age = 18;
        Sx = true;
    }


    //方法
    public virtual void Say()
    {
        Console.WriteLine(&quot;A person&quot; );
    }

    protected  void Ag()
    {
        Console.WriteLine(&quot;Ag&quot;+Age  );
    }
    public void Solid()
    {
        Console.WriteLine(&quot;Im&quot; + Ft + name);
    }

    private int  Core()
    {
        return 1;

    }

    //析构方法--对应构建方法（创建类），用于GC回收类。
    /*~Person ()
    {

    }*/

}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据存储-序列化/反序列化]]></title>
        <id>https://Wei715547.github.io/post/shu-ju-cun-chu-xu-lie-hua-fan-xu-lie-hua/</id>
        <link href="https://Wei715547.github.io/post/shu-ju-cun-chu-xu-lie-hua-fan-xu-lie-hua/">
        </link>
        <updated>2020-05-05T10:16:03.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Runtime.Serialization.Formatters.Binary;<br>
using System.IO;<br>
//二进制<br>
private void SaveByBin()<br>
{<br>
//要储存的类<br>
Save save = SaveDate();<br>
//创建二进制序列化程序<br>
BinaryFormatter bf = new BinaryFormatter();<br>
//创建文件流<br>
FileStream filestream = File.Create(Application.dataPath + &quot;/Savemaster&quot; + &quot;/Bin.txt&quot;);<br>
//用二进制序列化程序的序列化方法来序列化Save类对象，参数（文件流，需要序列化的类对象）<br>
bf.Serialize(filestream, save);<br>
//关闭流<br>
filestream.Close();<br>
if (File .Exists (Application.dataPath + &quot;/Savemaster&quot; + &quot;/Bin.txt&quot;))<br>
{<br>
UIManage.Instance . ShowMessage(&quot;保存成功&quot;);<br>
}</p>
<pre><code>}

private void  LoadByBin()
{
    if (File.Exists(Application.dataPath + &quot;/Savemaster&quot; + &quot;/Bin.txt&quot;))
    {
        Save save = new Save();
        BinaryFormatter bf = new BinaryFormatter();
        FileStream fs = File.Open(Application.dataPath + &quot;/Savemaster&quot; + &quot;/Bin.txt&quot;, FileMode.Open);
        save = (Save)bf.Deserialize(fs);
        fs.Close();
        LoadDate(save);
        //UIManage.Instance.ShowMessage(&quot;加载成功&quot;);
        UIPanle.Instance.OnStartButtonDown();
    }
    else
        UIManage.Instance.ShowMessage(&quot;无存档记录&quot;);
}
</code></pre>
<p>using LitJson;<br>
//Json<br>
private void SaveByJson()<br>
{<br>
Save save = SaveDate();<br>
//路径<br>
string filePath = Application.dataPath + &quot;/Savemaster&quot; + &quot;/ByJson.json&quot;;<br>
//利用JsonMapper将save对象转换为Json字符串<br>
string saveJsonMapper = JsonMapper.ToJson(save);<br>
//创建StreamWriter,并将字符串写入文件<br>
StreamWriter sw = new StreamWriter(filePath);<br>
sw.Write(saveJsonMapper);<br>
//关闭StreamWriter<br>
sw.Close();</p>
<pre><code>    UIManage.Instance.ShowMessage(&quot;保存成功&quot;);
}

private void LoadByJson()
{
    string filePath = Application.dataPath + &quot;/Savemaster&quot; + &quot;/ByJson.json&quot;;
    if(File .Exists (filePath ))
    {
        //创建StreamReader，读取流
        StreamReader sr = new StreamReader(filePath);
        //读取流赋值给jsonStr，并关闭流
        string jsonStr = sr.ReadToEnd();
        sr.Close();
        //将jsonStr转换为对象
        Save save = JsonMapper.ToObject&lt;Save&gt;(jsonStr);
        LoadDate(save);
        UIPanle.Instance.OnStartButtonDown();
    }
    else
    {
        UIManage.Instance.ShowMessage(&quot;无存档记录&quot;);
    }
}</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[静态]]></title>
        <id>https://Wei715547.github.io/post/jing-tai/</id>
        <link href="https://Wei715547.github.io/post/jing-tai/">
        </link>
        <updated>2020-05-01T09:34:55.000Z</updated>
        <content type="html"><![CDATA[<p>using System;<br>
using System.Collections.Generic;<br>
using System.Text;</p>
<p>namespace 继承_static_结构体_2048核心类<br>
{<br>
class Student : Person<br>
{<br>
//prop +tab +tab 自动属性快捷生成<br>
/// <summary><br>
/// 成绩<br>
/// </summary></p>
<pre><code>    // 实例成员属于   对象    静态成员属于   类

    public int Score { get; set; }

    //每个对象都存储一份
    public int InstanceCount;

    

    //静态字段 仅仅存储一份 所有对象共享 常驻内存中
    public static int StaticCount;

    private Random random;
    private int[] arr;

    //实例构造函数：提供创建对象的方式，初始化类的实例数据成员
    //
    public Student()
    {
        random = new Random();
        arr = new int[5];
        InstanceCount++;
        StaticCount++;
    }

    //静态构造函数 不需要访问修饰符 都可以访问
    //作用：初始化类的静态数据成员
    //执行时机：类加载时调用一次
    static Student()
    {
        //InstanceCount++;//”非静态字段 要求 对象引用 ”  静态代码块只能访问静态成员
        StaticCount++;
    }

    //静态方法 
    public static void Fun1()
    {
        //Console.WriteLine(InstanceCount);//静态方法只能访问静态成员
    }

    public  void Fun2()
    {
        Console.WriteLine(InstanceCount);// 通过引用(对象 / 实例)调用实例方法，都会自动传递(对象 / 实例的)引用   
        //Console.WriteLine(this.InstanceCount);//所以可以访问 InstanceCount 实例成员
        Console.WriteLine(StaticCount );//但实例（对象）方法可以访问静态成员（类）
    }

    //静态类
    /*不能实例化，只能包含静态成员
     * 静态类不能被继承，但非静态类的方法，属性都可以被继承
     */


    /* 静态适用
    * 利：单独空间存储，所有对象共享，可直接被类名调用
    * 弊：静态方法中只能访问静态成员，共享数据被多个对象访问时会出现并发。
    * 适用场合：
    * 1.所有对象需要共享的数据。
    * 2.在没有对象是就要访问成员。
    * 3.工具类适合做静态类（常用，不需要过多数据）。
    * 如类 Math.方法
    *      unuty中有静态类Random
    *      Random.randuoRange(1,101); （randomRange()静态类Random的静态方法。
    *      简易与.Net中
    *      Random r = new Random();
    *      random.Next(1,101);（Next()实例（对象）方法。
    *      
    */
    //



}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DoTweening完成后执行]]></title>
        <id>https://Wei715547.github.io/post/dotweening-wan-cheng-hou-zhi-xing/</id>
        <link href="https://Wei715547.github.io/post/dotweening-wan-cheng-hou-zhi-xing/">
        </link>
        <updated>2020-05-01T03:46:49.000Z</updated>
        <content type="html"><![CDATA[<p>private void Close()<br>
{<br>
EventCenter.Broadcast(EventDefine.PlayBuyyonSound);<br>
bg.GetComponent<Image>().DOColor(new Color(bg.GetComponent<Image>().color.r, bg.GetComponent<Image>().color.g, bg.GetComponent<Image>().color.b, 0), 0.3f);<br>
rankt.transform.DOScale(Vector3.zero, 0.3f).OnComplete(() =&gt;<br>
{<br>
gameObject.SetActive(false);<br>
});<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[EventSystems，屏幕拖拽]]></title>
        <id>https://Wei715547.github.io/post/eventsystemsping-mu-tuo-zhuai/</id>
        <link href="https://Wei715547.github.io/post/eventsystemsping-mu-tuo-zhuai/">
        </link>
        <updated>2020-05-01T03:22:17.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.EventSystems;<br>
public class DIalogDrag : MonoBehaviour, IPointerDownHandler,IDragHandler,IPointerClickHandler<br>
{<br>
private RectTransform parentRTF;<br>
private void Start()<br>
{<br>
//设置UI长宽<br>
RectTransform rtf = GetComponent<RectTransform>();<br>
rtf.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, 700);<br>
rtf.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, 400);</p>
<pre><code>    parentRTF = this.transform.parent as RectTransform;
}
private Vector3 siftVector;
//按下时执行
public void OnPointerDown(PointerEventData eventData)
{
    //记录按下点到中心点偏移量

    Vector3 wordPoint;
    //屏幕坐标--&gt;世界坐标
    //(父物体的变换组件，屏幕坐标，摄像机，out 世界坐标)
    RectTransformUtility.ScreenPointToWorldPointInRectangle(parentRTF, eventData.position, eventData.pressEventCamera, out wordPoint);
    siftVector = this.transform.position - wordPoint;
}
//拖拽时执行
public void OnDrag(PointerEventData eventData)
{
    Vector3 wordPoint;
    //屏幕坐标--&gt;世界坐标
    //(父物体的变换组件，屏幕坐标，摄像机，out 世界坐标)
    RectTransformUtility.ScreenPointToWorldPointInRectangle(parentRTF, eventData.position, eventData.pressEventCamera, out wordPoint);
    this.transform.position = wordPoint + siftVector ;
    
}

public void OnPointerClick(PointerEventData eventData)
{
    if (eventData.clickCount == 2)
        Destroy (this .gameObject );
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[游戏数据类创建，储存、读取]]></title>
        <id>https://Wei715547.github.io/post/you-xi-shu-ju-lei-chuang-jian-chu-cun-du-qu/</id>
        <link href="https://Wei715547.github.io/post/you-xi-shu-ju-lei-chuang-jian-chu-cun-du-qu/">
        </link>
        <updated>2020-04-24T03:45:01.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>[System .Serializable]<br>
public class GameDate<br>
{<br>
public  static bool IsAgainGame =false ;</p>
<pre><code>private bool isFirstGame;
private bool isMusicOn;

private int[] bestScoreArr;

private int selectSkin;
private bool[] skinUnlocked;
private int diamondCount;


public void SetIsFirstGame(bool isFirstGame)
{
    this.isFirstGame = isFirstGame;
}

public void SetMusicOn(bool isMusicOn)
{
    this.isMusicOn = isMusicOn;
}

public void SetBestScoreArr(int[] bestScoreArr)
{
    this.bestScoreArr = bestScoreArr;
}

public void SetSelectSkin(int  selectSkin)
{
    this.selectSkin = selectSkin;
}

public void SetSkinUnlocked(bool [] skinUnlocked)
{
    this.skinUnlocked = skinUnlocked;
}

public void SetDiamondCount (int diamondCount)
{
    this.diamondCount = diamondCount;
}



public bool  GetIsFirstGame()
{
    return isFirstGame;
}

public bool GetMusicOn()
{
    return isMusicOn ;
}

public int [] GetBestScoreArr()
{
    return bestScoreArr;
}

public int GetSelectSkin()
{
    return selectSkin;
}

public bool [] GetUnlockedSkin()
{
    return skinUnlocked;
}

public int GetDiamongCount()
{
    return diamondCount;
}
</code></pre>
<p>}</p>
<pre><code>/// &lt;summary&gt;
/// 储存数据
/// &lt;/summary&gt;
private void Save()
{
    try
    {
        BinaryFormatter bf = new BinaryFormatter();
        using (FileStream fs = File.Create(Application.persistentDataPath + &quot;/DameData.data&quot;))

        {
            data.SetBestScoreArr(bestScoreArr);
            data.SetDiamondCount(diamondCount);
            data.SetIsFirstGame(isFirstGame);
            data.SetMusicOn(isMusicOn);
            data.SetSelectSkin(selectSkin);
            data.SetSkinUnlocked(skinUnlocked);
            bf.Serialize(fs, data);

        }
    }
    catch (System.Exception e)
    {
        Debug.Log(e.Message);

    }
}
/// &lt;summary&gt;
/// 读取数据
/// &lt;/summary&gt;
private void Read()
{
    try
    {
        BinaryFormatter bf = new BinaryFormatter();
        using (FileStream fs = File .Open (Application.persistentDataPath + &quot;/DameData.data&quot;,FileMode.Open ))
        {
            data = (GameDate )bf.Deserialize(fs);
        }
    }
    catch (System.Exception e)
    {
        Debug.Log(e.Message);
    }
}
</code></pre>
<p>//初始化<br>
public void ResetData()<br>
{<br>
isFirstGame = false;<br>
isMusicOn = true;<br>
bestScoreArr = new int[3];<br>
selectSkin = 0;<br>
skinUnlocked = new bool[vars.skinSpriteList.Count];<br>
skinUnlocked[0] = true;<br>
diamondCount = 10;</p>
<pre><code>    data = new GameDate();//初始化时读取

    Save();
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
</feed>