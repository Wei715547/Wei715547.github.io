<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Wei715547.github.io</id>
    <title>WeiBlog</title>
    <updated>2021-04-29T16:19:41.654Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Wei715547.github.io"/>
    <link rel="self" href="https://Wei715547.github.io/atom.xml"/>
    <subtitle>年月增长，我宜强盛。
用于Unity+开发的技术积累</subtitle>
    <logo>https://Wei715547.github.io/images/avatar.png</logo>
    <icon>https://Wei715547.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, WeiBlog</rights>
    <entry>
        <title type="html"><![CDATA[水面Shader]]></title>
        <id>https://Wei715547.github.io/post/shui-mian-shader/</id>
        <link href="https://Wei715547.github.io/post/shui-mian-shader/">
        </link>
        <updated>2021-04-26T09:57:03.000Z</updated>
        <content type="html"><![CDATA[<p>#2D<br>
<img src="https://Wei715547.github.io/post-images/1619694485822.PNG" alt="" loading="lazy"><br>
Shader &quot;Unlit/Water&quot;<br>
{<br>
Properties<br>
{<br>
_ColorOpacity(&quot;Water Tint (RGB) &amp; Opacity (A)&quot;, 2D) = &quot;white&quot; {}<br>
_DistortionNormalMap(&quot;Normal Map&quot;, 2D) = &quot;bump&quot; {}<br>
_DistortionStrength(&quot;Distortion strength&quot;, Float) = 1.0<br>
}<br>
SubShader<br>
{<br>
Tags { &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Transparent&quot; }<br>
LOD 100</p>
<pre><code>	// Grab the screen behind the object into _BackgroundTexture
	GrabPass
	{
		&quot;_BackgroundTexture&quot;
	}

	Pass
	{
		CGPROGRAM
		#pragma vertex vert
		#pragma fragment frag


		#include &quot;UnityCG.cginc&quot;

		struct appdata
		{
			float4 vertex : POSITION;
			float2 uv : TEXCOORD0;
			float2 uv2 : TEXCOORD1;
		};

		struct v2f
		{
			float2 uv : TEXCOORD0;
			float2 uv2 : TEXCOORD1;
			float4 grabPos : TEXCOORD2;
			float4 vertex : SV_POSITION;
		};

		sampler2D _BackgroundTexture;
		sampler2D _ColorOpacity;
		sampler2D _DistortionNormalMap;

		float _DistortionStrength;
		float4 _DistortionNormalMap_ST;
		float4 _BackgroundTexture_TexelSize;

		v2f vert (appdata v)
		{
			v2f o;
			o.vertex = UnityObjectToClipPos(v.vertex);
			o.grabPos = ComputeGrabScreenPos(o.vertex);//获取截取屏幕的采样坐标
</code></pre>
<p>#if !UNITY_UV_STARTS_AT_TOP<br>
if(_BackgroundTexture_TexelSize.y &lt; 0)<br>
o.grabPos.y = 1.0 - o.grabPos.y;<br>
#endif<br>
o.uv = v.uv;<br>
o.uv2 = v.uv2;</p>
<pre><code>			return o;
		}

		fixed4 frag (v2f i) : SV_Target
		{
			float2 properuv = _DistortionNormalMap_ST.zw + (i.uv2.xy * _DistortionNormalMap_ST.xy);

			float3 normal1 = UnpackNormal(tex2D(_DistortionNormalMap, properuv + _Time.y));
			float3 normal2 = UnpackNormal(tex2D(_DistortionNormalMap, (1.0f - properuv) + _Time.y));

			float3 norm = (normal1 + normal2) * 0.5f * _DistortionStrength;

			half4 coloropa = tex2D(_ColorOpacity, i.uv + norm.xy * 0.1f);

			half4 bgcolor = tex2Dproj(_BackgroundTexture, i.grabPos + float4(norm.x*0.5f, norm.y*0.5f, 0, 0));

			//col = lerp(col, float4(1, 1, 1, 1), step(0.98f, i.uv.y));

			bgcolor.rgb = lerp(bgcolor.rgb, coloropa.rgb, coloropa.a);
			bgcolor.rgb *= coloropa.rgb;

			return bgcolor;
			//return float4(i.uv2.x, i.uv2.y, 0, 1);
		}
		ENDCG
	}
}
</code></pre>
<p>}</p>
<p>#3D<br>
<img src="https://Wei715547.github.io/post-images/1619431100957.PNG" alt="" loading="lazy"><br>
Shader &quot;Unlit/Wave&quot;<br>
{<br>
Properties<br>
{<br>
_Color(&quot;MainColor&quot;, Color) = (1,1,1,1)<br>
_MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}<br>
_WaveMap(&quot;WaveMap&quot;,2D) = &quot;while&quot;{}<br>
_CubMap(&quot;CubMap&quot;,Cube) = &quot;_Skybox&quot;{}<br>
_WaveSpeedX(&quot;WaveSpeedX&quot;,Range(-0.1,0.1)) = 0.1<br>
_WaveSpeedY(&quot;WaveSpeedY&quot;,Range(-0.1,0.1)) = 0.1<br>
_Distortion(&quot;Distortion&quot;,Range(0,100)) = 10<br>
}<br>
SubShader<br>
{<br>
Tags {&quot;Queue&quot; = &quot;Transparent&quot; &quot;RenderType&quot;=&quot;Opaque&quot; }<br>
//GrabPass{&quot;_RefractionTex&quot;}<br>
Pass<br>
{<br>
CGPROGRAM</p>
<pre><code>		float4 _Color;
		sampler2D _MainTex;
        float4 _MainTex_ST;
		sampler2D _WaveMap;
		float4 _WaveMap_ST;
		samplerCUBE _CubMap;
		fixed _WaveSpeedX;
		fixed _WaveSpeedY;
		float _Distortion;
		//sampler2D _RefractionTex;
		//float4 _RefractionTex_ST;
		//float4 _RefractionTex_TexeSize;

        #pragma vertex vert
        #pragma fragment frag

        #include &quot;UnityCG.cginc&quot;
		#include &quot;AutoLight.cginc&quot;

        struct a2v
        {
            float4 vertex : POSITION;
            float2 texcoord : TEXCOORD0;
			float4 normal :NORMAL;
			float4 tangent :TANGENT;
        };

        struct v2f
        {                
            float4 pos : SV_POSITION;
			float4 scrPos : TEXCOORD0;
			float4 uv : TEXCOORD1;
			float4 TtoW0 :TEXCOORD2;
			float4 TtoW1 :TEXCOORD3;
			float4 TtoW2 : TEXCOORD4;
			SHADOW_COORDS(5)
        };
        

        v2f vert (a2v v)
        {
            v2f o;
            o.pos = UnityObjectToClipPos(v.vertex);
			o.scrPos = ComputeGrabScreenPos(o.pos);

			o.uv.xy = TRANSFORM_TEX(v.texcoord,_MainTex);
			o.uv.zw = TRANSFORM_TEX(v.texcoord,_WaveMap);

			float3 worldPos = mul(unity_ObjectToWorld,v.vertex);
			float3 worldNormal = UnityObjectToWorldNormal(v.normal);
			float3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
			float3 worldBinormal = cross(worldNormal,worldTangent)*v.tangent.w;

			o.TtoW0 = float4 (worldTangent.x,worldBinormal.x,worldNormal.x,worldPos.x);
			o.TtoW1 = float4 (worldTangent.y,worldBinormal.y,worldNormal.y,worldPos.y);
			o.TtoW2 = float4 (worldTangent.z,worldBinormal.z,worldNormal.z,worldPos.z);
			TRANSFER_SHADOW(o);
            return o;
        }

        fixed4 frag (v2f i) : SV_Target
        {
            float3 worldPos = float3(i.TtoW0.w,i.TtoW1.w,i.TtoW2.w);
			fixed3 viewDir = normalize(UnityWorldSpaceViewDir(worldPos));
			float2 speed = _Time.y*float2(_WaveSpeedX,_WaveSpeedY);

			fixed3 bump1 = UnpackNormal(tex2D(_WaveMap,i.uv.zw+speed)).rgb;
			fixed3 bump2 = UnpackNormal(tex2D(_WaveMap,i.uv.zw-speed)).rgb;
			fixed3 bump = normalize(bump1+bump2);

			float2 offset = bump.xy*_Distortion;//*_RefractionTex_TexeSize.xy;
			i.scrPos.xy = offset*i.scrPos.z + i.scrPos.xy;
			//fixed3 refrCol = tex2D(_RefractionTex,i.scrPos.xy/i.scrPos.w).rgb;

			bump = normalize(half3(dot(i.TtoW0.xyz,bump),dot(i.TtoW1.xyz,bump),dot(i.TtoW2.xyz,bump)));
			fixed4 texColor = tex2D(_MainTex,i.uv.xy+speed);
			fixed3 refDir = reflect(-viewDir,bump);
			fixed3 refCol = texCUBE(_CubMap,refDir).rgb * texColor.rgb * _Color.rgb;

			fixed fresnel = pow(1-saturate(dot(viewDir,bump)),4);

			fixed shadow = SHADOW_ATTENUATION(i);

			fixed3 finalColor = (fresnel+refCol*(1-fresnel))*shadow;
            return fixed4(finalColor,1);
        }
        ENDCG
    }
}
FallBack &quot;Diffuse&quot;
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HLSL常用函数]]></title>
        <id>https://Wei715547.github.io/post/hlsl-chang-yong-han-shu/</id>
        <link href="https://Wei715547.github.io/post/hlsl-chang-yong-han-shu/">
        </link>
        <updated>2021-04-24T07:16:56.000Z</updated>
        <content type="html"><![CDATA[<p><a href = "https://blog.csdn.net/qq_43210334/article/details/115870675">CSDN</a><br>
<strong>一.CG/HLSL/GLSL</strong><br>
1.CG<br>
Unity shader的入门时，不管是《入门精要》还是庄老师的课，都是从CG语言开始学习的。它是由NVIDIA公司所开发的，基于C语言同时被OpenGL和Direct3D所支持的开发语言，其语法和HLSL类似。在《GPU编程与CG语言之阳春白雪》中虽然曾认为CG会越来越受欢迎，但遗憾的是，NVIDIA还是抛弃了CG，目前CG的最终版本是3.1。虽然在一些简单的shader编写上还是可以使用，但是在新的硬件环境下还是可能不支持，且对一些新功能的支持较差。</p>
<p>2.GLSL<br>
GLSL是基于OpenGL的接口，其语法体系自成一家。闫老师的Games课程，以及学校的图形学教学中，一般还是使用GLSL。但是它不支持DirectX，就不得不放弃仅支持DirectX的Xbox等平台。</p>
<p>3.HLSL<br>
HLSL是由微软开发的，在Windows平台上一家独大，多用于游戏领域。语法类似CG语言，在Unity中CG和HLSL等价。</p>
<p><strong>二.HLSL常用函数</strong><br>
1.基本数学运算<br>
<img src="https://Wei715547.github.io/post-images/1619340526887.PNG" alt="" loading="lazy"><br>
<a href = "https://graphtoy.com/">graphtoy</a></p>
<p>2.幂指对函数<br>
<img src="https://Wei715547.github.io/post-images/1619341012896.PNG" alt="" loading="lazy"></p>
<p>3.三角函数与双曲函数<br>
<img src="https://Wei715547.github.io/post-images/1619341373189.PNG" alt="" loading="lazy"></p>
<p>4.数据范围类<br>
<img src="https://Wei715547.github.io/post-images/1619341545125.PNG" alt="" loading="lazy"></p>
<p>5.类型判断类<br>
<img src="https://Wei715547.github.io/post-images/1619341600552.PNG" alt="" loading="lazy"></p>
<p>6.向量与矩阵类<br>
<img src="https://Wei715547.github.io/post-images/1619341637736.PNG" alt="" loading="lazy"></p>
<p>7.光线运算类<br>
<img src="https://Wei715547.github.io/post-images/1619341725403.PNG" alt="" loading="lazy"></p>
<p>8.2D纹理查找<br>
<img src="https://Wei715547.github.io/post-images/1619341791205.PNG" alt="" loading="lazy"></p>
<p>10.3D纹理查找<br>
<img src="https://Wei715547.github.io/post-images/1619341893660.PNG" alt="" loading="lazy"></p>
<p>11.立体纹理查找<br>
<img src="https://Wei715547.github.io/post-images/1619341941577.PNG" alt="" loading="lazy"></p>
<p>#关于ddx和ddy</p>
<p>函数ddx和ddy用于求取相邻像素间某属性差值；<br>
函数ddx和ddy输入参数通常是纹理坐标；<br>
函数ddx和ddy返回相邻像素键的属性差值；<br>
这里是测试的在片元着色器中利用底下的代码，可以表现世界空间法线；<br>
float3 col=normalize(cross(ddy(i.worldPos),ddx(i.worldPos))).xyz;<br>
<img src="https://Wei715547.github.io/post-images/1619342973207.PNG" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shader阴影投射/接收]]></title>
        <id>https://Wei715547.github.io/post/yin-ying-chu-li/</id>
        <link href="https://Wei715547.github.io/post/yin-ying-chu-li/">
        </link>
        <updated>2021-04-23T09:01:28.000Z</updated>
        <content type="html"><![CDATA[<p><strong>1. 向其他物体投射阴影需要ShadowCaster的Pass</strong><br>
Diffuse的Fallback调用的VertexLit中的ShadowCaster Pass来实现向其他物体投射阴影<br>
Pass{<br>
Name&quot;ShadowCaster&quot;<br>
Tage{&quot;LightMde&quot; = &quot;ShadowCaster&quot;}</p>
<pre><code>CGPROGRAM
#pragma vertex vert
#pragma fragment frag    
#pragma multi_compile_shadowcaster    
#include &quot;UnityCG.cginc&quot;

Struct v2f {
V2F SHADOW CASTER; 
);

v2f vert(appdata_base v)
｛
        v2f o;
        TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)//需要v中含有顶点位置与法线信息
        return o;
}
float4 frag(v2f i) : SV_Target
｛
        SHADOW_CASTER_FRAGMENT(i)
    }
</code></pre>
<p>ENDCG<br>
}<br>
<strong>对物体添加顶点动画或局部剔除时要使阴影与变化一致：需要在ShadowCaster的Pass中做出相应的调整</strong><br>
#例如：在顶点动画中<br>
Pass<br>
{<br>
Tags{&quot;LightMode&quot; = &quot;ShadowCaster&quot;}<br>
CGPROGRAM</p>
<pre><code>	float _Manitude;
	float _Frequency;
	float _InvWaveLength;
	float _Speed;

	#pragma vertex vert
	#pragma fragment frag

	#pragma multi_compile_shadowcaster
	#include &quot;UnityCG.cginc&quot;

	struct a2v{
		float4 vertex : POSITION;			
		float4 normal :NORMAL;
	};

	struct v2f{
		V2F_SHADOW_CASTER;
	};

	v2f vert(a2v v)
	{
		v2f o;
		float4 offset ;
		offset.xzw = float3(0.0,0.0,0.0);
		offset.y = sin(_Frequency*_Time.y + v.vertex.x * _InvWaveLength + v.vertex.y*_InvWaveLength + v.vertex.z*_InvWaveLength )*_Manitude;
		v.vertex = v.vertex+offset;

		TRANSFER_SHADOW_CASTER_NORMALOFFSET(o);//
		return o;
	}
	fixed4 frag(v2f i):SV_Target
	{
		SHADOW_CASTER_FRAGMENT(i)
	}
	ENDCG
}
</code></pre>
<p>#例如：存在部分剔除时<br>
Pass<br>
{<br>
Tags{&quot;LightMode&quot; = &quot;ShadowCaster&quot;}<br>
CGPROGRAM</p>
<pre><code>	float _ResAmount;
	sampler2D _ResMap;
	float4 _ResMap_ST;

	#pragma vertex vert
	#pragma fragment frag

	#pragma multi_compile_shadowcaster
	#include &quot;UnityCG.cginc&quot;

	struct v2f{
		V2F_SHADOW_CASTER;
		float2 uvBurnMap:TEXCOORD1;
	};

	v2f vert(appdata_base v)
	{
		v2f o;
		TRANSFER_SHADOW_CASTER_NORMALOFFSET(o);
		o.uvBurnMap = TRANSFORM_TEX(v.texcoord,_ResMap);
		return o;
	}
	fixed4 frag(v2f i):SV_Target
	{
		fixed3 burn = tex2D(_ResMap,i.uvBurnMap).rgb;
		clip(burn.r-_ResAmount);
		SHADOW_CASTER_FRAGMENT(i)
	}
	ENDCG
}
</code></pre>
<p><strong>2. 接收其他物体阴影</strong><br>
（1）首先需要引入内置文件：包含计算阴影时所包含的宏<br>
#include &quot;AutoLight.cginc&quot;<br>
（2）在v2f中添加内置的SHADOW_COORDS宏（用于声明一个用于阴影采样的坐标）<br>
struct v2f {<br>
float4 pos : SV_POSITION;<br>
float3 worldNormal : TEXCOORD0;<br>
float3 worldPos : TEXCOORD1;<br>
SHADOW_COORDS(2) //参数为下一个可用的寄存器<br>
}<br>
（3）在顶点着色器中用TRANSFER_SHADOW计算阴影纹理坐标<br>
v2f vert(atv v){<br>
v2f o;<br>
......<br>
TRANSFER_SHADOW(o);//使用上一步在v2f中定义的SHADOW_COORD<br>
}<br>
（4）在片原着色器中使用计算阴影<br>
fixed shadow = SHADOW_ATTENUATION(i)//参数为v2f，得到阴影值与漫反、高光相乘即可实现接收阴影</p>
<p><strong>3.使用UNITY_LIGHT_ATTENUATION统一计算阴影与光衰</strong><br>
代码基本同上引用<br>
#include &quot;Lighting.cginc&quot;<br>
#include &quot;AutoLight.cginc&quot;<br>
在片元着色器中使用宏同时计算光衰与阴影<br>
fixed4 frag(v2f i):SV_Target{<br>
......<br>
UNITY_LIGHT_ATTENUATION(atten,i,i.worldPos);//第一各参数主动生成，第二个参数v2f用于SHADOW_ATTENUATION计算阴影，第三个参数为世界空间坐标<br>
return fixed4(ambient+(diffuse+specular)*atten,1);<br>
}<br>
<strong>FallBack &quot;Transparent/VertexLit&quot;//对于混合实现的透明物体很难实现投射与接收阴影</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[溶解Shader]]></title>
        <id>https://Wei715547.github.io/post/rong-jie-shader/</id>
        <link href="https://Wei715547.github.io/post/rong-jie-shader/">
        </link>
        <updated>2021-04-22T11:45:29.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://Wei715547.github.io/post-images/1619092502635.PNG" alt="" loading="lazy"><br>
Shader &quot;Unlit/Dissolve2&quot;<br>
{<br>
Properties<br>
{<br>
_ResAmount(&quot;溶解&quot;,Range(0.0,1.0)) = 0.0<br>
_LineWidth (&quot;LineWidth&quot;, Range(0.0,0.2)) = 0.1<br>
_MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}<br>
_Gloss(&quot;Gliss&quot;,Range(1,100)) = 1<br>
_NormalST(&quot;NormalST&quot;, Float) = 1<br>
_NormalMap(&quot;NormalMap&quot;,2D) = &quot;while&quot;{}<br>
_ResMap(&quot;ResMap&quot;,2D) = &quot;while&quot;{}<br>
_EDGColor (&quot;EDGColor&quot;,Color) = (1,1,1,1)<br>
}<br>
SubShader<br>
{<br>
Pass<br>
{<br>
//Tags{&quot;LightMode&quot; = &quot;ForwardBase&quot;}<br>
Cull Off</p>
<pre><code>        CGPROGRAM
        #pragma vertex vert
        #pragma fragment frag
		#include &quot;UnityCG.cginc&quot;
		#include &quot;Lighting.cginc&quot;

		float _ResAmount;
		float _LineWidth;
		sampler2D _MainTex;
		float4 _MainTex_ST;
		float _Gloss;
		float _NormalST;
		sampler2D _NormalMap;
		float4 _NormalMap_ST;
		sampler2D _ResMap;
		float4 _ResMap_ST;
		float4 _EDGColor;

        struct appdata
        {
            float4 vertex : POSITION;
            float2 uv : TEXCOORD0;
			float3 normal:NORMAL;
			float4 tangent:TANGENT;
        };

        struct v2f
        {
            float2 uvMaintex : TEXCOORD0;
			float2 uvNormal : TEXCOORD1;
			float3 lightDir : TEXCOORD2;
			float3 worldvertex : TEXCOORD3;
			float3 viewDir : TEXCOORD4;
			float2 uvResMap:TEXCOORD5;
            float4 vertex : SV_POSITION;
        };


        v2f vert (appdata v)
        {
            v2f o;
            o.vertex = UnityObjectToClipPos(v.vertex);
            o.uvMaintex = TRANSFORM_TEX(v.uv, _MainTex);
			o.uvNormal = TRANSFORM_TEX(v.uv,_NormalMap);
			o.uvResMap = TRANSFORM_TEX(v.uv,_ResMap);

			TANGENT_SPACE_ROTATION;
			o.lightDir = mul(rotation,ObjSpaceLightDir(v.vertex)).xyz;
			o.worldvertex = mul(unity_ObjectToWorld,v.vertex).xyz;
			o.viewDir = mul(rotation, ObjSpaceViewDir(v.vertex)).xyz;
            return o;
        }

        fixed4 frag (v2f i) : SV_Target
        {
			fixed3 res = tex2D(_ResMap,i.uvResMap).rgb;
			clip(res.r-_ResAmount);//小于0时剔除像素

			//计算漫反射
			float3 tangenLightDir = normalize(i.lightDir);
			fixed3 tangentNormalDir = UnpackNormal(tex2D(_NormalMap,i.uvNormal));
			tangentNormalDir.xy = tangentNormalDir.xy*_NormalST;
			float3 diff = tex2D(_MainTex,i.uvMaintex);
			fixed3 diffuse = _LightColor0.rgb*diff*max(dot(tangenLightDir,tangentNormalDir)*0.5+0.5,0);
			//计算高光
			fixed3 viewDir = normalize(i.viewDir);//视线方向
			fixed3 harfDir = normalize(viewDir + tangenLightDir);//视角与平行光的平分方向
			fixed3 specular = _LightColor0.rgb * diff * pow(max(dot(tangentNormalDir, harfDir),0), _Gloss);
            fixed3 col = diffuse + specular+UNITY_LIGHTMODEL_AMBIENT.rgb*diff;
			//添加边线颜色				
			fixed3 eColor = _EDGColor;//边线颜色
			eColor = pow(eColor,5);//加强
			fixed t = 1-smoothstep(0.0,_LineWidth,res.r-_ResAmount);//像素未被剔除时差值大于线宽输出1，相减t=0：未剔除的显示原色。
			//差值小于边线，接近0时输出接近0，t增大：将被剔除的像素显色边界色
			fixed3 finalColor = lerp(col,eColor,t*step(0.0001,_ResAmount));//_ResAmount大于0时t即生效t=0原色，=1边界色

            return fixed4( finalColor,1);
        }
        ENDCG
    }
    //消融部分阴影处理
    Pass {
	Tags{&quot;LightMode&quot; = &quot;ShadowCaster&quot;}
	CGPROGRAM
	
	float _ResAmount;
	sampler2D _ResMap;
	float4 _ResMap_ST;

	#pragma vertex vert
	#pragma fragment frag

	#pragma multi_compile_shadowcaster
	#include &quot;UnityCG.cginc&quot;

	struct v2f{
		V2F_SHADOW_CASTER;
		float2 uvBurnMap:TEXCOORD1;
	};

	v2f vert(appdata_base v)
	{
		v2f o;
		TRANSFER_SHADOW_CASTER_NORMALOFFSET(o);
		o.uvBurnMap = TRANSFORM_TEX(v.texcoord,_ResMap);
		return o;
	}
	fixed4 frag(v2f i):SV_Target
	{
		fixed3 burn = tex2D(_ResMap,i.uvBurnMap).rgb;
		clip(burn.r-_ResAmount);
		SHADOW_CASTER_FRAGMENT(i)
	}
	ENDCG
}
}
</code></pre>
<p>}<br>
//调用脚本(Update中)<br>
r = Mathf.Lerp(0, 1, r+=Time.deltaTime/rtime);//rtime时间内r变为1<br>
mt.SetFloat(&quot;_ResAmount&quot;, r);</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[护盾Shader]]></title>
        <id>https://Wei715547.github.io/post/hu-dun-shader/</id>
        <link href="https://Wei715547.github.io/post/hu-dun-shader/">
        </link>
        <updated>2021-04-17T10:12:46.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://Wei715547.github.io/post-images/1618655258132.PNG" alt="" loading="lazy"><br>
<a href = "https://www.bilibili.com/video/BV1kv411r7x2?p=4">视频</a><br>
<img src="https://Wei715547.github.io/post-images/1618654561889.PNG" alt="" loading="lazy"><br>
Shader &quot;Unlit/ShileShader&quot;<br>
{<br>
Properties<br>
{<br>
[HDR]_Color (&quot;六边形边缘颜色&quot;, Color) = (1,1,1,1)                    //控制每一个蜂巢网格的边缘光颜色<br>
[HDR]_Color1 (&quot;条带颜色&quot;, Color) = (1,1,1,1)                    //控制每一个蜂巢网格的主体颜色<br>
[HDR]_FresnelColor (&quot;菲尼尔颜色&quot;, Color) = (1,1,1,1)        //控制防护罩的边缘高光颜色<br>
_FresnelPower (&quot;FresnelPower&quot;, Range(0.1, 11)) = 1            //控制防护罩的边缘高光强度<br>
_FresnelAlpha (&quot;FresnelAlpha&quot;, Range(0, 50)) = 1            //控制防护罩的不透明度<br>
_MainTex (&quot;MainTex&quot;, 2D) = &quot;white&quot; {}<br>
_ShieldTex (&quot;ShieldTex&quot;, 2D) = &quot;white&quot; {}<br>
_OffsetFactor (&quot;OffsetFactor&quot;, Float) = 0.0001                //控制网格偏移程度<br>
_RollSpeed (&quot;RollSpeed&quot;, Range(0, 5)) = 1                    //控制滚动速度</p>
<pre><code>	_AlphaTex(&quot;AlphaTex&quot;, 2D) = &quot;white&quot; {}
	_ScaleOffset (&quot;ScaleOffset&quot;, Range(0, 5)) = 1            //控制防护罩缩放的程度
	_ScaleSpeed (&quot;ScaleSpeed&quot;, Range(0, 10)) = 1            //控制防护罩缩放的速度
}
SubShader
{
    Tags{&quot;Queue&quot; = &quot;Transparent&quot;/*模型渲染队列*/ &quot;IngnoreProjector&quot; = &quot;True&quot; &quot;RanderType&quot; = &quot;Transparent&quot;
	&quot;DisableBatching&quot; = &quot;True&quot;}//Pass块参数标签
    LOD 100

    Pass
    {
		ZWrite Off
		Blend SrcAlpha OneMinusSrcAlpha
		
        CGPROGRAM
		float4 _Color;
		float4 _Color1;
		float4 _FresnelColor;
		float _FresnelPower;
		float _FresnelAlpha;
		sampler2D _MainTex;
		float4 _MainTex_ST;
		sampler2D _ShieldTex;
		float4 _ShieldTex_ST;
		float _OffsetFactor;
		float _RollSpeed;

		sampler2D _AlphaTex;
		fixed _ScaleOffset;
		fixed _ScaleSpeed;

        #pragma vertex vert
        #pragma fragment frag

        #include &quot;UnityCG.cginc&quot;

        struct appdata
        {
            float4 vertex : POSITION;
            float2 uv : TEXCOORD0;
			float3 normal:NORMAL;
        };

        struct v2f
        {
			float4 vertex : SV_POSITION;
            float2 uv1 : TEXCOORD0;
			float2 uv2 : TEXCOORD1;               
			float3 worldNormal:TEXCOORD2;
			float3 worldPos:TEXCOORD3;
        };

        v2f vert (appdata v)
	{
		v2f o;
		//注意uv的范围是0~1
		float2 uv = v.normal.xy * 0.5 + 0.5;
		//加上_MainTex贴图的缩放和偏移
		uv = uv * _MainTex_ST.xy + _MainTex_ST.zw;
		//用_RollSpeed来控制滚动速度
		uv.y += _Time.y * _RollSpeed;
		//利用texDlod函数来进行采样
		float3 offset = tex2Dlod(_MainTex, float4(uv.x, uv.y, 0,0));
		offset = smoothstep(0, 1, offset);
		v.vertex.xyz += normalize(v.normal) * (offset * _OffsetFactor);
		v.vertex.xyz += normalize(v.normal) * sin(_Time.y * _ScaleSpeed) * _ScaleOffset * 0.0005;

		o.vertex = UnityObjectToClipPos(v.vertex);
		//uv1和uv相同
		o.uv1 = uv;
		//uv2为物体本身的uv
		o.uv2 = v.uv * _ShieldTex_ST.xy + _ShieldTex_ST.zw;
		o.worldNormal = normalize(UnityObjectToWorldNormal(v.normal));
		o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
		return o;
	}

        fixed4 frag (v2f i) : SV_Target
	{
		//菲尼尔系数Fresnel：F = pow(1-max(dot(v.n),0),_FresnelPower)
		float NdotV = max(dot(i.worldNormal, normalize(UnityWorldSpaceViewDir(i.worldPos))),0);//模型边缘NdotV接近0
		NdotV = 1 - NdotV;//取反：模型边缘为1
		fixed3 fresnelCol = pow(NdotV * _FresnelColor, _FresnelPower);//模型边缘颜色

	 //Single Shield Color
		fixed3 sCol = tex2D(_ShieldTex, i.uv2) * _Color.rgb;//六边形边缘光颜色
		fixed4 col = tex2D(_MainTex, i.uv1) * _Color1;//偏移UV采样六边形颜色

		fixed colAlpha = tex2D(_AlphaTex, i.uv1).a;//偏移UV采样遮罩

		return fixed4(fresnelCol + col + sCol, pow(NdotV, _FresnelAlpha) + colAlpha);
		//(模型边缘颜色+六边形本身颜色+添加边线颜色，边缘不透明+采样遮罩部分不透明)
	}
        ENDCG
    }
    }
    FallBack &quot;Transparent/VertexLit&quot;//混合透明物体无法投射与接收阴影
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LC链表相关]]></title>
        <id>https://Wei715547.github.io/post/lc-lian-biao-xiang-guan/</id>
        <link href="https://Wei715547.github.io/post/lc-lian-biao-xiang-guan/">
        </link>
        <updated>2021-04-16T07:36:15.000Z</updated>
        <content type="html"><![CDATA[<p><strong>1.反转链表</strong><br>
public ListNode ReversListNode(ListNode head)<br>
{<br>
if (head == null || head.next == null) return head;//返回条件到最后一个节点时返回</p>
<pre><code>        ListNode res = ReversListNode(head.next);//当前节点与上一个节点变换指向
        head.next.next = head;
        head.next = null;
        return res;
    }
</code></pre>
<p><strong>2.单链表排序</strong><br>
public ListNode SortList(ListNode head)<br>
{<br>
if (head == null||head.next==null) return head;<br>
ListNode fast = head.next;<br>
ListNode slow = head;<br>
while(fast!=null&amp;&amp;fast.next!=null)<br>
{<br>
slow = slow.next;<br>
fast = fast.next.next;<br>
}<br>
ListNode temp = slow.next;<br>
slow.next = null;<br>
//对两部分进行递归排序，分为一个节点时返回<br>
ListNode left = SortList(head);<br>
ListNode right = SortList(temp);<br>
//对比两部分大小，小的排在前面<br>
ListNode h = new ListNode();<br>
ListNode res = h;<br>
while(left!=null&amp;&amp;right!=null)<br>
{<br>
if (left.val &lt; right.val)<br>
{<br>
h.next = left;<br>
left = left.next;<br>
}<br>
else<br>
{<br>
h.next = right;<br>
right = right.next;<br>
}<br>
h = h.next;<br>
}<br>
h.next = left == null ? right : left;<br>
return res.next;<br>
}<br>
<strong>3.合并有序链表</strong><br>
public static ListNode MergeTwoLists(ListNode l1, ListNode l2)<br>
{<br>
if (l1 == null || l2 == null) return l1 == null ? l2 : l1;</p>
<pre><code>        if (l1.val &lt; l2.val)
        {
            l1.next = MergeTwoLists(l1.next, l2);
            return l1;
        }
        else
        {
            l2.next = MergeTwoLists(l1, l2.next);
            return l2;
        }
    }
    public static ListNode MergeTwoLists2(ListNode l1, ListNode l2)
    {
        ListNode head = new ListNode();
        ListNode res = head;
        while(l1 != null &amp;&amp; l2!=null)
        {
            if(l1.val&lt; l2.val)
            {
                head.next = l1;
                l1 = l1.next;
            }else
            {
                head.next = l2;
                l2 = l2.next;
            }
            head = head.next;
        }
        head.next = l1 == null ? l2 : l1;
        return res.next;
    }
    **4.排序链表去重**
    public ListNode DeleteDuplicates(ListNode head)
    {
        if (head == null || head.next == null) return head;
        ListNode res = new ListNode();
        res.next = head;
        while (head != null &amp;&amp; head.next != null)
        {
            if (head.val == head.next.val)
            {
                head.next = head.next.next;
            }
            else
                head = head.next;
        }
        return res.next;
    }
</code></pre>
<p><strong>5.链表倒数第K个节点</strong><br>
public ListNode GetKthFromEnd(ListNode head, int k) {<br>
if (head == null) return null;<br>
ListNode l = head;<br>
ListNode r = head;<br>
for (int i = 0; i &lt; k; i++)<br>
{<br>
r = r.next;<br>
}<br>
while(r!=null)<br>
{<br>
l = l.next;<br>
r = r.next;<br>
}<br>
return l;<br>
}<br>
<strong>6.回文链表</strong><br>
static ListNode p = new ListNode();<br>
public static bool IsPalindrome2(ListNode head)<br>
{<br>
p = head;<br>
return Recursion(head);<br>
}<br>
public static bool Recursion(ListNode head)<br>
{<br>
if (head == null)//到最后节点时返回<br>
return true;<br>
if (!Recursion(head.next))//不满足回文即退出<br>
return false;</p>
<pre><code>        if (p.val != head.val)//不相等时即不是回文链表
            return false;
        p = p.next;//相等头结点下一，返回上一层节点继续比较
        return true;
    }   
</code></pre>
<p><strong>7.相交链表</strong><br>
public ListNode GetIntersectionNode(ListNode headA, ListNode headB) {<br>
if (headA == null || headB == null) return null;</p>
<pre><code>        HashSet&lt;ListNode&gt; list = new HashSet&lt;ListNode&gt;();
        while(headA!=null)
        {
            list.Add(headA);
            headA = headA.next;
        }
        while(headB!=null)
        {
            if (!list.Contains(headB))
            {
                list.Add(headB);
                headB = headB.next;
            }
            else
                return headB;
        }
        return null;
}
</code></pre>
<p><strong>//8.环形链表</strong><br>
public bool HasCycle(ListNode head)<br>
{<br>
ListNode pos = head;<br>
HashSet<ListNode> set = new HashSet<ListNode>();</p>
<pre><code>        while (pos != null)
        {
            if (!set.Contains(pos))
            {
                set.Add(pos);
                pos = pos.next;
            }
            else
            {
                return true;
            }
        }
        return false;
    }
</code></pre>
<p><strong>//9.奇偶链表</strong><br>
public ListNode OddEvenList(ListNode head)<br>
{<br>
if (head == null || head.next == null) return head;</p>
<pre><code>        ListNode odd = head;
        ListNode even = head.next;
        ListNode evenHead = head.next;
        while (even != null &amp;&amp; even.next != null)
        {
            odd.next = odd.next.next;
            odd = odd.next;
            even.next = even.next.next;
            even = even.next;
        }
        odd.next = evenHead;
        return head;
    }
   ** //10.两两交换链表中的节点**
    public ListNode SwapPairs(ListNode head)
    {
        if (head == null || head.next == null)
        {
            return head;
        }
        ListNode next = head.next;//后一个节点
        head.next = SwapPairs(head.next.next);//前一个节点等于下一层递归返回的后一个节点
        next.next = head;//后一个节点指向前一个节点
        return next;
    }
    public ListNode SwapPairs2(ListNode head)
    {
        ListNode dummy = new ListNode();            
        ListNode res = dummy;
        dummy.next = head;
        ListNode first = new ListNode();
        ListNode second = new ListNode();
        while(dummy.next!=null&amp;&amp;dummy.next.next!=null)
        {
            first = dummy.next;
            second = dummy.next.next;
            first.next = second.next;
            second.next = first;
            dummy.next = second;
            dummy = dummy.next.next;
        }
        return res.next;
    }</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shader纹理/顶点动画]]></title>
        <id>https://Wei715547.github.io/post/shader-wen-li-ding-dian-dong-hua/</id>
        <link href="https://Wei715547.github.io/post/shader-wen-li-ding-dian-dong-hua/">
        </link>
        <updated>2021-04-13T08:34:59.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://Wei715547.github.io/post-images/1618303098602.PNG" alt="" loading="lazy"></figure>
<p><strong>1.纹理序列帧动画</strong><br>
<code><br>
Shader &quot;Unlit/TcAnimition&quot;<br>
{<br>
Properties<br>
{<br>
_MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}<br>
_Color(&quot;ColorTint&quot;,Color) = (1,1,1,1)<br>
_HCount(&quot;HCount&quot;,Float) = 4<br>
_VCount(&quot;VCount&quot;,Float) = 4<br>
_Speed(&quot;Speed&quot;,Range(1,100)) = 1<br>
_A(&quot;Alp&quot;,Range(0,1))=0.5<br>
}<br>
SubShader<br>
{	<br>
Tags{&quot;Queue&quot; = &quot;Transparent&quot;/<em>设置模型渲染队列为透明度混合</em>/ &quot;IngnoreProjector&quot; = &quot;True&quot; &quot;RanderType&quot; = &quot;Transparent&quot;}<br>
Pass<br>
{<br>
//Tags{&quot;LightMode&quot; = &quot;ForwardBase&quot;}<br>
ZWrite Off<br>
Blend SrcAlpha OneMinusSrcAlpha</p>
<pre><code>        CGPROGRAM
		sampler2D _MainTex;
		float4 _MainTex_ST;
		float4 _Color;
		float _HCount;
		float _VCount;
		float _Speed;
		float _A;

        #pragma vertex vert
        #pragma fragment frag
		#include &quot;UnityCG.cginc&quot;
        struct a2v
        {
            float4 vertex : POSITION;
            float2 uv : TEXCOORD0;
        };

        struct v2f
        {
            float2 uv : TEXCOORD0;
            float4 vertex : SV_POSITION;
        };


        v2f vert (a2v v)
        {
            v2f o;
            o.vertex = UnityObjectToClipPos(v.vertex);
            o.uv = TRANSFORM_TEX(v.uv, _MainTex);
			
            return o;
        }

        fixed4 frag (v2f i) : SV_Target
        {
			float time = floor(_Time.y*_Speed);
			float row = floor(time/_HCount);
			float column = time- row*_HCount;

			half2 uv = i.uv+half2(column,-row);
			uv.x /=_HCount;
			uv.y /= _VCount;
            fixed4 col = tex2D(_MainTex, uv);
			col *=_Color;
            return float4( col.xyz,_A*col.w);
        }
        ENDCG
    }
}
FallBack &quot;Transparent/VertexLit&quot;
</code></pre>
<p>}</code><br>
<img src="https://Wei715547.github.io/post-images/1618305332948.PNG" alt="" loading="lazy"><br>
<strong>2.纹理平移</strong><br>
<code><br>
Shader &quot;Unlit/TcMoveAni&quot;<br>
{<br>
Properties<br>
{<br>
_MainTex (&quot;BaseLayer&quot;, 2D) = &quot;white&quot; {}<br>
_DetaliTex (&quot;UpLayer&quot;, 2D) = &quot;white&quot; {}<br>
_ScrollX(&quot;BaseSpeed&quot;,Float) = 1.0<br>
_Scroll2X(&quot;UpSpeed&quot;,Float) = 1.0<br>
_Multipler(&quot;LayerHLT&quot;,fLOAT) = 1<br>
}<br>
SubShader<br>
{			<br>
Pass<br>
{</p>
<pre><code>        CGPROGRAM
		sampler2D _MainTex;
		float4 _MainTex_ST;
		sampler2D _DetaliTex;
		float4 _DetaliTex_ST;
		float _ScrollX;
		float _Scroll2X;
		float _Multipler;

        #pragma vertex vert
        #pragma fragment frag
		#include &quot;UnityCG.cginc&quot;
        struct a2v
        {
            float4 vertex : POSITION;
            float2 uv : TEXCOORD0;
        };

        struct v2f
        {
            float4 uv : TEXCOORD0;
            float4 vertex : SV_POSITION;
        };


        v2f vert (a2v v)
        {
            v2f o;
            o.vertex = UnityObjectToClipPos(v.vertex);
            o.uv.xy = TRANSFORM_TEX(v.uv, _MainTex)+frac(float2(_ScrollX,0.0)*_Time.y);
			o.uv.zw = TRANSFORM_TEX(v.uv,_DetaliTex)+frac(float2(_Scroll2X,0.0)*_Time.y);				
            return o;
        }

        fixed4 frag (v2f i) : SV_Target
        {
			fixed4 baseLayer = tex2D(_MainTex,i.uv.xy);
			fixed4 upLayer = tex2D(_DetaliTex,i.uv.zw);

            fixed4 col = lerp(baseLayer,upLayer,upLayer.a);
			col.rgb *=_Multipler;
            return col;
        }
        ENDCG
    }
}
FallBack &quot;Diffuse&quot;
</code></pre>
<p>}</code><br>
<strong>3.顶点动画</strong><br>
<img src="https://Wei715547.github.io/post-images/1618311312093.PNG" alt="" loading="lazy"><br>
<code><br>
Shader &quot;Custom/VTAni&quot;<br>
{<br>
Properties<br>
{<br>
_Color (&quot;Color&quot;, Color) = (1,1,1,1)<br>
_MainTex (&quot;Albedo (RGB)&quot;, 2D) = &quot;white&quot; {}<br>
_Manitude(&quot;Mangitude&quot;, Float) = 1<br>
_Frequency(&quot;Frequency&quot;,Float) = 1<br>
_InvWaveLength(&quot;InvWaveLength&quot;,Float) = 10<br>
_Speed(&quot;Speed&quot;,Float) = 0.5<br>
}<br>
SubShader<br>
{<br>
Tags{&quot;Queue&quot; = &quot;Transparent&quot; &quot;IgnoreProjector&quot; = &quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot;<br>
&quot;DisableBatching&quot; = &quot;True&quot;}//该模型依靠模型空间计算顶点动画，不进行批处理合并<br>
Pass{<br>
//Tags{&quot;LightMode&quot; = &quot;ForwardBase&quot;}<br>
ZWrite Off<br>
Blend SrcAlpha OneMinusSrcAlpha<br>
Cull Off//双面可见</p>
<pre><code>    CGPROGRAM

    sampler2D _MainTex;
	float4 _MainTex_ST;
	float4 _Color;
	float _Manitude;
	float _Frequency;
	float _InvWaveLength;
	float _Speed;
	#pragma vertex vert
    #pragma fragment frag
	#include &quot;UnityCG.cginc&quot;

    struct a2v
        {
            float4 vertex : POSITION;
            float2 uv : TEXCOORD0;
        };

        struct v2f
        {
            float2 uv : TEXCOORD0;
            float4 pos : SV_POSITION;
        };

	v2f vert(a2v v){
		v2f o;
		float4 offset ;
		offset.xzw = float3(0.0,0.0,0.0);
		offset.y = sin(_Frequency*_Time.y + v.vertex.x * _InvWaveLength + v.vertex.y*_InvWaveLength + v.vertex.z*_InvWaveLength )*_Manitude;
		o.pos = UnityObjectToClipPos(v.vertex+offset);
		o.uv = TRANSFORM_TEX(v.uv,_MainTex);
		o.uv += float2(0.0,_Time.y*_Speed);
		return o;
	}
	fixed4 frag(v2f i):SV_Target{
		fixed4 c = tex2D(_MainTex,i.uv);
		c.rgb *= c;
		return c;
	}
	ENDCG
}
}
FallBack &quot;Transparent/VertexLit&quot;
</code></pre>
<p>}</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图形学：向量/矩阵/空间变换]]></title>
        <id>https://Wei715547.github.io/post/tu-xing-xue-xiang-liang-ju-zhen/</id>
        <link href="https://Wei715547.github.io/post/tu-xing-xue-xiang-liang-ju-zhen/">
        </link>
        <updated>2021-04-04T08:14:03.000Z</updated>
        <content type="html"><![CDATA[<p><strong>向量：点乘，叉乘</strong><br>
//点乘：a<em>b = axbx+ayby+azbz =|a| |b|cos(x),ab夹角：<br>
//b在a上的投影：|b|cos(x) = (a</em>b)/|a| = b<em>a(A),//单位矢量a<br>
应用：<br>
a为平面法线，求b在平面上的投影<br>
b在a向量上的投影向量为c = Vector.Dot(a,b)/a.magintude ()<em>a.normalized<br>
则b在平面上的投影为：b-c;<br>
<img src="https://Wei715547.github.io/post-images/1617524585593.png" alt="" loading="lazy"><br>
//点乘Vector3.Dot();v2在v1上投影的标量。V1( x1, y1)   V2(x2, y2) = x1</em>x2 + y1</em>y2<br>
//叉乘Vector3.Cross();v1v2平面的法线向量。V1(x1, y1) X V2(x2, y2) = x1y2 – y1x2<br>
（右手顺时v1指向v2）。即叉乘的第一个向量在第二个向量右边时为正，否则为负。<br>
A x B = |A||B|Sin(θ)<br>
<img src="https://Wei715547.github.io/post-images/1617524798354.png" alt="" loading="lazy"><br>
<strong>矩阵</strong><br>
矩阵相乘：A（rxc）,B（cxn）矩阵只允许A的列数等于B的行数时两矩阵才能相乘得到r行n列的新矩阵<br>
新矩阵C的i行j列元素等于A的i行与B的j列点乘<br>
<img src="https://Wei715547.github.io/post-images/1617525313203.PNG" alt="" loading="lazy"><br>
<strong>特殊矩阵</strong><br>
方块矩阵：行列数相同的矩阵<br>
对角矩阵：除了对角元素m11,m22,m33等其他元素都为0的矩阵<br>
单位矩阵：对角元素为1的矩阵{[1 0 0],[0 1 0],[0 0 1]}任何矩阵与其相乘还是原来的矩阵</p>
<p>转置矩阵：  对矩阵的一种运算，将元素的行变为列，列变为行<br>
<img src="https://Wei715547.github.io/post-images/1617525786685.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1617525838429.PNG" alt="" loading="lazy"><br>
逆矩阵：原矩阵与其逆矩阵(纯在逆矩阵，元素都为0的矩阵不存在逆矩阵)相乘=单位矩阵<br>
一个矩阵有对应的逆矩阵即是可逆的又称非奇异的  ，没有逆矩阵则是不可逆的，奇异的<br>
<img src="https://Wei715547.github.io/post-images/1617526690926.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1617526823864.PNG" alt="" loading="lazy"><br>
正交矩阵：若矩阵与该矩阵的转置矩阵相乘得到单位矩阵，即该矩阵的转置正交也是该矩阵的逆矩阵<br>
<img src="https://Wei715547.github.io/post-images/1617527574679.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1617527627513.PNG" alt="" loading="lazy"><br>
由上得出对于3x3的正交矩阵实际上即是三维空间坐标轴，若它们长度为1构成标准正交基则被称为标准正交矩阵<br>
正交矩阵可用于构造变换矩阵，对应的逆变换(逆矩阵计算复杂)可直接由转置矩阵得到。</p>
<p><strong>关于矢量变为行矩阵还是列矩阵</strong>：在U3D中将矢量放在矩阵右边进行相乘计算（当做列矩阵）。<br>
<img src="https://Wei715547.github.io/post-images/1617528382482.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1617528390964.PNG" alt="" loading="lazy"></p>
<p><strong>变换</strong><br>
线性变换：那些可以保留矢量相加标量相乘的变换。包括缩放、旋转、正交投影等。<br>
仿射变换：由于平移不是线性变换，因此仿射变换是合并线性变换和平移变换的变换类型。<br>
仿射变换可以使用4x4的矩阵来表示-齐次坐标空间：三维转四维：对于点w=1；对于矢量w=0(当平移作用于矢量时不会产生影响)<br>
<img src="https://Wei715547.github.io/post-images/1617529382160.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1617529442695.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1617529477199.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1617529549995.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1617529575805.PNG" alt="" loading="lazy"></p>
<p><strong>复合变换</strong>：矢量转为列矩阵计算，顺序从右到左<br>
<img src="https://Wei715547.github.io/post-images/1617530502589.PNG" alt="" loading="lazy"><br>
绝大多数下先进行缩放，再旋转，最后平移<br>
关于xyz轴的旋转顺序：U3D中的旋转顺序是z,x,y，但矩阵的计算顺序不需要从右到左(由于坐标系的旋转)<br>
<img src="https://Wei715547.github.io/post-images/1617530788048.PNG" alt="" loading="lazy"></p>
<p><strong>空间变换</strong><br>
模型空间-&gt;世界空间-&gt;观察空间-&gt;裁剪空间-&gt;屏幕空间NDC<br>
M：m-&gt;w变换矩阵 平移<em>旋转</em>缩放（移动整个坐标系坐标系中的点也跟随移动）<br>
<img src="https://Wei715547.github.io/post-images/1617778015972.PNG" alt="" loading="lazy"><br>
V：w-&gt;v变换矩阵 根据参数对相机进行逆变换移动到世界原点(对z取反)<br>
<img src="https://Wei715547.github.io/post-images/1617778125927.PNG" alt="" loading="lazy"><br>
P：<br>
透视投影，<br>
<img src="https://Wei715547.github.io/post-images/1617778934812.PNG" alt="" loading="lazy"><br>
正交投影。<br>
<img src="https://Wei715547.github.io/post-images/1617778988783.PNG" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Grass交互]]></title>
        <id>https://Wei715547.github.io/post/grass-jiao-hu/</id>
        <link href="https://Wei715547.github.io/post/grass-jiao-hu/">
        </link>
        <updated>2021-03-21T13:28:37.000Z</updated>
        <content type="html"><![CDATA[<p><a href = "https://www.bilibili.com/video/BV1kv411r7x2?p=3">视频</a><br>
色位置脚本<br>
private void Update()<br>
{<br>
grassMateral.SetVector(&quot;_PlayerPos&quot;, this.transform.position + Vector3.up * 0.5f);<br>
}<br>
<strong>————————————————————</strong><br>
Shader &quot;Unlit/Grass+Wind+Cashing&quot;<br>
{<br>
Properties<br>
{<br>
[HDR]_GrassColor(&quot;GrassColor&quot;, Color) = (1,1,1,1)          //控制草的颜色<br>
_SpecualarColor(&quot;SpecularColor&quot;, Color) = (1,1,1,1)          //控制草的高光颜色<br>
_Specular(&quot;_Specular&quot;, Range(0, 1)) = 1          //控制草的高光程度<br>
_Gloss(&quot;Gloss&quot;, Range(0,20)) = 1          //控制草的高光<br>
[HDR]_FresnelColor(&quot;FresnelColor&quot;, Color) = (1,1,1,1)          //控制草的边缘高光颜色<br>
_FresnelPower(&quot;FresnelPower&quot;, Range(0, 5)) = 1          //控制草的边缘高光程度<br>
_MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}          //草的颜色贴图<br>
_AlphaTex(&quot;AlphaTexture&quot;, 2D) = &quot;white&quot; {}          //草的透明贴图<br>
_GrassHeight(&quot;GrassHeight&quot;, Range(0.5, 5)) = 2.5          //控制草的高度<br>
_GrassWidth(&quot;GrassWidth&quot;, Range(0.001, 0.5)) = 0.05          //控制草的宽度<br>
_BladeForward(&quot;BladeForward&quot;, Range(0, 2)) = 1          //控制草的弯曲程度</p>
<pre><code>	_WindTex(&quot;WindTex&quot;, 2D) = &quot;white&quot; {}          //风的采样贴图
    _WindVector(&quot;WindVector&quot;, Vector) = (1,1,1,0)          //控制风的方向
    _WindTimeScale(&quot;WindTimeScale&quot;, float) = 1          //控制风的速度
    _WindTexMapSize(&quot;WindTexMapSize&quot;, float) = 80          //控制风的采样贴图大小
    _WindXZStrength(&quot;WindXZStrength&quot;, float) = 10          //控制风在草的XZ轴上的偏移
    _WindYStrength(&quot;WindYStrength&quot;, float) = 10          //控制风在草的Y轴上的偏移          */

	//交互
	_InteracRadius(&quot;InteracRadius&quot;,Range(0.5,20))=1
	_InteracStrength(&quot;InteracStrength&quot;,Range(0.5,20))=1
}

SubShader
{
    //存在顶点动画，所以要关闭批处理，DisableBatching 设置为 True
    Tags {
        &quot;RenderType&quot; = &quot;TransparentCutout&quot;
        &quot;IgnoreProjector&quot; = &quot;True&quot;
        &quot;Queue&quot; = &quot;AlphaTest&quot;
        &quot;DisableBatching&quot; = &quot;True&quot;
    }

    //设置为双面渲染，关闭背面剔除
    Cull Off
    LOD 100

    Pass
    {
        //设置为前向渲染模式
        Tags { &quot;LightMode&quot; = &quot;ForwardBase&quot; }
        Cull Off
        AlphaToMask On

        CGPROGRAM
        //引入头文件
        #include &quot;UnityCG.cginc&quot;
        #include &quot;Lighting.cginc&quot;
        #include &quot;AutoLight.cginc&quot;

        //要应用几何着色器必须要将编译目标设置为 4.0 
        #pragma target 4.0
        #pragma multi_compile_fwdbase
        #pragma vertex vert
        #pragma fragment frag
        //定义几何着色器
        #pragma geometry geom
		
        fixed4 _GrassColor;
        fixed4 _SpecualarColor;
        fixed _Specular;
        float _Gloss;
        fixed4 _FresnelColor;
        half _FresnelPower;
        sampler2D _MainTex;
        float4 _MainTex_ST;
        sampler2D _AlphaTex;
        fixed _GrassHeight;
        fixed _GrassWidth;
		fixed _BladeForward;

		sampler2D _WindTex;
        float4 _WindTex_ST;
        half4 _WindVector;
        half _WindTimeScale;
        float _WindTexMapSize;
        half _WindXZStrength;
        half _WindYStrength;

		float4 _PlayerPos;
		half _InteracRadius;
		half _InteracStrength;

        struct a2v {
            float4 pos : POSITION;
            float3 normal : NORMAL;
            float2 uv : TEXCOORD0;
        };

        //顶点着色器传给几何着色器的数据结构
        struct v2g {
            float4 pos : POSITION;
            float3 normal : NORMAL;
            float2 uv : TEXCOORD0;
        };

        //几何着色器传给片元着色器的数据结构
        struct g2f {
            float4 pos : SV_POSITION;
            float3 normal : NORMAL;
            float2 uv : TEXCOORD0;
            float3 worldPos : TEXCOORD1;
        };

		static const float oscillateDelta = 0.05;

        //顶点着色器
        //直接将从网格得到的数据传给传入几何着色器的结构体 v2g
        v2g vert(a2v v) {
            v2g o;
            o.pos = v.pos;
            o.normal = v.normal;
            o.uv = v.uv;
            return o;
        }

        //创建 CreatG2fOut() 函数
        //初始化从几何着色器传入片元着色器的结构体 g2f
        g2f CreatG2fOut() {
            g2f output;
            output.pos = float4(0, 0, 0, 0);
            output.normal = float3(0, 0, 0);
            output.uv = float2(0, 0);
            output.worldPos = float3(0, 0, 0);
            return output;
        }

        g2f GetVertex(float4 pos, float3 normal, float2 uv) {
            g2f output;

            output.pos = UnityObjectToClipPos(pos);    
            output.normal = UnityObjectToWorldNormal(normal);
            output.uv = uv;
            output.worldPos = UnityObjectToWorldDir(pos);

            return output;
        }

        //几何着色器
        [maxvertexcount(30)]//限制几何着色器输出的最大顶点数目。每当输入一个图元，几何着色器可以输出 0~N 个图元。不论是什么结构的图元都是由顶点构成的，而这个语句就是用来限制输出最大的顶点数量（只要小于等于这个数量就可以，多余的顶点会被剔除）
        void geom(point v2g points[1], inout TriangleStream&lt;g2f&gt; triStream) {

            //顶点着色器输入的顶点位置
            float4 root = points[0].pos;

            //生成一个伪随机数
            float random = sin(UNITY_HALF_PI * frac(root.x) + UNITY_HALF_PI * frac(root.z));
            //给每根草的长宽加上这个随机值，我们希望草的宽度不要太宽或者太窄
            _GrassWidth = _GrassWidth + (random / 50);
            _GrassHeight = _GrassHeight + (random / 5);

            //设置草的网格顶点一共有12个
            const int vertexCount = 12;

            //创建12个 g2f 输出数组
            g2f v[vertexCount] = {
                CreatG2fOut(), CreatG2fOut(), CreatG2fOut(), CreatG2fOut(),
                CreatG2fOut(), CreatG2fOut(), CreatG2fOut(), CreatG2fOut(),
                CreatG2fOut(), CreatG2fOut(), CreatG2fOut(), CreatG2fOut()
            };

            //初始化每个顶点的位置 pos 和 uv
            float4 pos = float4(0, 0, 0, 0);
            float2 uv = float2(0, 0);

            //顶点的 UV 在竖直方向上的当前值和偏移值
            float currentV = 0;
            float offsetV = 1.0 / (vertexCount / 2 - 1);

            //顶点的 y 坐标在竖直方向上的当前值的偏移值
            float currentVertexHeight = 0;
            float currentHeightOffset = 0;
            float verticalEff = 0;
			
			//BlendCood
			//让草绕着自身的 y 轴进行旋转
            //生成一个随机角度
            fixed randomAngle = frac(sin(root.x)*10000.0) * UNITY_HALF_PI;

            //根据矩阵旋转的定理，分别创建旋转矩阵
            //平移矩阵，先将所有点平移到原点
            float4x4 firstTransformMatrix = float4x4(
                1.0, 0.0, 0.0, -root.x,
                0.0, 1.0, 0.0, -root.y,
                0.0, 0.0, 1.0, -root.z,
                0.0, 0.0, 0.0, 1.0
                );

            //旋转矩阵
            float4x4 rotateMatrix = float4x4(
                cos(randomAngle), 0, sin(randomAngle), 0,
                0, 1, 0, 0,
                -sin(randomAngle), 0, cos(randomAngle), 0,
                0, 0, 0, 1
                );

            //再平移回去
            float4x4 lastTransformMatrix = float4x4(
                1.0, 0.0, 0.0, root.x,
                0.0, 1.0, 0.0, root.y,
                0.0, 0.0, 1.0, root.z,
                0.0, 0.0, 0.0, 1.0
                );
				//BlendCood

            //进行生成全部草顶点的循环
            for (int i = 0; i &lt; vertexCount; i++)
            {
                //fmod(a,b) 返回 a 除 b 的余数
                //如果返回值为偶数，顶点 UV 坐标均为(0,V)
                if (fmod(i, 2) == 0) {
                    pos = float4(root.x - _GrassWidth, root.y + currentVertexHeight, root.z, 1);
                    uv = fixed2(0, currentV) * _MainTex_ST.xy + _MainTex_ST.zw;
                }
                else {
                    pos = float4(root.x + _GrassWidth, root.y + currentVertexHeight, root.z, 1);
                    uv = fixed2(1, currentV) * _MainTex_ST.xy + _MainTex_ST.zw;

                    currentV += offsetV;
                    currentVertexHeight += currentV * _GrassHeight;
                }
				 //对顶点 XZ 轴进行偏移
                float2 randomDir = float2(sin((random * 15)), sin((random * 10)));
                float2 forward = (sin((root.x * 10 + root.z / 5) * random)* verticalEff + randomDir * sin((random * 15)))* verticalEff;
                pos.xz += forward * _BladeForward;
                if (fmod(i, 2) == 1) {
                    verticalEff += offsetV;
                }

                //对顶点 Y 轴进行旋转
                //pos = mul(lastTransformMatrix, mul(rotateMatrix, mul(firstTransformMatrix, pos)));

                 //对顶点 Y 轴进行旋转
                pos = mul(lastTransformMatrix, mul(rotateMatrix, mul(firstTransformMatrix, pos)));
				
				//交互
				//--与玩家的交互
				float3 worldPos = mul(unity_ObjectToWorld, pos).xyz;
                //每根草的顶点与玩家的距离
                float3 dis = distance(_PlayerPos, worldPos);
                //将这段距离由进到远的范围缩小为 0~1
                float3 circle = 1 - saturate(dis / _InteracRadius);
                //每根草的顶点倒下的方向
                float3 dir = normalize(worldPos - _PlayerPos);
                float3 strength = dir * circle;
                //XZ 轴上的移动
                pos.xz += strength * _InteracStrength * uv.y;
                //Y 轴上的移动
                float2 InterOffsetXZ = strength * _InteracStrength * uv.y;
                pos.y -= pos.y - sqrt(pos.y * pos.y - (InterOffsetXZ.x * InterOffsetXZ.x + InterOffsetXZ.y * InterOffsetXZ.y));
				
				/*/风随机偏移
				float2 wind = float2(sin(_Time.x * UNITY_PI * 5), sin(_Time.x * UNITY_PI * 5));
				wind.x += (sin(_Time.x + root.x / 25) + sin((_Time.x + root.x / 15) + 50)) * 0.5;
				wind.y += cos(_Time.x + root.z / 80);
				wind *= lerp(0.7, 1.0, 1.0 - random);

				float oscillationStrength = 2.5f;
				float sinSkewCoeff = random;
				float lerpCoeff = (sin(oscillationStrength * _Time.x + sinSkewCoeff) + 1.0) / 2;
				float2 leftWindBound = wind * (1.0 - oscillateDelta);
				float2 rightWindBound = wind * (1.0 + oscillateDelta);

				wind = lerp(leftWindBound, rightWindBound, lerpCoeff);

				float randomAngle = lerp(-UNITY_PI, UNITY_PI, random);
				float randomMagnitude = lerp(0, 1., random);
				float2 randomWindDir = float2(sin(randomAngle), cos(randomAngle));
				wind += randomWindDir * randomMagnitude;

				float windForce = length(wind);

				pos.xz += wind.xy * verticalEff;
				pos.y -= windForce * verticalEff * 0.8;

				pos = UnityObjectToClipPos(pos);

				if (fmod(i, 2) == 1) {

					verticalEff += offsetV;
				}*/
                //--风
                //将世界坐标下的风的方向转化为局部坐标
                float4 localWindDir = normalize(mul(unity_WorldToObject, _WindVector));
                //控制风速（实际上为采样 uv 的移动速度）
                float time = (_Time.y)*(_WindTimeScale);
                //对风贴图进行采样
                half4 rootWorldPos = mul(unity_ObjectToWorld, root);
                //windmutation 一直在 0~1 之间变化 
                float windmutation = 1 - tex2Dlod(_WindTex, float4(rootWorldPos.x / _WindTexMapSize + time, rootWorldPos.z / _WindTexMapSize, 0, 0)).g;
                //sin(time + windmutation * 10) * cos(time * 2 / 3 + 1 + windmutation * 10) -1~1
                //localWindDir.xz 控制风的方向
                //clamp(uv.y - 0.1, 0, 1) UV.y 范围在 0.1 以下的顶点不发生移动 
                //xz 轴上的偏移
                half2 xzOffset = sin(time + windmutation * 10) * cos(time * 2 / 3 + 1 + windmutation * 10) * localWindDir.xz * clamp(uv.y - 0.1, 0, 1);
                pos.xz += xzOffset * _WindXZStrength;
                //根据 XZ 轴上的偏移算出在 Y 轴上
                //直角三角形定理
                //Y轴的偏移
                half yOffset = pos.y - sqrt(pos.y * pos.y - (xzOffset.x * xzOffset.x + xzOffset.y * xzOffset.y));
                pos.y -= yOffset * _WindYStrength * clamp(uv.y - 0.35, 0, 1);
				
                //pos.xz += sin(_Time.y * _WindTimeScale) * uv.y;

                v[i] = GetVertex(pos, points[0].normal, uv);


            }

            //inout TriangleStream&lt;g2f&gt; triStream 输出三角形，即三个顶点数据
            //将每三个顶点转化为三角形输出到片元着色器
            for (int p = 0; p &lt; (vertexCount - 2); p++)
            {
                //triStream.Append(vertex); 该方法将输入的三个顶点自动构建成三角形
                triStream.Append(v[p]);
                triStream.Append(v[p + 2]);
                triStream.Append(v[p + 1]);
            }
        }

        //片元着色器
        //简单的 Blin-Phong 光照模型
        float4 frag(g2f i) : SV_Target{

            //对_MainTex纹理和_AlphaTex纹理进行采样
            fixed4 texColor = tex2D(_MainTex, i.uv);
            fixed alpha = tex2D(_AlphaTex, i.uv).a;

            //将法线归一化
            float3 worldNormal = normalize(i.normal);
            float3 worldSpecNormal = worldNormal;
            worldNormal = worldNormal * 0.5 + 0.5;

            //得到环境光
            fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;
            //得到世界空间下光照方向
            fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));

            //Diffuse 漫反射颜色
            fixed NdotL = saturate(dot(worldNormal, worldLightDir));
            fixed3 diffuse = _LightColor0.rgb * NdotL;

            //Specular 高光颜色
            //得到世界空间下的视线方向
            fixed3 worldViewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));
            //得到半角向量
            fixed3 halfDir = normalize(worldLightDir + worldViewDir);
            fixed3 NdotH = saturate(dot(worldSpecNormal, halfDir));
            float spec = pow(NdotH, _Specular * 128.0) * _Gloss;
            fixed3 specular = _SpecualarColor * _LightColor0.rgb * spec;

            //Fresnel
            fixed fresnel = saturate(1 - dot(worldSpecNormal, worldViewDir));
            //fresnel = clamp(fresnel - 0.2, 0, 1);
            fresnel = pow(fresnel, _FresnelPower) * clamp(i.uv.y - 0.5, 0, i.uv.y);
            fixed3 fresnelColor =	 fresnel * _FresnelColor;

            //得到并输出最终颜色
            fixed3 finalColor = ambient + diffuse + specular;
            return fixed4(texColor * _GrassColor.rgb * finalColor, alpha);
            //return fixed4(worldNormal, alpha);
        }
        ENDCG
    }
}
FallBack &quot;Diffuse&quot;
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[渲染管线]]></title>
        <id>https://Wei715547.github.io/post/xuan-ran-guan-xian/</id>
        <link href="https://Wei715547.github.io/post/xuan-ran-guan-xian/">
        </link>
        <updated>2021-03-19T07:04:00.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://Wei715547.github.io/post-images/1617077796123.jpg" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1616211232568.png" alt="" loading="lazy"><br>
<a href = "https://b23.tv/BV1L54y1s7xw/p2">渲染管线参考视频</a><br>
一、应用程序:-准备基本场景数据-加速算法粗粒度剔除-设置渲染状态-调用DrawCall输出渲染图元到显存<br>
1.基本场景数据包括：物体位置/网格；光源信息类型/位置（设置阴影逐光源绘制阴影贴图）；相机参数<br>
2.加速算法粗粒度剔除：可见光裁剪；可见场景裁剪（八叉树，BSP/K——D树，BVH）<br>
3.渲染设置：绘制设置（使用着色器，合批方式）；绘制物体顺序（相对摄像机距离，渲染队列，UI设置）渲染目标（输出到帧缓存或渲染贴图）；渲染模式（前项渲染/延迟渲染）<br>
/*<br>
1.CPU将数据加载到显存：顶点位置信息，法线方向，顶点颜色，uv坐标<br>
2.设置渲染状态：使用哪个顶点着色器，片元着色器，光源属性材质等<br>
3.调用Draw Call：由CPU发起命令GPU渲染图像。指向一个需要被渲染的图元列表(以传入显存中)。<br>
*/<br>
二、几何阶段：顶点着色器-曲面细分着色器-几何着色器-投影-裁剪-屏幕映射<br>
其中曲面，几何着色器可选分别用于细分图元，着色或产生新图元（网格细分/粒子点生成新图元）。。最后屏幕映射，将顶点坐标转换到屏幕坐标系中。<br>
顶点着色器：将顶点坐标从模型空间转换到齐次裁剪空间<br>
如：v2f.pos = UnityObjectToClipPos(a2v.pos);  或  mul(UNITY_MVP, a2v.pos)//通过MVP矩阵转换得到齐次裁剪坐标，<br>
投影：再由硬件做透视除法，得到设备坐标NDC（OpenGL中z分量[-1,1]，DX中[0,1]）。<br>
裁剪：CVV剔除视平面外的顶点，正面/背面剔除可配置<br>
屏幕映射：将每个图元的x,y坐标（不对z进行操作）转换到屏幕坐标系下/OpenGL从左下到右上，DX从左上到右下，实际上屏幕坐标系与z坐标组成窗口坐标系，这些值一起被传递到光栅化阶段。</p>
<p>三、光栅化阶段：三角形设置-三角形遍历-片元着色器-逐片元操作（计算每个图元覆盖了那些像素，计算着些像素的颜色）<br>
三角形设置：计算光栅化一个三角形所需的信息<br>
三角形遍历：检查每个像素是否被一个三角形覆盖，如果都被一个三角形所覆盖，就会生成一个片元。同时也会根据三个顶点信息对所覆盖的像素的深度插值计算。这一阶段也称扫描变换。即输出是一系列片元序列（包含很多状态集合：屏幕坐标，深度信息及顶点信息）。（抗锯齿MSAA：1.SSAA：渲染到放大n倍的buffer然后对其采样。2.MSAA：只有此方式在光栅化阶段，计算多个覆盖样本。3.FXAA/TXAA：后处理技术不再此阶段）<br>
片元着色器：颜色插值，纹理采样（此时的片元并不是真正意义上的像素）<br>
逐片元操作(输出合并阶段)：主要进行片元可见性判断和颜色混合<br>
透明测试：有时会与提前测试发生冲突。API:clip(tex.r-_Cutoff);<br>
模板测试：（蒙版/遮罩）<br>
<a href="https://b23.tv/BV1NJ41167Ec">参考视频</a><br>
<img src="https://Wei715547.github.io/post-images/1616214031623.jpg" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1616214040771.jpg" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1616214048833.jpg" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1616214055096.jpg" alt="" loading="lazy"><br>
深度测试：（可以指定是否开启深度测试与深度写入）与深度缓冲区中的值进行对比，小于深度缓冲中的值(更近)时有权利是否写入Z-Buffer。（Early-Z提前执行）<br>
合并：得到的目标颜色根据是否进行混合，半透明物体-与颜色缓冲区中的颜色值进行混合得到新颜色，或直接覆盖原颜色缓冲区中的颜色。</p>
]]></content>
    </entry>
</feed>