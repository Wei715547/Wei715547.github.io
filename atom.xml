<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Wei715547.github.io</id>
    <title>WeiBlog</title>
    <updated>2020-09-17T08:08:06.805Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Wei715547.github.io"/>
    <link rel="self" href="https://Wei715547.github.io/atom.xml"/>
    <subtitle>年月增长，我宜强盛。
用于Unity+开发的技术积累</subtitle>
    <logo>https://Wei715547.github.io/images/avatar.png</logo>
    <icon>https://Wei715547.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, WeiBlog</rights>
    <entry>
        <title type="html"><![CDATA[Lua面向对象实现]]></title>
        <id>https://Wei715547.github.io/post/lua-mian-xiang-dui-xiang-shi-xian/</id>
        <link href="https://Wei715547.github.io/post/lua-mian-xiang-dui-xiang-shi-xian/">
        </link>
        <updated>2020-09-16T09:28:03.000Z</updated>
        <content type="html"><![CDATA[<p><cood>print(&quot;<strong><strong><strong><strong><strong><strong>封装</strong></strong></strong></strong></strong></strong>__&quot;)<br>
Object = {}<br>
Object.ID = 1<br>
function Object:Text()--&quot;:&quot;自动传入调用这个函数的对象，作为第一个参数传入方法<br>
print(self.ID)--“self”代表默认传入的第一个参数<br>
end</p>
<p>function Object:new( )--类用于创建对象的方法--构造函数<br>
--function Object:new(o)--充当构造函数，返回空表，将本身设为空表的原表来继承类的属性与函数<br>
--local obj= o or {}--o填写时在填入子类的属性/函数基础上创建对象，不填时为空继承父类默认所有属性/函数创建对象（）p1 = Object:new(weight = 100) 或 p1 = Object:new()<br>
local obj = {}<br>
--原表的__index指向自身<br>
self.__index =self--__index:当在自己的表中找不到目标属性时，就会在元表的__index中寻找<br>
setmetatable(obj ,self)<br>
--setmetatable (obj,{__index=self})--与上两句作用相同<br>
return obj<br>
end</p>
<p>local myObj = Object:new()<br>
print(myObj)<br>
print(myObj.ID)<br>
myObj:Text()--myObj调用则传入myObj</p>
<p>print(&quot;_<strong><strong><strong><strong><strong><strong><strong><strong>继承</strong></strong></strong></strong></strong></strong></strong></strong>&quot;)</p>
<p>--构造用于继承的方法<br>
function Object:subClass(className)--声明类的方法<br>
--_G表存储所有的全局变量<br>
_G[className] = {}<br>
local obj = _G[className]<br>
self.__index = self<br>
--为子类定义一个父类属性base<br>
obj.base = self<br>
setmetatable(obj,self)<br>
end</p>
<p>Object:subClass(&quot;Person&quot;)<br>
--print(Person)--此时是通过类名访问属性，类似静态变量<br>
--Person:Text()<br>
--通过对象访问属性<br>
local p1 = Person:new ()--Person继承自Object的new方法。self使Person为第一变量传入<br>
p1:Text()--原表中不存在，会继续查找原表的原表</p>
<p>print(&quot;____________多态————————————————————————————&quot;)</p>
<p>Object:subClass(&quot;GameObject&quot;)--声明游戏对象类<br>
GameObject.posX = 0<br>
GameObject.posY = 0<br>
function GameObject:Move()<br>
self .posX = self.posX+1<br>
self.posY = self.posY+1<br>
print(self.posX)<br>
print(self.posX)</p>
<p>end</p>
<p>GameObject:subClass(&quot;Player&quot;)--声明角色类</p>
<p>function Player:Move()--与父类方法“重名&quot;即相当于重写方法<br>
--此时base指GameObject类，使用“：”调用相当于把基类作为第一参数传入方法中，则此时创建pl2时会输出2，2<br>
--self.base:Move()<br>
--因此为了避免把基类表传入方法中，不使用“：”调用<br>
self.base.Move(self)--使用.进行调用自行填入第一个传入的参数<br>
print(&quot;子类重写&quot;)<br>
end</p>
<p>local pl1 = Player:new()--角色类对象<br>
pl1:Move()</p>
<p>local pl2 = Player:new()<br>
pl2:Move()<cood></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Grass批量生成]]></title>
        <id>https://Wei715547.github.io/post/grass-pi-liang-sheng-cheng/</id>
        <link href="https://Wei715547.github.io/post/grass-pi-liang-sheng-cheng/">
        </link>
        <updated>2020-09-14T15:09:33.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://Wei715547.github.io/post-images/1600096518618.PNG" alt="" loading="lazy"><br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
[ExecuteInEditMode]<br>
public class ProceduralGrass : MonoBehaviour<br>
{<br>
#region Terrain Data<br>
[Range(0, 1000)]<br>
public int terrainSize = 250;          //地形大小<br>
[Range(0, 100f)]<br>
public float terrainHeight = 10f;          //地形高度<br>
public Material terrainMat;          //地形材质</p>
<pre><code>private float xOffset;
private float zOffset;

[Range(1f, 100f)]
public float scaleFatter = 10f;          //地形缩放
[Range(1f, 100f)]
public float offsetFatter = 10f;          //地形偏移

List&lt;Vector3&gt; vertexs = new List&lt;Vector3&gt;();          //顶点列表，存储网格顶点信息
List&lt;int&gt; triangles = new List&lt;int&gt;();          //三角形面列表，存储网格三角形信息
float[,] perlinNoise;          //存储每个顶点的高度值

Vector3[] terrainNormals;          //存储地形的顶点法线的一维数组
Vector3[,] terrainNormals2D;          //存储地形的顶点法线的二维数组
#endregion 
//___________________________________________________________________________
#region Grass Data
[Range(0, 100)]
public int grassRowCount = 50;          //草根集,定义草的广度
[Range(1, 1000)]
public int grassCountPerPatch = 100;          //定义每一堆 草根集 的草密度
public Material grassMat;           //草的材质
public Mesh grassMesh;          //草的网格
List&lt;Vector3&gt; grassVerts = new List&lt;Vector3&gt;();          //存储草的顶点

Vector3[] grassNormals;          //存储草的顶点法线
List&lt;Vector3&gt; grassNormalList = new List&lt;Vector3&gt;();          //存储草的顶点法线列表
#endregion

void Start()
{
    xOffset = transform.position.x;
    zOffset = transform.position.z;
    terrainNormals = new Vector3[terrainSize * terrainSize];//顶点法线数组容量250*250
    terrainNormals2D = new Vector3[terrainSize, terrainSize];//2D顶点法线数组容量250*250
    perlinNoise = new float[terrainSize, terrainSize];//顶点高度数组容量250*250
    GenerateTerrain();//生成地形

    GenerateGrassArea(grassRowCount, grassCountPerPatch);//生成草地（广度，密度）

    
}

void CreateVertsAndTris()
{
    //遍历每一个顶点，并用列表 vertexs 和 triangles 存储
    for (int i = 0; i &lt; terrainSize; i++)
    {
        for (int j = 0; j &lt; terrainSize; j++)
        {
            float noiseHeight = GeneratePerlinNoise(i, j);//顶点随机高度
            perlinNoise[i, j] = noiseHeight;//该坐标下的顶点高度存入数组

            vertexs.Add(new Vector3(i, noiseHeight * terrainHeight, j));//顶点坐标（x,y,z）

            //不算上坐标轴的顶点
            if (i == 0 || j == 0)
                continue;

            //每三个顶点作为一个索引建立三角形
            triangles.Add(terrainSize * i + j);
            triangles.Add(terrainSize * i + j - 1);
            triangles.Add(terrainSize * (i - 1) + j - 1);
            triangles.Add(terrainSize * (i - 1) + j - 1);
            triangles.Add(terrainSize * (i - 1) + j);
            triangles.Add(terrainSize * i + j);
        }
    }

    //清空grassVerts的数据    
    grassVerts.Clear();
}

//生成地形高度的随机 Perlin 值
float GeneratePerlinNoise(int i, int j)
{
    float xCoord = (float)(i + xOffset) / terrainSize * scaleFatter + offsetFatter;
    float zCoord = (float)(j + zOffset) / terrainSize * scaleFatter + offsetFatter;

    return Mathf.PerlinNoise(xCoord, zCoord);
}

//生成地形网格数据
void GenerateTerrain()
{
    CreateVertsAndTris();

    //计算UV(二维向量-顶点坐标作为法线方向)
    Vector2[] uvs = new Vector2[vertexs.Count];
    for (int i = 0; i &lt; vertexs.Count; i++)
    {
        uvs[i] = new Vector2(vertexs[i].x, vertexs[i].z);
    }

    //添加一个 MyTerrain 的物体，并添加 MeshFilter / MeshRenderer 两个组件
    //MeshFilter 存储物体的网格信息
    //MeshRenderer 负责接收这些信息并把这些信息渲染出来
    GameObject Myterrain = new GameObject(&quot;Terrain0&quot;);
    Myterrain.transform.position = this.gameObject.transform.position;
    Myterrain.AddComponent&lt;MeshFilter&gt;();
    MeshRenderer renderer = Myterrain.AddComponent&lt;MeshRenderer&gt;();
    //开启地面的阴影投射和接受
    renderer.receiveShadows = true;
    renderer.shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.On;
    //添加Mesh Collider
    MeshCollider collider = Myterrain.AddComponent&lt;MeshCollider&gt;();

    //添加材质
    renderer.sharedMaterial = terrainMat;

    //创建一个 Mesh 网格
    Mesh groundMesh = new Mesh//网格构造函数
    {
        //输入网格顶点数据
        vertices = vertexs.ToArray(),
        //输入网格三角面数据
        triangles = triangles.ToArray(),
        uv = uvs
    };

    //为了得到正确的光照需要重新计算得到正确的法线信息
    groundMesh.RecalculateNormals();
    terrainNormals = groundMesh.normals;

    //将存储地形法线数组从一维数组转为二维，便于索引
    for (int i = 0; i &lt; terrainSize; i++)
    {
        for (int j = 0; j &lt; terrainSize; j++)
        {
            terrainNormals2D[i, j] = terrainNormals[i * terrainSize + j];
        }
    }
    //网格赋值到渲染器/碰撞体
    Myterrain.GetComponent&lt;MeshFilter&gt;().mesh = groundMesh;
    collider.sharedMesh = groundMesh;
}

void GenerateGrassArea(int rowCount, int perPatchSize)
{
    //最大顶点数为 65000
    List&lt;int&gt; indices = new List&lt;int&gt;();
    for (int i = 0; i &lt; 65000; i++)
    {
        indices.Add(i);
    }

    //初始位置
    Vector3 currentPos = transform.position;
    //草根集 每一次循环偏移的距离
    Vector3 patchSize = new Vector3(terrainSize / rowCount, 0, terrainSize / rowCount);

    //每一堆 草根集 进行循环
    for (int i = 0; i &lt; rowCount; i++)
    {
        for (int j = 0; j &lt; rowCount; j++)
        {
            GenerateGrass(currentPos, patchSize, perPatchSize);
            currentPos.x += patchSize.x;
        }
        currentPos.x = transform.position.x;
        currentPos.z += patchSize.z;
    }

    //生成 GrassLayerGruop 来成为父级管理物理
    GameObject grassLayerGroup1 = new GameObject(&quot;GrassLayerGroup1&quot;);
    //生成 GrassLayer 物体来存储草数据
    GameObject grassLayer;
    MeshFilter grassMeshFilter;
    //Mesh grassMesh;
    MeshRenderer grassMeshRenderer;
    int a = 0;

    //当 grassVerts.Count 的数量即草的全部顶点数超过 65000 个时
    //创立多个网格处理
    while (grassVerts.Count &gt; 65000)
    {
        Debug.Log(&quot;More65000&quot;);
        grassMesh = new Mesh();
        grassMesh.vertices = grassVerts.GetRange(0, 65000).ToArray();
        //存储每个草顶点的法线（当顶点超过 65000个）
        grassNormals = new Vector3[65000];
        grassNormalList.GetRange(0, 65000);
        for (int i = 0; i &lt; 65000; i++)
        {
            grassNormals[i] = grassNormalList[i];
        }

        //设置子网格的索引缓冲区,相关官方文档：https://docs.unity3d.com/ScriptReference/Mesh.SetIndices.html
        //每一个创建的网格的顶点数目不会超过 65000 个
        grassMesh.SetIndices(indices.ToArray(), MeshTopology.Points, 0);

        //创建一个新的 GameObject 来承载这些点
        grassLayer = new GameObject(&quot;GrassLayer &quot; + a++);
        grassLayer.transform.SetParent(grassLayerGroup1.transform);
        grassMeshFilter = grassLayer.AddComponent&lt;MeshFilter&gt;();
        grassMeshRenderer = grassLayer.AddComponent&lt;MeshRenderer&gt;();
        //关闭草地的阴影投射和接受
        grassMeshRenderer.receiveShadows = false;
        grassMeshRenderer.shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.Off;
        grassMeshRenderer.sharedMaterial = grassMat;
        grassMesh.normals = grassNormals;
        grassMeshFilter.mesh = grassMesh;
        //移除前 65000 个顶点
        grassVerts.RemoveRange(0, 65000);
        grassNormalList.RemoveRange(0, 65000);
    }
    #region 草的数量少于6500时
    //当 grassVerts.Count 的数量即草的全部顶点数没有超过 65000 个时
    grassLayer = new GameObject(&quot;GrassLayer&quot; + a);
    grassLayer.transform.SetParent(grassLayerGroup1.transform);
    grassMeshFilter = grassLayer.AddComponent&lt;MeshFilter&gt;();
    grassMeshRenderer = grassLayer.AddComponent&lt;MeshRenderer&gt;();
    
    //关闭草地的阴影投射和接受
    grassMeshRenderer.receiveShadows = false;
    grassMeshRenderer.shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.Off;
    grassMesh = new Mesh
    {
        vertices = grassVerts.ToArray()
    };

    //存储每个草顶点的法线（当顶点没有超过 65000个）
    grassNormals = new Vector3[grassMesh.vertexCount];
    grassNormalList.GetRange(0, grassMesh.vertexCount);
    for (int i = 0; i &lt; grassMesh.vertexCount; i++)
    {
        grassNormals[i] = grassNormalList[i];
    }
    grassMesh.normals = grassNormals;
    //设立子网格数据
    grassMesh.SetIndices(indices.GetRange(0, grassVerts.Count).ToArray(), MeshTopology.Points, 0);

    grassMeshFilter.mesh = grassMesh;
    grassMeshRenderer.sharedMaterial = grassMat;
    #endregion
}

//生成草
void GenerateGrass(Vector3 vertPos, Vector3 patchSize, int grassCountPerPatch)
{
    //每一堆 草根集 里的草进行循环
    for (int i = 0; i &lt; grassCountPerPatch; i++)
    {
        //Random.value 返回 0~1 之间的随机值
        //得到在两个 草根集 之间的草的随机位置并用索引值
        float randomX = Random.value * patchSize.x;
        float randomZ = Random.value * patchSize.z;

        int indexX = (int)((vertPos.x - transform.position.x) + randomX);
        int indexZ = (int)((vertPos.z - transform.position.z) + randomZ);

        //防止草种出地形
        if (indexX &gt;= terrainSize)
        {
            Debug.Log(&quot;Full&quot;);
            indexX = (int)terrainSize - 1;
        }

        if (indexZ &gt;= terrainSize)
        {
            Debug.Log(&quot;Full&quot;);
            indexZ = (int)terrainSize - 1;
        }

        //添加每一个草的顶点位置到 grassVert 列表里
        grassVerts.Add(new Vector3(vertPos.x + randomX, perlinNoise[indexX, indexZ] * terrainHeight, vertPos.z + randomZ));//包括草地Mesh网格顶点高度值

        //添加每一个草的顶点法线到 grassNormalList 列表里
        grassNormalList.Add(terrainNormals2D[indexX, indexZ]);//草地Mesh网格顶点法线，与同坐标的地面网格法线相同
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unet局域网连接]]></title>
        <id>https://Wei715547.github.io/post/unet-ju-yu-wang-lian-jie/</id>
        <link href="https://Wei715547.github.io/post/unet-ju-yu-wang-lian-jie/">
        </link>
        <updated>2020-09-12T03:14:28.000Z</updated>
        <content type="html"><![CDATA[<p>NetWorkManager:<br>
<img src="https://Wei715547.github.io/post-images/1599881098982.PNG" alt="" loading="lazy"></p>
<p>Player:<br>
<img src="https://Wei715547.github.io/post-images/1599881197525.PNG" alt="" loading="lazy"><br>
PlayerCT Cood:<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.Networking;</p>
<p>//[System.Obsolete]<br>
public class PlayerCT : NetworkBehaviour<br>
{</p>
<pre><code>public int rotateSpeed = 120;
public int moveSpeed = 3;

public GameObject Bullet;
public Transform firePoint;

// Update is called once per frame
void Update()
{
    if (isLocalPlayer == false)//控制本地角色
        return;
    float h = Input.GetAxis(&quot;Horizontal&quot;);
    float v = Input.GetAxis(&quot;Vertical&quot;);

    transform.Rotate(Vector3.up * h * rotateSpeed * Time.deltaTime); 
    transform.Translate(Vector3.forward * v * moveSpeed * Time.deltaTime);

    if (Input.GetKeyDown(KeyCode.Space))
    {
        CmdFire();
    }

}
[Command]//客户端发起调用，服务端执行
void CmdFire()//服务端调用的方法以Cmd开头
{
    GameObject bullet = Instantiate(Bullet, firePoint.position, firePoint.rotation);
    bullet.GetComponent&lt;Rigidbody&gt;().velocity = transform.forward * 10;//Bulet预制体添加Network Transform监测刚体组件（初始监测一次施加速度）
    Destroy(bullet, 2f);//2s后销毁

    NetworkServer.Spawn(bullet);//服务端执行同步到客户端
}

public override void OnStartLocalPlayer()//回调函数：加角色时执行
{
    GetComponent&lt;MeshRenderer&gt;().material.color = Color.blue;
    //firePoint = transform.Find(&quot;FirePoint&quot;).GetComponent&lt;Transform&gt;();
}
</code></pre>
<p>}</p>
<hr>
<p>Player Health Cood:<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.UI;<br>
using UnityEngine.Networking;</p>
<p>[System.Obsolete]<br>
public class Health : NetworkBehaviour<br>
{<br>
private Slider hpSl;<br>
public const int hp = 100;<br>
[SyncVar(hook =&quot;OnChangeHealth&quot;)]//特性：变量数据同步到客户端，变量变化时调用方法“方法名”<br>
private int currentHp = hp;<br>
private void Start()<br>
{<br>
hpSl = transform.Find(&quot;Canvas/HpSlider&quot;).GetComponent <Slider >();</p>
<pre><code>}
public void TakeDamage(int damege)
{
    if (isServer == false)//服务端执行，同步到客户端
        return;
    currentHp -= damege;
    if (currentHp &lt;=0)
    {
        currentHp = hp;
        Debug.Log(&quot;Dead&quot;);
        //Destroy(this.gameObject);
        RpcRespown();//角色复位
    }
    
}
void OnChangeHealth(int health)//[SyncVar hook=&quot;方法&quot;]特性标记的变量值发生变化时执行
{
    hpSl.value = health / (float)hp;
}
[ClientRpc]//客户端调用
void RpcRespown()//客户端调用以Rpc开头
{
    if (isLocalPlayer == false)//本地角色执行
        return;
    transform.position = Vector3.zero;
}
</code></pre>
<p>}</p>
<hr>
<p><img src="https://Wei715547.github.io/post-images/1599881655946.PNG" alt="" loading="lazy"><br>
Bullet Cood:<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class Bullet : MonoBehaviour<br>
{<br>
[System.Obsolete]<br>
private void OnCollisionEnter(Collision collision)<br>
{<br>
GameObject hit = collision.gameObject;<br>
Health health = hit.GetComponent<Health>();<br>
if (health !=null)<br>
{<br>
health.TakeDamage(Random.Range(10, 21));<br>
Destroy(this.gameObject);<br>
}<br>
}<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shader,屏幕后处理(Post Effect)]]></title>
        <id>https://Wei715547.github.io/post/shaderping-mu-hou-chu-li-post-effect/</id>
        <link href="https://Wei715547.github.io/post/shaderping-mu-hou-chu-li-post-effect/">
        </link>
        <updated>2020-09-08T07:34:21.000Z</updated>
        <content type="html"><![CDATA[<p>挂在主相机上的脚本：<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
[ExecuteInEditMode]//在编译器下执行脚本（不用点击开始即执行）<br>
public class Post : MonoBehaviour<br>
{<br>
public Material EffectMat;//承载后处理Shader的材质</p>
<pre><code>private void OnRenderImage(RenderTexture source, RenderTexture destination)//该函数在所有的渲染完成后由monobehavior自动调用。
//官方解释：该函数允许我们使用着色器滤波操作来修改最终的图像，输入原图像source，输出的图像放在desitination里。
{
    if (EffectMat !=null)
    {
        Graphics.Blit(source, destination, EffectMat);//该函数的作用就是通过一个shader将原图的像素放置到destionation中。
    }
}
</code></pre>
<p>}<br>
——————————————————————————————————————<br>
<img src="https://Wei715547.github.io/post-images/1599552275469.PNG" alt="" loading="lazy"><br>
Shader1画面溶解流动效果：<br>
Shader &quot;Shader104/Distortion&quot;<br>
{<br>
Properties<br>
{<br>
_MainTex(&quot;Texture&quot;, 2D) = &quot;white&quot; {}<br>
_DisplaceTex(&quot;Displacement Texture&quot;, 2D) = &quot;white&quot; {}<br>
_Magnitude(&quot;Magnitude&quot;, Range(0,0.1)) = 1</p>
<pre><code>}

SubShader
{
    Tags
    {
        &quot;Queue&quot; = &quot;Transparent&quot;
    }

    Pass{
        Blend SrcAlpha OneMinusSrcAlpha

        CGPROGRAM
        #pragma vertex vert
        #pragma fragment frag

        #include &quot;UnityCG.cginc&quot;

        struct appdata
        {
            float4 vertex : POSITION;
            float2 uv : TEXCOORD0;
        };

        struct v2f
        {
            float4 vertex : SV_POSITION;
            float2 uv : TEXCOORD0;
        };

        v2f vert(appdata v)
        {
            v2f o;
            o.vertex = UnityObjectToClipPos(v.vertex);
            o.uv = v.uv;
            return o;
        };

        sampler2D _MainTex;
        sampler2D _DisplaceTex;//噪波贴图
        float _Magnitude;

        float4 frag(v2f i): SV_Target//画面流动效果
        {
            float2 distuv = float2(i.uv.x + _Time.x * 2, i.uv.y + _Time.x * 2);
            float2 disp = tex2D(_DisplaceTex, distuv).xy;//噪波贴图的.rg
            disp = ((disp * 2) - 1) * _Magnitude;
            float4 col = tex2D(_MainTex, i.uv + disp);
            return col;
        }
        ENDCG
    }
}
</code></pre>
<p>}<br>
————————————————————————————————————————<br>
<img src="https://Wei715547.github.io/post-images/1599552284677.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1599552463055.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1599553049020.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1599553279813.PNG" alt="" loading="lazy"><br>
Shader2屏幕黑白、反色、RGB分离、像素效果：<br>
Shader &quot;Shader104/GreyScale&quot;<br>
{<br>
Properties<br>
{<br>
_MainTex(&quot;Texture&quot;, 2D) = &quot;white&quot; {}<br>
_Slider(&quot;Slider&quot;,Range(0,1)) = 0.5<br>
}</p>
<pre><code>SubShader
{
	Tags
	{
		&quot;PreviewType&quot; = &quot;Plane&quot;
	}
	Pass
	{
		CGPROGRAM
		#pragma vertex vert
		#pragma fragment frag

		#include &quot;UnityCG.cginc&quot;

		struct appdata
		{
			float4 vertex : POSITION;
			float2 uv: TEXCOORD0;
		};

		struct v2f
		{
			float4 vertex : SV_POSITION;
			float2 uv: TEXCOORD0;
		};

		sampler2D _MainTex;
		float _Slider;

		v2f vert(appdata v)
		{
			v2f o;
			o.vertex = UnityObjectToClipPos(v.vertex);
			o.uv = v.uv;
			return o;
		}

		float4 frag(v2f i) : SV_Target
		{
            /*pixelate像素效果对UV进行变换
            float2 uv = i.uv;
            uv.x *= _PixelateAmt;
            uv.y *= _PixelateAmt;
            uv.x = round(uv.x);
            uv.y = round(uv.y);
            uv.x /= _PixelateAmt;
            uv.y /= _PixelateAmt;*/
			float4 color = tex2D(_MainTex,i.uv);//默认混合颜色(白色)：不进行后处理
			float average = 0.212 * color.r + 0.7152 * color.g + 0.0722 * color.b;//颜色黑白化
			if (i.uv.x &gt; _Slider)//大于Slidr的部分进行后处理
				return float4(average, average, average, 1);
                //return float4(1-color.r, 1-color.g, 1-color.b, 1);//反色
			else
				return color;
             /*chromatic aberration RGB分离
            float4 red = tex2D(_MainTex , i.uv - _Offset);           
            float4 green = tex2D(_MainTex, i.uv);
            float4 blue = tex2D(_MainTex, i.uv + _Offset);
            float4 color = float4(red.r,green.g,blue.b,1);
            return color;*/
		}
		ENDCG
	}
}
</code></pre>
<p>}<br>
————————————————————————————————————————<br>
<img src="https://Wei715547.github.io/post-images/1599552847954.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1599553788615.PNG" alt="" loading="lazy"><br>
Shader3Kernal矩阵边缘检测、渐变着色:<br>
Shader &quot;Shader104/Kernal&quot;<br>
{<br>
Properties<br>
{<br>
_MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}<br>
_Matrix00 (&quot;Matrix00&quot;,float) = 1<br>
_Matrix01 (&quot;Matrix01&quot;,float) = 1<br>
_Matrix02 (&quot;Matrix02&quot;,float) = 1<br>
_Matrix10 (&quot;Matrix10&quot;,float) = 1<br>
_Matrix11 (&quot;Matrix11&quot;,float) = -8<br>
_Matrix12 (&quot;Matrix12&quot;,float) = 1<br>
_Matrix20 (&quot;Matrix20&quot;,float) = 1<br>
_Matrix21 (&quot;Matrix21&quot;,float) = 1<br>
_Matrix22 (&quot;Matrix22&quot;,float) = 1<br>
_Slider(&quot;Slider&quot;,Range(0,1)) = 0.5<br>
_Threshold(&quot;_Threshold&quot;,Range(0,1)) = 0.1<br>
_EdgeColor(&quot;_EdgeColor&quot;,Color) = (1,1,1,1)<br>
_BackColor(&quot;_BackColor&quot;,Color) = (0,0,0,0)</p>
<pre><code>}
SubShader
{
    Tags
    {
        &quot;PreviewType&quot; = &quot;Plane&quot;
    }

    Pass
    {
        CGPROGRAM
        #pragma vertex vert
        #pragma fragment frag
        
        #include &quot;UnityCG.cginc&quot;

        struct appdata
        {
            float4 vertex : POSITION;
            float2 uv : TEXCOORD0;
        };

        struct v2f
        {
            float2 uv : TEXCOORD0;
            float4 vertex : SV_POSITION;
        };

        v2f vert (appdata v)
        {
            v2f o;
            o.vertex = UnityObjectToClipPos(v.vertex);
            o.uv = v.uv;
            return o;
        }
        
        sampler2D _MainTex;
        float4 _MainTex_TexelSize;
        float _Matrix00;
        float _Matrix01;
        float _Matrix02;
        float _Matrix10;
        float _Matrix11;
        float _Matrix12;
        float _Matrix20;
        float _Matrix21;
        float _Matrix22;
        float _Slider;
        float _Threshold;
        float4 _EdgeColor;//边缘色
        float4 _BackColor;//背景色

        float4 box(sampler2D tex, float2 uv, float4 size)//检测函数
        {
            float4 c = tex2D(tex, uv + float2(-size.x, size.y))*_Matrix00 + tex2D(tex, uv + float2(0, size.y))*_Matrix01 
            + tex2D(tex, uv + float2(size.x, size.y)) *_Matrix02 + tex2D(tex, uv + float2(-size.x, 0)) * _Matrix10
            + tex2D(tex, uv + float2(0, 0))*_Matrix11 + tex2D(tex, uv + float2(size.x, 0))*_Matrix12 
            + tex2D(tex, uv + float2(-size.x, -size.y))*_Matrix20 + tex2D(tex, uv + float2(0, -size.y))*_Matrix21
            + tex2D(tex, uv + float2(size.x, -size.y))*_Matrix22;

            return c / (_Matrix00+_Matrix01+_Matrix02+_Matrix10+_Matrix11+_Matrix12+_Matrix20+_Matrix21+_Matrix22);
        }

        float4 frag (v2f i) : SV_Target
        {
            float4 color = tex2D(_MainTex, i.uv);
            if(i.uv.x&gt;_Slider)
			{//边缘检测
                color = box(_MainTex, i.uv, _MainTex_TexelSize);
                if (color.r &lt;= _Threshold &amp;&amp; color.g &lt;= _Threshold &amp;&amp; color.b &lt;= _Threshold)//渐变着色
                    return _EdgeColor;
                else
                    return _BackColor;
            }
            else
                if (color.r &lt;= _Threshold &amp;&amp; color.g &lt;= _Threshold &amp;&amp; color.b &lt;= _Threshold)//渐变着色
                    return color;
                else
                    return float4(1, 1, 1, 1);//未上色部分为白色
        }
        ENDCG
    }
}
</code></pre>
<p>}<br>
————————————————————————————————————<br>
<img src="https://Wei715547.github.io/post-images/1599556756456.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1599556177672.PNG" alt="" loading="lazy"><br>
Shader深度值渲染/范围扫描：<br>
相机脚本：<br>
using UnityEngine;<br>
using System.Collections;<br>
using System.Collections.Generic;</p>
<p>[ExecuteInEditMode]<br>
public class ReplacementShaderEffect : MonoBehaviour<br>
{<br>
public Color color;<br>
public float slider;<br>
public Shader ReplacementShader;</p>
<pre><code>void OnValidate()
{
    Shader.SetGlobalColor(&quot;_Color_1&quot;, color);//获取Shader中未公开的全局变量
}

private void Update()
{
    Shader.SetGlobalFloat(&quot;_Temp&quot;, slider);//获取Shader中未公开的全局变量
}

void OnEnable()
{
    if (ReplacementShader != null)
        GetComponent&lt;Camera&gt;().SetReplacementShader(ReplacementShader, &quot;&quot;);
}

void OnDisable()
{
    GetComponent&lt;Camera&gt;().ResetReplacementShader();
}
</code></pre>
<p>}<br>
————————————————————————————————<br>
Shader程序：<br>
Shader &quot;Shader102/Depth&quot;<br>
{<br>
SubShader<br>
{<br>
Tags<br>
{<br>
&quot;RenderType&quot; = &quot;Opaque&quot;<br>
}</p>
<pre><code>	ZWrite On


	Pass
	{
		CGPROGRAM
		#pragma vertex vert
		#pragma fragment frag

		#include &quot;UnityCG.cginc&quot;

		struct appdata
		{
			float4 vertex : POSITION;
		};

		struct v2f
		{
			float4 vertex : SV_POSITION;
			float depth : DEPTH;
		};

		v2f vert(appdata v)
		{
			v2f o;
			o.vertex = UnityObjectToClipPos(v.vertex);
			o.depth = -(mul(UNITY_MATRIX_MV, v.vertex).z) * _ProjectionParams.w;//相机坐标空间下的深度值
			return o;
		}
		//未公开的全局变量
		float4 _Color_1;
		float _Temp;
        //根据深度值切换渲染方式
		/*fixed4 frag(v2f i) : SV_Target
		{
			float invert = 1 - i.depth;//近处颜色为白色

		if (i.depth &lt;_Temp / 2)//不同深度下实现不同的渲染方式
			return fixed4(invert, invert, invert, 1);
		else
			return fixed4(invert*1.5, 0.3, 0.3,1) ;
		}*/
        //范围扫描
        fixed4 frag(v2f i) : SV_Target
		{
			float invert = 1 - i.depth;//近处颜色为白色

		if (abs(i.depth- _Temp / 2)&lt;0.005)//深度范围绝对值内扫描的渲染方式
			return fixed4(invert*2, 0.2, 0.2, 1);
		else//正常渲染方式
			return fixed4(invert, 0.3, 0.3,1) ;
		}
		ENDCG
	}
}
</code></pre>
<p>}<br>
数值动画/代码：<br>
timer += Time.deltaTime;<br>
if (timer &gt;2.0f)<br>
{<br>
ht += Time.deltaTime*(1/5f);<br>
slider = Mathf.Lerp(0f, 10f, 0.5f * ht);<br>
if (ht&gt;=1f)<br>
{<br>
ht = 0;<br>
slider = 0;<br>
timer = 0;<br>
}<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UGUI 背包模块(事件订阅/渗透)]]></title>
        <id>https://Wei715547.github.io/post/ugui-bei-bao-mo-kuai-shi-jian-ding-yue-shen-tou/</id>
        <link href="https://Wei715547.github.io/post/ugui-bei-bao-mo-kuai-shi-jian-ding-yue-shen-tou/">
        </link>
        <updated>2020-09-02T14:26:34.000Z</updated>
        <content type="html"><![CDATA[<p>UI搭建：<img src="https://Wei715547.github.io/post-images/1599057822367.PNG" alt="" loading="lazy"><br>
————————————————————————————————<br>
代码：</p>
<p>装备共有属性类：<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public enum ArticleType//装备种类<br>
{<br>
Weapon,<br>
Drag,<br>
Collect,<br>
Pick<br>
}</p>
<p>public class Article //装备属性类(装备共有参数)<br>
{<br>
public string name;//装备名称<br>
public string spritPath;//装备UI图路径<br>
public ArticleType articleType;//装备类型<br>
public int count;//装备数量</p>
<pre><code>//构造函数
public Article(string name,string spritPath,ArticleType articleType,int count)
{
    this.name = name;
    this.spritPath = spritPath;
    this.articleType = articleType;
    this.count = count;
}
</code></pre>
<p>}<br>
——————————————————————————————<br>
装备“物品”类<br>
using System;<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.UI;</p>
<p>public class ArticleItem : MonoBehaviour<br>
{<br>
private Image articleSprit;<br>
private Text count;<br>
public Article article;<br>
private UIDrag UIDrag;//实现拖拽的类<br>
private Canvas canvas;//物体上的Canvas组件，用于物体显示在上层<br>
//private CanvasGroup canvasGroup;//拖拽此物体是取消其射线检测,代替事件渗透<br>
private int defortSort;<br>
//private Transform Origentparent;</p>
<pre><code>private Vector3 currentLocalPosition;
private float moveTimer;
public float moveTime = 0.2f;

private bool isMoving = false;

private Action onMoveEnd;

// Start is called before the first frame update
void Awake()
{
    articleSprit = transform.GetComponent&lt;Image&gt;();
    count = transform.Find(&quot;ItemCount&quot;).GetComponent&lt;Text&gt;();
    //将对应拖拽状态时要掉用的方法注册到拖拽类的委托链
    UIDrag = transform.GetComponent&lt;UIDrag&gt;();
    UIDrag.onStartDrag += OnStartDrag;
    UIDrag.onDrag += OnDrag;
    UIDrag.onEndDrag += OnEndDrag;
    
    canvas = transform.GetComponent&lt;Canvas&gt;();
    defortSort = canvas.sortingOrder;
    //canvasGroup = transform.GetComponent&lt;CanvasGroup&gt;();
    
    //currentLocalPosition = transform.localPosition;
}
private void Start()
{
    transform.localPosition = Vector3.zero;
    currentLocalPosition = transform.localPosition;
}
private void Update()
{
    MoveBack();
}
//Lerpg固定时间内完成执行
private void MoveBack()
{
    if (isMoving)
    {
        moveTimer += Time.deltaTime * (1 / moveTime);//0.2秒后为1
        transform.localPosition = Vector3.Lerp(currentLocalPosition, Vector3.zero, moveTimer);
        if (moveTimer &gt;= 1)
        {
            isMoving = false;
            //MoveToOrigin方法导致的事件完成后执行自身委托
            onMoveEnd?.Invoke();
        }
    }
}
//执行Lerp
public void MoveToOrigin(Action onMoveEnd)
{
    isMoving = true;
    moveTimer = 0;
    currentLocalPosition = transform.localPosition;
    this.onMoveEnd = onMoveEnd;//将之后要执行的方法方到自身委托链上
}
//设置装备属性(UI图标，数量等)
public void SetArticle(Article article)
{
    this.article = article;

    //显示数据
    articleSprit.sprite = Resources.Load&lt;Sprite&gt;(this.article.spritPath);
    count.text = this.article.count.ToString();
}
//开始拖拽时执行
public void OnStartDrag()
{
    canvas.sortingOrder = defortSort + 1;//显示在同级上层
    //transform.SetParent(transform.parent.parent);
    BagPanel.instence.curretnAricle = this;//正在拖拽的为此物体
}
public void OnDrag()
{

}
//拖拽结束时执行
public void OnEndDrag()
{
    //结束拖拽时所选格子不为空时，物品进入格子，
    if (BagPanel.instence.currtenHoverGrid != null &amp;&amp; !BagPanel.instence.currtenHoverGrid.gameObject.Equals(transform.parent.gameObject))
    {
        BagPanel.instence.currtenHoverGrid.DragIntoGride(BagPanel.instence.curretnAricle);//格子的方法
        canvas.sortingOrder = defortSort;//恢复层级
    }
    else//为空则返回
    {
        //transform.SetParent(Origentparent);
        //使用委托实现结束后执行
        MoveToOrigin(() =&gt; { canvas.sortingOrder = defortSort; });//表达式内为方法结束后要执行的语句
    }
    BagPanel.instence.curretnAricle = null;//结束拖拽时正在拖拽的物体为空
}    
</code></pre>
<p>}<br>
——————————————————————————————<br>
实现拖拽的类：<br>
using System;<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.EventSystems;</p>
<p>public class UIDrag : MonoBehaviour,IBeginDragHandler,ICanvasRaycastFilter ,IDragHandler,IEndDragHandler<br>
{<br>
private Vector3 mousePosition;<br>
private RectTransform rect;</p>
<pre><code>public Action onDrag;
public Action onStartDrag;
public Action onEndDrag;

private bool isDraging = false;

private void Awake()
{
    rect = GetComponent&lt;RectTransform&gt;();
    if (rect ==null)
    {
        throw new System.Exception(&quot;只能拖拽UI物体&quot;);
    }
}
//使用事件渗透监听不到拖拽事件时可用下面代码
/*private void Update()
{
    if (isDraging)
    {
        *//*rect.anchoredPosition += (Vector2)(Input.mousePosition - mousePosition);
        mousePosition = Input.mousePosition;
        //transform.position = eventData.position; //中心随光标移动
        //锚点的位置加上鼠标移动
        //rect.anchoredPosition += eventData.delta;
        //if (onDrag != null) onDrag();
        onDrag?.Invoke();*//*
    }
    if(Input .GetMouseButtonUp(0)&amp;&amp;isDraging==true)
    {
        onEndDrag?.Invoke();
        isDraging = false;
    }
}*/

public void OnBeginDrag(PointerEventData eventData)
{
    mousePosition = Input.mousePosition;
    onStartDrag?.Invoke();
    isDraging = true;
}
//事件渗透接口：渗透过当前事件向下进行事件检测（背包系统渗透装备UI图标向下检测所在物品栏）
public bool IsRaycastLocationValid(Vector2 sp, Camera eventCamera)//事件渗透接口：返回值TRUE时：检测，返回值为FALES：渗透事件。
{
    return !isDraging;
}
//事件渗透监听不到此接口事件(实际监听的到)，但要保留接口实现拖拽
public void OnDrag(PointerEventData eventData)//参数为相机与点击物体的射线检测点
{
    rect.anchoredPosition += (Vector2)(Input.mousePosition - mousePosition);
    mousePosition = Input.mousePosition;
    //transform.position = eventData.position; //中心随光标移动
    //锚点的位置加上鼠标移动
    //rect.anchoredPosition += eventData.delta;
    //if (onDrag != null) onDrag();
    onDrag?.Invoke();
}
//事件渗透监听不到此接口事件(实际监听的到)
public void OnEndDrag(PointerEventData eventData)
{
    onEndDrag?.Invoke();
    isDraging = false;
}
</code></pre>
<p>}<br>
——————————————————————————————<br>
格子类：<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.EventSystems;<br>
using UnityEngine.UI;</p>
<p>public class BagGrde : MonoBehaviour , IPointerEnterHandler,IPointerExitHandler<br>
{<br>
private ArticleItem articleItem;</p>
<pre><code>private Image bgImage;
private Color defortColor;

public ArticleItem ArticleItem
{
    get { return articleItem; }
}

private void Awake()
{
    bgImage = transform.GetComponent&lt;Image&gt;();
    defortColor = bgImage.color;
}
//设置格子内的装备物品方法
public void SetArticleItem(ArticleItem articleItem)
{
    this.articleItem = articleItem;//此格子装着的物品
    this.articleItem.gameObject.SetActive(true);
    //将此物品栏设置父物体
    this.articleItem.transform.SetParent(transform);
    //刷新背包时直接设置位置，取消物品UI缓动效果
    articleItem.transform.localPosition = Vector3.zero;

    //防止发生变化
    //设置位置
    //this.articleItem.transform.localPosition = Vector3.zero;
    this.articleItem.MoveToOrigin(() =&gt;//用物品类里面的方法实现拖拽到格子时的缓动效果
   {//设置5px的边界值
       this.articleItem.GetComponent&lt;RectTransform&gt;().offsetMin = new Vector2(5, 5);
       this.articleItem.GetComponent&lt;RectTransform&gt;().offsetMax = new Vector2(-5, -5);
   });
    //设置大小
    this.articleItem.transform.localScale = Vector3.one;
    //设置
    //this.articleItem.GetComponent&lt;RectTransform&gt;().offsetMin = new Vector2(5, 5);
    //this.articleItem.GetComponent&lt;RectTransform&gt;().offsetMax = new Vector2(-5, -5);
}
//清空格子
public void ClearGride()
{
    articleItem.gameObject.SetActive(false);
    articleItem.transform.SetParent(null);
    articleItem = null;
}

//物品填入格子
public void DragIntoGride(ArticleItem articleItem)
{
    //物品原来所在的格子
    BagGrde lastGride = articleItem.transform.parent.GetComponent&lt;BagGrde&gt;();
    if (this.articleItem==null)//如果这个格子中没有物品
    {
        //清空之前的格子
        lastGride.ClearGride();

        //设置拖拽到的此格子
        SetArticleItem(articleItem);
        //lastGride.ClearGride();
    }
    else//此格子不为空时将物品进行交换
    {
        //当前格子内物品设置到之前的格子
        lastGride.SetArticleItem(this.articleItem);
        //设置拖拽过来的新物品到的此格子
        SetArticleItem(articleItem);
    }
}
//鼠标进入格子时接口调用的函数
public void OnPointerEnter(PointerEventData eventData)
{
    if(BagPanel.instence .curretnAricle!=null)//拖拽的物品不为空时
    {
        BagPanel.instence.currtenHoverGrid = this;//光标进入此格子则选中此格子
        bgImage.color = Color.white;//该变选中格子的颜色
    }
    //此格子布为空时显示此格子物品的信息界面
    if (this.articleItem != null)
    {
        UIManager.Instence.articleInformation.gameObject.SetActive(true);
        UIManager.Instence.articleInformation.panel.transform.position = transform.position;
        UIManager.Instence.articleInformation.info.text = this.articleItem.article.name + &quot;\n&quot; + this.articleItem.article.count.ToString ();
    }
}
//光标退出时
public void OnPointerExit(PointerEventData eventData)
{
    BagPanel.instence.currtenHoverGrid = null;
    bgImage.color = defortColor;
    //隐藏信息界面
    UIManager.Instence.articleInformation.gameObject.SetActive(false);
    UIManager.Instence.articleInformation.panel.transform.position = Vector3.zero;
    UIManager.Instence.articleInformation.info.text = &quot; &quot;;
}
</code></pre>
<p>}<br>
———————————————————————————————————<br>
背包模块类：<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.UI;</p>
<p>public class BagPanel : MonoBehaviour<br>
{</p>
<pre><code>private List&lt;Article&gt; articlesList = new List&lt;Article&gt;();//背包中所有物品的属性

private List&lt;GameObject&gt; articleObjectPool = new List&lt;GameObject&gt;();//储存物品预制件的对象池

public GameObject articleItemPrafab;//物品UI预制件
private BagGrde[] bagGrdes;//物品栏

public BagGrde currtenHoverGrid;//当前鼠标所悬浮所在格子
public ArticleItem curretnAricle;//当前拖拽物品
//单例
public static BagPanel instence;//单例，在外部访问公开属性

//private Button btn_Back;
// Start is called before the first frame update
void Awake()
{
    /*if (instence !=null)
    {
        Destroy(gameObject);
        return;
    }*/
    instence = this;
    //DontDestroyOnLoad(gameObject);

    //btn_Back = transform.Find(&quot;btn_Back&quot;).GetComponent&lt;Button&gt;();
    //btn_Back.onClick.AddListener(UIManager.Instence.ExtBagPanel);
    InitArticleDate();
    bagGrdes = transform.GetComponentsInChildren&lt;BagGrde&gt;();//获取所有格子
    LoadDate();//初始加载全部数据
}
</code></pre>
<p>/*    private void Start()<br>
{<br>
LoadDate();<br>
}*/<br>
//加载全部数据<br>
public void LoadDate()<br>
{<br>
ClearGrideAndHideItems();<br>
for (int i = 0; i &lt; articlesList.Count; i++)<br>
{<br>
//将列表中所有物品的属性生成对应物品装入空着的格子<br>
GetBagGrid().SetArticleItem(LoadArticleItem(articlesList[i]));<br>
}<br>
}<br>
//按类加载的重载方法<br>
public void LoadDate(ArticleType articleType)<br>
{<br>
ClearGrideAndHideItems();<br>
for (int i = 0; i &lt; articlesList.Count; i++)<br>
{<br>
if (articlesList[i].articleType == articleType)<br>
{<br>
//将列表中某类物品生成对应物品装入空着的格子<br>
GetBagGrid().SetArticleItem(LoadArticleItem(articlesList[i]));<br>
}<br>
}<br>
}<br>
//获取空着的格子<br>
public BagGrde GetBagGrid()<br>
{<br>
for (int i = 0; i &lt; bagGrdes.Length; i++)<br>
{<br>
if (bagGrdes[i].ArticleItem == null)<br>
return bagGrdes[i];<br>
}<br>
return null;<br>
}<br>
//加载ArticleItem物品：根据属性创建对应装备物品<br>
public ArticleItem LoadArticleItem(Article article)<br>
{<br>
GameObject go = GetGameObject();<br>
ArticleItem articleItem = go.GetComponent<ArticleItem>();<br>
articleItem.SetArticle(article);<br>
return articleItem;<br>
}<br>
//获取GameObject：获取对象池中空闲物品预制件<br>
public GameObject GetGameObject()<br>
{<br>
for (int i = 0; i &lt; articleObjectPool.Count; i++)<br>
{<br>
if (articleObjectPool[i].activeSelf==false)<br>
{<br>
articleObjectPool[i].SetActive(true);<br>
return articleObjectPool[i];<br>
}<br>
}<br>
GameObject go = Instantiate(articleItemPrafab);<br>
articleObjectPool.Add(go);<br>
return go;</p>
<pre><code>}
//重新加载背包时物品栏清空
public void ClearGrideAndHideItems()
{
    for (int i = 0; i &lt; bagGrdes.Length; i++)
    {
        if (bagGrdes[i].ArticleItem!=null)
        {
            bagGrdes[i].ClearGride();
        }
    }
}

//初始化物品数据：加载拥有的制备数据应从服务器获取，此处实验性加载部分装备
public void InitArticleDate()
{
    //武器
    articlesList.Add(new Article(&quot;刀刀&quot;,&quot;at0&quot;, ArticleType.Weapon, 2));
    articlesList.Add(new Article(&quot;剑剑&quot;, &quot;at1&quot;, ArticleType.Weapon, 1));
    articlesList.Add(new Article(&quot;春药&quot;, &quot;at2&quot;, ArticleType.Drag, 7));
    articlesList.Add(new Article(&quot;夏药&quot;, &quot;at3&quot;, ArticleType.Drag, 6));
    articlesList.Add(new Article(&quot;秋药&quot;, &quot;at4&quot;, ArticleType.Drag, 5));
    articlesList.Add(new Article(&quot;冬药&quot;, &quot;at5&quot;, ArticleType.Drag, 4));
    articlesList.Add(new Article(&quot;典藏种子&quot;, &quot;at6&quot;, ArticleType.Collect, 1001));
    articlesList.Add(new Article(&quot;玻璃碎片&quot;, &quot;at7&quot;, ArticleType.Pick, 12));
}


#region 点击标签事件(所有标签都在同一个标签组-只有一个标签可选。勾选标签是执行)
public void OnAllToggleValueChange(bool v)//v为标签是否被勾选
{
    if (v) LoadDate();
}
public void OnWepanToggleValueChange(bool v)
{
    if (v) LoadDate(ArticleType.Weapon);
}
public void OnDragToggleValueChange(bool v)
{
    if (v) LoadDate(ArticleType.Drag);
}
public void OnClctorToggleValueChange(bool v)
{
    if (v) LoadDate(ArticleType.Collect);
}
public void OnPickToggleValueChange(bool v)
{
    if (v) LoadDate(ArticleType.Pick);
}
#endregion
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shader_反射]]></title>
        <id>https://Wei715547.github.io/post/shader_-fan-she/</id>
        <link href="https://Wei715547.github.io/post/shader_-fan-she/">
        </link>
        <updated>2020-08-25T15:41:56.000Z</updated>
        <content type="html"><![CDATA[<p>Shader &quot;Custom/Reflection&quot;<br>
{<br>
Properties//属性<br>
{<br>
_MainTex(&quot;Main Tex&quot;,2D) = &quot;white&quot;{}//贴图代替漫反射颜色<br>
_Color(&quot;Tex Color&quot;,Color) = (1,1,1,1)//贴图颜色:与贴图uv坐标下的像素点颜色混合<br>
_NormalMap(&quot;Normal Map&quot;,2D) = &quot;bump&quot;{}//未添法线贴图时为默认法线<br>
_NormalST(&quot;Normal ST&quot;,Float) = 1//法线贴图强度参数<br>
_Specular(&quot;_Specular&quot;, Color) = (1, 1, 1, 1)//高光颜色<br>
_Gloss(&quot;_Gloss&quot;, Range(1, 200)) = 20//高光参数<br>
_ReflectAmount(&quot;_ReflectAmount&quot;,Range(0,1)) = 1<br>
_CubeMap(&quot;_CubeMap&quot;,Cube) = &quot;_Skybox&quot;{}//天空和贴图<br>
}<br>
SubShader<br>
{<br>
Pass<br>
{<br>
Tags {&quot;Lighting&quot; = &quot;ForwardBase&quot;} //定义LightMode,获取UNITY内部光照变量<br>
CGPROGRAM<br>
//在CG声明属性<br>
sampler2D _MainTex;//ShaderCG中的关键字<br>
float4 _MainTex_ST; //主贴图的缩放与偏移“属性名称固定”_MainTex_ST.xy缩放属性；_MainTex_ST.zw偏移属性<br>
fixed4 _Color;//与贴图叠混合颜色<br>
sampler2D _NormalMap;<br>
float4 _NormalMap_ST;<br>
float _NormalST;<br>
fixed4 _Specular;<br>
int _Gloss;<br>
fixed _ReflectAmount;<br>
samplerCUBE _CubeMap;<br>
#include &quot;Lighting.cginc&quot;//引入UNITY内置文件，获取光照变量 _LightColor0.rgb;光源颜色<br>
#pragma vertex vert//声明顶点函数<br>
#pragma fragment frag//声明片原函数</p>
<pre><code>	struct a2v//应用向顶点函数传递参数
	{
		float4 vertex:POSITION;//模型空间顶点坐标
		//切线空间的确定是通过（存储到模型里的/模型空间）法线 与 （存储到模型里的/模型空间）切线确定的
		float3 normal:NORMAL;//模型空间法线方向
		float4 tangent:TANGENT;//模型空间下的切线方向：tangent.w:是用来确定切线空间中坐标轴的方向（切线空间下的Z轴方向默认为顶点的法线方向:通过控制缩放xy可改变法线强度）
		float4 texcoord :TEXCOORD0;//获取纹理坐标
	};
	struct v2f//顶点函数向片原函数传递参数
	{
		float4 svPos:SV_POSITION;//顶点函数返回值：剪裁空间中的顶点坐标-系统直接使用
		//float3 worldNormal : TEXCOORD3;//顶点函数向片原函数传递世界坐标下的法线方向(使用法线贴图后不需要)
		float3 lightDir:TEXCOORD0;//切线空间下的平行光方向
		float3 viewDir:TEXCOORD1;//顶点函数向片原函数传递且切线空间下的视线方向

		float4 uv:TEXCOORD2;//xy用来存储_MainTex的纹理坐标，zw用来存储_NormalMap的纹理坐标
		float3 WorldRefl:TEXCOORD3;
	};

	v2f vert(a2v v)//顶点函数将顶点从模型空间转到世界空间，返回值在世界坐标系下的顶点坐标
	{
		v2f f;//声明传参结构体,并对其中的值赋值
		f.svPos = UnityObjectToClipPos(v.vertex);
		//f.worldNormal = UnityObjectToWorldNormal(v.normal);
		//f.worldView = (UnityObjectToWorldNormal(v.vertex), 0);
		f.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;//将纹理坐标传递到片原函数 * 乘上主贴图缩放属性 + 加上主贴图的偏移属性
        //f.uv.xy = TRANSFORM_TEX(v.uv,_MainTex);//将纹理坐标传递到片原函数 * 乘上主贴图缩放属性 + 加上主贴图的偏移属性
		f.uv.zw = v.texcoord.xy * _NormalMap_ST.xy + _NormalMap_ST.zw;//将法线纹理坐标与其属性结合存储到uv.zw中

		TANGENT_SPACE_ROTATION;//调用这个宏后(保证a2v &quot;v&quot;中存在&quot;normal&quot;&quot;tangent&quot;宏自动调用)，会得到一个矩阵&quot;rotation&quot;这个矩阵用来把模型空间下的法线转换到切线空间下

		//ObjSpaceLightDir(v.vertex);//模型空间下的平行光方向
		f.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex));//将切线就下的平行光方向传到片原函数
		f.viewDir = mul(rotation, ObjSpaceViewDir(v.vertex));//计算切线空间下的视角方向
		return f;//返回结构体
	}

	//把与法线有关相关计算放到切线空间下（从法线贴图取到的方向坐标为切线空间下的）
	fixed4 frag(v2f f) :SV_Target//片原函数，返回值为输出到像素颜色值的缓存
	{
		//计算漫反射
		//fixed3 normalDir = normalize(f.worldNormal);//法线方向
		fixed4 normalColor = tex2D(_NormalMap,f.uv.zw);//法线贴图在纹理坐标下的颜色值(只使用其中RGB值)

		//此方法法线读取不正确//fixed3 tangentNormal = normalize(normalColor.xyz * 2 - 1);//切线空间下的法线方向
		fixed3 tangentNormal = normalize(UnpackNormal(normalColor));//在UNITY中将法线贴图类型设置为法线贴图时可用此方法获得切线空间下的法线方向
		//切线空间下的Z轴方向默认为顶点的法线方向:通过控制缩放xy可改变法线强度，则如下
		tangentNormal.xy = tangentNormal.xy * _NormalST;//强度为0时使用的即是模型顶点默认的法线方向

		fixed3 lightDir = normalize(f.lightDir);//单位化切线空间下的光源方向

		fixed3 texColor = tex2D(_MainTex, f.uv.xy) * _Color.rgb;//获取纹理坐标下贴图像素点的颜色*与外部属性控制的贴图颜色混合

		

		fixed3 diffuse = _LightColor0.rgb * texColor * max((dot(lightDir,tangentNormal) * 0.5 + 0.5), 0);//fixed3 harfLambert =dot(f.wordNormalDir, lightDir)*0.5+0.5;//半兰伯特光照模型:直射光颜色 * (cos夹角(光与法线)*0.5+0.5):使背光面不完全为黑色

		//计算高光反射
		//fixed3 reflectDir = normalize(reflect(-lightDir, normalDir));
		fixed3 viewDir = normalize(f.viewDir);//实视线方向
		fixed3 harfDir = normalize(viewDir + lightDir);//视角与平行光的平分方向
		fixed3 specular = _LightColor0.rgb * texColor * _Specular.rgb * pow(max(dot(tangentNormal, harfDir),0), _Gloss);//BP模型://Blinn-Phong光照模型Specular = 直射光*pow(max(cos夹角,0)*高光参数) ，夹角：法线与x方向夹角,x:平行光与视野方向的平分项。


		fixed3 worleRefl = reflect(-viewDir,tangentNormal);
		fixed3 reflection = texCUBE(_CubeMap,worleRefl).rgb;

		fixed3 tempColor = lerp(diffuse, reflection,_ReflectAmount) + specular + UNITY_LIGHTMODEL_AMBIENT.rgb * texColor;//漫反射+高光+环境光*纹理，相加混合（环境光与纹理混合：使强光下的纹理仍保持清晰）
		

		return fixed4(tempColor,1);
	}
	ENDCG
}

	}
		FallBack &quot;Diffuse&quot;
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UI滚动窗口Scroll View(自动/手动)缓动缩放]]></title>
        <id>https://Wei715547.github.io/post/ui-gun-dong-chuang-kou-scroll-viewzi-dong-shou-dong-huan-dong-suo-fang/</id>
        <link href="https://Wei715547.github.io/post/ui-gun-dong-chuang-kou-scroll-viewzi-dong-shou-dong-huan-dong-suo-fang/">
        </link>
        <updated>2020-08-24T12:24:01.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://Wei715547.github.io/post-images/1598272075912.PNG" alt="" loading="lazy"><br>
//基础手动/自动滚动代码<br>
using System;<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.EventSystems;<br>
using UnityEngine.UI;</p>
<p>public class PstPanel : MonoBehaviour ,IEndDragHandler,IBeginDragHandler<br>
{<br>
protected ScrollRect rect;<br>
RectTransform content;<br>
public int pageCount;<br>
public float[] pagePos;//存储各滚动页的坐标</p>
<pre><code>public float runTime = 0;//控制滚动快慢的记录系统时间
public float holdTime = 0.2f;//控制滚动快慢的时间
public float startPos;//滚动窗口rect.horizontalNormalizedPosition属性线性变化的开始值
public int currentPage = 0;//当前滚动窗口要显示页面

public bool isMoving = false;

public bool isAutoRoll;
public float autoHodeTime = 2;//自动股东间隔时间
private float AutoRunTimer=0;//控制自动滚动间隔的记录系统时间

private bool isDrag = false;

public Action&lt;int&gt; OnPageChange;//事件/委托链：公开变量用于外部订阅

// Start is called before the first frame update
protected virtual void Start()
{
    Init();
}

private void Init()
{
    rect = GetComponent&lt;ScrollRect&gt;();
    content = transform.Find(&quot;Viewport/Content&quot;).GetComponent&lt;RectTransform&gt;();
    pageCount = content.childCount;
    if (pageCount == 1)
    {
        throw new System.Exception(&quot;UnAutoR&quot;);
    }
    pagePos = new float[pageCount];
    for (int i = 0; i &lt; pagePos.Length; i++)
    {
        pagePos[i] = i * (1.0f / (float)(pageCount - 1));//计算并存储每个页面的坐标
    }
}

// Update is called once per frame
protected virtual void Update()
{
    LisenerMove();//监听移动方法
    LisenerAutoRoll();//监听自动移动方法
}

private void LisenerMove()//每帧执行：使窗口显示目标页面
{
    if (isMoving)
    {
        runTime += Time.deltaTime / holdTime;
        rect.horizontalNormalizedPosition = Mathf.Lerp(rect.horizontalNormalizedPosition, pagePos[currentPage], runTime);//runTime=1时立即移动到目标值
        if (runTime &gt;= 1)
        {
            isMoving = false;
        }
    }
}

public void LisenerAutoRoll()
{
    if (isDrag) return;
    if (isAutoRoll)//间隔时间调用滚动方法
    {
        AutoRunTimer += Time.deltaTime;
        if(AutoRunTimer&gt;=autoHodeTime)
        {
            AutoRunTimer = 0;
            currentPage++ ;
            currentPage %= pageCount;
            ScrollToPage(currentPage);
        }
    }
}
/// &lt;summary&gt;
/// 滚动到指定页面方法
/// &lt;/summary&gt;
/// &lt;param name=&quot;page&quot;&gt;要滚动到的页面&lt;/param&gt;
public void ScrollToPage(int page)
{
    isMoving = true;
    currentPage =page;
    runTime = 0;
    startPos = rect.horizontalNormalizedPosition;//范围(0~1)
    if(OnPageChange!=null)// OnPageChange?.Invoke(this.currentPage);
    {//作用同于广播此事件(委托连不为空则调用)
        OnPageChange(this.currentPage);
    }
}

public void OnEndDrag(PointerEventData eventData)//结束拖拽接口实现：重置自动滚动时间，判断当前停留位置更接近那个页面并移动到目标页面
{
    isDrag = false;
    AutoRunTimer = 0;
    ToEndPos();
}
/// &lt;summary&gt;
/// 拖拽结束时一定到目标位置    
/// &lt;/summary&gt;
private void ToEndPos()
{
    int pageIndex = 0;
    for (int i = 1; i &lt; pagePos.Length; i++)
    {
        if (Mathf.Abs(pagePos[i] - rect.horizontalNormalizedPosition) &lt; Mathf.Abs(pagePos[pageIndex] - rect.horizontalNormalizedPosition))
        {
            pageIndex = i;
        }
    }
    ScrollToPage(pageIndex);
}

public void OnBeginDrag(PointerEventData eventData)//开始拖拽接口实现
{
    isDrag = true;
}
</code></pre>
<p>}</p>
<p>//通过代码继承与多态对父类代码复用与扩展添加缓动效果<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class PageScale : PstPanel<br>
{<br>
public GameObject[] items;<br>
public float currentScle = 1f;<br>
public float otherScle = 0.6f;<br>
public int lastPage;<br>
public int nextPage;<br>
public float percent;<br>
protected override void Start()<br>
{<br>
base.Start();<br>
items = new GameObject[pageCount];<br>
for (int i = 0; i &lt; pageCount; i++)<br>
{<br>
items[i] = transform.Find(&quot;Viewport/Content&quot;).transform.GetChild(i).gameObject;<br>
}<br>
}</p>
<pre><code>protected override void Update()
{
    base.Update();
    LissenterScale();
    //SetItenSize(currentPage);
}
/// &lt;summary&gt;
/// 监听Scale
/// &lt;/summary&gt;
public void LissenterScale()
{
    //获取当前上一页，下一页
    for (int i = 0; i &lt; pagePos.Length; i++)
    {
        if(pagePos[i]&lt;=rect.horizontalNormalizedPosition)
        {
            lastPage = i;
        }            
    }
    for (int i = 0; i &lt; pagePos.Length; i++)
    {
        if(pagePos[i]&gt;rect.horizontalNormalizedPosition)
        {
            nextPage = i;
            break;
        }
    }

    if (lastPage == nextPage)
        return;
    percent = (rect.horizontalNormalizedPosition - pagePos[lastPage]) / (pagePos[nextPage] - pagePos[lastPage]);//当前页到下一页0~1变动
    items[lastPage].transform.localScale = Vector3.Lerp(Vector3.one * currentScle, Vector3.one * otherScle, percent);//按比例返回a,b间的值0返回a，1返回b
    items[nextPage].transform.localScale = Vector3.Lerp(Vector3.one * currentScle, Vector3.one * otherScle, 1-percent);

    for (int i = 0; i &lt; items.Length; i++)
    {
        if (i!=lastPage&amp;&amp;i!=nextPage)
            items[i].transform.localScale = Vector3.one * otherScle;
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shader_渐变与遮罩纹理]]></title>
        <id>https://Wei715547.github.io/post/shader_-jian-bian-yu-zhe-zhao-wen-li/</id>
        <link href="https://Wei715547.github.io/post/shader_-jian-bian-yu-zhe-zhao-wen-li/">
        </link>
        <updated>2020-08-22T07:30:11.000Z</updated>
        <content type="html"><![CDATA[<p>Shader &quot;Custom/Jianbian_Zhezhao&quot;<br>
{<br>
Properties//属性<br>
{<br>
_Diffuse(&quot;_DiffuseColor&quot;,Color) = (1,1,1,1)//漫反射颜色<br>
_Specular(&quot;_Specular&quot;, Color) = (1, 1, 1, 1)//高光颜色<br>
_Gloss(&quot;_Gloss&quot;, Range(10, 200)) = 20//高光参数<br>
_Fad(&quot;_Fad&quot;,Color) = (1,1,1,1)//渐变贴图：作用于漫反射：fixed3 fad = tex2D(_Fad,float2()halfLambert,halfLambert).rgb(以半兰伯特值作为坐标获得在渐变贴图上的颜色代替半兰伯特值)<br>
_SpecularMask(&quot;_SpecularMask&quot;,Color) = (1,1,1,1)//高光遮罩贴图<br>
_SpecularScale(&quot;_SpecularScale&quot;,float) = 1//高光遮罩强度<br>
}<br>
SubShader<br>
{<br>
Pass<br>
{<br>
Tags {&quot;Lighting&quot; = &quot;ForwardBase&quot;} //定义LightMode,获取UNITY内部光照变量<br>
CGPROGRAM<br>
//在CG声明属性<br>
fixed4 _Diffuse;<br>
fixed4 _Specular;<br>
int _Gloss;<br>
fixed4 _Fad;<br>
fixed4 _SpecularMask;<br>
float _SpecularScale;</p>
<pre><code>		#include &quot;Lighting.cginc&quot;//引入UNITY内置文件，获取光照变量 _LightColor0.rgb;光源颜色
		#pragma vertex vert//声明顶点函数
		#pragma fragment frag//声明片原函数
		

		struct a2v//应用向顶点函数传递参数
		{
			float4 vertex:POSITION;//模型空间顶点坐标
			float3 normal:NORMAL;//模型空间法线方向
		};
		struct v2f//顶点函数向片原函数传递参数
		{
			float4 svPos:SV_POSITION;//顶点函数返回值：剪裁空间中的顶点坐标-系统直接使用
			float3 worldNormal : TEXCOORD0;//顶点函数向片原函数传递世界坐标下的法线方向
			float4 worldView:TEXCOORD1;//顶点函数向片原函数传递世界坐标下的顶点坐标
		};

		v2f vert(a2v v)//顶点函数将顶点从模型空间转到世界空间，返回值在世界坐标系下的顶点坐标
		{
			v2f f;//声明传参结构体,并对其中的值赋值
			f.svPos = UnityObjectToClipPos(v.vertex);
			f.worldNormal = UnityObjectToWorldNormal(v.normal);
			f.worldView = (UnityObjectToWorldNormal(v.vertex), 0);
			return f;//返回结构体
		}

		fixed4 frag(v2f f) :SV_Target//片原函数，返回值为输出到像素颜色值的缓存
		{
			//计算漫反射
			fixed3 amblent = UNITY_LIGHTMODEL_AMBIENT.rgb;//获取系统环境光		
			fixed3 normalDir = normalize(f.worldNormal);
			fixed3 lightDir = normalize(_WorldSpaceLightPos0.xyz);//第一个直射光的位置，对于顶点来说光的位置即是光的方向
			//漫反射渐变贴图
			//fixed3 fad = tex2D(_Fad,float2()halfLambert,halfLambert).rgb
			//fixed3 diffuse = _LightColor0.rgb*_DiffuseColor*fad;

			fixed3 harfLambert = max( dot(normalDir, lightDir)*0.5+0.5,0)*_Fad.rgb;//半兰伯特光照模型:直射光颜色 * (cos夹角(光与法线)*0.5+0.5):使背光面不完全为黑色,半兰伯特模型*渐变贴图.rgb
			fixed3 diffuse = _LightColor0.rgb * harfLambert * _Diffuse.rgb;//根据漫反射公式：直射光颜色 * cos夹角(光与法线)获取颜色 dot(a,b):点乘获取两向量的夹角cos

			//计算高光反射
			//fixed3 reflectDir = normalize(reflect(-lightDir, normalDir));
			fixed3 viewDir = normalize(WorldSpaceViewDir(f.worldView));//实视线方向
			fixed3 harfDir = normalize(viewDir + lightDir);//视角与平行光的平分方向

			//fixed specularMask = tex2D(_SpecularMask,f.uv.xy).r * _SpecularScale;//高光遮罩贴图的某通道值 * 遮罩强度 与高光反射模型相乘控制高光遮罩强度

			fixed specularMask = _SpecularMask.rgb*_SpecularScale;
			fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(dot(normalDir, harfDir),0), _Gloss)*specularMask;//BP模型://Blinn-Phong光照模型Specular = 直射光*pow(max(cos夹角,0)*高光参数) ，夹角：法线与x方向夹角,x:平行光与视野方向的平分项。
			fixed3 tempColor = diffuse + specular + UNITY_LIGHTMODEL_AMBIENT.rgb;//漫反射+高光+环境光，相加混合
			return fixed4(tempColor,1);
		}
		ENDCG
	}

}
FallBack &quot;Diffuse&quot;
</code></pre>
<p>}<br>
<img src="https://Wei715547.github.io/post-images/1598081504394.PNG" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式-观察者模式(事件监听/广播C#委托链)]]></title>
        <id>https://Wei715547.github.io/post/she-ji-mo-shi-guan-cha-zhe-mo-shi-shi-jian-jian-ting-guang-bo-cwei-tuo-lian/</id>
        <link href="https://Wei715547.github.io/post/she-ji-mo-shi-guan-cha-zhe-mo-shi-shi-jian-jian-ting-guang-bo-cwei-tuo-lian/">
        </link>
        <updated>2020-08-21T16:06:03.000Z</updated>
        <content type="html"><![CDATA[<p>各类委托：用于添加不同类型方法<br>
public delegate void CallBack();<br>
public delegate void CallBack<T>(T arg);<br>
public delegate void CallBack&lt;T, X&gt;(T arg1, X arg2);<br>
public delegate void CallBack&lt;T, X, Y&gt;(T arg1, X arg2, Y arg3);<br>
public delegate void CallBack&lt;T, X, Y, Z&gt;(T arg1, X arg2, Y arg3, Z arg4);<br>
public delegate void CallBack&lt;T, X, Y, Z, W&gt;(T arg1, X arg2, Y arg3, Z arg4, W arg5);<br>
事件类型枚举：<br>
public enum EventDefine<br>
{<br>
ShowGamePanel,<br>
DecidePath,<br>
AddScore,<br>
UpdateScoreText,<br>
PlayerMove,<br>
AddDiamond,<br>
UpdateDiamondText,<br>
ShowGameOverPale,<br>
ShowShopPanle,<br>
ShowMainPanle,<br>
ChageSkin,<br>
ShowResetPanel,<br>
ShowRankPanel,<br>
PlayBuyyonSound,<br>
}<br>
事件中心类：<br>
using System;<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class EventCenter<br>
{<br>
//存储的 事件表（事件类型，对应方法类型的委托链）<br>
private static Dictionary&lt;EventDefine, Delegate&gt; m_EventTable = new Dictionary&lt;EventDefine, Delegate&gt;();</p>
<p>//在委托链上添加广播该事件时要调用的方法<br>
private static void OnListenerAdding(EventDefine eventType, Delegate callBack)<br>
{<br>
if (!m_EventTable.ContainsKey(eventType))<br>
{<br>
m_EventTable.Add(eventType, null);<br>
}<br>
Delegate d = m_EventTable[eventType];<br>
if (d != null &amp;&amp; d.GetType() != callBack.GetType())<br>
{<br>
throw new Exception(string.Format(&quot;尝试为事件{0}添加不同类型的委托，当前事件所对应的委托是{1}，要添加的委托类型为{2}&quot;, eventType, d.GetType(), callBack.GetType()));<br>
}<br>
}<br>
//把监听该事件时所调用的方法从委托链上移除<br>
private static void OnListenerRemoving(EventDefine eventType, Delegate callBack)<br>
{<br>
if (m_EventTable.ContainsKey(eventType))<br>
{<br>
Delegate d = m_EventTable[eventType];<br>
if (d == null)<br>
{<br>
throw new Exception(string.Format(&quot;移除监听错误：事件{0}没有对应的委托&quot;, eventType));<br>
}<br>
else if (d.GetType() != callBack.GetType())<br>
{<br>
throw new Exception(string.Format(&quot;移除监听错误：尝试为事件{0}移除不同类型的委托，当前委托类型为{1}，要移除的委托类型为{2}&quot;, eventType, d.GetType(), callBack.GetType()));<br>
}<br>
}<br>
else<br>
{<br>
throw new Exception(string.Format(&quot;移除监听错误：没有事件码{0}&quot;, eventType));<br>
}<br>
}<br>
//把监听该事件时所调用的方法从委托链上移除<br>
private static void OnListenerRemoved(EventDefine eventType)<br>
{<br>
if (m_EventTable[eventType] == null)<br>
{<br>
m_EventTable.Remove(eventType);<br>
}<br>
}<br>
//no parameters<br>
public static void AddListener(EventDefine eventType, CallBack callBack)<br>
{<br>
OnListenerAdding(eventType, callBack);<br>
m_EventTable[eventType] = (CallBack)m_EventTable[eventType] + callBack;<br>
}<br>
//Single parameters<br>
public static void AddListener<T>(EventDefine eventType, CallBack<T> callBack)<br>
{<br>
OnListenerAdding(eventType, callBack);<br>
m_EventTable[eventType] = (CallBack<T>)m_EventTable[eventType] + callBack;<br>
}<br>
//two parameters<br>
public static void AddListener&lt;T, X&gt;(EventDefine eventType, CallBack&lt;T, X&gt; callBack)<br>
{<br>
OnListenerAdding(eventType, callBack);<br>
m_EventTable[eventType] = (CallBack&lt;T, X&gt;)m_EventTable[eventType] + callBack;<br>
}</p>
<pre><code>//no parameters
public static void RemoveListener(EventDefine eventType, CallBack callBack)
{
    OnListenerRemoving(eventType, callBack);
    m_EventTable[eventType] = (CallBack)m_EventTable[eventType] - callBack;
    OnListenerRemoved(eventType);
}
//single parameters
public static void RemoveListener&lt;T&gt;(EventDefine eventType, CallBack&lt;T&gt; callBack)
{
    OnListenerRemoving(eventType, callBack);
    m_EventTable[eventType] = (CallBack&lt;T&gt;)m_EventTable[eventType] - callBack;
    OnListenerRemoved(eventType);
}
//two parameters
public static void RemoveListener&lt;T, X&gt;(EventDefine eventType, CallBack&lt;T, X&gt; callBack)
{
    OnListenerRemoving(eventType, callBack);
    m_EventTable[eventType] = (CallBack&lt;T, X&gt;)m_EventTable[eventType] - callBack;
    OnListenerRemoved(eventType);
}
</code></pre>
<p>}<br>
//no parameters<br>
public static void Broadcast(EventDefine eventType)<br>
{<br>
Delegate d;<br>
if (m_EventTable.TryGetValue(eventType, out d))<br>
{<br>
CallBack callBack = d as CallBack;<br>
if (callBack != null)<br>
{<br>
callBack();<br>
}<br>
else<br>
{<br>
throw new Exception(string.Format(&quot;广播事件错误：事件{0}对应委托具有不同的类型&quot;, eventType));<br>
}<br>
}<br>
}<br>
//single parameters<br>
public static void Broadcast<T>(EventDefine eventType, T arg)<br>
{<br>
Delegate d;<br>
if (m_EventTable.TryGetValue(eventType, out d))<br>
{<br>
CallBack<T> callBack = d as CallBack<T>;<br>
if (callBack != null)<br>
{<br>
callBack(arg);<br>
}<br>
else<br>
{<br>
throw new Exception(string.Format(&quot;广播事件错误：事件{0}对应委托具有不同的类型&quot;, eventType));<br>
}<br>
}<br>
}</p>
<hr>
<p>UI脚本中代码：<br>
void Start()<br>
{<br>
EventCenter.AddListener(EventDefine.ShowShopPanle, Show);<br>
}<br>
private void OnDestroy()<br>
{<br>
EventCenter.RemoveListener (EventDefine.ShowShopPanle, Show);<br>
}</p>
<pre><code>private void Show()
{
    gameObject.SetActive(true);
}</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shader-透明度]]></title>
        <id>https://Wei715547.github.io/post/shader-tou-ming-du/</id>
        <link href="https://Wei715547.github.io/post/shader-tou-ming-du/">
        </link>
        <updated>2020-08-20T09:21:09.000Z</updated>
        <content type="html"><![CDATA[<p>Shader &quot;Custom/Alpha&quot;<br>
{<br>
Properties//属性<br>
{<br>
_MainTex(&quot;Main Tex&quot;,2D) = &quot;white&quot;{}//贴图代替漫反射颜色<br>
_Color(&quot;Tex Color&quot;,Color) = (1,1,1,1)//贴图颜色:与贴图uv坐标下的像素点颜色混合<br>
_NormalMap(&quot;Normal Map&quot;,2D) = &quot;bump&quot;{}//未添法线贴图时为默认法线<br>
_NormalST(&quot;Normal ST&quot;,Float) = 1//法线贴图强度参数<br>
_AlphaScale(&quot;_AlphaScale&quot;,Float) = 1<br>
}<br>
SubShader<br>
{<br>
Tags{&quot;Queue&quot; = &quot;Transparent&quot;/<em>模型渲染队列</em>/ &quot;IngnoreProjector&quot; = &quot;True&quot; &quot;RanderType&quot; = &quot;Transparent&quot;}//Pass块参数标签<br>
<img src="https://Wei715547.github.io/post-images/1598164914894.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1598166460428.PNG" alt="" loading="lazy"><br>
Pass<br>
{<br>
Tags {&quot;Lighting&quot; = &quot;ForwardBase&quot;} //定义LightMode,获取UNITY内部光照变量</p>
<pre><code>			ZWrite Off//深度写入关闭
			Blend SrcAlpha OneMinusSrcAlpha//混合模式：透明区域与透明物体后颜色混合

	*		CGPROGRAM
	*	//在CG声明属性
		sampler2D _MainTex;//ShaderCG中的关键字
		float4 _MainTex_ST; //主贴图的缩放与偏移“属性名称固定”_MainTex_ST.xy缩放属性；_MainTex_ST.zw偏移属性
		fixed4 _Color;//与贴图叠混合颜色
		sampler2D _NormalMap;
		float4 _NormalMap_ST;
		float _NormalST;
		float _AlphaScale;

	#include &quot;Lighting.cginc&quot;//引入UNITY内置文件，获取光照变量 _LightColor0.rgb;光源颜色
	#pragma vertex vert//声明顶点函数
	#pragma fragment frag//声明片原函数


	struct a2v//应用向顶点函数传递参数
	{
		float4 vertex:POSITION;//模型空间顶点坐标
		//切线空间的确定是通过（存储到模型里的/模型空间）法线 与 （存储到模型里的/模型空间）切线确定的
		float3 normal:NORMAL;//模型空间法线方向
		float4 tangent:TANGENT;//模型空间下的切线方向：tangent.w:是用来确定切线空间中坐标轴的方向（切线空间下的Z轴方向默认为顶点的法线方向:通过控制缩放xy可改变法线强度）
		float4 texcoord :TEXCOORD0;//获取纹理坐标
	};
	struct v2f//顶点函数向片原函数传递参数
	{
		float4 svPos:SV_POSITION;//顶点函数返回值：剪裁空间中的顶点坐标-系统直接使用
		//float3 worldNormal : TEXCOORD0;//顶点函数向片原函数传递世界坐标下的法线方向(使用法线贴图后不需要)
		float3 lightDir:TEXCOORD0;//切线空间下的平行光方向
		//float4 worldView:TEXCOORD1;//顶点函数向片原函数传递世界坐标下的顶点坐标

		float4 uv:TEXCOORD2;//xy用来存储_MainTex的纹理坐标，zw用来存储_NormalMap的纹理坐标
	};

	v2f vert(a2v v)//顶点函数将顶点从模型空间转到世界空间，返回值在世界坐标系下的顶点坐标
	{
		v2f f;//声明传参结构体,并对其中的值赋值
		f.svPos = UnityObjectToClipPos(v.vertex);
		//f.worldNormal = UnityObjectToWorldNormal(v.normal);
		//f.worldView = (UnityObjectToWorldNormal(v.vertex), 0);
		f.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;//将纹理坐标传递到片原函数 * 乘上主贴图缩放属性 + 加上主贴图的偏移属性
		f.uv.zw = v.texcoord.xy * _NormalMap_ST.xy + _NormalMap_ST.zw;//将法线纹理坐标与其属性结合存储到uv.zw中

		TANGENT_SPACE_ROTATION;//调用这个宏后(保证a2v &quot;v&quot;中存在&quot;normal&quot;&quot;tangent&quot;宏自动调用)，会得到一个矩阵&quot;rotation&quot;这个矩阵用来把模型空间下的法线转换到切线空间下

		//ObjSpaceLightDir(v.vertex);//模型空间下的平行光方向
		f.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex));//将切线就下的平行光方向传到片原函数
		return f;//返回结构体
	}

	//把与法线有关相关计算放到切线空间下（从法线贴图取到的方向坐标为切线空间下的）
	fixed4 frag(v2f f) :SV_Target//片原函数，返回值为输出到像素颜色值的缓存
	{
		//计算漫反射
		//fixed3 normalDir = normalize(f.worldNormal);//法线方向
		fixed4 normalColor = tex2D(_NormalMap,f.uv.zw);//法线贴图在纹理坐标下的颜色值(只使用其中RGB值)

		//此方法法线读取不正确//fixed3 tangentNormal = normalize(normalColor.xyz * 2 - 1);//切线空间下的法线方向
		fixed3 tangentNormal = normalize(UnpackNormal(normalColor));//在UNITY中将法线贴图类型设置为法线贴图时可用此方法获得切线空间下的法线方向
		//切线空间下的Z轴方向默认为顶点的法线方向:通过控制缩放xy可改变法线强度，则如下
		tangentNormal.xy = tangentNormal.xy * _NormalST;//强度为0时使用的即是模型顶点默认的法线方向

		fixed3 lightDir = normalize(f.lightDir);//单位化切线空间下的光源方向

		fixed4 texColor = tex2D(_MainTex, f.uv.xy) * _Color;//获取纹理坐标下贴图像素点的颜色*与外部属性控制的贴图颜色混合

		fixed3 diffuse = _LightColor0.rgb * texColor.rgb * max((dot(tangentNormal,lightDir) * 0.5 + 0.5), 0);//fixed3 harfLambert =dot(f.wordNormalDir, lightDir)*0.5+0.5;//半兰伯特光照模型:直射光颜色 * (cos夹角(光与法线)*0.5+0.5):使背光面不完全为黑色

		//计算高光反射
		//fixed3 reflectDir = normalize(reflect(-lightDir, normalDir));
		//fixed3 viewDir = normalize(WorldSpaceViewDir(f.worldView));//实视线方向
		//fixed3 harfDir = normalize(viewDir + lightDir);//视角与平行光的平分方向
		//fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(dot(normalDir, harfDir),0), _Gloss);//BP模型://Blinn-Phong光照模型Specular = 直射光*pow(max(cos夹角,0)*高光参数) ，夹角：法线与x方向夹角,x:平行光与视野方向的平分项。

		fixed3 tempColor = diffuse + UNITY_LIGHTMODEL_AMBIENT.rgb * texColor;//漫反射+高光+环境光*纹理，相加混合（环境光与纹理混合：使强光下的纹理仍保持清晰）
		return fixed4(tempColor,_AlphaScale*texColor.a);//外部属性与纹理贴图Alpha值混合控制
	}
	ENDCG
}

	}
		FallBack &quot;Diffuse&quot;
</code></pre>
<p>}</p>
]]></content>
    </entry>
</feed>