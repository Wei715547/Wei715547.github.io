<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Wei715547.github.io</id>
    <title>Wei: Development technology accumulation</title>
    <updated>2020-08-22T11:37:02.019Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Wei715547.github.io"/>
    <link rel="self" href="https://Wei715547.github.io/atom.xml"/>
    <subtitle>年月增长，我宜强盛。
用于Unity+开发的技术积累</subtitle>
    <logo>https://Wei715547.github.io/images/avatar.png</logo>
    <icon>https://Wei715547.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Wei: Development technology accumulation</rights>
    <entry>
        <title type="html"><![CDATA[Shader_渐变与遮罩纹理]]></title>
        <id>https://Wei715547.github.io/post/shader_-jian-bian-yu-zhe-zhao-wen-li/</id>
        <link href="https://Wei715547.github.io/post/shader_-jian-bian-yu-zhe-zhao-wen-li/">
        </link>
        <updated>2020-08-22T07:30:11.000Z</updated>
        <content type="html"><![CDATA[<p>Shader &quot;Custom/Jianbian_Zhezhao&quot;<br>
{<br>
Properties//属性<br>
{<br>
_Diffuse(&quot;_DiffuseColor&quot;,Color) = (1,1,1,1)//漫反射颜色<br>
_Specular(&quot;_Specular&quot;, Color) = (1, 1, 1, 1)//高光颜色<br>
_Gloss(&quot;_Gloss&quot;, Range(10, 200)) = 20//高光参数<br>
_Fad(&quot;_Fad&quot;,Color) = (1,1,1,1)//渐变贴图：作用于漫反射：fixed3 fad = tex2D(_Fad,float2()halfLambert,halfLambert).rgb(以半兰伯特值作为坐标获得在渐变贴图上的颜色代替半兰伯特值)<br>
_SpecularMask(&quot;_SpecularMask&quot;,Color) = (1,1,1,1)//高光遮罩贴图<br>
_SpecularScale(&quot;_SpecularScale&quot;,float) = 1//高光遮罩强度<br>
}<br>
SubShader<br>
{<br>
Pass<br>
{<br>
Tags {&quot;Lighting&quot; = &quot;ForwardBase&quot;} //定义LightMode,获取UNITY内部光照变量<br>
CGPROGRAM<br>
//在CG声明属性<br>
fixed4 _Diffuse;<br>
fixed4 _Specular;<br>
int _Gloss;<br>
fixed4 _Fad;<br>
fixed4 _SpecularMask;<br>
float _SpecularScale;</p>
<pre><code>		#include &quot;Lighting.cginc&quot;//引入UNITY内置文件，获取光照变量 _LightColor0.rgb;光源颜色
		#pragma vertex vert//声明顶点函数
		#pragma fragment frag//声明片原函数
		

		struct a2v//应用向顶点函数传递参数
		{
			float4 vertex:POSITION;//模型空间顶点坐标
			float3 normal:NORMAL;//模型空间法线方向
		};
		struct v2f//顶点函数向片原函数传递参数
		{
			float4 svPos:SV_POSITION;//顶点函数返回值：剪裁空间中的顶点坐标-系统直接使用
			float3 worldNormal : TEXCOORD0;//顶点函数向片原函数传递世界坐标下的法线方向
			float4 worldView:TEXCOORD1;//顶点函数向片原函数传递世界坐标下的顶点坐标
		};

		v2f vert(a2v v)//顶点函数将顶点从模型空间转到世界空间，返回值在世界坐标系下的顶点坐标
		{
			v2f f;//声明传参结构体,并对其中的值赋值
			f.svPos = UnityObjectToClipPos(v.vertex);
			f.worldNormal = UnityObjectToWorldNormal(v.normal);
			f.worldView = (UnityObjectToWorldNormal(v.vertex), 0);
			return f;//返回结构体
		}

		fixed4 frag(v2f f) :SV_Target//片原函数，返回值为输出到像素颜色值的缓存
		{
			//计算漫反射
			fixed3 amblent = UNITY_LIGHTMODEL_AMBIENT.rgb;//获取系统环境光		
			fixed3 normalDir = normalize(f.worldNormal);
			fixed3 lightDir = normalize(_WorldSpaceLightPos0.xyz);//第一个直射光的位置，对于顶点来说光的位置即是光的方向
			//漫反射渐变贴图
			//fixed3 fad = tex2D(_Fad,float2()halfLambert,halfLambert).rgb
			//fixed3 diffuse = _LightColor0.rgb*_DiffuseColor*fad;

			fixed3 harfLambert = max( dot(normalDir, lightDir)*0.5+0.5,0)*_Fad.rgb;//半兰伯特光照模型:直射光颜色 * (cos夹角(光与法线)*0.5+0.5):使背光面不完全为黑色,半兰伯特模型*渐变贴图.rgb
			fixed3 diffuse = _LightColor0.rgb * harfLambert * _Diffuse.rgb;//根据漫反射公式：直射光颜色 * cos夹角(光与法线)获取颜色 dot(a,b):点乘获取两向量的夹角cos

			//计算高光反射
			//fixed3 reflectDir = normalize(reflect(-lightDir, normalDir));
			fixed3 viewDir = normalize(WorldSpaceViewDir(f.worldView));//实视线方向
			fixed3 harfDir = normalize(viewDir + lightDir);//视角与平行光的平分方向

			//fixed specularMask = tex2D(_SpecularMask,f.uv.xy).r * _SpecularScale;//高光遮罩贴图的某通道值 * 遮罩强度 与高光反射模型相乘控制高光遮罩强度

			fixed specularMask = _SpecularMask.rgb*_SpecularScale;
			fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(dot(normalDir, harfDir),0), _Gloss)*specularMask;//BP模型://Blinn-Phong光照模型Specular = 直射光*pow(max(cos夹角,0)*高光参数) ，夹角：法线与x方向夹角,x:平行光与视野方向的平分项。
			fixed3 tempColor = diffuse + specular + UNITY_LIGHTMODEL_AMBIENT.rgb;//漫反射+高光+环境光，相加混合
			return fixed4(tempColor,1);
		}
		ENDCG
	}

}
FallBack &quot;Diffuse&quot;
</code></pre>
<p>}<br>
<img src="https://Wei715547.github.io/post-images/1598081504394.PNG" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式-观察者模式(事件监听/广播C#委托链)]]></title>
        <id>https://Wei715547.github.io/post/she-ji-mo-shi-guan-cha-zhe-mo-shi-shi-jian-jian-ting-guang-bo-cwei-tuo-lian/</id>
        <link href="https://Wei715547.github.io/post/she-ji-mo-shi-guan-cha-zhe-mo-shi-shi-jian-jian-ting-guang-bo-cwei-tuo-lian/">
        </link>
        <updated>2020-08-21T16:06:03.000Z</updated>
        <content type="html"><![CDATA[<p>各类委托：用于添加不同类型方法<br>
public delegate void CallBack();<br>
public delegate void CallBack<T>(T arg);<br>
public delegate void CallBack&lt;T, X&gt;(T arg1, X arg2);<br>
public delegate void CallBack&lt;T, X, Y&gt;(T arg1, X arg2, Y arg3);<br>
public delegate void CallBack&lt;T, X, Y, Z&gt;(T arg1, X arg2, Y arg3, Z arg4);<br>
public delegate void CallBack&lt;T, X, Y, Z, W&gt;(T arg1, X arg2, Y arg3, Z arg4, W arg5);<br>
事件类型枚举：<br>
public enum EventDefine<br>
{<br>
ShowGamePanel,<br>
DecidePath,<br>
AddScore,<br>
UpdateScoreText,<br>
PlayerMove,<br>
AddDiamond,<br>
UpdateDiamondText,<br>
ShowGameOverPale,<br>
ShowShopPanle,<br>
ShowMainPanle,<br>
ChageSkin,<br>
ShowResetPanel,<br>
ShowRankPanel,<br>
PlayBuyyonSound,<br>
}<br>
事件中心类：<br>
using System;<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class EventCenter<br>
{<br>
//存储的 事件表（事件类型，对应方法类型的委托链）<br>
private static Dictionary&lt;EventDefine, Delegate&gt; m_EventTable = new Dictionary&lt;EventDefine, Delegate&gt;();</p>
<p>//在委托链上添加广播该事件时要调用的方法<br>
private static void OnListenerAdding(EventDefine eventType, Delegate callBack)<br>
{<br>
if (!m_EventTable.ContainsKey(eventType))<br>
{<br>
m_EventTable.Add(eventType, null);<br>
}<br>
Delegate d = m_EventTable[eventType];<br>
if (d != null &amp;&amp; d.GetType() != callBack.GetType())<br>
{<br>
throw new Exception(string.Format(&quot;尝试为事件{0}添加不同类型的委托，当前事件所对应的委托是{1}，要添加的委托类型为{2}&quot;, eventType, d.GetType(), callBack.GetType()));<br>
}<br>
}<br>
//把监听该事件时所调用的方法从委托链上移除<br>
private static void OnListenerRemoving(EventDefine eventType, Delegate callBack)<br>
{<br>
if (m_EventTable.ContainsKey(eventType))<br>
{<br>
Delegate d = m_EventTable[eventType];<br>
if (d == null)<br>
{<br>
throw new Exception(string.Format(&quot;移除监听错误：事件{0}没有对应的委托&quot;, eventType));<br>
}<br>
else if (d.GetType() != callBack.GetType())<br>
{<br>
throw new Exception(string.Format(&quot;移除监听错误：尝试为事件{0}移除不同类型的委托，当前委托类型为{1}，要移除的委托类型为{2}&quot;, eventType, d.GetType(), callBack.GetType()));<br>
}<br>
}<br>
else<br>
{<br>
throw new Exception(string.Format(&quot;移除监听错误：没有事件码{0}&quot;, eventType));<br>
}<br>
}<br>
//把监听该事件时所调用的方法从委托链上移除<br>
private static void OnListenerRemoved(EventDefine eventType)<br>
{<br>
if (m_EventTable[eventType] == null)<br>
{<br>
m_EventTable.Remove(eventType);<br>
}<br>
}<br>
//no parameters<br>
public static void AddListener(EventDefine eventType, CallBack callBack)<br>
{<br>
OnListenerAdding(eventType, callBack);<br>
m_EventTable[eventType] = (CallBack)m_EventTable[eventType] + callBack;<br>
}<br>
//Single parameters<br>
public static void AddListener<T>(EventDefine eventType, CallBack<T> callBack)<br>
{<br>
OnListenerAdding(eventType, callBack);<br>
m_EventTable[eventType] = (CallBack<T>)m_EventTable[eventType] + callBack;<br>
}<br>
//two parameters<br>
public static void AddListener&lt;T, X&gt;(EventDefine eventType, CallBack&lt;T, X&gt; callBack)<br>
{<br>
OnListenerAdding(eventType, callBack);<br>
m_EventTable[eventType] = (CallBack&lt;T, X&gt;)m_EventTable[eventType] + callBack;<br>
}</p>
<pre><code>//no parameters
public static void RemoveListener(EventDefine eventType, CallBack callBack)
{
    OnListenerRemoving(eventType, callBack);
    m_EventTable[eventType] = (CallBack)m_EventTable[eventType] - callBack;
    OnListenerRemoved(eventType);
}
//single parameters
public static void RemoveListener&lt;T&gt;(EventDefine eventType, CallBack&lt;T&gt; callBack)
{
    OnListenerRemoving(eventType, callBack);
    m_EventTable[eventType] = (CallBack&lt;T&gt;)m_EventTable[eventType] - callBack;
    OnListenerRemoved(eventType);
}
//two parameters
public static void RemoveListener&lt;T, X&gt;(EventDefine eventType, CallBack&lt;T, X&gt; callBack)
{
    OnListenerRemoving(eventType, callBack);
    m_EventTable[eventType] = (CallBack&lt;T, X&gt;)m_EventTable[eventType] - callBack;
    OnListenerRemoved(eventType);
}
</code></pre>
<p>}<br>
//no parameters<br>
public static void Broadcast(EventDefine eventType)<br>
{<br>
Delegate d;<br>
if (m_EventTable.TryGetValue(eventType, out d))<br>
{<br>
CallBack callBack = d as CallBack;<br>
if (callBack != null)<br>
{<br>
callBack();<br>
}<br>
else<br>
{<br>
throw new Exception(string.Format(&quot;广播事件错误：事件{0}对应委托具有不同的类型&quot;, eventType));<br>
}<br>
}<br>
}<br>
//single parameters<br>
public static void Broadcast<T>(EventDefine eventType, T arg)<br>
{<br>
Delegate d;<br>
if (m_EventTable.TryGetValue(eventType, out d))<br>
{<br>
CallBack<T> callBack = d as CallBack<T>;<br>
if (callBack != null)<br>
{<br>
callBack(arg);<br>
}<br>
else<br>
{<br>
throw new Exception(string.Format(&quot;广播事件错误：事件{0}对应委托具有不同的类型&quot;, eventType));<br>
}<br>
}<br>
}</p>
<hr>
<p>UI脚本中代码：<br>
void Start()<br>
{<br>
EventCenter.AddListener(EventDefine.ShowShopPanle, Show);<br>
}<br>
private void OnDestroy()<br>
{<br>
EventCenter.RemoveListener (EventDefine.ShowShopPanle, Show);<br>
}</p>
<pre><code>private void Show()
{
    gameObject.SetActive(true);
}</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shader-透明度]]></title>
        <id>https://Wei715547.github.io/post/shader-tou-ming-du/</id>
        <link href="https://Wei715547.github.io/post/shader-tou-ming-du/">
        </link>
        <updated>2020-08-20T09:21:09.000Z</updated>
        <content type="html"><![CDATA[<p>Shader &quot;Custom/Alpha&quot;<br>
{<br>
Properties//属性<br>
{<br>
_MainTex(&quot;Main Tex&quot;,2D) = &quot;white&quot;{}//贴图代替漫反射颜色<br>
_Color(&quot;Tex Color&quot;,Color) = (1,1,1,1)//贴图颜色:与贴图uv坐标下的像素点颜色混合<br>
_NormalMap(&quot;Normal Map&quot;,2D) = &quot;bump&quot;{}//未添法线贴图时为默认法线<br>
_NormalST(&quot;Normal ST&quot;,Float) = 1//法线贴图强度参数<br>
_AlphaScale(&quot;_AlphaScale&quot;,Float) = 1<br>
}<br>
SubShader<br>
{<br>
Tags{&quot;Queue&quot; = &quot;Transparent&quot; &quot;IngnoreProjector&quot; = &quot;True&quot; &quot;RanderType&quot; = &quot;Transparent&quot;}//Pass块参数标签</p>
<pre><code>		Pass
		{
			Tags {&quot;Lighting&quot; = &quot;ForwardBase&quot;} //定义LightMode,获取UNITY内部光照变量

			ZWrite Off//深度写入关闭
			Blend SrcAlpha OneMinusSrcAlpha//模式

			CGPROGRAM
		//在CG声明属性
		sampler2D _MainTex;//ShaderCG中的关键字
		float4 _MainTex_ST; //主贴图的缩放与偏移“属性名称固定”_MainTex_ST.xy缩放属性；_MainTex_ST.zw偏移属性
		fixed4 _Color;//与贴图叠混合颜色
		sampler2D _NormalMap;
		float4 _NormalMap_ST;
		float _NormalST;
		float _AlphaScale;

	#include &quot;Lighting.cginc&quot;//引入UNITY内置文件，获取光照变量 _LightColor0.rgb;光源颜色
	#pragma vertex vert//声明顶点函数
	#pragma fragment frag//声明片原函数


	struct a2v//应用向顶点函数传递参数
	{
		float4 vertex:POSITION;//模型空间顶点坐标
		//切线空间的确定是通过（存储到模型里的/模型空间）法线 与 （存储到模型里的/模型空间）切线确定的
		float3 normal:NORMAL;//模型空间法线方向
		float4 tangent:TANGENT;//模型空间下的切线方向：tangent.w:是用来确定切线空间中坐标轴的方向（切线空间下的Z轴方向默认为顶点的法线方向:通过控制缩放xy可改变法线强度）
		float4 texcoord :TEXCOORD0;//获取纹理坐标
	};
	struct v2f//顶点函数向片原函数传递参数
	{
		float4 svPos:SV_POSITION;//顶点函数返回值：剪裁空间中的顶点坐标-系统直接使用
		//float3 worldNormal : TEXCOORD0;//顶点函数向片原函数传递世界坐标下的法线方向(使用法线贴图后不需要)
		float3 lightDir:TEXCOORD0;//切线空间下的平行光方向
		//float4 worldView:TEXCOORD1;//顶点函数向片原函数传递世界坐标下的顶点坐标

		float4 uv:TEXCOORD2;//xy用来存储_MainTex的纹理坐标，zw用来存储_NormalMap的纹理坐标
	};

	v2f vert(a2v v)//顶点函数将顶点从模型空间转到世界空间，返回值在世界坐标系下的顶点坐标
	{
		v2f f;//声明传参结构体,并对其中的值赋值
		f.svPos = UnityObjectToClipPos(v.vertex);
		//f.worldNormal = UnityObjectToWorldNormal(v.normal);
		//f.worldView = (UnityObjectToWorldNormal(v.vertex), 0);
		f.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;//将纹理坐标传递到片原函数 * 乘上主贴图缩放属性 + 加上主贴图的偏移属性
		f.uv.zw = v.texcoord.xy * _NormalMap_ST.xy + _NormalMap_ST.zw;//将法线纹理坐标与其属性结合存储到uv.zw中

		TANGENT_SPACE_ROTATION;//调用这个宏后(保证a2v &quot;v&quot;中存在&quot;normal&quot;&quot;tangent&quot;宏自动调用)，会得到一个矩阵&quot;rotation&quot;这个矩阵用来把模型空间下的法线转换到切线空间下

		//ObjSpaceLightDir(v.vertex);//模型空间下的平行光方向
		f.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex));//将切线就下的平行光方向传到片原函数
		return f;//返回结构体
	}

	//把与法线有关相关计算放到切线空间下（从法线贴图取到的方向坐标为切线空间下的）
	fixed4 frag(v2f f) :SV_Target//片原函数，返回值为输出到像素颜色值的缓存
	{
		//计算漫反射
		//fixed3 normalDir = normalize(f.worldNormal);//法线方向
		fixed4 normalColor = tex2D(_NormalMap,f.uv.zw);//法线贴图在纹理坐标下的颜色值(只使用其中RGB值)

		//此方法法线读取不正确//fixed3 tangentNormal = normalize(normalColor.xyz * 2 - 1);//切线空间下的法线方向
		fixed3 tangentNormal = normalize(UnpackNormal(normalColor));//在UNITY中将法线贴图类型设置为法线贴图时可用此方法获得切线空间下的法线方向
		//切线空间下的Z轴方向默认为顶点的法线方向:通过控制缩放xy可改变法线强度，则如下
		tangentNormal.xy = tangentNormal.xy * _NormalST;//强度为0时使用的即是模型顶点默认的法线方向

		fixed3 lightDir = normalize(f.lightDir);//单位化切线空间下的光源方向

		fixed4 texColor = tex2D(_MainTex, f.uv.xy) * _Color;//获取纹理坐标下贴图像素点的颜色*与外部属性控制的贴图颜色混合

		fixed3 diffuse = _LightColor0.rgb * texColor.rgb * max((dot(tangentNormal,lightDir) * 0.5 + 0.5), 0);//fixed3 harfLambert =dot(f.wordNormalDir, lightDir)*0.5+0.5;//半兰伯特光照模型:直射光颜色 * (cos夹角(光与法线)*0.5+0.5):使背光面不完全为黑色

		//计算高光反射
		//fixed3 reflectDir = normalize(reflect(-lightDir, normalDir));
		//fixed3 viewDir = normalize(WorldSpaceViewDir(f.worldView));//实视线方向
		//fixed3 harfDir = normalize(viewDir + lightDir);//视角与平行光的平分方向
		//fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(dot(normalDir, harfDir),0), _Gloss);//BP模型://Blinn-Phong光照模型Specular = 直射光*pow(max(cos夹角,0)*高光参数) ，夹角：法线与x方向夹角,x:平行光与视野方向的平分项。

		fixed3 tempColor = diffuse + UNITY_LIGHTMODEL_AMBIENT.rgb * texColor;//漫反射+高光+环境光*纹理，相加混合（环境光与纹理混合：使强光下的纹理仍保持清晰）
		return fixed4(tempColor,_AlphaScale*texColor.a);//外部属性与纹理贴图Alpha值混合控制
	}
	ENDCG
}

	}
		FallBack &quot;Diffuse&quot;
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shader-法线]]></title>
        <id>https://Wei715547.github.io/post/shader-fa-xian/</id>
        <link href="https://Wei715547.github.io/post/shader-fa-xian/">
        </link>
        <updated>2020-08-20T06:55:11.000Z</updated>
        <content type="html"><![CDATA[<p>像素点.rgb(0<sub>1)与法线方向(-1</sub>1)转换：<br>
pixel = (normal+1)/2<br>
normal = pixel*2-1 (切下空间下法线方向)<br>
切线空间来存储法线：模型的每个顶点都有一个属于自己的切线空间，这个切线空间的原点就是该点本身，的Z轴方向默认为该顶点的法线方向，x轴是该顶点的切线方向，则y轴可由法线与切线的叉积得到(副切线)。<br>
模型空间下的法线贴图看起来的五颜六色的是由于在模型空间下个顶点的法线方向是各异的。<br>
切线空间下的法线贴图大部分呈现浅蓝色是由于如果一个点的法线方向不变则默认方向即为Z轴方向对应(0,0,1)转换后的像素颜色为RGB(0.5,0.5,1)浅蓝色，贴图中大部分的蓝色实际上说明顶点的大部分法线是和模型本身一样的不需要改变。<br>
<code><br>
Shader &quot;Custom/Normal&quot;<br>
{<br>
Properties//属性<br>
{<br>
_MainTex(&quot;Main Tex&quot;,2D) = &quot;white&quot;{}//贴图代替漫反射颜色<br>
_Color(&quot;Tex Color&quot;,Color) = (1,1,1,1)//贴图颜色:与贴图uv坐标下的像素点颜色混合<br>
_NormalMap(&quot;Normal Map&quot;,2D) = &quot;bump&quot;{}//未添法线贴图时为默认法线<br>
_NormalST(&quot;Normal ST&quot;,Float) = 1//法线贴图强度参数<br>
}<br>
SubShader<br>
{<br>
Pass<br>
{<br>
Tags {&quot;Lighting&quot; = &quot;ForwardBase&quot;} //定义LightMode,获取UNITY内部光照变量<br>
CGPROGRAM<br>
//在CG声明属性<br>
sampler2D _MainTex;//ShaderCG中的关键字<br>
float4 _MainTex_ST; //主贴图的缩放与偏移“属性名称固定”_MainTex_ST.xy缩放属性；_MainTex_ST.zw偏移属性<br>
fixed4 _Color;//与贴图叠混合颜色<br>
sampler2D _NormalMap;<br>
float4 _NormalMap_ST;<br>
float _NormalST;</p>
<pre><code>	#include &quot;Lighting.cginc&quot;//引入UNITY内置文件，获取光照变量 _LightColor0.rgb;光源颜色
	#pragma vertex vert//声明顶点函数
	#pragma fragment frag//声明片原函数


	struct a2v//应用向顶点函数传递参数
	{
		float4 vertex:POSITION;//模型空间顶点坐标
		//切线空间的确定是通过（存储到模型里的/模型空间）法线 与 （存储到模型里的/模型空间）切线确定的
		float3 normal:NORMAL;//模型空间法线方向
		float4 tangent:TANGENT;//模型空间下的切线方向：tangent.w:是用来确定切线空间中坐标轴的方向（切线空间下的Z轴方向默认为顶点的法线方向:通过控制缩放xy可改变法线强度）
		float4 texcoord :TEXCOORD0;//获取纹理坐标
	};
	struct v2f//顶点函数向片原函数传递参数
	{
		float4 svPos:SV_POSITION;//顶点函数返回值：剪裁空间中的顶点坐标-系统直接使用
		//float3 worldNormal : TEXCOORD0;//顶点函数向片原函数传递世界坐标下的法线方向(使用法线贴图后不需要)
		float3 lightDir:TEXCOORD0;//切线空间下的平行光方向
		//float4 worldView:TEXCOORD1;//顶点函数向片原函数传递世界坐标下的顶点坐标

		float4 uv:TEXCOORD2;//xy用来存储_MainTex的纹理坐标，zw用来存储_NormalMap的纹理坐标
	};

	v2f vert(a2v v)//顶点函数将顶点从模型空间转到世界空间，返回值在世界坐标系下的顶点坐标
	{
		v2f f;//声明传参结构体,并对其中的值赋值
		f.svPos = UnityObjectToClipPos(v.vertex);
		//f.worldNormal = UnityObjectToWorldNormal(v.normal);
		//f.worldView = (UnityObjectToWorldNormal(v.vertex), 0);
		f.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;//将纹理坐标传递到片原函数 * 乘上主贴图缩放属性 + 加上主贴图的偏移属性
		f.uv.zw = v.texcoord.xy * _NormalMap_ST.xy + _NormalMap_ST.zw;//将法线纹理坐标与其属性结合存储到uv.zw中

		TANGENT_SPACE_ROTATION;//调用这个宏后(保证a2v &quot;v&quot;中存在&quot;normal&quot;&quot;tangent&quot;宏自动调用)，会得到一个矩阵&quot;rotation&quot;这个矩阵用来把模型空间下的法线转换到切线空间下

		//ObjSpaceLightDir(v.vertex);//模型空间下的平行光方向
		f.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex));//将切线就下的平行光方向传到片原函数
		return f;//返回结构体
	}

	//把与法线有关相关计算放到切线空间下（从法线贴图取到的方向坐标为切线空间下的）
	fixed4 frag(v2f f) :SV_Target//片原函数，返回值为输出到像素颜色值的缓存
	{
		//计算漫反射
		//fixed3 normalDir = normalize(f.worldNormal);//法线方向
		fixed4 normalColor = tex2D(_NormalMap,f.uv.zw);//法线贴图在纹理坐标下的颜色值(只使用其中RGB值)

		//此方法法线读取不正确//fixed3 tangentNormal = normalize(normalColor.xyz * 2 - 1);//切线空间下的法线方向
		fixed3 tangentNormal = normalize(UnpackNormal(normalColor));//在UNITY中将法线贴图类型设置为法线贴图时可用此方法获得切线空间下的法线方向
		//切线空间下的Z轴方向默认为顶点的法线方向:通过控制缩放xy可改变法线强度，则如下
		tangentNormal.xy = tangentNormal.xy * _NormalST;//强度为0时使用的即是模型顶点默认的法线方向

		fixed3 lightDir = normalize(f.lightDir);//单位化切线空间下的光源方向

		fixed3 texColor = tex2D(_MainTex, f.uv.xy) * _Color.rgb;//获取纹理坐标下贴图像素点的颜色*与外部属性控制的贴图颜色混合

		fixed3 diffuse = _LightColor0.rgb * texColor * max((dot(tangentNormal,lightDir) * 0.5 + 0.5), 0);//fixed3 harfLambert =dot(f.wordNormalDir, lightDir)*0.5+0.5;//半兰伯特光照模型:直射光颜色 * (cos夹角(光与法线)*0.5+0.5):使背光面不完全为黑色

		//计算高光反射
		//fixed3 reflectDir = normalize(reflect(-lightDir, normalDir));
		//fixed3 viewDir = normalize(WorldSpaceViewDir(f.worldView));//实视线方向
		//fixed3 harfDir = normalize(viewDir + lightDir);//视角与平行光的平分方向
		//fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(dot(normalDir, harfDir),0), _Gloss);//BP模型://Blinn-Phong光照模型Specular = 直射光*pow(max(cos夹角,0)*高光参数) ，夹角：法线与x方向夹角,x:平行光与视野方向的平分项。

		fixed3 tempColor = diffuse + UNITY_LIGHTMODEL_AMBIENT.rgb * texColor;//漫反射+高光+环境光*纹理，相加混合（环境光与纹理混合：使强光下的纹理仍保持清晰）
		return fixed4(tempColor,1);
	}
	ENDCG
}

	}
		FallBack &quot;Diffuse&quot;
</code></pre>
<p>}<br>
</code><br>
<img src="https://Wei715547.github.io/post-images/1597913629337.PNG" alt="" loading="lazy"><br>
————————————————————————————————————<br>
法线与高光(在切线空间下使用BP光照模型计算高光)<br>
<code><br>
Shader &quot;Custom/Normal&quot;<br>
{<br>
Properties//属性<br>
{<br>
_MainTex(&quot;Main Tex&quot;,2D) = &quot;white&quot;{}//贴图代替漫反射颜色<br>
_Color(&quot;Tex Color&quot;,Color) = (1,1,1,1)//贴图颜色:与贴图uv坐标下的像素点颜色混合<br>
_NormalMap(&quot;Normal Map&quot;,2D) = &quot;bump&quot;{}//未添法线贴图时为默认法线<br>
_NormalST(&quot;Normal ST&quot;,Float) = 1//法线贴图强度参数<br>
_Specular(&quot;_Specular&quot;, Color) = (1, 1, 1, 1)//高光颜色<br>
_Gloss(&quot;_Gloss&quot;, Range(1, 200)) = 20//高光参数<br>
}<br>
SubShader<br>
{<br>
Pass<br>
{<br>
Tags {&quot;Lighting&quot; = &quot;ForwardBase&quot;} //定义LightMode,获取UNITY内部光照变量<br>
CGPROGRAM<br>
//在CG声明属性<br>
sampler2D _MainTex;//ShaderCG中的关键字<br>
float4 _MainTex_ST; //主贴图的缩放与偏移“属性名称固定”_MainTex_ST.xy缩放属性；_MainTex_ST.zw偏移属性<br>
fixed4 _Color;//与贴图叠混合颜色<br>
sampler2D _NormalMap;<br>
float4 _NormalMap_ST;<br>
float _NormalST;<br>
fixed4 _Specular;<br>
int _Gloss;</p>
<pre><code>	#include &quot;Lighting.cginc&quot;//引入UNITY内置文件，获取光照变量 _LightColor0.rgb;光源颜色
	#pragma vertex vert//声明顶点函数
	#pragma fragment frag//声明片原函数


	struct a2v//应用向顶点函数传递参数
	{
		float4 vertex:POSITION;//模型空间顶点坐标
		//切线空间的确定是通过（存储到模型里的/模型空间）法线 与 （存储到模型里的/模型空间）切线确定的
		float3 normal:NORMAL;//模型空间法线方向
		float4 tangent:TANGENT;//模型空间下的切线方向：tangent.w:是用来确定切线空间中坐标轴的方向（切线空间下的Z轴方向默认为顶点的法线方向:通过控制缩放xy可改变法线强度）
		float4 texcoord :TEXCOORD0;//获取纹理坐标
	};
	struct v2f//顶点函数向片原函数传递参数
	{
		float4 svPos:SV_POSITION;//顶点函数返回值：剪裁空间中的顶点坐标-系统直接使用
		//float3 worldNormal : TEXCOORD3;//顶点函数向片原函数传递世界坐标下的法线方向(使用法线贴图后不需要)
		float3 lightDir:TEXCOORD0;//切线空间下的平行光方向
		float3 viewDir:TEXCOORD1;//顶点函数向片原函数传递且切线空间下的视线方向

		float4 uv:TEXCOORD2;//xy用来存储_MainTex的纹理坐标，zw用来存储_NormalMap的纹理坐标
	};

	v2f vert(a2v v)//顶点函数将顶点从模型空间转到世界空间，返回值在世界坐标系下的顶点坐标
	{
		v2f f;//声明传参结构体,并对其中的值赋值
		f.svPos = UnityObjectToClipPos(v.vertex);
		//f.worldNormal = UnityObjectToWorldNormal(v.normal);
		//f.worldView = (UnityObjectToWorldNormal(v.vertex), 0);
		f.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;//将纹理坐标传递到片原函数 * 乘上主贴图缩放属性 + 加上主贴图的偏移属性
		f.uv.zw = v.texcoord.xy * _NormalMap_ST.xy + _NormalMap_ST.zw;//将法线纹理坐标与其属性结合存储到uv.zw中

		TANGENT_SPACE_ROTATION;//调用这个宏后(保证a2v &quot;v&quot;中存在&quot;normal&quot;&quot;tangent&quot;宏自动调用)，会得到一个矩阵&quot;rotation&quot;这个矩阵用来把模型空间下的法线转换到切线空间下

		//ObjSpaceLightDir(v.vertex);//模型空间下的平行光方向
		f.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex));//将切线就下的平行光方向传到片原函数
		f.viewDir = mul(rotation, ObjSpaceViewDir(v.vertex));//计算切线空间下的视角方向
		return f;//返回结构体
	}

	//把与法线有关相关计算放到切线空间下（从法线贴图取到的方向坐标为切线空间下的）
	fixed4 frag(v2f f) :SV_Target//片原函数，返回值为输出到像素颜色值的缓存
	{
		//计算漫反射
		//fixed3 normalDir = normalize(f.worldNormal);//法线方向
		fixed4 normalColor = tex2D(_NormalMap,f.uv.zw);//法线贴图在纹理坐标下的颜色值(只使用其中RGB值)

		//此方法法线读取不正确//fixed3 tangentNormal = normalize(normalColor.xyz * 2 - 1);//切线空间下的法线方向
		fixed3 tangentNormal = normalize(UnpackNormal(normalColor));//在UNITY中将法线贴图类型设置为法线贴图时可用此方法获得切线空间下的法线方向
		//切线空间下的Z轴方向默认为顶点的法线方向:通过控制缩放xy可改变法线强度，则如下
		tangentNormal.xy = tangentNormal.xy * _NormalST;//强度为0时使用的即是模型顶点默认的法线方向

		fixed3 lightDir = normalize(f.lightDir);//单位化切线空间下的光源方向

		fixed3 texColor = tex2D(_MainTex, f.uv.xy) * _Color.rgb;//获取纹理坐标下贴图像素点的颜色*与外部属性控制的贴图颜色混合

		fixed3 diffuse = _LightColor0.rgb * texColor * max((dot(lightDir,tangentNormal) * 0.5 + 0.5), 0);//fixed3 harfLambert =dot(f.wordNormalDir, lightDir)*0.5+0.5;//半兰伯特光照模型:直射光颜色 * (cos夹角(光与法线)*0.5+0.5):使背光面不完全为黑色

		//计算高光反射
		//fixed3 reflectDir = normalize(reflect(-lightDir, normalDir));
		fixed3 viewDir = normalize(f.viewDir);//实视线方向
		fixed3 harfDir = normalize(viewDir + lightDir);//视角与平行光的平分方向
		fixed3 specular = _LightColor0.rgb * texColor * _Specular.rgb * pow(max(dot(tangentNormal, harfDir),0), _Gloss);//BP模型://Blinn-Phong光照模型Specular = 直射光*pow(max(cos夹角,0)*高光参数) ，夹角：法线与x方向夹角,x:平行光与视野方向的平分项。

		fixed3 tempColor = diffuse + specular + UNITY_LIGHTMODEL_AMBIENT.rgb * texColor;//漫反射+高光+环境光*纹理，相加混合（环境光与纹理混合：使强光下的纹理仍保持清晰）
		return fixed4(tempColor,1);
	}
	ENDCG
}

	}
		FallBack &quot;Diffuse&quot;
</code></pre>
<p>}<br>
</code><br>
<img src="https://Wei715547.github.io/post-images/1598002656882.PNG" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shader-纹理贴图]]></title>
        <id>https://Wei715547.github.io/post/shader-wen-li-tie-tu/</id>
        <link href="https://Wei715547.github.io/post/shader-wen-li-tie-tu/">
        </link>
        <updated>2020-08-20T06:29:51.000Z</updated>
        <content type="html"><![CDATA[<code>
Shader "Custom/Single_Texture"
{
	Properties//属性
	{
		_MainTex("Main Tex",2D) = "white"{}//贴图代替漫反射颜色
		_Color("Tex Color",Color) = (1,1,1,1)//贴图颜色:与贴图uv坐标下的像素点颜色混合
		//_Diffuse("_DiffuseColor",Color) = (1,1,1,1)//漫反射颜色
		_Specular("_Specular", Color) = (1, 1, 1, 1)//高光颜色
		_Gloss("_Gloss", Range(10, 200)) = 20//高光参数
<pre><code>}
	SubShader
	{
		Pass
		{
			Tags {&quot;Lighting&quot; = &quot;ForwardBase&quot;} //定义LightMode,获取UNITY内部光照变量
			CGPROGRAM
		//在CG声明属性
		sampler2D _MainTex;//ShaderCG中的关键字
		float4 _MainTex_ST; //主贴图的缩放与偏移“属性名称固定”_MainTex_ST.xy缩放属性；_MainTex_ST.zw偏移属性
		fixed4 _Color;//与贴图叠混合颜色
		//fixed4 _Diffuse;
		fixed4 _Specular;
		int _Gloss;

	#include &quot;Lighting.cginc&quot;//引入UNITY内置文件，获取光照变量 _LightColor0.rgb;光源颜色
	#pragma vertex vert//声明顶点函数
	#pragma fragment frag//声明片原函数


	struct a2v//应用向顶点函数传递参数
	{
		float4 vertex:POSITION;//模型空间顶点坐标
		float3 normal:NORMAL;//模型空间法线方向

		float4 texcoord :TEXCOORD0;//获取纹理坐标
	};
	struct v2f//顶点函数向片原函数传递参数
	{
		float4 svPos:SV_POSITION;//顶点函数返回值：剪裁空间中的顶点坐标-系统直接使用
		float3 worldNormal : TEXCOORD0;//顶点函数向片原函数传递世界坐标下的法线方向
		float4 worldView:TEXCOORD1;//顶点函数向片原函数传递世界坐标下的顶点坐标

		float2 uv:TEXCOORD2;
	};

	v2f vert(a2v v)//顶点函数将顶点从模型空间转到世界空间，返回值在世界坐标系下的顶点坐标
	{
		v2f f;//声明传参结构体,并对其中的值赋值
		f.svPos = UnityObjectToClipPos(v.vertex);
		f.worldNormal = UnityObjectToWorldNormal(v.normal);
		f.worldView = (UnityObjectToWorldNormal(v.vertex), 0);
		f.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;//将纹理坐标传递到片原函数 * 乘上主贴图缩放属性 + 加上主贴图的偏移属性
		return f;//返回结构体
	}

	fixed4 frag(v2f f) :SV_Target//片原函数，返回值为输出到像素颜色值的缓存
	{
		//计算漫反射
		fixed3 normalDir = normalize(f.worldNormal);//法线方向
		fixed3 lightDir = normalize(UnityWorldSpaceLightDir(f.worldView));//光源方向

		fixed3 texColor = tex2D(_MainTex, f.uv.xy)*_Color.rgb;//获取纹理坐标下贴图像素点的颜色*与外部属性控制的贴图颜色混合

		fixed3 diffuse = _LightColor0.rgb * texColor * max((dot(normalDir,lightDir) * 0.5 + 0.5), 0);//fixed3 harfLambert =dot(f.wordNormalDir, lightDir)*0.5+0.5;//半兰伯特光照模型:直射光颜色 * (cos夹角(光与法线)*0.5+0.5):使背光面不完全为黑色

		//计算高光反射
		//fixed3 reflectDir = normalize(reflect(-lightDir, normalDir));
		fixed3 viewDir = normalize(WorldSpaceViewDir(f.worldView));//实视线方向
		fixed3 harfDir = normalize(viewDir + lightDir);//视角与平行光的平分方向
		fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(dot(normalDir, harfDir),0), _Gloss);//BP模型://Blinn-Phong光照模型Specular = 直射光*pow(max(cos夹角,0)*高光参数) ，夹角：法线与x方向夹角,x:平行光与视野方向的平分项。

		fixed3 tempColor = diffuse + specular + UNITY_LIGHTMODEL_AMBIENT.rgb*texColor;//漫反射+高光+环境光*纹理，相加混合（环境光与纹理混合：使强光下的纹理仍保持清晰）
		return fixed4(tempColor,1);
	}
	ENDCG
}

}
	FallBack &quot;Diffuse&quot;
</code></pre>
<p>}<br>
</code><br>
<img src="https://Wei715547.github.io/post-images/1597905313414.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1597905320903.PNG" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shader-漫反射(半兰伯特),高光(BP)混合实现]]></title>
        <id>https://Wei715547.github.io/post/shader-man-fan-she-ban-lan-bo-te-gao-guang-bphun-he-shi-xian/</id>
        <link href="https://Wei715547.github.io/post/shader-man-fan-she-ban-lan-bo-te-gao-guang-bphun-he-shi-xian/">
        </link>
        <updated>2020-08-19T08:39:01.000Z</updated>
        <content type="html"><![CDATA[<code>
Shader "Custom/ShaderDiffues-Specular"
{
	Properties//属性
	{
		_Diffuse("_DiffuseColor",Color) = (1,1,1,1)//漫反射颜色
		_Specular("_Specular", Color) = (1, 1, 1, 1)//高光颜色
		_Gloss("_Gloss", Range(10, 200)) = 20//高光参数
	}
		SubShader
	{
		Pass
		{
			Tags {"Lighting" = "ForwardBase"} //定义LightMode,获取UNITY内部光照变量
			CGPROGRAM
			//在CG声明属性
			fixed4 _Diffuse;
			fixed4 _Specular;
			int _Gloss;
<pre><code>		#include &quot;Lighting.cginc&quot;//引入UNITY内置文件，获取光照变量 _LightColor0.rgb;光源颜色
		#pragma vertex vert//声明顶点函数
		#pragma fragment frag//声明片原函数
		

		struct a2v//应用向顶点函数传递参数
		{
			float4 vertex:POSITION;//模型空间顶点坐标
			float3 normal:NORMAL;//模型空间法线方向
		};
		struct v2f//顶点函数向片原函数传递参数
		{
			float4 svPos:SV_POSITION;//顶点函数返回值：剪裁空间中的顶点坐标-系统直接使用
			float3 worldNormal : TEXCOORD0;//顶点函数向片原函数传递世界坐标下的法线方向
			float4 worldView:TEXCOORD1;//顶点函数向片原函数传递世界坐标下的顶点坐标
		};

		v2f vert(a2v v)//顶点函数将顶点从模型空间转到世界空间，返回值在世界坐标系下的顶点坐标
		{
			v2f f;//声明传参结构体,并对其中的值赋值
			f.svPos = UnityObjectToClipPos(v.vertex);
			f.worldNormal = UnityObjectToWorldNormal(v.normal);
			f.worldView = (UnityObjectToWorldNormal(v.vertex), 0);
			return f;//返回结构体
		}

		fixed4 frag(v2f f) :SV_Target//片原函数，返回值为输出到像素颜色值的缓存
		{
			//计算漫反射
			fixed3 normalDir = normalize(f.worldNormal);//法线方向
			fixed3 lightDir = normalize(UnityWorldSpaceLightDir(f.worldView));//光源方向
			fixed3 diffuse = _LightColor0.rgb * _Diffuse * max((dot(normalDir,lightDir)*0.5+0.5), 0);//fixed3 harfLambert =dot(f.wordNormalDir, lightDir)*0.5+0.5;//半兰伯特光照模型:直射光颜色 * (cos夹角(光与法线)*0.5+0.5):使背光面不完全为黑色

			//计算高光反射
			//fixed3 reflectDir = normalize(reflect(-lightDir, normalDir));
			fixed3 viewDir = normalize(WorldSpaceViewDir(f.worldView));//实视线方向
			fixed3 harfDir = normalize(viewDir + lightDir);//视角与平行光的平分方向
			fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(dot(normalDir, harfDir),0), _Gloss);//BP模型://Blinn-Phong光照模型Specular = 直射光*pow(max(cos夹角,0)*高光参数) ，夹角：法线与x方向夹角,x:平行光与视野方向的平分项。
			
			fixed3 tempColor = diffuse + specular + UNITY_LIGHTMODEL_AMBIENT.rgb;//漫反射+高光+环境光，相加混合
			return fixed4(tempColor,1);
		}
		ENDCG
	}

}
FallBack &quot;Diffuse&quot;
</code></pre>
<p>}<br>
</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shader-高光反射(顶点/像素)]]></title>
        <id>https://Wei715547.github.io/post/shader-gao-guang-fan-she-ding-dian-xiang-su/</id>
        <link href="https://Wei715547.github.io/post/shader-gao-guang-fan-she-ding-dian-xiang-su/">
        </link>
        <updated>2020-08-18T03:51:59.000Z</updated>
        <content type="html"><![CDATA[<code>
高光反射 Specular = 直射光*pow(max(cos夹角,0)*高光参数) ，夹角：反射光与视野方向夹角。(夹角越小高光越强,大于90度时即没有高光)；pox(a,b):a的b次方，高光参数取值（1~10）高光参数越大可以看到高光的夹角范围越小
<p>在顶点函数中计算<br>
Shader &quot;Custom/HightLightRefalxRander_Vertex&quot;<br>
{<br>
Properties<br>
{<br>
_Diffuse(&quot;DiffuseColor&quot;, Color) = (1,1,1,1)<br>
//外部可调节高光属性<br>
_Specular(&quot;_SpecularColor&quot;,Color) = (1,1,1,1)//高光颜色<br>
_Gloss(&quot;Gloss&quot;,Range(8,100)) = 10//高光参数</p>
<pre><code>}
	SubShader
{
   Pass
{
	Tags {&quot;Lighting&quot; = &quot;ForwardBase&quot;} //定义LightMode,获取UNITY内部光照变量
	CGPROGRAM
	fixed4 _Diffuse;
    int _Gloss;
    fixed4 _Specular;
</code></pre>
<p>#include &quot;Lighting.cginc&quot;<br>
#pragma vertex vert//声明顶点着色器<br>
#pragma fragment frag//声明片段着色器</p>
<pre><code>struct a2v {//从应用程序传递到顶点函数的语义POSITION:顶点坐标，NURMAL:法线(模型空间下)，TEXCOORD0-n:纹理坐标，COLOR:顶点颜色
	float4 vertex:POSITION;//获取顶点坐标
	float3 normal:NORMAL;

};
struct v2f {//从顶点函数传递到片原函数的语义SV_POSITION:(剪裁空间中的顶点坐标-系统直接使用)，COLOR0/COLOR1:可以传递一组值(4个)，TEXCOORD0~7:传递纹理坐标
			//f2s片原函数传递给系统：SV_Target:颜色值-输出到屏幕上的颜色(缓存颜色)
	float4 position:SV_POSITION;
	fixed3 color : COLOR1;
};

v2f vert(a2v v)//顶点之间片段颜色采用插值计算填充
{
	v2f f;
	f.position = UnityObjectToClipPos(v.vertex);//将坐标从模型空间转换到剪裁空间
	fixed3 amblent = UNITY_LIGHTMODEL_AMBIENT.rgb;//获取系统环境光
	//fixed3 norDir = normalize(unity_WorldToObject(v.normal));//法线方向从世界空间转到模型空间(弃用的方法) 
	fixed3 N = UnityObjectToWorldNormal(v.normal);//法线方向从世界空间转到模型空间 
	fixed3 lightDir = normalize(_WorldSpaceLightPos0.xyz);//第一个直射光的位置，对于顶点来说光的位置即是光的方向
	fixed3 diffuse = _LightColor0.rgb * max(dot(N,lightDir),0) * _Diffuse.rgb;//根据漫反射公式：直射光颜色 * cos夹角(光与法线)获取颜色 dot(a,b):点乘获取两向量的夹角

	fixed3 reflectDir = normalize(reflect(-lightDir,N));//计算反射光方向
	fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - UnityObjectToWorldNormal(v.vertex));//计算视点方向(世界坐标下相机位置-顶点位置)
	fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(dot(reflectDir, viewDir), 0), _Gloss);//夹角：反射光与视野方向夹角

	f.color = diffuse + amblent + specular;//+:颜色得加(亮度增强),*:融合
	return f;
}


fixed4 frag(v2f f) :SV_Target//片原函数，片段在屏幕上像素颜色，返回颜色值
{
return fixed4(f.color,1);//返回法线
}
	ENDCG
}

}
	FallBack &quot;Diffuse&quot;
</code></pre>
<p>}<br>
—————————————————————————————————<br>
在片原函数中计算<br>
Shader &quot;Custom/HightLightRefalxRander_Fragment&quot;<br>
{<br>
Properties<br>
{<br>
_Diffuse(&quot;DiffuseColor&quot;, Color) = (1,1,1,1)<br>
_Specular(&quot;_SpecularColor&quot;,Color) = (1,1,1,1)<br>
_Gloss(&quot;Gloss&quot;,Range(8,100)) = 10//高光参数<br>
}<br>
SubShader<br>
{<br>
Pass<br>
{<br>
Tags {&quot;Lighting&quot; = &quot;ForwardBase&quot;} //定义LightMode,获取UNITY内部光照变量<br>
CGPROGRAM<br>
fixed4 _Diffuse;<br>
int _Gloss;<br>
fixed4 _Specular;<br>
#include &quot;Lighting.cginc&quot;<br>
#pragma vertex vert//声明顶点着色器<br>
#pragma fragment frag//声明片段着色器</p>
<pre><code>struct a2v {//从应用程序传递到顶点函数的语义POSITION:顶点坐标，NURMAL:法线(模型空间下)，TEXCOORD0-n:纹理坐标，COLOR:顶点颜色
	float4 vertex:POSITION;//获取顶点坐标
	float3 normal:NORMAL;

};
struct v2f {//从顶点函数传递到片原函数的语义SV_POSITION:(剪裁空间中的顶点坐标-系统直接使用)，COLOR0/COLOR1:可以传递一组值(4个)，TEXCOORD0~7:传递纹理坐标
			//f2s片原函数传递给系统：SV_Target:颜色值-输出到屏幕上的颜色(缓存颜色)
	float4 position:SV_POSITION;
	fixed3 worldNormal : TEXCOORD0;//传递法线方向
	float3 worldView :TEXCOORD1;//传递顶点坐标
};

v2f vert(a2v v)//顶点之间片段颜色采用插值计算填充
{
	v2f f;
	f.position = UnityObjectToClipPos(v.vertex);//将坐标从模型空间转换到剪裁空间
	f.worldNormal = UnityObjectToWorldNormal(v.normal);//向片原函数传递法线方向
	f.worldView = UnityObjectToWorldNormal(v.vertex);//向片原函数传递顶点坐标
	return f;
}


fixed4 frag(v2f f) :SV_Target//片原函数，片段在屏幕上像素颜色，返回颜色值
{
	fixed3 amblent = UNITY_LIGHTMODEL_AMBIENT.rgb;//获取系统环境光
	//fixed3 norDir = normalize(unity_WorldToObject(v.normal));//法线方向从世界空间转到模型空间(弃用的方法) 
	fixed3 N = f.worldNormal;//法线方向从世界空间转到模型空间 
	fixed3 lightDir = normalize(_WorldSpaceLightPos0.xyz);//第一个直射光的位置，对于顶点来说光的位置即是光的方向
	fixed3 diffuse = _LightColor0.rgb * max(dot(N,lightDir),0) * _Diffuse.rgb;//根据漫反射公式：直射光颜色 * cos夹角(光与法线)获取颜色 dot(a,b):点乘获取两向量的夹角

	//fixed3 reflectDir = normalize(reflect(-lightDir,N));//计算反射光方向
	fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - f.worldView);//计算视点方向(世界坐标下相机位置-顶点位置)
	//fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(dot(reflectDir, viewDir), 0), _Gloss);//夹角：反射光与视野方向夹角
	fixed3 harfDir = normalize(viewDir + lightDir);//平行光与视野方向平分项
	fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(dot(N, harfDir), 0), _Gloss);//Blinn-Phong光照模型Specular = 直射光*pow(max(cos夹角,0)*高光参数) ，夹角：法线与x方向夹角,x:平行光与视野方向的平分项。		
    

	fixed3 tempColor = diffuse + amblent + specular;//+:颜色得加(亮度增强),*:融合
return fixed4(tempColor,1);//返回法线
}
	ENDCG
}

}
	FallBack &quot;Diffuse&quot;
</code></pre>
<p>}</p>
<code/>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shader-顶点漫反射(*自身)(+环境光)-逐像素反射]]></title>
        <id>https://Wei715547.github.io/post/shader-ding-dian-man-fan-she-zi-shen-huan-jing-guang/</id>
        <link href="https://Wei715547.github.io/post/shader-ding-dian-man-fan-she-zi-shen-huan-jing-guang/">
        </link>
        <updated>2020-08-17T08:30:49.000Z</updated>
        <content type="html"><![CDATA[<code>
逐顶点漫反射：顶点之间片段颜色采用插值计算填充
<p>Shader &quot;Custom/Shader04&quot;<br>
{<br>
Properties<br>
{<br>
_Diffuse(&quot;DiffuseColor&quot;, Color) = (1,1,1,1)</p>
<pre><code>}
	SubShader
{
   Pass
{
	Tags {&quot;Lighting&quot; = &quot;ForwardBase&quot;} //定义LightMode,获取UNITY内部光照变量
	CGPROGRAM
	fixed4 _Diffuse;
</code></pre>
<p>#include &quot;Lighting.cginc&quot;//引入UNITY内置文件，获取光照变量 _LightColor0:第一个直射光的颜色，_WorldSpaceLightPos0.xyz<br>
// Physically based Standard lighting model, and enable shadows on all light types<br>
//#pragma surface surf Standard fullforwardshadows<br>
#pragma vertex vert//声明顶点着色器<br>
#pragma fragment frag//声明片段着色器<br>
// Use shader model 3.0 target, to get nicer looking lighting<br>
//#pragma target 3.0</p>
<pre><code>struct a2v {//从应用程序传递到顶点函数的语义POSITION:顶点坐标，NURMAL:法线(模型空间下)，TEXCOORD0-n:纹理坐标，COLOR:顶点颜色
	float4 vertex:POSITION;//获取顶点坐标
	float3 normal:NORMAL;

};
struct v2f {//从顶点函数传递到片原函数的语义SV_POSITION:(剪裁空间中的顶点坐标-系统直接使用)，COLOR0/COLOR1:可以传递一组值(4个)，TEXCOORD0~7:传递纹理坐标
			//f2s片原函数传递给系统：SV_Target:颜色值-输出到屏幕上的颜色(缓存颜色)
	float4 position:SV_POSITION;
	fixed3 color : COLOR1;
};

v2f vert(a2v v)//顶点之间片段颜色采用插值计算填充
{
	v2f f;
	f.position = UnityObjectToClipPos(v.vertex);//将坐标从模型空间转换到剪裁空间
	//f.temp = v.normal;
	fixed3 amblent = UNITY_LIGHTMODEL_AMBIENT.rgb;//获取系统环境光
	//fixed3 norDir = normalize(unity_WorldToObject(v.normal));//法线方向从世界空间转到模型空间(弃用的方法) 
	fixed3 N = UnityObjectToWorldNormal(v.normal);//法线方向从世界空间转到模型空间 
	fixed3 lightDir = normalize(_WorldSpaceLightPos0.xyz);//第一个直射光的位置，对于顶点来说光的位置即是光的方向
	fixed3 diffuse = _LightColor0.rgb*max(dot(N,lightDir),0)* _Diffuse.rgb;//根据漫反射公式：直射光颜色 * cos夹角(光与法线)获取颜色 dot(a,b):点乘获取两向量的夹角
	f.color = diffuse+amblent;//+:颜色得加(亮度增强),*:融合
	return f;
}


fixed4 frag(v2f f) :SV_Target//片原函数，片段在屏幕上像素颜色，返回颜色值
{
return fixed4(f.color,1);//返回法线
}
	ENDCG
}

}
	FallBack &quot;Diffuse&quot;
</code></pre>
<p>}<br>
——————————————————————————————————<br>
逐像素漫反射：逐个像素计算漫反射计算量大<br>
Shader &quot;Custom/PixivsRander&quot;<br>
{<br>
Properties<br>
{<br>
_Diffuse(&quot;DiffuseColor&quot;, Color) = (1,1,1,1)</p>
<pre><code>}
	SubShader
{
   Pass
{
	Tags {&quot;Lighting&quot; = &quot;ForwardBase&quot;} //定义LightMode,获取UNITY内部光照变量
	CGPROGRAM
	fixed4 _Diffuse;
</code></pre>
<p>#include &quot;Lighting.cginc&quot;//引入UNITY内置文件，获取光照变量 _LightColor0:第一个直射光的颜色，_WorldSpaceLightPos0.xyz<br>
// Physically based Standard lighting model, and enable shadows on all light types<br>
//#pragma surface surf Standard fullforwardshadows<br>
#pragma vertex vert//声明顶点着色器<br>
#pragma fragment frag//声明片段着色器<br>
// Use shader model 3.0 target, to get nicer looking lighting<br>
//#pragma target 3.0</p>
<pre><code>struct a2v {//从应用程序传递到顶点函数的语义POSITION:顶点坐标，NURMAL:法线(模型空间下)，TEXCOORD0-n:纹理坐标，COLOR:顶点颜色
	float4 vertex:POSITION;//获取顶点坐标
	float3 normal:NORMAL;

};
struct v2f {//从顶点函数传递到片原函数的语义SV_POSITION:(剪裁空间中的顶点坐标-系统直接使用)，COLOR0/COLOR1:可以传递一组值(4个)，TEXCOORD0~7:传递纹理坐标
			//f2s片原函数传递给系统：SV_Target:颜色值-输出到屏幕上的颜色(缓存颜色)
	float4 position:SV_POSITION;
	fixed3 wordNormalDir : COLOR1;//向片原函数传递法线
};

v2f vert(a2v v)
{
	v2f f;
	f.position = UnityObjectToClipPos(v.vertex);//将坐标从模型空间转换到剪裁空间
	f.wordNormalDir = UnityObjectToWorldNormal(v.normal);
	return f;
}


fixed4 frag(v2f f) :SV_Target//片原函数，片段在屏幕上像素颜色，返回颜色值
{
	fixed3 amblent = UNITY_LIGHTMODEL_AMBIENT.rgb;//获取系统环境光		
	fixed3 lightDir = normalize(_WorldSpaceLightPos0.xyz);//第一个直射光的位置，对于顶点来说光的位置即是光的方向
	//fixed3 diffuse = _LightColor0.rgb * max(dot(f.wordNormalDir,lightDir),0) * _Diffuse.rgb;//根据漫反射公式：直射光颜色 * cos夹角(光与法线)获取颜色 dot(a,b):点乘获取两向量的夹角
    fixed3 harfLambert =dot(f.wordNormalDir, lightDir)*0.5+0.5;//半兰伯特光照模型:直射光颜色 * (cos夹角(光与法线)*0.5+0.5):使背光面不完全为黑色
	fixed3 diffuse = _LightColor0.rgb * harfLambert * _Diffuse.rgb;
	fixed3 tempColor = diffuse + amblent;//+:颜色得加(亮度增强),*:融合
	return fixed4(tempColor,1);//返回法线
}
	ENDCG
}

}
	FallBack &quot;Diffuse&quot;
</code></pre>
<p>}</p>
</code>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ShaderLab-系统语义]]></title>
        <id>https://Wei715547.github.io/post/shaderlab-xi-tong-yu-yi/</id>
        <link href="https://Wei715547.github.io/post/shaderlab-xi-tong-yu-yi/">
        </link>
        <updated>2020-08-16T08:03:03.000Z</updated>
        <content type="html"><![CDATA[<code>
Shader "Custom/FW03exeable"
{
	SubShader
	{
        Tags {"Lighting" = "ForwardBase"} //定义LightMode（前项渲染）,获取UNITY内部光照变量
		Pass
	{
		 CGPROGRAM
// Upgrade NOTE: excluded shader from DX11; has structs without semantics (struct v2f members temp)
#pragma exclude_renderers d3d11
		 #pragma vertex vert//声明顶点着色器
		 #pragma fragment frag//声明片段着色器
<pre><code>	 //定义结构体-方便传值
	 struct a2v {//从应用程序传递到顶点函数的语义POSITION:顶点坐标，NURMAL:法线(模型空间下)，TEXCOORD0-n:纹理坐标，COLOR:顶点颜色
			float4 vertex:POSITION;//获取顶点坐标
			float3 nol:NORMAL;//获取法线方向
			//float4 textcoord:TEXTCOORD0;//获取纹理坐标
		};
	struct v2f {//从顶点函数传递到片原函数的语义SV_POSITION:(剪裁空间中的顶点坐标-系统直接使用)，COLOR0/COLOR1:可以传递一组值(4个)，TEXCOORD0~7:传递纹理坐标
				//f2s片原函数传递给系统：SV_Target:颜色值-输出到屏幕上的颜色(缓存颜色)
			float4 position:SV_POSITION;
			fixed3 temp:COLOR0;	//可用于传递值
		};

	  v2f vert(a2v v)
	  {
		  v2f f;
		  f.position = UnityObjectToClipPos(v.vertex);
		  f.temp = v.nol;
		  return f;
	  }
	 

	fixed4 frag(v2f f) :SV_Target//片原函数，片段在屏幕上像素颜色，返回颜色值
	{
	return fixed4(f.temp,1);//返回法线
	}
   ENDCG
		}

}
	FallBack &quot;Diffuse&quot;
</code></pre>
<p>}<br>
</code><br>
光照模型公式：计算某个点的光照效果<br>
标准光照模型：<br>
1.自发光<br>
2.高光反射 Specular = 直射光*pow(max(cos夹角,0)*高光参数) ，夹角：反射光与视野方向夹角。(夹角越小高光越强,大于90度时即没有高光)；pox(a,b):a的b次方，高光参数取值（1~10）高光参数越大可以看到高光的夹角范围越小<br>
3.漫反射 Diffuse = 直射光颜色 * cos夹角(光与法线)<br>
4.环境光<br>
——————————————————————————————————————<br>
UnityCG.cginc中一些常用函数<br>
摄像机方向<br>
float3 WorldSpaceViewDir(Float4 v)//根据模型空间下的顶点坐标 -》世界空间下从这一点到相机的观察方向（返回值需要归一化）<br>
float3 UnityWorldSpaceViewDir(float4 v)//世界空间中的顶点坐标-》世界空间从这一顶点到摄像机的方向<br>
float3 ObjSpaceViewDir(float4 v)//模型空间中的顶点坐标-》模型空间下这个点到摄像机的观察方向<br>
光源方向<br>
float3 WorldSpaceLightDir(Float4 v)//根据模型空间下的顶点坐标 -》世界空间下从这一点到光源的方向（返回值需要归一化）<br>
float3 UnityWorldSpaceLightDir(float4 v)//世界空间中的顶点坐标-》世界空间从这一顶点到光源的方向<br>
float3 ObjSpaceLightDir(float4 v)//模型空间中的顶点坐标-》模型空间下这个点到光源的观察方向<br>
方向转换<br>
float3 UnityObjectToWorldNormal(float3 norm)//把法线方向 从模型空间转到世界空间<br>
float3 UnityObjectToWorldDir(float3 dir)//把方向 从模型空间转到世界空间<br>
float3 UnityWorldToObjectDir(float3 dir)//把方向 从世界空间转到模型空间</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shader框架]]></title>
        <id>https://Wei715547.github.io/post/shader-kuang-jia/</id>
        <link href="https://Wei715547.github.io/post/shader-kuang-jia/">
        </link>
        <updated>2020-08-15T15:28:26.000Z</updated>
        <content type="html"><![CDATA[<p>渲染管线流程图：<br>
<img src="https://Wei715547.github.io/post-images/1597916253014.jpg" alt="" loading="lazy"></p>
<code>
Shader "Custom/FW"
{
	Properties//公开属性
	{
		//_MainTex ("Texture", 2D) = "white" {}
		_Colorcosm("_Colorc",Color) = (1,1,1,1)//属性类型（“属性名字”，属性类型）= 属性值
		_Vector("_Vectorc",Vector) = (1,2,3,4)//float4
		_Int("_Intc",Int) = 2333 //float
		_Float("_Floatc",Float) = 7.5//float
		_Range("_Range",Range(1,11)) = 7//范围值
		_2D("Texture",2D) = "white"{}//sampler2D
		_Cube("Cube",Cube) = "red"{}//samplerCube
		_3D("Texture",3D) = "black"{}//sampler3D
	}
		SubShader//子着色器可以写多个
	{
<pre><code>	Pass//着色器具体绘制方式，同样可以有多个，（尽量写在一个中只提交一次）
	{
		CGPROGRAM//CG语言代码
		//在CG语言中国对公开的属性进行声明
		fixed4 _Color//颜色0~1可用fixed存储
		float4 _Vector
		float _Int
		float _Float
		float _Range
		sampler2D _2D
		samplerCube _Cube
		sampler3D _3D
		#pragma vertex vert//声明顶点着色器
		#pragme fragment frag//声明片段着色器
		//数据类型：float(32位)/half(16万 -60000~+60000)/fixed(11 -2~+2)-不同精度的浮点
		//Integer-整型，sampler-2D贴图，sampleCUBE-六面3D贴图

		 //返回值(坐标) 方法名（参数（坐标）:POSITON(语义)）:SV_POSOTION(返回值语义)
	 //顶点函数：将模型坐标从模型空间(建模时原点坐标)转化到剪裁空间(栅格化)
	  float4 vert(float4 pos:POSITION) :SV_POSITION
	  {
	//通过矩阵将模型空间坐标转化为屏幕剪裁空间下的坐标
	//float4 pos = mul(UNITY_MATRIX_MVP,/*UNITY宏*/pos);//4*4矩阵相乘返回转化后的坐标
	return UnityObjectToClipPos(pos);
	 }

	float4 frag() :SV_Target//片原函数，片段在屏幕上像素颜色，返回颜色值
	{
	return float4 (0.5,1,1,1);//返回白色
	}
		ENDCG
	}
}
	//CostomEditer &quot;&quot;//材质面板自定义样式的脚本路径

	FallBack &quot;Diffuse&quot;//以上SubShader都不支持时执行此路径的Shader，还是不支持时继续找此路径Shader里边的FallBack(都不支持变为粉色)
</code></pre>
<p>}</p>
</code>]]></content>
    </entry>
</feed>