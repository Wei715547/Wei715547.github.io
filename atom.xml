<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Wei715547.github.io</id>
    <title>WeiBlog</title>
    <updated>2020-09-08T15:05:01.315Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Wei715547.github.io"/>
    <link rel="self" href="https://Wei715547.github.io/atom.xml"/>
    <subtitle>年月增长，我宜强盛。
用于Unity+开发的技术积累</subtitle>
    <logo>https://Wei715547.github.io/images/avatar.png</logo>
    <icon>https://Wei715547.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, WeiBlog</rights>
    <entry>
        <title type="html"><![CDATA[Shader,屏幕后处理(Post Effect)]]></title>
        <id>https://Wei715547.github.io/post/shaderping-mu-hou-chu-li-post-effect/</id>
        <link href="https://Wei715547.github.io/post/shaderping-mu-hou-chu-li-post-effect/">
        </link>
        <updated>2020-09-08T07:34:21.000Z</updated>
        <content type="html"><![CDATA[<p>挂在主相机上的脚本：<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
[ExecuteInEditMode]//在编译器下执行脚本（不用点击开始即执行）<br>
public class Post : MonoBehaviour<br>
{<br>
public Material EffectMat;//承载后处理Shader的材质</p>
<pre><code>private void OnRenderImage(RenderTexture source, RenderTexture destination)//该函数在所有的渲染完成后由monobehavior自动调用。
//官方解释：该函数允许我们使用着色器滤波操作来修改最终的图像，输入原图像source，输出的图像放在desitination里。
{
    if (EffectMat !=null)
    {
        Graphics.Blit(source, destination, EffectMat);//该函数的作用就是通过一个shader将原图的像素放置到destionation中。
    }
}
</code></pre>
<p>}<br>
——————————————————————————————————————<br>
<img src="https://Wei715547.github.io/post-images/1599552275469.PNG" alt="" loading="lazy"><br>
Shader1画面溶解流动效果：<br>
Shader &quot;Shader104/Distortion&quot;<br>
{<br>
Properties<br>
{<br>
_MainTex(&quot;Texture&quot;, 2D) = &quot;white&quot; {}<br>
_DisplaceTex(&quot;Displacement Texture&quot;, 2D) = &quot;white&quot; {}<br>
_Magnitude(&quot;Magnitude&quot;, Range(0,0.1)) = 1</p>
<pre><code>}

SubShader
{
    Tags
    {
        &quot;Queue&quot; = &quot;Transparent&quot;
    }

    Pass{
        Blend SrcAlpha OneMinusSrcAlpha

        CGPROGRAM
        #pragma vertex vert
        #pragma fragment frag

        #include &quot;UnityCG.cginc&quot;

        struct appdata
        {
            float4 vertex : POSITION;
            float2 uv : TEXCOORD0;
        };

        struct v2f
        {
            float4 vertex : SV_POSITION;
            float2 uv : TEXCOORD0;
        };

        v2f vert(appdata v)
        {
            v2f o;
            o.vertex = UnityObjectToClipPos(v.vertex);
            o.uv = v.uv;
            return o;
        };

        sampler2D _MainTex;
        sampler2D _DisplaceTex;//噪波贴图
        float _Magnitude;

        float4 frag(v2f i): SV_Target//画面流动效果
        {
            float2 distuv = float2(i.uv.x + _Time.x * 2, i.uv.y + _Time.x * 2);
            float2 disp = tex2D(_DisplaceTex, distuv).xy;//噪波贴图的.rg
            disp = ((disp * 2) - 1) * _Magnitude;
            float4 col = tex2D(_MainTex, i.uv + disp);
            return col;
        }
        ENDCG
    }
}
</code></pre>
<p>}<br>
————————————————————————————————————————<br>
<img src="https://Wei715547.github.io/post-images/1599552284677.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1599552463055.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1599553049020.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1599553279813.PNG" alt="" loading="lazy"><br>
Shader2屏幕黑白、反色、RGB分离、像素效果：<br>
Shader &quot;Shader104/GreyScale&quot;<br>
{<br>
Properties<br>
{<br>
_MainTex(&quot;Texture&quot;, 2D) = &quot;white&quot; {}<br>
_Slider(&quot;Slider&quot;,Range(0,1)) = 0.5<br>
}</p>
<pre><code>SubShader
{
	Tags
	{
		&quot;PreviewType&quot; = &quot;Plane&quot;
	}
	Pass
	{
		CGPROGRAM
		#pragma vertex vert
		#pragma fragment frag

		#include &quot;UnityCG.cginc&quot;

		struct appdata
		{
			float4 vertex : POSITION;
			float2 uv: TEXCOORD0;
		};

		struct v2f
		{
			float4 vertex : SV_POSITION;
			float2 uv: TEXCOORD0;
		};

		sampler2D _MainTex;
		float _Slider;

		v2f vert(appdata v)
		{
			v2f o;
			o.vertex = UnityObjectToClipPos(v.vertex);
			o.uv = v.uv;
			return o;
		}

		float4 frag(v2f i) : SV_Target
		{
            /*pixelate像素效果对UV进行变换
            float2 uv = i.uv;
            uv.x *= _PixelateAmt;
            uv.y *= _PixelateAmt;
            uv.x = round(uv.x);
            uv.y = round(uv.y);
            uv.x /= _PixelateAmt;
            uv.y /= _PixelateAmt;*/
			float4 color = tex2D(_MainTex,i.uv);//默认混合颜色(白色)：不进行后处理
			float average = 0.212 * color.r + 0.7152 * color.g + 0.0722 * color.b;//颜色黑白化
			if (i.uv.x &gt; _Slider)//大于Slidr的部分进行后处理
				return float4(average, average, average, 1);
                //return float4(1-color.r, 1-color.g, 1-color.b, 1);//反色
			else
				return color;
             /*chromatic aberration RGB分离
            float4 red = tex2D(_MainTex , i.uv - _Offset);           
            float4 green = tex2D(_MainTex, i.uv);
            float4 blue = tex2D(_MainTex, i.uv + _Offset);
            float4 color = float4(red.r,green.g,blue.b,1);
            return color;*/
		}
		ENDCG
	}
}
</code></pre>
<p>}<br>
————————————————————————————————————————<br>
<img src="https://Wei715547.github.io/post-images/1599552847954.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1599553788615.PNG" alt="" loading="lazy"><br>
Shader3Kernal矩阵边缘检测、渐变着色:<br>
Shader &quot;Shader104/Kernal&quot;<br>
{<br>
Properties<br>
{<br>
_MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}<br>
_Matrix00 (&quot;Matrix00&quot;,float) = 1<br>
_Matrix01 (&quot;Matrix01&quot;,float) = 1<br>
_Matrix02 (&quot;Matrix02&quot;,float) = 1<br>
_Matrix10 (&quot;Matrix10&quot;,float) = 1<br>
_Matrix11 (&quot;Matrix11&quot;,float) = -8<br>
_Matrix12 (&quot;Matrix12&quot;,float) = 1<br>
_Matrix20 (&quot;Matrix20&quot;,float) = 1<br>
_Matrix21 (&quot;Matrix21&quot;,float) = 1<br>
_Matrix22 (&quot;Matrix22&quot;,float) = 1<br>
_Slider(&quot;Slider&quot;,Range(0,1)) = 0.5<br>
_Threshold(&quot;_Threshold&quot;,Range(0,1)) = 0.1<br>
_EdgeColor(&quot;_EdgeColor&quot;,Color) = (1,1,1,1)<br>
_BackColor(&quot;_BackColor&quot;,Color) = (0,0,0,0)</p>
<pre><code>}
SubShader
{
    Tags
    {
        &quot;PreviewType&quot; = &quot;Plane&quot;
    }

    Pass
    {
        CGPROGRAM
        #pragma vertex vert
        #pragma fragment frag
        
        #include &quot;UnityCG.cginc&quot;

        struct appdata
        {
            float4 vertex : POSITION;
            float2 uv : TEXCOORD0;
        };

        struct v2f
        {
            float2 uv : TEXCOORD0;
            float4 vertex : SV_POSITION;
        };

        v2f vert (appdata v)
        {
            v2f o;
            o.vertex = UnityObjectToClipPos(v.vertex);
            o.uv = v.uv;
            return o;
        }
        
        sampler2D _MainTex;
        float4 _MainTex_TexelSize;
        float _Matrix00;
        float _Matrix01;
        float _Matrix02;
        float _Matrix10;
        float _Matrix11;
        float _Matrix12;
        float _Matrix20;
        float _Matrix21;
        float _Matrix22;
        float _Slider;
        float _Threshold;
        float4 _EdgeColor;//边缘色
        float4 _BackColor;//背景色

        float4 box(sampler2D tex, float2 uv, float4 size)//检测函数
        {
            float4 c = tex2D(tex, uv + float2(-size.x, size.y))*_Matrix00 + tex2D(tex, uv + float2(0, size.y))*_Matrix01 
            + tex2D(tex, uv + float2(size.x, size.y)) *_Matrix02 + tex2D(tex, uv + float2(-size.x, 0)) * _Matrix10
            + tex2D(tex, uv + float2(0, 0))*_Matrix11 + tex2D(tex, uv + float2(size.x, 0))*_Matrix12 
            + tex2D(tex, uv + float2(-size.x, -size.y))*_Matrix20 + tex2D(tex, uv + float2(0, -size.y))*_Matrix21
            + tex2D(tex, uv + float2(size.x, -size.y))*_Matrix22;

            return c / (_Matrix00+_Matrix01+_Matrix02+_Matrix10+_Matrix11+_Matrix12+_Matrix20+_Matrix21+_Matrix22);
        }

        float4 frag (v2f i) : SV_Target
        {
            float4 color = tex2D(_MainTex, i.uv);
            if(i.uv.x&gt;_Slider)
			{//边缘检测
                color = box(_MainTex, i.uv, _MainTex_TexelSize);
                if (color.r &lt;= _Threshold &amp;&amp; color.g &lt;= _Threshold &amp;&amp; color.b &lt;= _Threshold)//渐变着色
                    return _EdgeColor;
                else
                    return _BackColor;
            }
            else
                if (color.r &lt;= _Threshold &amp;&amp; color.g &lt;= _Threshold &amp;&amp; color.b &lt;= _Threshold)//渐变着色
                    return color;
                else
                    return float4(1, 1, 1, 1);//未上色部分为白色
        }
        ENDCG
    }
}
</code></pre>
<p>}<br>
————————————————————————————————————<br>
<img src="https://Wei715547.github.io/post-images/1599556756456.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1599556177672.PNG" alt="" loading="lazy"><br>
Shader深度值渲染/范围扫描：<br>
相机脚本：<br>
using UnityEngine;<br>
using System.Collections;<br>
using System.Collections.Generic;</p>
<p>[ExecuteInEditMode]<br>
public class ReplacementShaderEffect : MonoBehaviour<br>
{<br>
public Color color;<br>
public float slider;<br>
public Shader ReplacementShader;</p>
<pre><code>void OnValidate()
{
    Shader.SetGlobalColor(&quot;_Color_1&quot;, color);//获取Shader中未公开的全局变量
}

private void Update()
{
    Shader.SetGlobalFloat(&quot;_Temp&quot;, slider);//获取Shader中未公开的全局变量
}

void OnEnable()
{
    if (ReplacementShader != null)
        GetComponent&lt;Camera&gt;().SetReplacementShader(ReplacementShader, &quot;&quot;);
}

void OnDisable()
{
    GetComponent&lt;Camera&gt;().ResetReplacementShader();
}
</code></pre>
<p>}<br>
————————————————————————————————<br>
Shader程序：<br>
Shader &quot;Shader102/Depth&quot;<br>
{<br>
SubShader<br>
{<br>
Tags<br>
{<br>
&quot;RenderType&quot; = &quot;Opaque&quot;<br>
}</p>
<pre><code>	ZWrite On


	Pass
	{
		CGPROGRAM
		#pragma vertex vert
		#pragma fragment frag

		#include &quot;UnityCG.cginc&quot;

		struct appdata
		{
			float4 vertex : POSITION;
		};

		struct v2f
		{
			float4 vertex : SV_POSITION;
			float depth : DEPTH;
		};

		v2f vert(appdata v)
		{
			v2f o;
			o.vertex = UnityObjectToClipPos(v.vertex);
			o.depth = -(mul(UNITY_MATRIX_MV, v.vertex).z) * _ProjectionParams.w;//相机坐标空间下的深度值
			return o;
		}
		//未公开的全局变量
		float4 _Color_1;
		float _Temp;
        //根据深度值切换渲染方式
		/*fixed4 frag(v2f i) : SV_Target
		{
			float invert = 1 - i.depth;//近处颜色为白色

		if (i.depth &lt;_Temp / 2)//不同深度下实现不同的渲染方式
			return fixed4(invert, invert, invert, 1);
		else
			return fixed4(invert*1.5, 0.3, 0.3,1) ;
		}*/
        //范围扫描
        fixed4 frag(v2f i) : SV_Target
		{
			float invert = 1 - i.depth;//近处颜色为白色

		if (abs(i.depth- _Temp / 2)&lt;0.005)//深度范围绝对值内扫描的渲染方式
			return fixed4(invert*2, 0.2, 0.2, 1);
		else//正常渲染方式
			return fixed4(invert, 0.3, 0.3,1) ;
		}
		ENDCG
	}
}
</code></pre>
<p>}<br>
数值动画/代码：<br>
timer += Time.deltaTime;<br>
if (timer &gt;2.0f)<br>
{<br>
ht += Time.deltaTime*(1/5f);<br>
slider = Mathf.Lerp(0f, 10f, 0.5f * ht);<br>
if (ht&gt;=1f)<br>
{<br>
ht = 0;<br>
slider = 0;<br>
timer = 0;<br>
}<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UGUI 背包模块(事件订阅/渗透)]]></title>
        <id>https://Wei715547.github.io/post/ugui-bei-bao-mo-kuai-shi-jian-ding-yue-shen-tou/</id>
        <link href="https://Wei715547.github.io/post/ugui-bei-bao-mo-kuai-shi-jian-ding-yue-shen-tou/">
        </link>
        <updated>2020-09-02T14:26:34.000Z</updated>
        <content type="html"><![CDATA[<p>UI搭建：<img src="https://Wei715547.github.io/post-images/1599057822367.PNG" alt="" loading="lazy"><br>
————————————————————————————————<br>
代码：</p>
<p>装备共有属性类：<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public enum ArticleType//装备种类<br>
{<br>
Weapon,<br>
Drag,<br>
Collect,<br>
Pick<br>
}</p>
<p>public class Article //装备属性类(装备共有参数)<br>
{<br>
public string name;//装备名称<br>
public string spritPath;//装备UI图路径<br>
public ArticleType articleType;//装备类型<br>
public int count;//装备数量</p>
<pre><code>//构造函数
public Article(string name,string spritPath,ArticleType articleType,int count)
{
    this.name = name;
    this.spritPath = spritPath;
    this.articleType = articleType;
    this.count = count;
}
</code></pre>
<p>}<br>
——————————————————————————————<br>
装备“物品”类<br>
using System;<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.UI;</p>
<p>public class ArticleItem : MonoBehaviour<br>
{<br>
private Image articleSprit;<br>
private Text count;<br>
public Article article;<br>
private UIDrag UIDrag;//实现拖拽的类<br>
private Canvas canvas;//物体上的Canvas组件，用于物体显示在上层<br>
//private CanvasGroup canvasGroup;//拖拽此物体是取消其射线检测,代替事件渗透<br>
private int defortSort;<br>
//private Transform Origentparent;</p>
<pre><code>private Vector3 currentLocalPosition;
private float moveTimer;
public float moveTime = 0.2f;

private bool isMoving = false;

private Action onMoveEnd;

// Start is called before the first frame update
void Awake()
{
    articleSprit = transform.GetComponent&lt;Image&gt;();
    count = transform.Find(&quot;ItemCount&quot;).GetComponent&lt;Text&gt;();
    //将对应拖拽状态时要掉用的方法注册到拖拽类的委托链
    UIDrag = transform.GetComponent&lt;UIDrag&gt;();
    UIDrag.onStartDrag += OnStartDrag;
    UIDrag.onDrag += OnDrag;
    UIDrag.onEndDrag += OnEndDrag;
    
    canvas = transform.GetComponent&lt;Canvas&gt;();
    defortSort = canvas.sortingOrder;
    //canvasGroup = transform.GetComponent&lt;CanvasGroup&gt;();
    
    //currentLocalPosition = transform.localPosition;
}
private void Start()
{
    transform.localPosition = Vector3.zero;
    currentLocalPosition = transform.localPosition;
}
private void Update()
{
    MoveBack();
}
//Lerpg固定时间内完成执行
private void MoveBack()
{
    if (isMoving)
    {
        moveTimer += Time.deltaTime * (1 / moveTime);//0.2秒后为1
        transform.localPosition = Vector3.Lerp(currentLocalPosition, Vector3.zero, moveTimer);
        if (moveTimer &gt;= 1)
        {
            isMoving = false;
            //MoveToOrigin方法导致的事件完成后执行自身委托
            onMoveEnd?.Invoke();
        }
    }
}
//执行Lerp
public void MoveToOrigin(Action onMoveEnd)
{
    isMoving = true;
    moveTimer = 0;
    currentLocalPosition = transform.localPosition;
    this.onMoveEnd = onMoveEnd;//将之后要执行的方法方到自身委托链上
}
//设置装备属性(UI图标，数量等)
public void SetArticle(Article article)
{
    this.article = article;

    //显示数据
    articleSprit.sprite = Resources.Load&lt;Sprite&gt;(this.article.spritPath);
    count.text = this.article.count.ToString();
}
//开始拖拽时执行
public void OnStartDrag()
{
    canvas.sortingOrder = defortSort + 1;//显示在同级上层
    //transform.SetParent(transform.parent.parent);
    BagPanel.instence.curretnAricle = this;//正在拖拽的为此物体
}
public void OnDrag()
{

}
//拖拽结束时执行
public void OnEndDrag()
{
    //结束拖拽时所选格子不为空时，物品进入格子，
    if (BagPanel.instence.currtenHoverGrid != null &amp;&amp; !BagPanel.instence.currtenHoverGrid.gameObject.Equals(transform.parent.gameObject))
    {
        BagPanel.instence.currtenHoverGrid.DragIntoGride(BagPanel.instence.curretnAricle);//格子的方法
        canvas.sortingOrder = defortSort;//恢复层级
    }
    else//为空则返回
    {
        //transform.SetParent(Origentparent);
        //使用委托实现结束后执行
        MoveToOrigin(() =&gt; { canvas.sortingOrder = defortSort; });//表达式内为方法结束后要执行的语句
    }
    BagPanel.instence.curretnAricle = null;//结束拖拽时正在拖拽的物体为空
}    
</code></pre>
<p>}<br>
——————————————————————————————<br>
实现拖拽的类：<br>
using System;<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.EventSystems;</p>
<p>public class UIDrag : MonoBehaviour,IBeginDragHandler,ICanvasRaycastFilter ,IDragHandler,IEndDragHandler<br>
{<br>
private Vector3 mousePosition;<br>
private RectTransform rect;</p>
<pre><code>public Action onDrag;
public Action onStartDrag;
public Action onEndDrag;

private bool isDraging = false;

private void Awake()
{
    rect = GetComponent&lt;RectTransform&gt;();
    if (rect ==null)
    {
        throw new System.Exception(&quot;只能拖拽UI物体&quot;);
    }
}
//使用事件渗透监听不到拖拽事件时可用下面代码
/*private void Update()
{
    if (isDraging)
    {
        *//*rect.anchoredPosition += (Vector2)(Input.mousePosition - mousePosition);
        mousePosition = Input.mousePosition;
        //transform.position = eventData.position; //中心随光标移动
        //锚点的位置加上鼠标移动
        //rect.anchoredPosition += eventData.delta;
        //if (onDrag != null) onDrag();
        onDrag?.Invoke();*//*
    }
    if(Input .GetMouseButtonUp(0)&amp;&amp;isDraging==true)
    {
        onEndDrag?.Invoke();
        isDraging = false;
    }
}*/

public void OnBeginDrag(PointerEventData eventData)
{
    mousePosition = Input.mousePosition;
    onStartDrag?.Invoke();
    isDraging = true;
}
//事件渗透接口：渗透过当前事件向下进行事件检测（背包系统渗透装备UI图标向下检测所在物品栏）
public bool IsRaycastLocationValid(Vector2 sp, Camera eventCamera)//事件渗透接口：返回值TRUE时：检测，返回值为FALES：渗透事件。
{
    return !isDraging;
}
//事件渗透监听不到此接口事件(实际监听的到)，但要保留接口实现拖拽
public void OnDrag(PointerEventData eventData)//参数为相机与点击物体的射线检测点
{
    rect.anchoredPosition += (Vector2)(Input.mousePosition - mousePosition);
    mousePosition = Input.mousePosition;
    //transform.position = eventData.position; //中心随光标移动
    //锚点的位置加上鼠标移动
    //rect.anchoredPosition += eventData.delta;
    //if (onDrag != null) onDrag();
    onDrag?.Invoke();
}
//事件渗透监听不到此接口事件(实际监听的到)
public void OnEndDrag(PointerEventData eventData)
{
    onEndDrag?.Invoke();
    isDraging = false;
}
</code></pre>
<p>}<br>
——————————————————————————————<br>
格子类：<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.EventSystems;<br>
using UnityEngine.UI;</p>
<p>public class BagGrde : MonoBehaviour , IPointerEnterHandler,IPointerExitHandler<br>
{<br>
private ArticleItem articleItem;</p>
<pre><code>private Image bgImage;
private Color defortColor;

public ArticleItem ArticleItem
{
    get { return articleItem; }
}

private void Awake()
{
    bgImage = transform.GetComponent&lt;Image&gt;();
    defortColor = bgImage.color;
}
//设置格子内的装备物品方法
public void SetArticleItem(ArticleItem articleItem)
{
    this.articleItem = articleItem;//此格子装着的物品
    this.articleItem.gameObject.SetActive(true);
    //将此物品栏设置父物体
    this.articleItem.transform.SetParent(transform);
    //刷新背包时直接设置位置，取消物品UI缓动效果
    articleItem.transform.localPosition = Vector3.zero;

    //防止发生变化
    //设置位置
    //this.articleItem.transform.localPosition = Vector3.zero;
    this.articleItem.MoveToOrigin(() =&gt;//用物品类里面的方法实现拖拽到格子时的缓动效果
   {//设置5px的边界值
       this.articleItem.GetComponent&lt;RectTransform&gt;().offsetMin = new Vector2(5, 5);
       this.articleItem.GetComponent&lt;RectTransform&gt;().offsetMax = new Vector2(-5, -5);
   });
    //设置大小
    this.articleItem.transform.localScale = Vector3.one;
    //设置
    //this.articleItem.GetComponent&lt;RectTransform&gt;().offsetMin = new Vector2(5, 5);
    //this.articleItem.GetComponent&lt;RectTransform&gt;().offsetMax = new Vector2(-5, -5);
}
//清空格子
public void ClearGride()
{
    articleItem.gameObject.SetActive(false);
    articleItem.transform.SetParent(null);
    articleItem = null;
}

//物品填入格子
public void DragIntoGride(ArticleItem articleItem)
{
    //物品原来所在的格子
    BagGrde lastGride = articleItem.transform.parent.GetComponent&lt;BagGrde&gt;();
    if (this.articleItem==null)//如果这个格子中没有物品
    {
        //清空之前的格子
        lastGride.ClearGride();

        //设置拖拽到的此格子
        SetArticleItem(articleItem);
        //lastGride.ClearGride();
    }
    else//此格子不为空时将物品进行交换
    {
        //当前格子内物品设置到之前的格子
        lastGride.SetArticleItem(this.articleItem);
        //设置拖拽过来的新物品到的此格子
        SetArticleItem(articleItem);
    }
}
//鼠标进入格子时接口调用的函数
public void OnPointerEnter(PointerEventData eventData)
{
    if(BagPanel.instence .curretnAricle!=null)//拖拽的物品不为空时
    {
        BagPanel.instence.currtenHoverGrid = this;//光标进入此格子则选中此格子
        bgImage.color = Color.white;//该变选中格子的颜色
    }
    //此格子布为空时显示此格子物品的信息界面
    if (this.articleItem != null)
    {
        UIManager.Instence.articleInformation.gameObject.SetActive(true);
        UIManager.Instence.articleInformation.panel.transform.position = transform.position;
        UIManager.Instence.articleInformation.info.text = this.articleItem.article.name + &quot;\n&quot; + this.articleItem.article.count.ToString ();
    }
}
//光标退出时
public void OnPointerExit(PointerEventData eventData)
{
    BagPanel.instence.currtenHoverGrid = null;
    bgImage.color = defortColor;
    //隐藏信息界面
    UIManager.Instence.articleInformation.gameObject.SetActive(false);
    UIManager.Instence.articleInformation.panel.transform.position = Vector3.zero;
    UIManager.Instence.articleInformation.info.text = &quot; &quot;;
}
</code></pre>
<p>}<br>
———————————————————————————————————<br>
背包模块类：<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.UI;</p>
<p>public class BagPanel : MonoBehaviour<br>
{</p>
<pre><code>private List&lt;Article&gt; articlesList = new List&lt;Article&gt;();//背包中所有物品的属性

private List&lt;GameObject&gt; articleObjectPool = new List&lt;GameObject&gt;();//储存物品预制件的对象池

public GameObject articleItemPrafab;//物品UI预制件
private BagGrde[] bagGrdes;//物品栏

public BagGrde currtenHoverGrid;//当前鼠标所悬浮所在格子
public ArticleItem curretnAricle;//当前拖拽物品
//单例
public static BagPanel instence;//单例，在外部访问公开属性

//private Button btn_Back;
// Start is called before the first frame update
void Awake()
{
    /*if (instence !=null)
    {
        Destroy(gameObject);
        return;
    }*/
    instence = this;
    //DontDestroyOnLoad(gameObject);

    //btn_Back = transform.Find(&quot;btn_Back&quot;).GetComponent&lt;Button&gt;();
    //btn_Back.onClick.AddListener(UIManager.Instence.ExtBagPanel);
    InitArticleDate();
    bagGrdes = transform.GetComponentsInChildren&lt;BagGrde&gt;();//获取所有格子
    LoadDate();//初始加载全部数据
}
</code></pre>
<p>/*    private void Start()<br>
{<br>
LoadDate();<br>
}*/<br>
//加载全部数据<br>
public void LoadDate()<br>
{<br>
ClearGrideAndHideItems();<br>
for (int i = 0; i &lt; articlesList.Count; i++)<br>
{<br>
//将列表中所有物品的属性生成对应物品装入空着的格子<br>
GetBagGrid().SetArticleItem(LoadArticleItem(articlesList[i]));<br>
}<br>
}<br>
//按类加载的重载方法<br>
public void LoadDate(ArticleType articleType)<br>
{<br>
ClearGrideAndHideItems();<br>
for (int i = 0; i &lt; articlesList.Count; i++)<br>
{<br>
if (articlesList[i].articleType == articleType)<br>
{<br>
//将列表中某类物品生成对应物品装入空着的格子<br>
GetBagGrid().SetArticleItem(LoadArticleItem(articlesList[i]));<br>
}<br>
}<br>
}<br>
//获取空着的格子<br>
public BagGrde GetBagGrid()<br>
{<br>
for (int i = 0; i &lt; bagGrdes.Length; i++)<br>
{<br>
if (bagGrdes[i].ArticleItem == null)<br>
return bagGrdes[i];<br>
}<br>
return null;<br>
}<br>
//加载ArticleItem物品：根据属性创建对应装备物品<br>
public ArticleItem LoadArticleItem(Article article)<br>
{<br>
GameObject go = GetGameObject();<br>
ArticleItem articleItem = go.GetComponent<ArticleItem>();<br>
articleItem.SetArticle(article);<br>
return articleItem;<br>
}<br>
//获取GameObject：获取对象池中空闲物品预制件<br>
public GameObject GetGameObject()<br>
{<br>
for (int i = 0; i &lt; articleObjectPool.Count; i++)<br>
{<br>
if (articleObjectPool[i].activeSelf==false)<br>
{<br>
articleObjectPool[i].SetActive(true);<br>
return articleObjectPool[i];<br>
}<br>
}<br>
GameObject go = Instantiate(articleItemPrafab);<br>
articleObjectPool.Add(go);<br>
return go;</p>
<pre><code>}
//重新加载背包时物品栏清空
public void ClearGrideAndHideItems()
{
    for (int i = 0; i &lt; bagGrdes.Length; i++)
    {
        if (bagGrdes[i].ArticleItem!=null)
        {
            bagGrdes[i].ClearGride();
        }
    }
}

//初始化物品数据：加载拥有的制备数据应从服务器获取，此处实验性加载部分装备
public void InitArticleDate()
{
    //武器
    articlesList.Add(new Article(&quot;刀刀&quot;,&quot;at0&quot;, ArticleType.Weapon, 2));
    articlesList.Add(new Article(&quot;剑剑&quot;, &quot;at1&quot;, ArticleType.Weapon, 1));
    articlesList.Add(new Article(&quot;春药&quot;, &quot;at2&quot;, ArticleType.Drag, 7));
    articlesList.Add(new Article(&quot;夏药&quot;, &quot;at3&quot;, ArticleType.Drag, 6));
    articlesList.Add(new Article(&quot;秋药&quot;, &quot;at4&quot;, ArticleType.Drag, 5));
    articlesList.Add(new Article(&quot;冬药&quot;, &quot;at5&quot;, ArticleType.Drag, 4));
    articlesList.Add(new Article(&quot;典藏种子&quot;, &quot;at6&quot;, ArticleType.Collect, 1001));
    articlesList.Add(new Article(&quot;玻璃碎片&quot;, &quot;at7&quot;, ArticleType.Pick, 12));
}


#region 点击标签事件(所有标签都在同一个标签组-只有一个标签可选。勾选标签是执行)
public void OnAllToggleValueChange(bool v)//v为标签是否被勾选
{
    if (v) LoadDate();
}
public void OnWepanToggleValueChange(bool v)
{
    if (v) LoadDate(ArticleType.Weapon);
}
public void OnDragToggleValueChange(bool v)
{
    if (v) LoadDate(ArticleType.Drag);
}
public void OnClctorToggleValueChange(bool v)
{
    if (v) LoadDate(ArticleType.Collect);
}
public void OnPickToggleValueChange(bool v)
{
    if (v) LoadDate(ArticleType.Pick);
}
#endregion
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shader_反射]]></title>
        <id>https://Wei715547.github.io/post/shader_-fan-she/</id>
        <link href="https://Wei715547.github.io/post/shader_-fan-she/">
        </link>
        <updated>2020-08-25T15:41:56.000Z</updated>
        <content type="html"><![CDATA[<p>Shader &quot;Custom/Reflection&quot;<br>
{<br>
Properties//属性<br>
{<br>
_MainTex(&quot;Main Tex&quot;,2D) = &quot;white&quot;{}//贴图代替漫反射颜色<br>
_Color(&quot;Tex Color&quot;,Color) = (1,1,1,1)//贴图颜色:与贴图uv坐标下的像素点颜色混合<br>
_NormalMap(&quot;Normal Map&quot;,2D) = &quot;bump&quot;{}//未添法线贴图时为默认法线<br>
_NormalST(&quot;Normal ST&quot;,Float) = 1//法线贴图强度参数<br>
_Specular(&quot;_Specular&quot;, Color) = (1, 1, 1, 1)//高光颜色<br>
_Gloss(&quot;_Gloss&quot;, Range(1, 200)) = 20//高光参数<br>
_ReflectAmount(&quot;_ReflectAmount&quot;,Range(0,1)) = 1<br>
_CubeMap(&quot;_CubeMap&quot;,Cube) = &quot;_Skybox&quot;{}//天空和贴图<br>
}<br>
SubShader<br>
{<br>
Pass<br>
{<br>
Tags {&quot;Lighting&quot; = &quot;ForwardBase&quot;} //定义LightMode,获取UNITY内部光照变量<br>
CGPROGRAM<br>
//在CG声明属性<br>
sampler2D _MainTex;//ShaderCG中的关键字<br>
float4 _MainTex_ST; //主贴图的缩放与偏移“属性名称固定”_MainTex_ST.xy缩放属性；_MainTex_ST.zw偏移属性<br>
fixed4 _Color;//与贴图叠混合颜色<br>
sampler2D _NormalMap;<br>
float4 _NormalMap_ST;<br>
float _NormalST;<br>
fixed4 _Specular;<br>
int _Gloss;<br>
fixed _ReflectAmount;<br>
samplerCUBE _CubeMap;<br>
#include &quot;Lighting.cginc&quot;//引入UNITY内置文件，获取光照变量 _LightColor0.rgb;光源颜色<br>
#pragma vertex vert//声明顶点函数<br>
#pragma fragment frag//声明片原函数</p>
<pre><code>	struct a2v//应用向顶点函数传递参数
	{
		float4 vertex:POSITION;//模型空间顶点坐标
		//切线空间的确定是通过（存储到模型里的/模型空间）法线 与 （存储到模型里的/模型空间）切线确定的
		float3 normal:NORMAL;//模型空间法线方向
		float4 tangent:TANGENT;//模型空间下的切线方向：tangent.w:是用来确定切线空间中坐标轴的方向（切线空间下的Z轴方向默认为顶点的法线方向:通过控制缩放xy可改变法线强度）
		float4 texcoord :TEXCOORD0;//获取纹理坐标
	};
	struct v2f//顶点函数向片原函数传递参数
	{
		float4 svPos:SV_POSITION;//顶点函数返回值：剪裁空间中的顶点坐标-系统直接使用
		//float3 worldNormal : TEXCOORD3;//顶点函数向片原函数传递世界坐标下的法线方向(使用法线贴图后不需要)
		float3 lightDir:TEXCOORD0;//切线空间下的平行光方向
		float3 viewDir:TEXCOORD1;//顶点函数向片原函数传递且切线空间下的视线方向

		float4 uv:TEXCOORD2;//xy用来存储_MainTex的纹理坐标，zw用来存储_NormalMap的纹理坐标
		float3 WorldRefl:TEXCOORD3;
	};

	v2f vert(a2v v)//顶点函数将顶点从模型空间转到世界空间，返回值在世界坐标系下的顶点坐标
	{
		v2f f;//声明传参结构体,并对其中的值赋值
		f.svPos = UnityObjectToClipPos(v.vertex);
		//f.worldNormal = UnityObjectToWorldNormal(v.normal);
		//f.worldView = (UnityObjectToWorldNormal(v.vertex), 0);
		f.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;//将纹理坐标传递到片原函数 * 乘上主贴图缩放属性 + 加上主贴图的偏移属性
        //f.uv.xy = TRANSFORM_TEX(v.uv,_MainTex);//将纹理坐标传递到片原函数 * 乘上主贴图缩放属性 + 加上主贴图的偏移属性
		f.uv.zw = v.texcoord.xy * _NormalMap_ST.xy + _NormalMap_ST.zw;//将法线纹理坐标与其属性结合存储到uv.zw中

		TANGENT_SPACE_ROTATION;//调用这个宏后(保证a2v &quot;v&quot;中存在&quot;normal&quot;&quot;tangent&quot;宏自动调用)，会得到一个矩阵&quot;rotation&quot;这个矩阵用来把模型空间下的法线转换到切线空间下

		//ObjSpaceLightDir(v.vertex);//模型空间下的平行光方向
		f.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex));//将切线就下的平行光方向传到片原函数
		f.viewDir = mul(rotation, ObjSpaceViewDir(v.vertex));//计算切线空间下的视角方向
		return f;//返回结构体
	}

	//把与法线有关相关计算放到切线空间下（从法线贴图取到的方向坐标为切线空间下的）
	fixed4 frag(v2f f) :SV_Target//片原函数，返回值为输出到像素颜色值的缓存
	{
		//计算漫反射
		//fixed3 normalDir = normalize(f.worldNormal);//法线方向
		fixed4 normalColor = tex2D(_NormalMap,f.uv.zw);//法线贴图在纹理坐标下的颜色值(只使用其中RGB值)

		//此方法法线读取不正确//fixed3 tangentNormal = normalize(normalColor.xyz * 2 - 1);//切线空间下的法线方向
		fixed3 tangentNormal = normalize(UnpackNormal(normalColor));//在UNITY中将法线贴图类型设置为法线贴图时可用此方法获得切线空间下的法线方向
		//切线空间下的Z轴方向默认为顶点的法线方向:通过控制缩放xy可改变法线强度，则如下
		tangentNormal.xy = tangentNormal.xy * _NormalST;//强度为0时使用的即是模型顶点默认的法线方向

		fixed3 lightDir = normalize(f.lightDir);//单位化切线空间下的光源方向

		fixed3 texColor = tex2D(_MainTex, f.uv.xy) * _Color.rgb;//获取纹理坐标下贴图像素点的颜色*与外部属性控制的贴图颜色混合

		

		fixed3 diffuse = _LightColor0.rgb * texColor * max((dot(lightDir,tangentNormal) * 0.5 + 0.5), 0);//fixed3 harfLambert =dot(f.wordNormalDir, lightDir)*0.5+0.5;//半兰伯特光照模型:直射光颜色 * (cos夹角(光与法线)*0.5+0.5):使背光面不完全为黑色

		//计算高光反射
		//fixed3 reflectDir = normalize(reflect(-lightDir, normalDir));
		fixed3 viewDir = normalize(f.viewDir);//实视线方向
		fixed3 harfDir = normalize(viewDir + lightDir);//视角与平行光的平分方向
		fixed3 specular = _LightColor0.rgb * texColor * _Specular.rgb * pow(max(dot(tangentNormal, harfDir),0), _Gloss);//BP模型://Blinn-Phong光照模型Specular = 直射光*pow(max(cos夹角,0)*高光参数) ，夹角：法线与x方向夹角,x:平行光与视野方向的平分项。


		fixed3 worleRefl = reflect(-viewDir,tangentNormal);
		fixed3 reflection = texCUBE(_CubeMap,worleRefl).rgb;

		fixed3 tempColor = lerp(diffuse, reflection,_ReflectAmount) + specular + UNITY_LIGHTMODEL_AMBIENT.rgb * texColor;//漫反射+高光+环境光*纹理，相加混合（环境光与纹理混合：使强光下的纹理仍保持清晰）
		

		return fixed4(tempColor,1);
	}
	ENDCG
}

	}
		FallBack &quot;Diffuse&quot;
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UI滚动窗口Scroll View(自动/手动)缓动缩放]]></title>
        <id>https://Wei715547.github.io/post/ui-gun-dong-chuang-kou-scroll-viewzi-dong-shou-dong-huan-dong-suo-fang/</id>
        <link href="https://Wei715547.github.io/post/ui-gun-dong-chuang-kou-scroll-viewzi-dong-shou-dong-huan-dong-suo-fang/">
        </link>
        <updated>2020-08-24T12:24:01.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://Wei715547.github.io/post-images/1598272075912.PNG" alt="" loading="lazy"><br>
//基础手动/自动滚动代码<br>
using System;<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.EventSystems;<br>
using UnityEngine.UI;</p>
<p>public class PstPanel : MonoBehaviour ,IEndDragHandler,IBeginDragHandler<br>
{<br>
protected ScrollRect rect;<br>
RectTransform content;<br>
public int pageCount;<br>
public float[] pagePos;//存储各滚动页的坐标</p>
<pre><code>public float runTime = 0;//控制滚动快慢的记录系统时间
public float holdTime = 0.2f;//控制滚动快慢的时间
public float startPos;//滚动窗口rect.horizontalNormalizedPosition属性线性变化的开始值
public int currentPage = 0;//当前滚动窗口要显示页面

public bool isMoving = false;

public bool isAutoRoll;
public float autoHodeTime = 2;//自动股东间隔时间
private float AutoRunTimer=0;//控制自动滚动间隔的记录系统时间

private bool isDrag = false;

public Action&lt;int&gt; OnPageChange;//事件/委托链：公开变量用于外部订阅

// Start is called before the first frame update
protected virtual void Start()
{
    Init();
}

private void Init()
{
    rect = GetComponent&lt;ScrollRect&gt;();
    content = transform.Find(&quot;Viewport/Content&quot;).GetComponent&lt;RectTransform&gt;();
    pageCount = content.childCount;
    if (pageCount == 1)
    {
        throw new System.Exception(&quot;UnAutoR&quot;);
    }
    pagePos = new float[pageCount];
    for (int i = 0; i &lt; pagePos.Length; i++)
    {
        pagePos[i] = i * (1.0f / (float)(pageCount - 1));//计算并存储每个页面的坐标
    }
}

// Update is called once per frame
protected virtual void Update()
{
    LisenerMove();//监听移动方法
    LisenerAutoRoll();//监听自动移动方法
}

private void LisenerMove()//每帧执行：使窗口显示目标页面
{
    if (isMoving)
    {
        runTime += Time.deltaTime / holdTime;
        rect.horizontalNormalizedPosition = Mathf.Lerp(rect.horizontalNormalizedPosition, pagePos[currentPage], runTime);//runTime=1时立即移动到目标值
        if (runTime &gt;= 1)
        {
            isMoving = false;
        }
    }
}

public void LisenerAutoRoll()
{
    if (isDrag) return;
    if (isAutoRoll)//间隔时间调用滚动方法
    {
        AutoRunTimer += Time.deltaTime;
        if(AutoRunTimer&gt;=autoHodeTime)
        {
            AutoRunTimer = 0;
            currentPage++ ;
            currentPage %= pageCount;
            ScrollToPage(currentPage);
        }
    }
}
/// &lt;summary&gt;
/// 滚动到指定页面方法
/// &lt;/summary&gt;
/// &lt;param name=&quot;page&quot;&gt;要滚动到的页面&lt;/param&gt;
public void ScrollToPage(int page)
{
    isMoving = true;
    currentPage =page;
    runTime = 0;
    startPos = rect.horizontalNormalizedPosition;//范围(0~1)
    if(OnPageChange!=null)// OnPageChange?.Invoke(this.currentPage);
    {//作用同于广播此事件(委托连不为空则调用)
        OnPageChange(this.currentPage);
    }
}

public void OnEndDrag(PointerEventData eventData)//结束拖拽接口实现：重置自动滚动时间，判断当前停留位置更接近那个页面并移动到目标页面
{
    isDrag = false;
    AutoRunTimer = 0;
    ToEndPos();
}
/// &lt;summary&gt;
/// 拖拽结束时一定到目标位置    
/// &lt;/summary&gt;
private void ToEndPos()
{
    int pageIndex = 0;
    for (int i = 1; i &lt; pagePos.Length; i++)
    {
        if (Mathf.Abs(pagePos[i] - rect.horizontalNormalizedPosition) &lt; Mathf.Abs(pagePos[pageIndex] - rect.horizontalNormalizedPosition))
        {
            pageIndex = i;
        }
    }
    ScrollToPage(pageIndex);
}

public void OnBeginDrag(PointerEventData eventData)//开始拖拽接口实现
{
    isDrag = true;
}
</code></pre>
<p>}</p>
<p>//通过代码继承与多态对父类代码复用与扩展添加缓动效果<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class PageScale : PstPanel<br>
{<br>
public GameObject[] items;<br>
public float currentScle = 1f;<br>
public float otherScle = 0.6f;<br>
public int lastPage;<br>
public int nextPage;<br>
public float percent;<br>
protected override void Start()<br>
{<br>
base.Start();<br>
items = new GameObject[pageCount];<br>
for (int i = 0; i &lt; pageCount; i++)<br>
{<br>
items[i] = transform.Find(&quot;Viewport/Content&quot;).transform.GetChild(i).gameObject;<br>
}<br>
}</p>
<pre><code>protected override void Update()
{
    base.Update();
    LissenterScale();
    //SetItenSize(currentPage);
}
/// &lt;summary&gt;
/// 监听Scale
/// &lt;/summary&gt;
public void LissenterScale()
{
    //获取当前上一页，下一页
    for (int i = 0; i &lt; pagePos.Length; i++)
    {
        if(pagePos[i]&lt;=rect.horizontalNormalizedPosition)
        {
            lastPage = i;
        }            
    }
    for (int i = 0; i &lt; pagePos.Length; i++)
    {
        if(pagePos[i]&gt;rect.horizontalNormalizedPosition)
        {
            nextPage = i;
            break;
        }
    }

    if (lastPage == nextPage)
        return;
    percent = (rect.horizontalNormalizedPosition - pagePos[lastPage]) / (pagePos[nextPage] - pagePos[lastPage]);//当前页到下一页0~1变动
    items[lastPage].transform.localScale = Vector3.Lerp(Vector3.one * currentScle, Vector3.one * otherScle, percent);//按比例返回a,b间的值0返回a，1返回b
    items[nextPage].transform.localScale = Vector3.Lerp(Vector3.one * currentScle, Vector3.one * otherScle, 1-percent);

    for (int i = 0; i &lt; items.Length; i++)
    {
        if (i!=lastPage&amp;&amp;i!=nextPage)
            items[i].transform.localScale = Vector3.one * otherScle;
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shader_渐变与遮罩纹理]]></title>
        <id>https://Wei715547.github.io/post/shader_-jian-bian-yu-zhe-zhao-wen-li/</id>
        <link href="https://Wei715547.github.io/post/shader_-jian-bian-yu-zhe-zhao-wen-li/">
        </link>
        <updated>2020-08-22T07:30:11.000Z</updated>
        <content type="html"><![CDATA[<p>Shader &quot;Custom/Jianbian_Zhezhao&quot;<br>
{<br>
Properties//属性<br>
{<br>
_Diffuse(&quot;_DiffuseColor&quot;,Color) = (1,1,1,1)//漫反射颜色<br>
_Specular(&quot;_Specular&quot;, Color) = (1, 1, 1, 1)//高光颜色<br>
_Gloss(&quot;_Gloss&quot;, Range(10, 200)) = 20//高光参数<br>
_Fad(&quot;_Fad&quot;,Color) = (1,1,1,1)//渐变贴图：作用于漫反射：fixed3 fad = tex2D(_Fad,float2()halfLambert,halfLambert).rgb(以半兰伯特值作为坐标获得在渐变贴图上的颜色代替半兰伯特值)<br>
_SpecularMask(&quot;_SpecularMask&quot;,Color) = (1,1,1,1)//高光遮罩贴图<br>
_SpecularScale(&quot;_SpecularScale&quot;,float) = 1//高光遮罩强度<br>
}<br>
SubShader<br>
{<br>
Pass<br>
{<br>
Tags {&quot;Lighting&quot; = &quot;ForwardBase&quot;} //定义LightMode,获取UNITY内部光照变量<br>
CGPROGRAM<br>
//在CG声明属性<br>
fixed4 _Diffuse;<br>
fixed4 _Specular;<br>
int _Gloss;<br>
fixed4 _Fad;<br>
fixed4 _SpecularMask;<br>
float _SpecularScale;</p>
<pre><code>		#include &quot;Lighting.cginc&quot;//引入UNITY内置文件，获取光照变量 _LightColor0.rgb;光源颜色
		#pragma vertex vert//声明顶点函数
		#pragma fragment frag//声明片原函数
		

		struct a2v//应用向顶点函数传递参数
		{
			float4 vertex:POSITION;//模型空间顶点坐标
			float3 normal:NORMAL;//模型空间法线方向
		};
		struct v2f//顶点函数向片原函数传递参数
		{
			float4 svPos:SV_POSITION;//顶点函数返回值：剪裁空间中的顶点坐标-系统直接使用
			float3 worldNormal : TEXCOORD0;//顶点函数向片原函数传递世界坐标下的法线方向
			float4 worldView:TEXCOORD1;//顶点函数向片原函数传递世界坐标下的顶点坐标
		};

		v2f vert(a2v v)//顶点函数将顶点从模型空间转到世界空间，返回值在世界坐标系下的顶点坐标
		{
			v2f f;//声明传参结构体,并对其中的值赋值
			f.svPos = UnityObjectToClipPos(v.vertex);
			f.worldNormal = UnityObjectToWorldNormal(v.normal);
			f.worldView = (UnityObjectToWorldNormal(v.vertex), 0);
			return f;//返回结构体
		}

		fixed4 frag(v2f f) :SV_Target//片原函数，返回值为输出到像素颜色值的缓存
		{
			//计算漫反射
			fixed3 amblent = UNITY_LIGHTMODEL_AMBIENT.rgb;//获取系统环境光		
			fixed3 normalDir = normalize(f.worldNormal);
			fixed3 lightDir = normalize(_WorldSpaceLightPos0.xyz);//第一个直射光的位置，对于顶点来说光的位置即是光的方向
			//漫反射渐变贴图
			//fixed3 fad = tex2D(_Fad,float2()halfLambert,halfLambert).rgb
			//fixed3 diffuse = _LightColor0.rgb*_DiffuseColor*fad;

			fixed3 harfLambert = max( dot(normalDir, lightDir)*0.5+0.5,0)*_Fad.rgb;//半兰伯特光照模型:直射光颜色 * (cos夹角(光与法线)*0.5+0.5):使背光面不完全为黑色,半兰伯特模型*渐变贴图.rgb
			fixed3 diffuse = _LightColor0.rgb * harfLambert * _Diffuse.rgb;//根据漫反射公式：直射光颜色 * cos夹角(光与法线)获取颜色 dot(a,b):点乘获取两向量的夹角cos

			//计算高光反射
			//fixed3 reflectDir = normalize(reflect(-lightDir, normalDir));
			fixed3 viewDir = normalize(WorldSpaceViewDir(f.worldView));//实视线方向
			fixed3 harfDir = normalize(viewDir + lightDir);//视角与平行光的平分方向

			//fixed specularMask = tex2D(_SpecularMask,f.uv.xy).r * _SpecularScale;//高光遮罩贴图的某通道值 * 遮罩强度 与高光反射模型相乘控制高光遮罩强度

			fixed specularMask = _SpecularMask.rgb*_SpecularScale;
			fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(dot(normalDir, harfDir),0), _Gloss)*specularMask;//BP模型://Blinn-Phong光照模型Specular = 直射光*pow(max(cos夹角,0)*高光参数) ，夹角：法线与x方向夹角,x:平行光与视野方向的平分项。
			fixed3 tempColor = diffuse + specular + UNITY_LIGHTMODEL_AMBIENT.rgb;//漫反射+高光+环境光，相加混合
			return fixed4(tempColor,1);
		}
		ENDCG
	}

}
FallBack &quot;Diffuse&quot;
</code></pre>
<p>}<br>
<img src="https://Wei715547.github.io/post-images/1598081504394.PNG" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式-观察者模式(事件监听/广播C#委托链)]]></title>
        <id>https://Wei715547.github.io/post/she-ji-mo-shi-guan-cha-zhe-mo-shi-shi-jian-jian-ting-guang-bo-cwei-tuo-lian/</id>
        <link href="https://Wei715547.github.io/post/she-ji-mo-shi-guan-cha-zhe-mo-shi-shi-jian-jian-ting-guang-bo-cwei-tuo-lian/">
        </link>
        <updated>2020-08-21T16:06:03.000Z</updated>
        <content type="html"><![CDATA[<p>各类委托：用于添加不同类型方法<br>
public delegate void CallBack();<br>
public delegate void CallBack<T>(T arg);<br>
public delegate void CallBack&lt;T, X&gt;(T arg1, X arg2);<br>
public delegate void CallBack&lt;T, X, Y&gt;(T arg1, X arg2, Y arg3);<br>
public delegate void CallBack&lt;T, X, Y, Z&gt;(T arg1, X arg2, Y arg3, Z arg4);<br>
public delegate void CallBack&lt;T, X, Y, Z, W&gt;(T arg1, X arg2, Y arg3, Z arg4, W arg5);<br>
事件类型枚举：<br>
public enum EventDefine<br>
{<br>
ShowGamePanel,<br>
DecidePath,<br>
AddScore,<br>
UpdateScoreText,<br>
PlayerMove,<br>
AddDiamond,<br>
UpdateDiamondText,<br>
ShowGameOverPale,<br>
ShowShopPanle,<br>
ShowMainPanle,<br>
ChageSkin,<br>
ShowResetPanel,<br>
ShowRankPanel,<br>
PlayBuyyonSound,<br>
}<br>
事件中心类：<br>
using System;<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class EventCenter<br>
{<br>
//存储的 事件表（事件类型，对应方法类型的委托链）<br>
private static Dictionary&lt;EventDefine, Delegate&gt; m_EventTable = new Dictionary&lt;EventDefine, Delegate&gt;();</p>
<p>//在委托链上添加广播该事件时要调用的方法<br>
private static void OnListenerAdding(EventDefine eventType, Delegate callBack)<br>
{<br>
if (!m_EventTable.ContainsKey(eventType))<br>
{<br>
m_EventTable.Add(eventType, null);<br>
}<br>
Delegate d = m_EventTable[eventType];<br>
if (d != null &amp;&amp; d.GetType() != callBack.GetType())<br>
{<br>
throw new Exception(string.Format(&quot;尝试为事件{0}添加不同类型的委托，当前事件所对应的委托是{1}，要添加的委托类型为{2}&quot;, eventType, d.GetType(), callBack.GetType()));<br>
}<br>
}<br>
//把监听该事件时所调用的方法从委托链上移除<br>
private static void OnListenerRemoving(EventDefine eventType, Delegate callBack)<br>
{<br>
if (m_EventTable.ContainsKey(eventType))<br>
{<br>
Delegate d = m_EventTable[eventType];<br>
if (d == null)<br>
{<br>
throw new Exception(string.Format(&quot;移除监听错误：事件{0}没有对应的委托&quot;, eventType));<br>
}<br>
else if (d.GetType() != callBack.GetType())<br>
{<br>
throw new Exception(string.Format(&quot;移除监听错误：尝试为事件{0}移除不同类型的委托，当前委托类型为{1}，要移除的委托类型为{2}&quot;, eventType, d.GetType(), callBack.GetType()));<br>
}<br>
}<br>
else<br>
{<br>
throw new Exception(string.Format(&quot;移除监听错误：没有事件码{0}&quot;, eventType));<br>
}<br>
}<br>
//把监听该事件时所调用的方法从委托链上移除<br>
private static void OnListenerRemoved(EventDefine eventType)<br>
{<br>
if (m_EventTable[eventType] == null)<br>
{<br>
m_EventTable.Remove(eventType);<br>
}<br>
}<br>
//no parameters<br>
public static void AddListener(EventDefine eventType, CallBack callBack)<br>
{<br>
OnListenerAdding(eventType, callBack);<br>
m_EventTable[eventType] = (CallBack)m_EventTable[eventType] + callBack;<br>
}<br>
//Single parameters<br>
public static void AddListener<T>(EventDefine eventType, CallBack<T> callBack)<br>
{<br>
OnListenerAdding(eventType, callBack);<br>
m_EventTable[eventType] = (CallBack<T>)m_EventTable[eventType] + callBack;<br>
}<br>
//two parameters<br>
public static void AddListener&lt;T, X&gt;(EventDefine eventType, CallBack&lt;T, X&gt; callBack)<br>
{<br>
OnListenerAdding(eventType, callBack);<br>
m_EventTable[eventType] = (CallBack&lt;T, X&gt;)m_EventTable[eventType] + callBack;<br>
}</p>
<pre><code>//no parameters
public static void RemoveListener(EventDefine eventType, CallBack callBack)
{
    OnListenerRemoving(eventType, callBack);
    m_EventTable[eventType] = (CallBack)m_EventTable[eventType] - callBack;
    OnListenerRemoved(eventType);
}
//single parameters
public static void RemoveListener&lt;T&gt;(EventDefine eventType, CallBack&lt;T&gt; callBack)
{
    OnListenerRemoving(eventType, callBack);
    m_EventTable[eventType] = (CallBack&lt;T&gt;)m_EventTable[eventType] - callBack;
    OnListenerRemoved(eventType);
}
//two parameters
public static void RemoveListener&lt;T, X&gt;(EventDefine eventType, CallBack&lt;T, X&gt; callBack)
{
    OnListenerRemoving(eventType, callBack);
    m_EventTable[eventType] = (CallBack&lt;T, X&gt;)m_EventTable[eventType] - callBack;
    OnListenerRemoved(eventType);
}
</code></pre>
<p>}<br>
//no parameters<br>
public static void Broadcast(EventDefine eventType)<br>
{<br>
Delegate d;<br>
if (m_EventTable.TryGetValue(eventType, out d))<br>
{<br>
CallBack callBack = d as CallBack;<br>
if (callBack != null)<br>
{<br>
callBack();<br>
}<br>
else<br>
{<br>
throw new Exception(string.Format(&quot;广播事件错误：事件{0}对应委托具有不同的类型&quot;, eventType));<br>
}<br>
}<br>
}<br>
//single parameters<br>
public static void Broadcast<T>(EventDefine eventType, T arg)<br>
{<br>
Delegate d;<br>
if (m_EventTable.TryGetValue(eventType, out d))<br>
{<br>
CallBack<T> callBack = d as CallBack<T>;<br>
if (callBack != null)<br>
{<br>
callBack(arg);<br>
}<br>
else<br>
{<br>
throw new Exception(string.Format(&quot;广播事件错误：事件{0}对应委托具有不同的类型&quot;, eventType));<br>
}<br>
}<br>
}</p>
<hr>
<p>UI脚本中代码：<br>
void Start()<br>
{<br>
EventCenter.AddListener(EventDefine.ShowShopPanle, Show);<br>
}<br>
private void OnDestroy()<br>
{<br>
EventCenter.RemoveListener (EventDefine.ShowShopPanle, Show);<br>
}</p>
<pre><code>private void Show()
{
    gameObject.SetActive(true);
}</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shader-透明度]]></title>
        <id>https://Wei715547.github.io/post/shader-tou-ming-du/</id>
        <link href="https://Wei715547.github.io/post/shader-tou-ming-du/">
        </link>
        <updated>2020-08-20T09:21:09.000Z</updated>
        <content type="html"><![CDATA[<p>Shader &quot;Custom/Alpha&quot;<br>
{<br>
Properties//属性<br>
{<br>
_MainTex(&quot;Main Tex&quot;,2D) = &quot;white&quot;{}//贴图代替漫反射颜色<br>
_Color(&quot;Tex Color&quot;,Color) = (1,1,1,1)//贴图颜色:与贴图uv坐标下的像素点颜色混合<br>
_NormalMap(&quot;Normal Map&quot;,2D) = &quot;bump&quot;{}//未添法线贴图时为默认法线<br>
_NormalST(&quot;Normal ST&quot;,Float) = 1//法线贴图强度参数<br>
_AlphaScale(&quot;_AlphaScale&quot;,Float) = 1<br>
}<br>
SubShader<br>
{<br>
Tags{&quot;Queue&quot; = &quot;Transparent&quot;/<em>模型渲染队列</em>/ &quot;IngnoreProjector&quot; = &quot;True&quot; &quot;RanderType&quot; = &quot;Transparent&quot;}//Pass块参数标签<br>
<img src="https://Wei715547.github.io/post-images/1598164914894.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1598166460428.PNG" alt="" loading="lazy"><br>
Pass<br>
{<br>
Tags {&quot;Lighting&quot; = &quot;ForwardBase&quot;} //定义LightMode,获取UNITY内部光照变量</p>
<pre><code>			ZWrite Off//深度写入关闭
			Blend SrcAlpha OneMinusSrcAlpha//混合模式：透明区域与透明物体后颜色混合

	*		CGPROGRAM
	*	//在CG声明属性
		sampler2D _MainTex;//ShaderCG中的关键字
		float4 _MainTex_ST; //主贴图的缩放与偏移“属性名称固定”_MainTex_ST.xy缩放属性；_MainTex_ST.zw偏移属性
		fixed4 _Color;//与贴图叠混合颜色
		sampler2D _NormalMap;
		float4 _NormalMap_ST;
		float _NormalST;
		float _AlphaScale;

	#include &quot;Lighting.cginc&quot;//引入UNITY内置文件，获取光照变量 _LightColor0.rgb;光源颜色
	#pragma vertex vert//声明顶点函数
	#pragma fragment frag//声明片原函数


	struct a2v//应用向顶点函数传递参数
	{
		float4 vertex:POSITION;//模型空间顶点坐标
		//切线空间的确定是通过（存储到模型里的/模型空间）法线 与 （存储到模型里的/模型空间）切线确定的
		float3 normal:NORMAL;//模型空间法线方向
		float4 tangent:TANGENT;//模型空间下的切线方向：tangent.w:是用来确定切线空间中坐标轴的方向（切线空间下的Z轴方向默认为顶点的法线方向:通过控制缩放xy可改变法线强度）
		float4 texcoord :TEXCOORD0;//获取纹理坐标
	};
	struct v2f//顶点函数向片原函数传递参数
	{
		float4 svPos:SV_POSITION;//顶点函数返回值：剪裁空间中的顶点坐标-系统直接使用
		//float3 worldNormal : TEXCOORD0;//顶点函数向片原函数传递世界坐标下的法线方向(使用法线贴图后不需要)
		float3 lightDir:TEXCOORD0;//切线空间下的平行光方向
		//float4 worldView:TEXCOORD1;//顶点函数向片原函数传递世界坐标下的顶点坐标

		float4 uv:TEXCOORD2;//xy用来存储_MainTex的纹理坐标，zw用来存储_NormalMap的纹理坐标
	};

	v2f vert(a2v v)//顶点函数将顶点从模型空间转到世界空间，返回值在世界坐标系下的顶点坐标
	{
		v2f f;//声明传参结构体,并对其中的值赋值
		f.svPos = UnityObjectToClipPos(v.vertex);
		//f.worldNormal = UnityObjectToWorldNormal(v.normal);
		//f.worldView = (UnityObjectToWorldNormal(v.vertex), 0);
		f.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;//将纹理坐标传递到片原函数 * 乘上主贴图缩放属性 + 加上主贴图的偏移属性
		f.uv.zw = v.texcoord.xy * _NormalMap_ST.xy + _NormalMap_ST.zw;//将法线纹理坐标与其属性结合存储到uv.zw中

		TANGENT_SPACE_ROTATION;//调用这个宏后(保证a2v &quot;v&quot;中存在&quot;normal&quot;&quot;tangent&quot;宏自动调用)，会得到一个矩阵&quot;rotation&quot;这个矩阵用来把模型空间下的法线转换到切线空间下

		//ObjSpaceLightDir(v.vertex);//模型空间下的平行光方向
		f.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex));//将切线就下的平行光方向传到片原函数
		return f;//返回结构体
	}

	//把与法线有关相关计算放到切线空间下（从法线贴图取到的方向坐标为切线空间下的）
	fixed4 frag(v2f f) :SV_Target//片原函数，返回值为输出到像素颜色值的缓存
	{
		//计算漫反射
		//fixed3 normalDir = normalize(f.worldNormal);//法线方向
		fixed4 normalColor = tex2D(_NormalMap,f.uv.zw);//法线贴图在纹理坐标下的颜色值(只使用其中RGB值)

		//此方法法线读取不正确//fixed3 tangentNormal = normalize(normalColor.xyz * 2 - 1);//切线空间下的法线方向
		fixed3 tangentNormal = normalize(UnpackNormal(normalColor));//在UNITY中将法线贴图类型设置为法线贴图时可用此方法获得切线空间下的法线方向
		//切线空间下的Z轴方向默认为顶点的法线方向:通过控制缩放xy可改变法线强度，则如下
		tangentNormal.xy = tangentNormal.xy * _NormalST;//强度为0时使用的即是模型顶点默认的法线方向

		fixed3 lightDir = normalize(f.lightDir);//单位化切线空间下的光源方向

		fixed4 texColor = tex2D(_MainTex, f.uv.xy) * _Color;//获取纹理坐标下贴图像素点的颜色*与外部属性控制的贴图颜色混合

		fixed3 diffuse = _LightColor0.rgb * texColor.rgb * max((dot(tangentNormal,lightDir) * 0.5 + 0.5), 0);//fixed3 harfLambert =dot(f.wordNormalDir, lightDir)*0.5+0.5;//半兰伯特光照模型:直射光颜色 * (cos夹角(光与法线)*0.5+0.5):使背光面不完全为黑色

		//计算高光反射
		//fixed3 reflectDir = normalize(reflect(-lightDir, normalDir));
		//fixed3 viewDir = normalize(WorldSpaceViewDir(f.worldView));//实视线方向
		//fixed3 harfDir = normalize(viewDir + lightDir);//视角与平行光的平分方向
		//fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(dot(normalDir, harfDir),0), _Gloss);//BP模型://Blinn-Phong光照模型Specular = 直射光*pow(max(cos夹角,0)*高光参数) ，夹角：法线与x方向夹角,x:平行光与视野方向的平分项。

		fixed3 tempColor = diffuse + UNITY_LIGHTMODEL_AMBIENT.rgb * texColor;//漫反射+高光+环境光*纹理，相加混合（环境光与纹理混合：使强光下的纹理仍保持清晰）
		return fixed4(tempColor,_AlphaScale*texColor.a);//外部属性与纹理贴图Alpha值混合控制
	}
	ENDCG
}

	}
		FallBack &quot;Diffuse&quot;
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shader-法线]]></title>
        <id>https://Wei715547.github.io/post/shader-fa-xian/</id>
        <link href="https://Wei715547.github.io/post/shader-fa-xian/">
        </link>
        <updated>2020-08-20T06:55:11.000Z</updated>
        <content type="html"><![CDATA[<p>像素点.rgb(0<sub>1)与法线方向(-1</sub>1)转换：<br>
pixel = (normal+1)/2<br>
normal = pixel*2-1 (切下空间下法线方向)<br>
切线空间来存储法线：模型的每个顶点都有一个属于自己的切线空间，这个切线空间的原点就是该点本身，的Z轴方向默认为该顶点的法线方向，x轴是该顶点的切线方向，则y轴可由法线与切线的叉积得到(副切线)。<br>
模型空间下的法线贴图看起来的五颜六色的是由于在模型空间下个顶点的法线方向是各异的。<br>
切线空间下的法线贴图大部分呈现浅蓝色是由于如果一个点的法线方向不变则默认方向即为Z轴方向对应(0,0,1)转换后的像素颜色为RGB(0.5,0.5,1)浅蓝色，贴图中大部分的蓝色实际上说明顶点的大部分法线是和模型本身一样的不需要改变。<br>
<code><br>
Shader &quot;Custom/Normal&quot;<br>
{<br>
Properties//属性<br>
{<br>
_MainTex(&quot;Main Tex&quot;,2D) = &quot;white&quot;{}//贴图代替漫反射颜色<br>
_Color(&quot;Tex Color&quot;,Color) = (1,1,1,1)//贴图颜色:与贴图uv坐标下的像素点颜色混合<br>
_NormalMap(&quot;Normal Map&quot;,2D) = &quot;bump&quot;{}//未添法线贴图时为默认法线<br>
_NormalST(&quot;Normal ST&quot;,Float) = 1//法线贴图强度参数<br>
}<br>
SubShader<br>
{<br>
Pass<br>
{<br>
Tags {&quot;Lighting&quot; = &quot;ForwardBase&quot;} //定义LightMode,获取UNITY内部光照变量<br>
CGPROGRAM<br>
//在CG声明属性<br>
sampler2D _MainTex;//ShaderCG中的关键字<br>
float4 _MainTex_ST; //主贴图的缩放与偏移“属性名称固定”_MainTex_ST.xy缩放属性；_MainTex_ST.zw偏移属性<br>
fixed4 _Color;//与贴图叠混合颜色<br>
sampler2D _NormalMap;<br>
float4 _NormalMap_ST;<br>
float _NormalST;</p>
<pre><code>	#include &quot;Lighting.cginc&quot;//引入UNITY内置文件，获取光照变量 _LightColor0.rgb;光源颜色
	#pragma vertex vert//声明顶点函数
	#pragma fragment frag//声明片原函数


	struct a2v//应用向顶点函数传递参数
	{
		float4 vertex:POSITION;//模型空间顶点坐标
		//切线空间的确定是通过（存储到模型里的/模型空间）法线 与 （存储到模型里的/模型空间）切线确定的
		float3 normal:NORMAL;//模型空间法线方向
		float4 tangent:TANGENT;//模型空间下的切线方向：tangent.w:是用来确定切线空间中坐标轴的方向（切线空间下的Z轴方向默认为顶点的法线方向:通过控制缩放xy可改变法线强度）
		float4 texcoord :TEXCOORD0;//获取纹理坐标
	};
	struct v2f//顶点函数向片原函数传递参数
	{
		float4 svPos:SV_POSITION;//顶点函数返回值：剪裁空间中的顶点坐标-系统直接使用
		//float3 worldNormal : TEXCOORD0;//顶点函数向片原函数传递世界坐标下的法线方向(使用法线贴图后不需要)
		float3 lightDir:TEXCOORD0;//切线空间下的平行光方向
		//float4 worldView:TEXCOORD1;//顶点函数向片原函数传递世界坐标下的顶点坐标

		float4 uv:TEXCOORD2;//xy用来存储_MainTex的纹理坐标，zw用来存储_NormalMap的纹理坐标
	};

	v2f vert(a2v v)//顶点函数将顶点从模型空间转到世界空间，返回值在世界坐标系下的顶点坐标
	{
		v2f f;//声明传参结构体,并对其中的值赋值
		f.svPos = UnityObjectToClipPos(v.vertex);
		//f.worldNormal = UnityObjectToWorldNormal(v.normal);
		//f.worldView = (UnityObjectToWorldNormal(v.vertex), 0);
		f.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;//将纹理坐标传递到片原函数 * 乘上主贴图缩放属性 + 加上主贴图的偏移属性
		f.uv.zw = v.texcoord.xy * _NormalMap_ST.xy + _NormalMap_ST.zw;//将法线纹理坐标与其属性结合存储到uv.zw中

		TANGENT_SPACE_ROTATION;//调用这个宏后(保证a2v &quot;v&quot;中存在&quot;normal&quot;&quot;tangent&quot;宏自动调用)，会得到一个矩阵&quot;rotation&quot;这个矩阵用来把模型空间下的法线转换到切线空间下

		//ObjSpaceLightDir(v.vertex);//模型空间下的平行光方向
		f.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex));//将切线就下的平行光方向传到片原函数
		return f;//返回结构体
	}

	//把与法线有关相关计算放到切线空间下（从法线贴图取到的方向坐标为切线空间下的）
	fixed4 frag(v2f f) :SV_Target//片原函数，返回值为输出到像素颜色值的缓存
	{
		//计算漫反射
		//fixed3 normalDir = normalize(f.worldNormal);//法线方向
		fixed4 normalColor = tex2D(_NormalMap,f.uv.zw);//法线贴图在纹理坐标下的颜色值(只使用其中RGB值)

		//此方法法线读取不正确//fixed3 tangentNormal = normalize(normalColor.xyz * 2 - 1);//切线空间下的法线方向
		fixed3 tangentNormal = normalize(UnpackNormal(normalColor));//在UNITY中将法线贴图类型设置为法线贴图时可用此方法获得切线空间下的法线方向
		//切线空间下的Z轴方向默认为顶点的法线方向:通过控制缩放xy可改变法线强度，则如下
		tangentNormal.xy = tangentNormal.xy * _NormalST;//强度为0时使用的即是模型顶点默认的法线方向

		fixed3 lightDir = normalize(f.lightDir);//单位化切线空间下的光源方向

		fixed3 texColor = tex2D(_MainTex, f.uv.xy) * _Color.rgb;//获取纹理坐标下贴图像素点的颜色*与外部属性控制的贴图颜色混合

		fixed3 diffuse = _LightColor0.rgb * texColor * max((dot(tangentNormal,lightDir) * 0.5 + 0.5), 0);//fixed3 harfLambert =dot(f.wordNormalDir, lightDir)*0.5+0.5;//半兰伯特光照模型:直射光颜色 * (cos夹角(光与法线)*0.5+0.5):使背光面不完全为黑色

		//计算高光反射
		//fixed3 reflectDir = normalize(reflect(-lightDir, normalDir));
		//fixed3 viewDir = normalize(WorldSpaceViewDir(f.worldView));//实视线方向
		//fixed3 harfDir = normalize(viewDir + lightDir);//视角与平行光的平分方向
		//fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(dot(normalDir, harfDir),0), _Gloss);//BP模型://Blinn-Phong光照模型Specular = 直射光*pow(max(cos夹角,0)*高光参数) ，夹角：法线与x方向夹角,x:平行光与视野方向的平分项。

		fixed3 tempColor = diffuse + UNITY_LIGHTMODEL_AMBIENT.rgb * texColor;//漫反射+高光+环境光*纹理，相加混合（环境光与纹理混合：使强光下的纹理仍保持清晰）
		return fixed4(tempColor,1);
	}
	ENDCG
}

	}
		FallBack &quot;Diffuse&quot;
</code></pre>
<p>}<br>
</code><br>
<img src="https://Wei715547.github.io/post-images/1597913629337.PNG" alt="" loading="lazy"><br>
————————————————————————————————————<br>
法线与高光(在切线空间下使用BP光照模型计算高光)<br>
<code><br>
Shader &quot;Custom/Normal&quot;<br>
{<br>
Properties//属性<br>
{<br>
_MainTex(&quot;Main Tex&quot;,2D) = &quot;white&quot;{}//贴图代替漫反射颜色<br>
_Color(&quot;Tex Color&quot;,Color) = (1,1,1,1)//贴图颜色:与贴图uv坐标下的像素点颜色混合<br>
_NormalMap(&quot;Normal Map&quot;,2D) = &quot;bump&quot;{}//未添法线贴图时为默认法线<br>
_NormalST(&quot;Normal ST&quot;,Float) = 1//法线贴图强度参数<br>
_Specular(&quot;_Specular&quot;, Color) = (1, 1, 1, 1)//高光颜色<br>
_Gloss(&quot;_Gloss&quot;, Range(1, 200)) = 20//高光参数<br>
}<br>
SubShader<br>
{<br>
Pass<br>
{<br>
Tags {&quot;Lighting&quot; = &quot;ForwardBase&quot;} //定义LightMode,获取UNITY内部光照变量<br>
CGPROGRAM<br>
//在CG声明属性<br>
sampler2D _MainTex;//ShaderCG中的关键字<br>
float4 _MainTex_ST; //主贴图的缩放与偏移“属性名称固定”_MainTex_ST.xy缩放属性；_MainTex_ST.zw偏移属性<br>
fixed4 _Color;//与贴图叠混合颜色<br>
sampler2D _NormalMap;<br>
float4 _NormalMap_ST;<br>
float _NormalST;<br>
fixed4 _Specular;<br>
int _Gloss;</p>
<pre><code>	#include &quot;Lighting.cginc&quot;//引入UNITY内置文件，获取光照变量 _LightColor0.rgb;光源颜色
	#pragma vertex vert//声明顶点函数
	#pragma fragment frag//声明片原函数


	struct a2v//应用向顶点函数传递参数
	{
		float4 vertex:POSITION;//模型空间顶点坐标
		//切线空间的确定是通过（存储到模型里的/模型空间）法线 与 （存储到模型里的/模型空间）切线确定的
		float3 normal:NORMAL;//模型空间法线方向
		float4 tangent:TANGENT;//模型空间下的切线方向：tangent.w:是用来确定切线空间中坐标轴的方向（切线空间下的Z轴方向默认为顶点的法线方向:通过控制缩放xy可改变法线强度）
		float4 texcoord :TEXCOORD0;//获取纹理坐标
	};
	struct v2f//顶点函数向片原函数传递参数
	{
		float4 svPos:SV_POSITION;//顶点函数返回值：剪裁空间中的顶点坐标-系统直接使用
		//float3 worldNormal : TEXCOORD3;//顶点函数向片原函数传递世界坐标下的法线方向(使用法线贴图后不需要)
		float3 lightDir:TEXCOORD0;//切线空间下的平行光方向
		float3 viewDir:TEXCOORD1;//顶点函数向片原函数传递且切线空间下的视线方向

		float4 uv:TEXCOORD2;//xy用来存储_MainTex的纹理坐标，zw用来存储_NormalMap的纹理坐标
	};

	v2f vert(a2v v)//顶点函数将顶点从模型空间转到世界空间，返回值在世界坐标系下的顶点坐标
	{
		v2f f;//声明传参结构体,并对其中的值赋值
		f.svPos = UnityObjectToClipPos(v.vertex);
		//f.worldNormal = UnityObjectToWorldNormal(v.normal);
		//f.worldView = (UnityObjectToWorldNormal(v.vertex), 0);
		f.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;//将纹理坐标传递到片原函数 * 乘上主贴图缩放属性 + 加上主贴图的偏移属性
		f.uv.zw = v.texcoord.xy * _NormalMap_ST.xy + _NormalMap_ST.zw;//将法线纹理坐标与其属性结合存储到uv.zw中

		TANGENT_SPACE_ROTATION;//调用这个宏后(保证a2v &quot;v&quot;中存在&quot;normal&quot;&quot;tangent&quot;宏自动调用)，会得到一个矩阵&quot;rotation&quot;这个矩阵用来把模型空间下的法线转换到切线空间下

		//ObjSpaceLightDir(v.vertex);//模型空间下的平行光方向
		f.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex));//将切线就下的平行光方向传到片原函数
		f.viewDir = mul(rotation, ObjSpaceViewDir(v.vertex));//计算切线空间下的视角方向
		return f;//返回结构体
	}

	//把与法线有关相关计算放到切线空间下（从法线贴图取到的方向坐标为切线空间下的）
	fixed4 frag(v2f f) :SV_Target//片原函数，返回值为输出到像素颜色值的缓存
	{
		//计算漫反射
		//fixed3 normalDir = normalize(f.worldNormal);//法线方向
		fixed4 normalColor = tex2D(_NormalMap,f.uv.zw);//法线贴图在纹理坐标下的颜色值(只使用其中RGB值)

		//此方法法线读取不正确//fixed3 tangentNormal = normalize(normalColor.xyz * 2 - 1);//切线空间下的法线方向
		fixed3 tangentNormal = normalize(UnpackNormal(normalColor));//在UNITY中将法线贴图类型设置为法线贴图时可用此方法获得切线空间下的法线方向
		//切线空间下的Z轴方向默认为顶点的法线方向:通过控制缩放xy可改变法线强度，则如下
		tangentNormal.xy = tangentNormal.xy * _NormalST;//强度为0时使用的即是模型顶点默认的法线方向

		fixed3 lightDir = normalize(f.lightDir);//单位化切线空间下的光源方向

		fixed3 texColor = tex2D(_MainTex, f.uv.xy) * _Color.rgb;//获取纹理坐标下贴图像素点的颜色*与外部属性控制的贴图颜色混合

		fixed3 diffuse = _LightColor0.rgb * texColor * max((dot(lightDir,tangentNormal) * 0.5 + 0.5), 0);//fixed3 harfLambert =dot(f.wordNormalDir, lightDir)*0.5+0.5;//半兰伯特光照模型:直射光颜色 * (cos夹角(光与法线)*0.5+0.5):使背光面不完全为黑色

		//计算高光反射
		//fixed3 reflectDir = normalize(reflect(-lightDir, normalDir));
		fixed3 viewDir = normalize(f.viewDir);//实视线方向
		fixed3 harfDir = normalize(viewDir + lightDir);//视角与平行光的平分方向
		fixed3 specular = _LightColor0.rgb * texColor * _Specular.rgb * pow(max(dot(tangentNormal, harfDir),0), _Gloss);//BP模型://Blinn-Phong光照模型Specular = 直射光*pow(max(cos夹角,0)*高光参数) ，夹角：法线与x方向夹角,x:平行光与视野方向的平分项。

		fixed3 tempColor = diffuse + specular + UNITY_LIGHTMODEL_AMBIENT.rgb * texColor;//漫反射+高光+环境光*纹理，相加混合（环境光与纹理混合：使强光下的纹理仍保持清晰）
		return fixed4(tempColor,1);
	}
	ENDCG
}

	}
		FallBack &quot;Diffuse&quot;
</code></pre>
<p>}<br>
</code><br>
<img src="https://Wei715547.github.io/post-images/1598002656882.PNG" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shader-纹理贴图]]></title>
        <id>https://Wei715547.github.io/post/shader-wen-li-tie-tu/</id>
        <link href="https://Wei715547.github.io/post/shader-wen-li-tie-tu/">
        </link>
        <updated>2020-08-20T06:29:51.000Z</updated>
        <content type="html"><![CDATA[<code>
Shader "Custom/Single_Texture"
{
	Properties//属性
	{
		_MainTex("Main Tex",2D) = "white"{}//贴图代替漫反射颜色
		_Color("Tex Color",Color) = (1,1,1,1)//贴图颜色:与贴图uv坐标下的像素点颜色混合
		//_Diffuse("_DiffuseColor",Color) = (1,1,1,1)//漫反射颜色
		_Specular("_Specular", Color) = (1, 1, 1, 1)//高光颜色
		_Gloss("_Gloss", Range(10, 200)) = 20//高光参数
<pre><code>}
	SubShader
	{
		Pass
		{
			Tags {&quot;Lighting&quot; = &quot;ForwardBase&quot;} //定义LightMode,获取UNITY内部光照变量
			CGPROGRAM
		//在CG声明属性
		sampler2D _MainTex;//ShaderCG中的关键字
		float4 _MainTex_ST; //主贴图的缩放与偏移“属性名称固定”_MainTex_ST.xy缩放属性；_MainTex_ST.zw偏移属性
		fixed4 _Color;//与贴图叠混合颜色
		//fixed4 _Diffuse;
		fixed4 _Specular;
		int _Gloss;

	#include &quot;Lighting.cginc&quot;//引入UNITY内置文件，获取光照变量 _LightColor0.rgb;光源颜色
	#pragma vertex vert//声明顶点函数
	#pragma fragment frag//声明片原函数


	struct a2v//应用向顶点函数传递参数
	{
		float4 vertex:POSITION;//模型空间顶点坐标
		float3 normal:NORMAL;//模型空间法线方向

		float4 texcoord :TEXCOORD0;//获取纹理坐标
	};
	struct v2f//顶点函数向片原函数传递参数
	{
		float4 svPos:SV_POSITION;//顶点函数返回值：剪裁空间中的顶点坐标-系统直接使用
		float3 worldNormal : TEXCOORD0;//顶点函数向片原函数传递世界坐标下的法线方向
		float4 worldView:TEXCOORD1;//顶点函数向片原函数传递世界坐标下的顶点坐标

		float2 uv:TEXCOORD2;
	};

	v2f vert(a2v v)//顶点函数将顶点从模型空间转到世界空间，返回值在世界坐标系下的顶点坐标
	{
		v2f f;//声明传参结构体,并对其中的值赋值
		f.svPos = UnityObjectToClipPos(v.vertex);
		f.worldNormal = UnityObjectToWorldNormal(v.normal);
		f.worldView = (UnityObjectToWorldNormal(v.vertex), 0);
		f.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;//将纹理坐标传递到片原函数 * 乘上主贴图缩放属性 + 加上主贴图的偏移属性
		return f;//返回结构体
	}

	fixed4 frag(v2f f) :SV_Target//片原函数，返回值为输出到像素颜色值的缓存
	{
		//计算漫反射
		fixed3 normalDir = normalize(f.worldNormal);//法线方向
		fixed3 lightDir = normalize(UnityWorldSpaceLightDir(f.worldView));//光源方向

		fixed3 texColor = tex2D(_MainTex, f.uv.xy)*_Color.rgb;//获取纹理坐标下贴图像素点的颜色*与外部属性控制的贴图颜色混合

		fixed3 diffuse = _LightColor0.rgb * texColor * max((dot(normalDir,lightDir) * 0.5 + 0.5), 0);//fixed3 harfLambert =dot(f.wordNormalDir, lightDir)*0.5+0.5;//半兰伯特光照模型:直射光颜色 * (cos夹角(光与法线)*0.5+0.5):使背光面不完全为黑色

		//计算高光反射
		//fixed3 reflectDir = normalize(reflect(-lightDir, normalDir));
		fixed3 viewDir = normalize(WorldSpaceViewDir(f.worldView));//实视线方向
		fixed3 harfDir = normalize(viewDir + lightDir);//视角与平行光的平分方向
		fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(dot(normalDir, harfDir),0), _Gloss);//BP模型://Blinn-Phong光照模型Specular = 直射光*pow(max(cos夹角,0)*高光参数) ，夹角：法线与x方向夹角,x:平行光与视野方向的平分项。

		fixed3 tempColor = diffuse + specular + UNITY_LIGHTMODEL_AMBIENT.rgb*texColor;//漫反射+高光+环境光*纹理，相加混合（环境光与纹理混合：使强光下的纹理仍保持清晰）
		return fixed4(tempColor,1);
	}
	ENDCG
}

}
	FallBack &quot;Diffuse&quot;
</code></pre>
<p>}<br>
</code><br>
<img src="https://Wei715547.github.io/post-images/1597905313414.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1597905320903.PNG" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shader-漫反射(半兰伯特),高光(BP)混合实现]]></title>
        <id>https://Wei715547.github.io/post/shader-man-fan-she-ban-lan-bo-te-gao-guang-bphun-he-shi-xian/</id>
        <link href="https://Wei715547.github.io/post/shader-man-fan-she-ban-lan-bo-te-gao-guang-bphun-he-shi-xian/">
        </link>
        <updated>2020-08-19T08:39:01.000Z</updated>
        <content type="html"><![CDATA[<code>
Shader "Custom/ShaderDiffues-Specular"
{
	Properties//属性
	{
		_Diffuse("_DiffuseColor",Color) = (1,1,1,1)//漫反射颜色
		_Specular("_Specular", Color) = (1, 1, 1, 1)//高光颜色
		_Gloss("_Gloss", Range(10, 200)) = 20//高光参数
	}
		SubShader
	{
		Pass
		{
			Tags {"Lighting" = "ForwardBase"} //定义LightMode,获取UNITY内部光照变量
			CGPROGRAM
			//在CG声明属性
			fixed4 _Diffuse;
			fixed4 _Specular;
			int _Gloss;
<pre><code>		#include &quot;Lighting.cginc&quot;//引入UNITY内置文件，获取光照变量 _LightColor0.rgb;光源颜色
		#pragma vertex vert//声明顶点函数
		#pragma fragment frag//声明片原函数
		

		struct a2v//应用向顶点函数传递参数
		{
			float4 vertex:POSITION;//模型空间顶点坐标
			float3 normal:NORMAL;//模型空间法线方向
		};
		struct v2f//顶点函数向片原函数传递参数
		{
			float4 svPos:SV_POSITION;//顶点函数返回值：剪裁空间中的顶点坐标-系统直接使用
			float3 worldNormal : TEXCOORD0;//顶点函数向片原函数传递世界坐标下的法线方向
			float4 worldView:TEXCOORD1;//顶点函数向片原函数传递世界坐标下的顶点坐标
		};

		v2f vert(a2v v)//顶点函数将顶点从模型空间转到世界空间，返回值在世界坐标系下的顶点坐标
		{
			v2f f;//声明传参结构体,并对其中的值赋值
			f.svPos = UnityObjectToClipPos(v.vertex);
			f.worldNormal = UnityObjectToWorldNormal(v.normal);
			f.worldView = (UnityObjectToWorldNormal(v.vertex), 0);
			return f;//返回结构体
		}

		fixed4 frag(v2f f) :SV_Target//片原函数，返回值为输出到像素颜色值的缓存
		{
			//计算漫反射
			fixed3 normalDir = normalize(f.worldNormal);//法线方向
			fixed3 lightDir = normalize(UnityWorldSpaceLightDir(f.worldView));//光源方向
			fixed3 diffuse = _LightColor0.rgb * _Diffuse * max((dot(normalDir,lightDir)*0.5+0.5), 0);//fixed3 harfLambert =dot(f.wordNormalDir, lightDir)*0.5+0.5;//半兰伯特光照模型:直射光颜色 * (cos夹角(光与法线)*0.5+0.5):使背光面不完全为黑色

			//计算高光反射
			//fixed3 reflectDir = normalize(reflect(-lightDir, normalDir));
			fixed3 viewDir = normalize(WorldSpaceViewDir(f.worldView));//实视线方向
			fixed3 harfDir = normalize(viewDir + lightDir);//视角与平行光的平分方向
			fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(dot(normalDir, harfDir),0), _Gloss);//BP模型://Blinn-Phong光照模型Specular = 直射光*pow(max(cos夹角,0)*高光参数) ，夹角：法线与x方向夹角,x:平行光与视野方向的平分项。
			
			fixed3 tempColor = diffuse + specular + UNITY_LIGHTMODEL_AMBIENT.rgb;//漫反射+高光+环境光，相加混合
			return fixed4(tempColor,1);
		}
		ENDCG
	}

}
FallBack &quot;Diffuse&quot;
</code></pre>
<p>}<br>
</code></p>
]]></content>
    </entry>
</feed>