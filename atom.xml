<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Wei715547.github.io</id>
    <title>WeiBlog</title>
    <updated>2020-11-14T12:35:25.189Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Wei715547.github.io"/>
    <link rel="self" href="https://Wei715547.github.io/atom.xml"/>
    <subtitle>年月增长，我宜强盛。
用于Unity+开发的技术积累</subtitle>
    <logo>https://Wei715547.github.io/images/avatar.png</logo>
    <icon>https://Wei715547.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, WeiBlog</rights>
    <entry>
        <title type="html"><![CDATA[Graphic Raycaster：检测所有Canvas上的UI]]></title>
        <id>https://Wei715547.github.io/post/graphic-raycasterjian-ce-suo-you-canvas-shang-de-ui/</id>
        <link href="https://Wei715547.github.io/post/graphic-raycasterjian-ce-suo-you-canvas-shang-de-ui/">
        </link>
        <updated>2020-11-14T12:31:11.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://Wei715547.github.io/post-images/1605357183735.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1605357192515.PNG" alt="" loading="lazy"></p>
<p>The Graphic Raycaster is used to raycast against a Canvas. The Raycaster looks at all Graphics on the canvas and determines if any of them have been hit.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[点击事件 UI/Scene]]></title>
        <id>https://Wei715547.github.io/post/dian-ji-shi-jian-uiscene/</id>
        <link href="https://Wei715547.github.io/post/dian-ji-shi-jian-uiscene/">
        </link>
        <updated>2020-11-11T12:50:02.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEditor;<br>
using UnityEngine;<br>
using UnityEngine.EventSystems;</p>
<p>public class AniRayTest : MonoBehaviour<br>
{<br>
List<RaycastResult> list = new List<RaycastResult>();</p>
<pre><code>// Update is called once per frame
void Update()
{
    /// 鼠标左键没有点击，就不执行判断逻辑
    if (!Input.GetMouseButtonDown(0))
    {
        return;
    }

    ///相应的GameObject对象
    GameObject go = null;

    ///判断是否点再ui上
    if (EventSystem.current.IsPointerOverGameObject())
    {
        go = ClickUI();
    }
    else
    {
        go = ClickScene();
    }

    if (go == null)
    {
        Debug.Log(&quot;Click Nothing&quot;);
    }
    else
    {
        // 高亮点中GameObject
        EditorGUIUtility.PingObject(go);
        Selection.activeObject = go;
        Debug.Log(go, go);
    }

}

/// &lt;summary&gt;
/// 点中ui
/// &lt;/summary&gt;
private GameObject ClickUI()
{
    //场景中的EventSystem

    PointerEventData eventData = new PointerEventData(EventSystem.current);

    //鼠标位置
    eventData.position = Input.mousePosition;

    //调用所有GraphicsRacaster里面的Raycast，然后内部会进行排序，
    //直接拿出来，取第一个就可以用了
    EventSystem.current.RaycastAll(eventData, list);

    //这个函数抄的unity源码的，就是取第一个值
    var raycast = FindFirstRaycast(list);

    //获取父类中事件注册接口
    //如Button，Toggle之类的，毕竟我们想知道哪个Button被点击了，而不是哪张Image被点击了
    //当然可以细分为IPointerClickHandler, IBeginDragHandler之类细节一点的，各位可以自己取尝试
    var go = ExecuteEvents.GetEventHandler&lt;IEventSystemHandler&gt;(raycast.gameObject);

    //既然没拿到button之类的，说明只有Image挡住了，取点中结果即可
    if (go == null)
    {
        go = raycast.gameObject;
    }
    return go;


}

/// &lt;summary&gt;
/// Return the first valid RaycastResult.
/// &lt;/summary&gt;
private RaycastResult FindFirstRaycast(List&lt;RaycastResult&gt; candidates)
{
    for (var i = 0; i &lt; candidates.Count; ++i)
    {
        if (candidates[i].gameObject == null)
            continue;

        return candidates[i];
    }
    return new RaycastResult();
}

/// &lt;summary&gt;
/// 点中场景中对象
/// 然后无聊嘛，顺便把点场景的也顺手做了，不过这部分网上介绍挺多的，就不展开说了。
/// &lt;/summary&gt;
private GameObject ClickScene()
{
    Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
    RaycastHit hit;
    if (Physics.Raycast(ray, out hit))
    {
        GameObject go = hit.collider.gameObject;
        return go;
    }

    return null;
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++Class]]></title>
        <id>https://Wei715547.github.io/post/cclass/</id>
        <link href="https://Wei715547.github.io/post/cclass/">
        </link>
        <updated>2020-11-03T12:37:47.000Z</updated>
        <content type="html"><![CDATA[<p>声明：<br>
class 类名<br>
{<br>
public:<br>
外部调用方法<br>
属性get,set;<br>
private:<br>
属性<br>
}<br>
//在类外部定义“类中声明的方法”（必须加以“::”作为域限定符，用于声明函数属于哪个类）<br>
函数返回值  类名::函数名（参数）<br>
{<br>
方法体；//在类内实现定义的函数系统能够默认为内联函数。<br>
}<br>
内联函数(避免方法在栈空间中频繁存取释放)：只有在类外定义的成员函数规模较且调用频率较高时，才将成员函数指定为内联函数，(返回值2加inline ,类中的声明同样加上inline)。<br>
成员访问：<br>
1.对象名.成员名；<br>
2.指针-&gt;成员名<br>
3.引用名.成员名<br>
类：get,set方法：读写类的私有成员（保护作用）。<br>
类：成员函数：</p>
<p>类的成员函数声明与实现，分离；<br>
在头文件&quot;.h&quot;文件中进行类的声明；<br>
在源代码/程序文件&quot;.cpp&quot;文件中进行类成员函数的实现；<br>
在主函数&quot;main.cpp&quot;文件中使用类 的成员函数；</p>
<p>Re.h文件<br>
cood&lt;&gt;<br>
using namespace std;<br>
calss Re<br>
{<br>
public:<br>
int Area();<br>
int Perimeter;<br>
int getLength();<br>
void setLength(int Len);<br>
int getWidth();<br>
void setWidth（int Wid）;<br>
private:<br>
int length,width,<br>
}</p>
<p>Re.cpp文件：<br>
#include &quot;Re.h&quot;//引入要实现类的头文件<br>
int Re::Area()<br>
{<br>
return length*width;<br>
}<br>
int Re::getLength ()<br>
{<br>
return length;<br>
}<br>
void Re::setLength(int Len)<br>
{<br>
length = Len;<br>
}</p>
<p>main.cpp主函数<br>
#include &quot;Re.h&quot;//引入使用类头文件,预编译时使用Re.h中的内容替换引用<br>
using namespace std;<br>
int main (int arge,char *argv[])<br>
{</p>
<p>}<br>
构造函数：类名（）；{}<br>
1）无返回值，非void<br>
2）可以有多个构造函数，根据参数类型重载<br>
3）类对象创建时自动调用（new调用，delete调用析构函数）<br>
1、在类类内定义<br>
class Re<br>
{<br>
public:<br>
Re()//构造<br>
{<br>
length = 1;<br>
width = 1;<br>
}<br>
}<br>
2、在类外定义<br>
Re::Re()<br>
{<br>
length = 1;<br>
width = 1;<br>
}<br>
带参数构造函数：类名（类型 形参）；<br>
class Re<br>
{<br>
public:<br>
Re(int Len,int Wid)//构造<br>
{<br>
length = Len;<br>
width = Wid;<br>
}<br>
}<br>
参数初始化表对数据成员初始化：<br>
class Re<br>
{<br>
public:<br>
Re(int Len,int Wid):length(Len),width(Wid) {}//&quot;{}&quot;不能省略<br>
private:<br>
int length,windle;<br>
}<br>
默认参数值构造函数：用户不指定是，编译器使用默认值<br>
Re(int Len = 1,int Wid = 2)//构造<br>
{<br>
length = Len;<br>
width = Wid;<br>
}<br>
析构函数：~与类名相同 （）前面加上“~”<br>
1）与构造函数对应用于释放对象所占用内存(并不是删除对象)，由delete调用<br>
2）析构函数同样没有返回值，但也没有参数由于没有参数也不能重载，一个类存在多个构造函数但只存在一个析构函数。<br>
3）析构函数也可用于最后一次使用类对象后执行的操作（写在方法体中）<br>
4）后创建的对象先被释放<br>
class Re<br>
{<br>
public:<br>
Re(){}<br>
~Re(){}<br>
}</p>
<pre><code>new malloc区别
</code></pre>
<p>1、	new分配内存按照数据类型进行分配，malloc分配内存按照指定的大小分配；<br>
malloc 是函数，开辟内存需要传入字节数，如 malloc(100)；表示在堆上开辟了 100 个字 节的内存，返回 void*，表示分配的堆内存的起始地址，因此 malloc 的返回值需要强转成指 定类型的地址；new 是运算符，开辟内存需要指定类型，返回指定类型的地址，因此不需要 进行强转。<br>
2、	malloc 和 new 都是在堆上开辟内存的，malloc 只负责开辟内存，没有初始化功能，需要 用户自己初始化；new 不但开辟内存，还可以进行初始化，<br>
3、	malloc 开辟内存失败返回 NULL，new 开辟内存失败抛出 bad_alloc 类型的异常，需要捕 获异常才能判断内存开辟成功或失败，new 运算符其实是 operator new 函数的调用，它底 层调用的也是 malloc 来开辟内存的，new 它比 malloc 多的就是初始化功能，对于类类型来 说，所谓初始化，就是调用相应的构造函数。<br>
4、	new分配的内存要用delete销毁，malloc要用free来销毁；delete销毁的时候会调用对象的析构函数，而free则不会。</p>
<p>CONST<br>
共有数据<br>
常量数据成员：const在不同位置标示不同含义：<br>
const int aa//使用const的普通数据成员常量<br>
const int * bb//在int前使用const的指针数据成员<br>
int <em>const cc//在int后使用const的指针数据成员<br>
const int <em>const dd//在int类型前后使用const的指针数据成员<br>
const int &amp;cc //使用const的引用类型成员<br>
1）aa为整型常量，初始化后不能被改变，（在类中，必须在构造函数的初始化列表中进行初始化（不能在类定义时初始化：const int aa = 5//错误））<br>
2）在指针数据类型前时：指针指向的值不能改变<br>
3）在指针数据类型后时：指针变量值不能改变<br>
4）在指针数据类型前后时：指针指向值与指针值都不改变<br>
常量创建后不能将整型常量的地址赋值给一个int</em>指针，应赋值给cosnt int</em>指针。<br>
const int mm = 30；<br>
int *pp = &amp;mm;//应改为：const int *pp = &amp;mm<br>
C++允许创建指针常量，所指向的普通变量不是常量：<br>
int mm = 30;<br>
const int *pp = &amp;mm;//可以将非常量赋值给指针常量，但不能通过pp改变mm值。<br>
常成员函数：<br>
声明：<br>
void showDate() const;//const在参数列表后。<br>
定义：<br>
void Class::showDate() cosnt//在调用时不需加const<br>
{<br>
方法体;<br>
}<br>
常类对象：<br>
声明<br>
Re const r1 = {len = 2; wid = 3;}//定义常队形时必须进行初始化，而且其数据成员不能被更新（数据成员变为const）。<br>
注意：如果一个对象被声明为常对象，则通过该常对象只能调用它的常成员函数（不能调用非const型成员函数）(系统自动隐式调用的)构造/析构除外).<br>
静态成员：<br>
声明：<br>
static flot AccounntSum;<br>
初始化：<br>
float AccountRecord::AccountSum = 0;//C++中静态成员必须在类外进行，不能在构造函数中(C#中可定义静态构造函数用于初始化静态成员)</p>
<pre><code>1）静态字段 仅仅存储一份 所有对象共享 常驻内存中
2）静态方法只能访问静态成员（非静态成员依赖于对象生成） ，非静态方法静态非静态都可以访问，
3）*不能实例化，只能包含静态成员， 静态类不能被继承（工具类）
 /* 静态适用
    * 利：单独空间存储，所有对象共享，可直接被类名调用
    * 弊：静态方法中只能访问静态成员，共享数据被多个对象访问时会出现并发。
    * 适用场合：
    * 1.所有对象需要共享的数据。
    * 2.在没有对象是就要访问成员。
    * 3.工具类适合做静态类（常用，不需要过多数据）
</code></pre>
<p>继承，派生：<br>
继承的语法：<code>class 子类 : 继承方式 父类</code><br>
多继承语法：：class 派生类 ：继承方式1 基类1，继承方式2 基类2....<br>
{<br>
派生类新成员；<br>
}</p>
<p><strong>继承方式一共有三种：</strong></p>
<ul>
<li>公共继承</li>
<li>保护继承</li>
<li>私有继承<br>
<img src="https://Wei715547.github.io/post-images/1604666547871.png" alt="" loading="lazy"></li>
</ul>
<p>**问题：**从父类继承过来的成员，哪些属于子类对象中？<br>
父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到（子类的sizeof包括子类成员以及所有父类成员//包括私有成员）<br>
父类的方法也是单独储存的，子类调用时由this指针指向调用的对象实现调用。</p>
<p>**问题：父类和子类的构造和析构顺序是谁先谁后？<br>
继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C指针]]></title>
        <id>https://Wei715547.github.io/post/c-zhi-zhen/</id>
        <link href="https://Wei715547.github.io/post/c-zhi-zhen/">
        </link>
        <updated>2020-10-29T07:25:10.000Z</updated>
        <content type="html"><![CDATA[<p>定义：type * p_address; (type:数据类型)<br>
p_address = &amp; valu; (&amp;取引用)<br>
*p_address； 表示地址中的值（解引用）</p>
<p>值帧/数组  int array[3] = [7,1,5];<br>
int* p_array = array;<br>
(int类型(4字节)数组array所指向的是array[0]的地址，即&amp;array[0],<br>
一旦将array赋值给p_array，此时array和p_array都指向数组的第一个元素的地址，可以通过指针像数组一样操作数组，p_array[0] , array[0]含义相同)<br>
指针运算：p_array++ 和p_array+1都指向数组的下一个元素（int类型占4个字节+1地址偏移4位(C++不会进行数组越界检测)）<br>
如上所有数组索引表达式可以写成指针镓屁啊你量形式：<br>
array[1] 与 <em>(p_array+1)相同<br>
数组声明：type array [n];<br>
array含义1：代表这个数组其类型时type[n];<br>
array含义2：代表一个“常量”指针，指针类型时type</em> ,指向的类型是type，指向的存区域是数组第一个元素(0号单元)，该指针占有单独的内存区域，指针值不可修改，即类似array++的表达式错误。<br>
引用：(本质常量指针)<br>
数据类型 &amp;别名 = 原名<br>
type &amp;b = a;<br>
指针与引用：声明：double x = 7.5;<br>
double* p = &amp;x;<br>
//引用声明 （引用声明时必须指定引用对象，且绑定关系不可改变）<br>
double&amp; y = x;<br>
上述“&amp;”“<em>”为定义引用与指针，非取址与解引用。通过</em>p与y都可对x值进行更改；<br>
指针与函数：指针作为函数参数<br>
void swap (int * a ,int * b)//<br>
{<br>
int temp = *a;<br>
*a = *b;<br>
*b = temp;<br>
}<br>
int a = 10;<br>
int b - 20;<br>
swap(&amp;a,&amp;b); //C#,ref<br>
指针指向函数：<br>
void (*funcp)()//声明一个无参数无返回值的函数指针<br>
funcp = &amp;TheFunction;//<br>
funcp = TheFunction；//函数指针赋值<br>
funcp();//与函数调用书写方式无异，下式表示更明确<br>
(*funcp)()；//间接调用</p>
<p>C++内存分区模型：<br>
程序运行前存在<br>
//代码区：存放函数体的二进制代码，有系统进行管理。<br>
存放及其指令<br>
特点：共享，只读。<br>
全局区：存放全局变量和静态变量以及常量。<br>
常量包括：字符串常量，const修饰变量：修饰 的全局变量，(const修饰的局部变量不再全局区)。<br>
//运行后<br>
栈区：（指针本质局部变量放在栈上，保存堆区数据的地址）由编译器自动分配释放，存放函数参数值，形参，局部变量等。（不要返回局部变量的地址，栈区开辟的数据由编译器自动释放）：函数中的局部变量存放在栈区，栈区的数据在“函数”执行完成后会自动释放，在此、次访问时地址中的数据已发生改变。（只保留一次）<br>
堆区：由程序员分配释放，若不释放，程序结束时由系统进行回收。由new type;与delete申请/释放。<br>
动态内存分配：（在“堆”区开辟空间，由程序员管理，开辟/释放）new typr,（new返回type类型的指针）<br>
int* p_int;<br>
p_int = new int ;//或p_int = new(int)<br>
delete p_int</p>
<p>int* p_arrayint ;<br>
p_arrayint - new int[10]//声明数组内存空间，不能分配时返回NULL<br>
delete[] p_arrayint;<br>
分配到的内存系统不会自动回收，需要调用delete[] p_arrayint;来释放内存。<br>
不释放则导致内存泄漏。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[洗牌算法，洪水填充算法，重置内置运算符]]></title>
        <id>https://Wei715547.github.io/post/xi-pai-suan-fa/</id>
        <link href="https://Wei715547.github.io/post/xi-pai-suan-fa/">
        </link>
        <updated>2020-10-12T02:57:36.000Z</updated>
        <content type="html"><![CDATA[<p>public class Utilities<br>
{<br>
/// <summary><br>
/// 洗牌算法，<br>
/// </summary><br>
/// <param name="dateArray">随机重排的数组</param><br>
/// <returns></returns><br>
public static Coord[] ShuffleCoords(Coord[] dateArray)<br>
{<br>
for (int i = 0; i &lt; dateArray.Length; i++)<br>
{<br>
//将每次随机到的元素放到首位，第二次随机从“队首+1~最后元素”开始随机，这样每次随机到的即不为同一元素<br>
int random = Random.Range(i, dateArray.Length);<br>
//SWAP<br>
Coord temp = dateArray[random];<br>
dateArray[random] = dateArray[i];<br>
dateArray[i] = temp;<br>
}<br>
return dateArray;<br>
}<br>
}<br>
//应用程序<br>
<img src="https://Wei715547.github.io/post-images/1602493526529.PNG" alt="" loading="lazy"><br>
shuffleCoords = new Queue<Coord>(Utilities.ShuffleCoords(allTilesCoord.ToArray()));<br>
public Coord GetRandomCoord()<br>
{<br>
Coord randomCoord = shuffleCoords.Dequeue();<br>
shuffleCoords.Enqueue(randomCoord);<br>
return randomCoord;<br>
}<br>
——————————————————————————————————————————————————<br>
/// <summary><br>
/// 洪水填充算法<br>
/// </summary><br>
/// <param name="_mapObstacles">地图上的位置是否存在障碍物</param><br>
/// <param name="_currentObsCount">应该时候能承担障碍物数量</param><br>
/// <returns>是否可以在此处生成障碍物</returns><br>
public bool MapIsFullyAccessible(bool[,] _mapObstacles, int _currentObsCount)<br>
{<br>
bool[,] mapFlag = new bool[_mapObstacles.GetLength(0), _mapObstacles.GetLength(1)];<br>
Queue<Coord> queue = new Queue<Coord>();//存储所有筛选后的坐标<br>
queue.Enqueue(mapCenter);<br>
mapFlag[mapCenter.x, mapCenter.y] = true;//中心点标记为已检测<br>
int accessibleCount = 1;//可以行走的格子数量<br>
while(queue.Count&gt;0)<br>
{<br>
Coord currentTile = queue.Dequeue();<br>
for (int x = -1; x &lt;=1; x++)<br>
{<br>
for (int y = -1; y &lt;=1; y++)<br>
{<br>
int neighborX = currentTile.x + x;<br>
int neighborY = currentTile.y + y;</p>
<pre><code>                if (x==0||y==0)//检测上下左右四个相邻的位置是否可行
                {
                    if(neighborX &gt;=0&amp;&amp;neighborX&lt;_mapObstacles.GetLength(0)
                        &amp;&amp; neighborY&gt;=0&amp;&amp;neighborY&lt;_mapObstacles.GetLength(1))//范围限定在地图范围内
                    {
                        //该位置未检测，且不存在障碍物时
                        if(!mapFlag[neighborX,neighborY]&amp;&amp;!_mapObstacles[neighborX,neighborY])
                        {
                            mapFlag[neighborX, neighborY] = true;
                            accessibleCount++;
                            queue.Enqueue(new Coord(neighborX, neighborY));
                        }
                    }
                }
            }
        }
    }
    int walkableCount = (int)(mapSize.x * mapSize.y - _currentObsCount);//地图上应该可行走位置的数量
    return accessibleCount == walkableCount;//联通路径总的可行走数量与目标值相同时则可依据_mapObstacles中位置生成障碍物
}
------------------------重置内置运算符“operator”--------------------------
public struct Coord
</code></pre>
<p>{<br>
public int x;<br>
public int y;</p>
<pre><code>public Coord(int _x, int _y)
{
    this.x = _x;
    this.y = _y;
}
//operator：重置内置运算符，C#要求成对重载比较运算符
public static bool operator !=(Coord _c1,Coord _c2)
{
    return !(_c1 == _c2);
}
public static bool operator ==(Coord _c1,Coord _c2)
{
    return (_c1.x == _c2.x &amp;&amp; _c1.y == _c2.y);
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DgR]]></title>
        <id>https://Wei715547.github.io/post/dgr/</id>
        <link href="https://Wei715547.github.io/post/dgr/">
        </link>
        <updated>2020-10-03T10:54:03.000Z</updated>
        <content type="html"><![CDATA[<p>1.单一职责原则：类的职责要单一，不能将太多的职责放到一个类中。<br>
2.开闭原则：软件实体对扩展时开放的，但对修改是关闭的，即在不修改一个软件实体的基础上去扩展器功能。<br>
3.里转转换原则：在软件系统中一个可以接受基类对象的地方必然可以接受其子类对象（父类中装入子类）<br>
4.依赖倒转原则：要针对抽象对象编程，而不是对具体类编程。<br>
5.接口隔离原则：使用多个专门的接口 来取代一个统一的接口。<br>
6.合成复用原则：在系统中应多使用组合聚合关系，尽量少使用或不使用继承关系。<br>
7.迪米特法则：一个软件实体对其他实体的引用越少越好，或者说如果两个类不必彼此自黑通信，那么，两个类就不应当直接发生作用，而是通过引入中间体发生间接交互。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AStar-Base]]></title>
        <id>https://Wei715547.github.io/post/astar-base/</id>
        <link href="https://Wei715547.github.io/post/astar-base/">
        </link>
        <updated>2020-09-30T02:50:05.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://Wei715547.github.io/post-images/1601434274880.jpg" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1601434281055.jpg" alt="" loading="lazy"></p>
<p>//节点类<br>
//节点类型枚举<br>
public enum NodeTyp<br>
{<br>
//可用格子<br>
Able,<br>
//不可用格子<br>
Unable<br>
}<br>
public class AStartNode<br>
{<br>
//格子坐标<br>
public int x;<br>
public int y;</p>
<pre><code>//寻路消耗
public float f;

//起点距离
public float g;
//终点距离
public float h;

//父对象
public AStartNode father;
//格子类型
public NodeTyp type;

public AStartNode(int x,int y, NodeTyp type)
{
    this.x = x;
    this.y = y;
    this.type = type;
}
</code></pre>
<p>}</p>
<p>//单例基类<br>
public class BaseManager<T><br>
where T:new()//限定T有一个无参数的构造函数<br>
{<br>
private static T instence;</p>
<pre><code>public static T Instence
{
    get
    {
        if (instence == null)
            instence = new T();
        return instence;
    }
}
</code></pre>
<p>}</p>
<p>//管理器类（单例）<br>
public class AStartManager :BaseManager<AStarManager><br>
{<br>
/*private static AStartManager instence;<br>
public static AStartManager Instence<br>
{<br>
get<br>
{<br>
if (instence == null)<br>
instence = new AStartManager();<br>
return instence;<br>
}<br>
}<br>
*/<br>
//地图大小<br>
private int mapw;<br>
private int maph;<br>
//所有格子容器<br>
public AStartNode[,] nodes;<br>
//开启类表<br>
private List<AStartNode> openList = new List<AStartNode>();<br>
//关闭类表<br>
private List<AStartNode> closeList = new List<AStartNode>();<br>
/// <summary><br>
/// 初始化地图信息<br>
/// </summary><br>
/// <param name="mapw"></param><br>
/// <param name="maph"></param><br>
public void InitMapInfo(int mapw, int maph)<br>
{<br>
this.mapw = mapw;<br>
this.maph = maph;<br>
nodes = new AStartNode[mapw, maph];<br>
for (int i = 0; i &lt; mapw; i++)<br>
{<br>
for (int j = 0; j &lt; maph; j++)<br>
{<br>
//格子20%概率为阻挡<br>
AStartNode node = new AStartNode(i, j, Random.Range(0, 101) &lt; 20 ? NodeTyp.Unable : NodeTyp.Able);<br>
nodes[i, j] = node;<br>
}<br>
}<br>
}</p>
<pre><code>/// &lt;summary&gt;
/// 寻路方法
/// &lt;/summary&gt;
/// &lt;param name=&quot;startPos&quot;&gt;&lt;/param&gt;
/// &lt;param name=&quot;endPos&quot;&gt;&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public List&lt;AStartNode&gt; FindPath(Vector2 startPos, Vector2 endPos)
{

    /*/判断传入顶点是否合法*/
    //1.1传入顶点噪mapz范围内
    if (startPos.x &lt; 0 || startPos.x &gt;= mapw || startPos.y &lt; 0 || startPos.y &gt;= maph
       || endPos.x &lt; 0 || endPos.x &gt;= mapw || endPos.y &lt; 0 || endPos.y &gt;= maph)
    {
        Debug.Log(&quot;OutRange&quot;);
        return null;
    }
    AStartNode start = nodes[(int)startPos.x, (int)startPos.y];
    AStartNode end = nodes[(int)endPos.x, (int)endPos.y];
    //2.传入顶点不为阻挡
    //不合法则返回null
    if (start.type == NodeTyp.Unable ||
       end.type == NodeTyp.Unable)
    {
        Debug.Log(&quot;非法位置&quot;);
        return null;
    }

    //清空上一次相关数据，避免影响此次计算

    //清空开始/关闭类表
    openList.Clear();
    closeList.Clear();

    //把开始点放入关闭类表中
    start.father = null;
    start.g = 0;
    start.h = 0;
    start.f = 0;
    closeList.Add(start);
    while (true)
    {
        //从起点开始寻找周围的点
        //左上
        FindNearlyNodeToOpenList(start.x - 1, start.y - 1, 1.4f, start, end);
        //上
        FindNearlyNodeToOpenList(start.x, start.y - 1, 1f, start, end);
        //右上
        FindNearlyNodeToOpenList(start.x + 1, start.y - 1, 1.4f, start, end);
        //左
        FindNearlyNodeToOpenList(start.x - 1, start.y, 1f, start, end);
        //右
        FindNearlyNodeToOpenList(start.x + 1, start.y, 1f, start, end);
        //左下
        FindNearlyNodeToOpenList(start.x - 1, start.y + 1, 1.4f, start, end);
        //下
        FindNearlyNodeToOpenList(start.x, start.y + 1, 1f, start, end);
        //右下
        FindNearlyNodeToOpenList(start.x + 1, start.y + 1, 1.4f, start, end);
        //判断周围的点是否合法，是否在开启或关闭类表，不是则放入开始了表

        //死路判定：开启类表为空时中非那不可达
        if (openList.Count == 0)
        {
            Debug.Log(&quot;死路&quot;);
            return null;
        }
        //选出开启类表中寻路消耗最小的点
        openList.Sort(SortOpenList);//排序后openList[0]为f值最小的点
                                    //放入关闭类表中然后从开始了表中移除
        closeList.Add(openList[0]);
        //找到的点作为下一次寻找开始的起点
        start = openList[0];
        openList.RemoveAt(0);
        //如果这个点是终点则返回出去
        //不是终点则继续寻找
        if (start == end)
        {
            List&lt;AStartNode&gt; path = new List&lt;AStartNode&gt;();
            path.Add(end);
            while (end.father != null)
            {
                path.Add(end.father);
                end = end.father;
            }
            path.Reverse();
            return path;
        }

    }
}
/// &lt;summary&gt;
/// 排序函数
/// &lt;/summary&gt;
/// &lt;param name=&quot;a&quot;&gt;&lt;/param&gt;
/// &lt;param name=&quot;b&quot;&gt;&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
private int SortOpenList(AStartNode a, AStartNode b)
{
    if (a.f &gt; b.f)
        return 1;
    else if (a.f == b.f)
        return 1;
    else
        return -1;
}
/// &lt;summary&gt;
/// 把临近点放入开启类表中的函数
/// &lt;/summary&gt;
/// &lt;param name=&quot;x&quot;&gt;&lt;/param&gt;
/// &lt;param name=&quot;y&quot;&gt;&lt;/param&gt;
private void FindNearlyNodeToOpenList(int x, int y, float g, AStartNode fatherNode, AStartNode endNode)
{
    //边界判定
    if (x &lt; 0 || x &gt;= mapw ||
        y &lt; 0 || y &gt;= maph)
        return;
    //在map范围内在取点
    AStartNode node = nodes[x, y];
    if (node == null || node.type == NodeTyp.Unable
        || openList.Contains(node) || closeList.Contains(node))
        return;

    //计算f值：f=g+h
    //记录父对象
    node.father = fatherNode;
    //计算g（距离起点距离）值：父对象里欠点距离+距离父对象距离
    node.g = fatherNode.g + g;
    //计算h值（距离终点距离）：曼哈顿街区算法二维坐标差值
    node.h = Mathf.Abs(endNode.x - node.x) + Mathf.Abs(endNode.y - node.y);
    node.f = node.g + node.h;
    //通过验证则存入开始了表中
    openList.Add(node);
}
</code></pre>
<p>}</p>
<p><img src="https://Wei715547.github.io/post-images/1601435509787.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1601435519694.PNG" alt="" loading="lazy"><br>
//测试脚本<br>
public class TextA : MonoBehaviour<br>
{<br>
public int beginX = -2;<br>
public int beginY = -2;</p>
<pre><code>public int offSetX = 2;
public int OffSetY = 2;

public int mapW = 5;
public int mapY = 5;

public Material bnary;
public Material start;
public Material path;
public Material normal;

//存储格子容器（x_y,GameObject）
private Dictionary&lt;string, GameObject&gt; cubes = new Dictionary&lt;string, GameObject&gt;();

private Vector2 beginPos = Vector2.right * -1;
private Vector2 endPos;

//存储路径节点
List&lt;AStartNode&gt; pathList = new List&lt;AStartNode&gt;();

// Start is called before the first frame update
void Start()
{
    AStartManager.Instence.InitMapInfo(mapW, mapY);
    for (int i = 0; i &lt; mapW; i++)
    {
        for (int j = 0; j &lt; mapY; j++)
        {
            GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Cube);
            obj.transform.position = new Vector3(beginX + i * offSetX, beginY + j * OffSetY, 0);
            obj.name = i + &quot;_&quot; + j;
            cubes.Add(obj.name, obj);
            //判断格子是否阻挡
            AStartNode node = AStartManager.Instence.nodes[i, j];
            if(node.type == NodeTyp.Unable)
            {
                obj.GetComponent&lt;MeshRenderer&gt;().material= bnary ;
                Debug.Log(&quot;Br&quot;);
            }
        }
    }
}

// Update is called once per frame
void Update()
{
    if(Input.GetMouseButtonDown(0))
    {
        //射线检测返回值
        RaycastHit hit;
        //相机视角从鼠标位置发出的射线
        Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
        //射线检测，检测到物体返回true
        if (Physics.Raycast(ray, out hit, 1000))
        {
            //得到点击到的立方体
            //hit.collider.gameObject;
            //记录开始点与结束点
            if(beginPos == Vector2.right*-1)
            {
                //清理上一次路径
                if (pathList != null)
                {
                    for (int i = 0; i &lt; pathList.Count; i++)
                    {
                        cubes[pathList[i].x + &quot;_&quot; + pathList[i].y].GetComponent&lt;MeshRenderer&gt;().material = normal;
                    }
                }

                string[] str = hit.collider.gameObject.name.Split('_');
                beginPos = new Vector2(int.Parse(str[0]), int.Parse(str[1]));
                hit.collider.gameObject.GetComponent&lt;MeshRenderer&gt;().material = start;
            }
            else
            {
                string[] str = hit.collider.gameObject.name.Split('_');
                endPos = new Vector2(int.Parse(str[0]), int.Parse(str[1]));
                //hit.collider.gameObject.GetComponent&lt;MeshRenderer&gt;().material = end;

                pathList = AStartManager.Instence.FindPath(beginPos, endPos);
                if(pathList !=null)
                {
                    for (int i = 0; i &lt; pathList.Count; i++)
                    {
                        cubes[pathList[i].x + &quot;_&quot; + pathList[i].y].GetComponent&lt;MeshRenderer&gt;().material = path;
                    }
                }
                //清除开始点
                beginPos = Vector2.right * -1;
            }
        }
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[24.]]></title>
        <id>https://Wei715547.github.io/post/24/</id>
        <link href="https://Wei715547.github.io/post/24/">
        </link>
        <updated>2020-09-25T15:20:11.000Z</updated>
        <content type="html"><![CDATA[<p>class SL<br>
{<br>
public bool JudgePoint24(int[] nums)<br>
{<br>
List<double> list = new List<double>();<br>
foreach (int i in nums) list.Add((double)i); //为dfs做准备<br>
return dfs(list);<br>
}<br>
private bool dfs(List<double> list)<br>
{<br>
if (list.Count == 1)<br>
{//一个数时判断相等<br>
if (Math.Abs(list[0] - 24.0) &lt; 0.001) return true; //考虑除法造成的小数点<br>
return false;<br>
}<br>
for (int i = 0; i &lt; list.Count; ++i)<br>
{<br>
for (int j = i + 1; j &lt; list.Count; ++j)<br>
{<br>
foreach (double c in generatePossibleResults(list[i], list[j]))<br>
{<br>
List<double> nextRound = new List<double>();<br>
nextRound.Add(c); //遍历两个数的所有可能性<br>
for (int k = 0; k &lt; list.Count; ++k)<br>
{ //添加剩余项到next round<br>
if (k == i || k == j) continue;<br>
nextRound.Add(list[k]);<br>
}<br>
if (dfs(nextRound)) return true;<br>
}<br>
}<br>
}<br>
return false;<br>
}<br>
//生成两个数所有的组合<br>
private List<double> generatePossibleResults(double a, double b)<br>
{<br>
List<double> res = new List<double>();<br>
res.Add(a + b);<br>
res.Add(a - b);<br>
res.Add(b - a);<br>
res.Add(a * b);<br>
res.Add(a / b);<br>
res.Add(b / a);<br>
return res;<br>
}<br>
}</p>
<pre><code>C#改JAVA
</code></pre>
<p>class Solution<br>
{<br>
public boolean judgePoint24(int[] nums)<br>
{<br>
ArrayList<Double> list = new ArrayList&lt;&gt;();<br>
for (int n:nums)<br>
{<br>
list.add((double)n);<br>
}<br>
return Prm(list);<br>
}<br>
public boolean Prm(ArrayList<Double> list)<br>
{<br>
if (list.size() == 1)<br>
{<br>
return Math.abs(list.get(0) - 24) &lt; 1e-6;<br>
}<br>
for (int i = 0; i &lt; list.size(); i++)<br>
{<br>
for (int j = i + 1; j &lt; list.size(); j++)<br>
{<br>
for (double k:AllTowRes(list.get(i), list.get(j)))<br>
{<br>
ArrayList<Double> nextRound = new ArrayList&lt;&gt;();<br>
nextRound.add(k);<br>
for (int v = 0; v &lt; list.size(); v++)<br>
{<br>
if (v == i || v == j) continue;<br>
nextRound.add(list.get(v));<br>
}<br>
if (Prm(nextRound)) return true;<br>
}<br>
}<br>
}<br>
return false;<br>
}<br>
public ArrayList<Double> AllTowRes(double a, double b)<br>
{<br>
ArrayList<Double> res = new ArrayList&lt;&gt;();<br>
res.add(a + b);<br>
res.add(a - b);<br>
res.add(b - a);<br>
if (b != 0) res.add(a / b);<br>
if (a != 0) res.add(b / a);<br>
return res;<br>
}<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DGT]]></title>
        <id>https://Wei715547.github.io/post/dgt/</id>
        <link href="https://Wei715547.github.io/post/dgt/">
        </link>
        <updated>2020-09-22T09:56:23.000Z</updated>
        <content type="html"><![CDATA[<p>1.//变量插值方法<br>
DOTween.To(() =&gt; dtV, x =&gt; dtV = x, new Vector3(10, 10, 10), 2);//            DoTween.To(表达式1()目标变量，表达式2(目标变量=变量，变量值)，变化时间，)<br>
//当前位置到世界坐标下移动<br>
bgt.transform.DOMove(s, 0.5f, true ).OnComplete(() =&gt;<br>
{<br>
UM.bagPanel.SetActive(false);<br>
UM.UI_btns.SetActive(true);<br>
});<br>
2.//当前位置到局部坐标下移动<br>
bgt.transform.DOLocalMove(s, 0.5f, true ).OnComplete(() =&gt;<br>
{<br>
UM.bagPanel.SetActive(false);<br>
UM.UI_btns.SetActive(true);<br>
});<br>
3.//DGT倒放<br>
bgt.transform.DOMove(e, 0.25f, true );<br>
//Tweener对象保存DG返回的动画，设置动画不被销毁时可倒叙播放<br>
Tweener tweener = bgg.transform.DOMove(pe, 0.5f, true);//重复执行时会创建多个动画对象耗费性能，（不接收动画对象直接运行）<br>
tweener.SetAutoKill(false);<br>
tweener.Pause();//暂停<br>
//bgt.transform.DOPlayForward();//+<br>
bgt.transform.DOPlayBackwards();//-<br>
4.//From()<br>
bgt.transform.DOMoveX(5, 1f)//默认从初始位置移动到5，<br>
bgt.transform.DOMoveX(5, 1f).From();//添加From()从5移动到初始位置<br>
bgt.transform.DOMoveX(5, 1f).From(true);//填入参数时：从相“对位”置移动到初始位置<br>
5.//曲线/事件函数<br>
Tweener//DG返回对象<br>
tweener.SetEase(Ease.InBack);//设置曲线(枚举类型)<br>
public enum Ease<br>
{<br>
Unset = 0,<br>
Linear = 1,<br>
InSine = 2,<br>
OutSine = 3,<br>
InOutSine = 4,<br>
InQuad = 5,<br>
OutQuad = 6,<br>
InOutQuad = 7,<br>
InCubic = 8,<br>
OutCubic = 9,<br>
InOutCubic = 10,<br>
InQuart = 11,<br>
OutQuart = 12,<br>
InOutQuart = 13,<br>
InQuint = 14,<br>
OutQuint = 15,<br>
InOutQuint = 16,<br>
InExpo = 17,<br>
OutExpo = 18,<br>
InOutExpo = 19,<br>
InCirc = 20,<br>
OutCirc = 21,<br>
InOutCirc = 22,<br>
InElastic = 23,<br>
OutElastic = 24,<br>
InOutElastic = 25,<br>
InBack = 26,<br>
OutBack = 27,<br>
InOutBack = 28,<br>
InBounce = 29,<br>
OutBounce = 30,<br>
InOutBounce = 31,<br>
Flash = 32,<br>
InFlash = 33,<br>
OutFlash = 34,<br>
InOutFlash = 35,<br>
INTERNAL_Zero = 36,<br>
INTERNAL_Custom = 37<br>
}<br>
tweener.SetLoops(2);//设置循环次数<br>
tweener.OnComplete(() =&gt;//表达式形式在大括号中直接写入语句/或直接传入“方法”<br>
{<br>
UM.bagPanel.SetActive(false);<br>
UM.UI_btns.SetActive(true);<br>
});<br>
6.//生命周期//与其他脚本语言相似常用OnComplete()<br>
7.//文字动画<br>
text.DOText(&quot;文字动画&quot;,2f)/参数：文本动画时间<br>
8.//相机震动<br>
transform.DOShakePosition(1);//参数震动强度<br>
transform.DOShakePosition(1,new Vector3(1,1,0));//参数震动强度，方向约束Vector3(3,3,0)约束的值也可以控制强度<br>
9.//颜色/阿尔法通道(UI)<br>
text.DOColor(Color.cyan, 1f);<br>
text.DOFade(1, 1f);</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Lua面向对象实现]]></title>
        <id>https://Wei715547.github.io/post/lua-mian-xiang-dui-xiang-shi-xian/</id>
        <link href="https://Wei715547.github.io/post/lua-mian-xiang-dui-xiang-shi-xian/">
        </link>
        <updated>2020-09-16T09:28:03.000Z</updated>
        <content type="html"><![CDATA[<p><cood>print(&quot;<strong><strong><strong><strong><strong><strong>封装</strong></strong></strong></strong></strong></strong>__&quot;)<br>
Object = {}<br>
Object.ID = 1<br>
function Object:Text()--&quot;:&quot;自动传入调用这个函数的对象，作为第一个参数传入方法<br>
print(self.ID)--“self”代表默认传入的第一个参数<br>
end</p>
<p>function Object:new( )--类用于创建对象的方法--构造函数<br>
--function Object:new(o)--充当构造函数，返回空表，将本身设为空表的原表来继承类的属性与函数<br>
--local obj= o or {}--o填写时在填入子类的属性/函数基础上创建对象，不填时为空继承父类默认所有属性/函数创建对象（）p1 = Object:new(weight = 100) 或 p1 = Object:new()<br>
local obj = {}<br>
--原表的__index指向自身<br>
self.__index =self--__index:当在自己的表中找不到目标属性时，就会在元表的__index中寻找<br>
setmetatable(obj ,self)<br>
--setmetatable (obj,{__index=self})--与上两句作用相同<br>
return obj<br>
end</p>
<p>local myObj = Object:new()<br>
print(myObj)<br>
print(myObj.ID)<br>
myObj:Text()--myObj调用则传入myObj</p>
<p>print(&quot;_<strong><strong><strong><strong><strong><strong><strong><strong>继承</strong></strong></strong></strong></strong></strong></strong></strong>&quot;)</p>
<p>--构造用于继承的方法<br>
function Object:subClass(className)--声明类的方法<br>
--_G表存储所有的全局变量<br>
_G[className] = {}<br>
local obj = _G[className]<br>
self.__index = self<br>
--为子类定义一个父类属性base<br>
obj.base = self<br>
setmetatable(obj,self)<br>
end</p>
<p>Object:subClass(&quot;Person&quot;)<br>
--print(Person)--此时是通过类名访问属性，类似静态变量<br>
--Person:Text()<br>
--通过对象访问属性<br>
local p1 = Person:new ()--Person继承自Object的new方法。self使Person为第一变量传入<br>
p1:Text()--原表中不存在，会继续查找原表的原表</p>
<p>print(&quot;____________多态————————————————————————————&quot;)</p>
<p>Object:subClass(&quot;GameObject&quot;)--声明游戏对象类<br>
GameObject.posX = 0<br>
GameObject.posY = 0<br>
function GameObject:Move()<br>
self .posX = self.posX+1<br>
self.posY = self.posY+1<br>
print(self.posX)<br>
print(self.posX)</p>
<p>end</p>
<p>GameObject:subClass(&quot;Player&quot;)--声明角色类</p>
<p>function Player:Move()--与父类方法“重名&quot;即相当于重写方法<br>
--此时base指GameObject类，使用“：”调用相当于把基类作为第一参数传入方法中，则此时创建pl2时会输出2，2<br>
--self.base:Move()<br>
--因此为了避免把基类表传入方法中，不使用“：”调用<br>
self.base.Move(self)--使用.进行调用自行填入第一个传入的参数<br>
print(&quot;子类重写&quot;)<br>
end</p>
<p>local pl1 = Player:new()--角色类对象<br>
pl1:Move()</p>
<p>local pl2 = Player:new()<br>
pl2:Move()<cood></p>
]]></content>
    </entry>
</feed>