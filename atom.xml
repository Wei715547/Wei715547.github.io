<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Wei715547.github.io</id>
    <title>Wei: Development technology accumulation</title>
    <updated>2020-06-18T15:51:22.276Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Wei715547.github.io"/>
    <link rel="self" href="https://Wei715547.github.io/atom.xml"/>
    <subtitle>年月增长，我宜强盛。
用于Unity+开发的技术积累</subtitle>
    <logo>https://Wei715547.github.io/images/avatar.png</logo>
    <icon>https://Wei715547.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Wei: Development technology accumulation</rights>
    <entry>
        <title type="html"><![CDATA[补丁开发过程]]></title>
        <id>https://Wei715547.github.io/post/bu-ding-kai-fa-guo-cheng/</id>
        <link href="https://Wei715547.github.io/post/bu-ding-kai-fa-guo-cheng/">
        </link>
        <updated>2020-06-18T09:33:15.000Z</updated>
        <content type="html"><![CDATA[<p>Process-&gt;在所有可能出现问题的类上打上[Hotfix]标签，在所有Lua调用C#的方法打上[LuaCallCSharp]，在所有C#调用Lua的方法打上[CSharpCallLua]-&gt;打包发布-&gt;修改时只需要更新Lua文件，修改资源是（声音，模型，贴图，UI）只需要更新AB包。用户只需要下载Lua文件和AB包</p>
<p>using UnityEngine;<br>
using XLua;</p>
<p>namespace XLuaTest<br>
{<br>
[Hotfix]//在需要修复的类前加上[Hotfix]特性<br>
public class HotfixTest : MonoBehaviour<br>
{<br>
LuaEnv luaenv = new LuaEnv();//Lua虚拟运行环境</p>
<pre><code>    private int tick = 0;

    // Use this for initialization
    void Start()
    {
    }

    // Update is called once per frame
    [LuaCallCSharp]
    void Update()
    {
        if (++tick % 50 == 0)
        {
            Debug.Log(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;Update in C#, tick = &quot; + tick);
        }
    }

    void OnGUI()
    {
        if (GUI.Button(new Rect(10, 10, 300, 80), &quot;Hotfix&quot;))
        {//要修改的类名，要修复的类中的方法，作为替换的Lua中的方法
            luaenv.DoString(@&quot;
            xlua.hotfix(CS.XLuaTest.HotfixTest, 'Update', function(self)
                local a = CS.UnityEngine.GameObject.Find('Main Camera')
                CS.UnityEngine.Debug.Log(a.name)
                --[[self.tick = self.tick + 1
                if (self.tick % 50) == 0 then
                    print('&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;Update in lua, tick = ' .. self.tick)
                end--]]
            end)
        &quot;);
        }
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[XLua虚拟环境/Lua脚本调用方式]]></title>
        <id>https://Wei715547.github.io/post/xlua-xu-ni-huan-jing-lua-jiao-ben-diao-yong-fang-shi/</id>
        <link href="https://Wei715547.github.io/post/xlua-xu-ni-huan-jing-lua-jiao-ben-diao-yong-fang-shi/">
        </link>
        <updated>2020-06-18T09:19:29.000Z</updated>
        <content type="html"><![CDATA[<p>此处在本地执行，实际应从服务器中下在Lua补丁程序<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using XLua;<br>
using System.IO;<br>
public class HotFixScript : MonoBehaviour<br>
{<br>
private LuaEnv LuaEnv;<br>
// Start is called before the first frame update<br>
void Start()<br>
{<br>
LuaEnv = new LuaEnv();<br>
LuaEnv.AddLoader(MyLoader);<br>
LuaEnv.DoString(&quot;require'fish'&quot;);//fish中的Lua程序包含所有要更新的方法逻辑代码（Lua补丁程序）<br>
}</p>
<pre><code>private byte[] MyLoader(ref string filePath)
{
    string absPath = @&quot;D:\715\XluaProjects\PlayerGamePackage\&quot; + filePath + &quot;.lua.txt&quot;;
    return System.Text.Encoding.UTF8.GetBytes(File.ReadAllText(absPath));
}
private void OnDisable()
{
    //在销毁前将委托置为空（避免报错）
    //(Hotfix底层实际已委托形式实现，将Lua的方法注册到委托中，委托不为空时执行Lua中更新的方法)
    LuaEnv.DoString(&quot;require'fishDispose'&quot;);
}
private void OnDestroy()
{
    LuaEnv.Dispose();
}
</code></pre>
<p>}<br>
/////////////////////////////////////////////////////////////<br>
//fish.lua.txt<br>
--1.修复CL间距<br>
local UnityEngine=CS.UnityEngine<br>
xlua.hotfix(CS.Treasour,'CreatePrize',function(self)<br>
for i=0,4,1 do<br>
local go = UnityEngine.GameObject.Instantiate(self.gold,self.transform.position+UnityEngine.Vector3(-10+i<em>40,0,0),self.transform.rotation)<br>
go.transform.SetParent(go.transform,self.cavas)<br>
local go = UnityEngine.GameObject.Instantiate(self.diamands,self.transform.position+UnityEngine.Vector3(0,40,0)+UnityEngine.Vector3(-10+i</em>40,0,0),self.transform.rotation)<br>
go.transform.SetParent(go.transform,self.cavas)<br>
end<br>
end)</p>
<pre><code>--2.修复Attack方法
</code></pre>
<p>xlua.private_accessible(CS.Gun)--要访问类中的私有变量时<br>
xlua.hotfix(CS.Gun,'Attack',function(self)<br>
if UnityEngine.Input.GetMouseButtonDown(0) then<br>
if self.gold&lt;1+(self.gunLevel-1)<em>2 or gold ==0 than<br>
return<br>
end<br>
self.bullectAudio.clip = self.bullectAudios[self.gunLevel-1]<br>
--self.bullectAudio.Play(self)成员变量调用内部方法方式1<br>
self.bullectAudio:Play()--方式2<br>
if self.Butterfly then<br>
UnityEngine.GameObject.Instantiate(self.Bullects[self.gunLevel-1],self.attackPos.position,self.attackPos.rotation</em>UnityEngine.Quaternion.Euler(0,0,20))<br>
UnityEngine.GameObject.Instantiate(self.Bullects[self.gunLevel-1],self.attackPos.position,self.attackPos.rotation*UnityEngine.Quaternion.Euler(0,0,-20))<br>
end</p>
<pre><code>	UnityEngine.GameObject.Instantiate(self.Bullects[self.gunLevel-1],self.attackPos.position,self.attackPos.rotation)

	if not self.canShootForFree then
		self:GoldChange(-1,-(self.gunLevel-1)*2)
	end
	self.attackCD = 0
	self.attack = false
end
</code></pre>
<p>end)<br>
\\\\\\\\\\\\\\\\\\\\\\\\\\<br>
\fishDispose.lua.txt</p>
<p>xlua.hotfix(CS.Treasour,'CreatePrize',nil)</p>
<p>xlua.hotfix(CS.Gun,'Attack',nil)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[XLua迁入工程，Hotfis环境配置]]></title>
        <id>https://Wei715547.github.io/post/xlua-qian-ru-gong-cheng-hotfis-huan-jing-pei-zhi/</id>
        <link href="https://Wei715547.github.io/post/xlua-qian-ru-gong-cheng-hotfis-huan-jing-pei-zhi/">
        </link>
        <updated>2020-06-18T08:16:39.000Z</updated>
        <content type="html"><![CDATA[<p>工程路径名不包含中文<br>
<img src="https://Wei715547.github.io/post-images/1592472285876.png" alt="" loading="lazy"><br>
补丁创建完成后将XLua附带示例文件删除在进行打包</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[创建AssetBundles/从AssetBundles中加载文件到场景]]></title>
        <id>https://Wei715547.github.io/post/chuang-jian-assetbundles/</id>
        <link href="https://Wei715547.github.io/post/chuang-jian-assetbundles/">
        </link>
        <updated>2020-06-15T09:21:12.000Z</updated>
        <content type="html"><![CDATA[<p>//此脚本放在“Asset/Editor”<br>
using System.IO;<br>
using UnityEditor;</p>
<p>public class CreateAB<br>
{<br>
[MenuItem(&quot;Assets/Build AssetBundles&quot;)]<br>
static void BuildAllAssetBuundles()<br>
{<br>
string dir = &quot;AssetBundles&quot;;<br>
if (Directory.Exists (dir)==false)<br>
{<br>
Directory.CreateDirectory(dir);<br>
}<br>
BuildPipeline.BuildAssetBundles(dir, BuildAssetBundleOptions.None, BuildTarget.StandaloneWindows64);<br>
}<br>
}</p>
<p>////////////////////////////////////////////////////////<br>
//加载<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using System.IO;<br>
using UnityEngine;<br>
using UnityEngine.Networking;<br>
public class LoadFormFile : MonoBehaviour<br>
{<br>
IEnumerator Start()//异步加载使用协同程序调用<br>
//private void Start()<br>
{<br>
//string path1 = &quot;AssetBundles / mt.wei&quot;;<br>
string path = &quot;AssetBundles/tree.wei&quot;;<br>
//示例：通过本地路径加载AB包<br>
/<em>AssetBundle ab1 = AssetBundle.LoadFromFile(&quot;AssetBundles/mt.wei&quot;);//存在依赖包时，所依赖的资源包也需要加载<br>
AssetBundle ab = AssetBundle.LoadFromFile(&quot;AssetBundles/tree.wei&quot;);//文件路径<br>
GameObject tree = ab.LoadAsset<GameObject>(&quot;Tree 02&quot;);//预制件名称<br>
GameObject go = Instantiate(tree);<br>
go.transform.SetParent(this.transform );</em>/</p>
<pre><code>    //遍历生成AB报中所有物体并生成
    /*Object[] obj = ab.LoadAllAssets();
    foreach (Object item in obj)
    {
        Instantiate(item);
    }*/


    //第一种方式:通过内存加载AB包的方式：AssetBundle.LoadFromMemoryAsync
    //异步加载
    /*AssetBundleCreateRequest request = AssetBundle.LoadFromMemoryAsync(File.ReadAllBytes(path));
    yield return request;
    AssetBundle ab = request.assetBundle;*/

    //同步加载
    //AssetBundle ab = AssetBundle.LoadFromMemory(File.ReadAllBytes(path));

    //第二种方式：通过本地文件加载AB包：
    //异步加载
    /*AssetBundleCreateRequest request = AssetBundle.LoadFromFileAsync(path);
    yield return request;
    AssetBundle ab = request.assetBundle;*/
    //同步加载（示例）
    //AssetBundle ab = AssetBundle.LoadFromFile(path);

    ////////////网络加载////////////

    //第三种方式：WWW.LoadFromCacheOrDownload（异步加载(IEnumerator)）
    /*WWW www = WWW.LoadFromCacheOrDownload(@&quot;file:///D:\715\3DFreeWord\AssetBundles\tree.wei&quot;,1);
    yield return www;
    AssetBundle ab = www.assetBundle;*/


    //第四种方式：UnityWebRequest（异步执行(IEnumerator)）
    string uri = @&quot;file:///D:\715\3DFreeWord\AssetBundles\tree.wei&quot;;
    UnityWebRequest request = UnityWebRequestAssetBundle.GetAssetBundle(uri);
    yield return request.Send();
    //AssetBundle ab = DownloadHandlerAssetBundle.GetContent(request);//获取方式一
    AssetBundle ab = (request.downloadHandler as DownloadHandlerAssetBundle).assetBundle;//获取方式二


    //使用里面的资源
    GameObject tree = ab.LoadAsset&lt;GameObject&gt;(&quot;Tree 02&quot;);
    GameObject go = Instantiate(tree/*, transform.position,Quaternion.identity*/);
    go.transform.position = this.transform.position;
</code></pre>
<p>//通过Mainfest获取所有的依赖包<br>
AssetBundle mainfestAB = AssetBundle.LoadFromFile(&quot;AssetBundles/AssetBundles&quot;);//加载AssetBundles文件<br>
AssetBundleManifest mainfest = mainfestAB.LoadAsset<AssetBundleManifest>(&quot;AssetBundleManifest&quot;);//通过AssetBundles获取AssetBundles.manifest文件<br>
/<em>foreach (string name in mainfest.GetAllAssetBundles())//获取所有的AB包，返回包名。<br>
{<br>
print(name);<br>
}</em>/<br>
string[] strs = mainfest.GetAllDependencies(&quot;tree.wei&quot;);//获取某个AB包所依赖的包，返回包名。<br>
foreach (string name in strs)<br>
{<br>
print(name);<br>
AssetBundle.LoadFromFile(&quot;AssetBundles/&quot; + name);//加载所有的依赖包<br>
}<br>
}<br>
}<br>
<img src="https://Wei715547.github.io/post-images/1592216098868.jpg" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1592216105421.jpg" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Save Point]]></title>
        <id>https://Wei715547.github.io/post/save-point/</id>
        <link href="https://Wei715547.github.io/post/save-point/">
        </link>
        <updated>2020-06-13T08:06:34.000Z</updated>
        <content type="html"><![CDATA[<p>//Prefab脚本<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class SavePoint : MonoBehaviour<br>
{<br>
private LayerMask player;<br>
private Light signlLight;<br>
// Start is called before the first frame update<br>
void Start()<br>
{<br>
player = LayerMask.NameToLayer(&quot;Player&quot;);<br>
signlLight = GetComponentInChildren<Light>();<br>
}</p>
<pre><code>//玩家触碰到Point时调用GM中的方法
private void OnTriggerEnter2D(Collider2D collision)
{
    if (collision.gameObject .layer ==player )
    {
        signlLight.color = Color.green;
        this.gameObject.GetComponent&lt;SpriteRenderer&gt;().material.color = Color.green;
        Debug.Log(&quot;Save&quot;);
        
        GameManager.instance.SavePoint();
    }
}
</code></pre>
<p>}</p>
<p>//GameManager<br>
public Vector2 playerPos ;//存储玩家位置，(通关/返回主界面时职位Vector2.zero<br>
//instance.playerPos = Vector2.zero;//通关后位置初始化)<br>
/存档点位置更新<br>
public void SavePoint()<br>
{<br>
instance.playerPos = instance.playerMove.transform.position;//玩家位置赋值给GM中的Pos<br>
}<br>
//GM中的Save/Load<br>
public GameData Save()<br>
{<br>
GameData date = new GameData();<br>
date.scence = SceneManager.GetActiveScene().buildIndex;<br>
date.deathCount = instance.deathCount;<br>
date.bgmValue = UIManager.instence.GetBGMValue();<br>
date.fxValue = UIManager.instence.GetFXValue();</p>
<pre><code>    if (instance.playerPos == Vector2.zero)
    {
        date.posx = 0;
        date.posy = 0;
    }

    else
    {
        date.posx = instance.playerPos.x;
        date.posy = instance.playerPos.y;
    }

    return date;

}

public void Load(GameData date)
{
    instance.playerPos = new Vector2(date.posx, date.posy);

    SceneManager.LoadScene(date .scence );
    //UIManager.instence.ShowLoadPanel(date.scence);
    instance.deathCount = date.deathCount;
    UIManager.UpdataDeathUI(instance.deathCount);
    GameManager.instance.time = 0;
    UIManager.instence.SetBGMValue(date.bgmValue);
    UIManager.instence.SetFXValue(date.fxValue);
}

//Player控制脚本
Start
{
//玩家未接触到存档点GM中默认Pos=0；此时将默认未值赋值给GM中的Pos。
    //（通关之后GM中的Pos会被PlayerWin()方法赋值为默认值）
    if ( GameManager.instance.playerPos==Vector2.zero)
    {
        GameManager.instance.playerPos = playerPos;
    }else//玩家触碰到存档点时，将GM中的位置赋值给玩家物体的Pos。
    {
        transform.position = GameManager.instance.playerPos;
    }
    }</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[单例]]></title>
        <id>https://Wei715547.github.io/post/dan-li/</id>
        <link href="https://Wei715547.github.io/post/dan-li/">
        </link>
        <updated>2020-06-12T08:02:53.000Z</updated>
        <content type="html"><![CDATA[<p>3.单例模式---在被调用的脚本中，公开声明一个静态的该脚本实例，在初始化时使&quot;实例=this&quot;<br>
便于在其他脚本中直接调用该脚本与其中的方法。<br>
<img src="https://Wei715547.github.io/post-images/1589271341241.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1589271396945.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1589963622098.PNG" alt="" loading="lazy"></p>
<p>两脚本有碰撞，触发关系时可直接利用<br>
(碰撞)collsion.gameObject.GetComponent&lt;被调用脚本名&gt;().方法名();<br>
(触发)collsion.GetComponent&lt;被调用脚本名&gt;().方法名();<br>
或SendMessage（以”方法名“调用物体中继承 MonoBehaviour 脚本的方法.）<br>
(碰撞)collision.gameObject.SendMessage(&quot;方法名&quot;);<br>
(触发)collsion.SendMessage(&quot;方法名&quot;);<br>
调用对方脚本中的方法<br>
<img src="https://Wei715547.github.io/post-images/1589272112653.PNG" alt="" loading="lazy"></p>
<p>//4.单例模式<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.SceneManagement;<br>
public class GameManager : MonoBehaviour<br>
{<br>
public static GameManager instance;<br>
SceneFader fader;<br>
// Start is called before the first frame update<br>
void Awake()<br>
{<br>
if (instance!=null )<br>
{<br>
Destroy(gameObject);<br>
return;<br>
}<br>
instance = this;<br>
DontDestroyOnLoad(gameObject);</p>
<pre><code>}

//在外部将其他脚本通过此静态方法注册到GameManager中的变量（引用），（可在GameManager中调用其他脚本中的方法）
 /*   void Awake()//被调用的脚本
{
    ani = GetComponent&lt;Animator&gt;();
    FaderID = Animator.StringToHash(&quot;Fade&quot;);
    ////将脚本指定为GameManager的变量，使其中的方法可以在gamemanager中调用
    GameManager.RegisterCceneFader(this);
}*/
public static void RegisterCceneFader(SceneFader obj)
{
    instance.fader = obj;
}

public static void PlayerDied()
{
    instance.fader.FadeOut();//调用其他脚本中的方法
    instance.Invoke(&quot;RestartScence&quot;, 1.5f);
}

public void RestartScence()
{
    SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);
    
}
</code></pre>
<p>}</p>
<p>复杂时可使用事件的广播，监听</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next Scence Don't Destroy]]></title>
        <id>https://Wei715547.github.io/post/next-scence-dont-destroy/</id>
        <link href="https://Wei715547.github.io/post/next-scence-dont-destroy/">
        </link>
        <updated>2020-06-11T08:38:18.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class CanvasDS : MonoBehaviour<br>
{<br>
//声明单例，判断其在场景中是否已存在（被赋值）<br>
public static CanvasDS instance;</p>
<pre><code>void Awake()
{
    if (instance != null)
    {
        Destroy(gameObject);//已存在与场景中时销毁此对象，保证场景中只有一个此类对象
        return;
    }
    instance = this;
    DontDestroyOnLoad(this);
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Audio Mixer]]></title>
        <id>https://Wei715547.github.io/post/audio-mixer/</id>
        <link href="https://Wei715547.github.io/post/audio-mixer/">
        </link>
        <updated>2020-06-11T02:36:35.000Z</updated>
        <content type="html"><![CDATA[<p>void Awake()<br>
{<br>
//Nomal Slider Ct<br>
Vo.value = FindObjectOfType<AudioSource>().volume;</p>
<pre><code>    //Pvo = transform.Find(&quot;Player_Slider&quot;).GetComponent&lt;Slider&gt;();

    auM.GetFloat(&quot;MainVolume&quot;,out float v);
    Pvo.value = v;//Audio Mixer output value  to Slider
}

private void Update()
{
    //Panel enable update the value
    FindObjectOfType&lt;AudioSource&gt;().volume = Vo.value;
    auM .SetFloat(&quot;MainVolume&quot;, Pvo.value);
}
</code></pre>
<p><img src="https://Wei715547.github.io/post-images/1591860911716.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1591860919096.PNG" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UI图标冷却]]></title>
        <id>https://Wei715547.github.io/post/ui-tu-biao-leng-que/</id>
        <link href="https://Wei715547.github.io/post/ui-tu-biao-leng-que/">
        </link>
        <updated>2020-06-11T02:23:02.000Z</updated>
        <content type="html"><![CDATA[<p>private void FixedUpdate()<br>
{<br>
coodTime += Time.deltaTime;</p>
<pre><code>    if (Input.GetKeyDown(KeyCode.Z) &amp;&amp; coodTime &gt; setcoodtime)
    {
        au.PlayOneShot(russ, 1f);
        Russing();
        coodTime = 0;
    }
}

// Update is called once per frame
void Update()
{
    //UI显示
    if (coodTime &gt; setcoodtime)
    {
        coodUI.fillAmount = 0;
    }else
    {
        coodUI.fillAmount = 1-coodTime/setcoodtime ;
    }
}
![](https://Wei715547.github.io/post-images/1591842421156.PNG)</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Post Process Effect/Camer Shake]]></title>
        <id>https://Wei715547.github.io/post/post-process-effectcamer-shake/</id>
        <link href="https://Wei715547.github.io/post/post-process-effectcamer-shake/">
        </link>
        <updated>2020-06-07T07:05:12.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://Wei715547.github.io/post-images/1591513702359.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1591513708909.PNG" alt="" loading="lazy"></p>
<p><img src="https://Wei715547.github.io/post-images/1591514562757.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1591514569006.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1591514575527.PNG" alt="" loading="lazy"></p>
]]></content>
    </entry>
</feed>