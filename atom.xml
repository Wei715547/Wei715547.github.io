<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Wei715547.github.io</id>
    <title>Weiwei的个人网站</title>
    <updated>2020-05-26T15:24:28.624Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Wei715547.github.io"/>
    <link rel="self" href="https://Wei715547.github.io/atom.xml"/>
    <subtitle>7</subtitle>
    <logo>https://Wei715547.github.io/images/avatar.png</logo>
    <icon>https://Wei715547.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Weiwei的个人网站</rights>
    <entry>
        <title type="html"><![CDATA[委托事件实现广播/监听（底层实现）]]></title>
        <id>https://Wei715547.github.io/post/wei-tuo-shi-jian-shi-xian-guang-bo-jian-ting-di-ceng-shi-xian/</id>
        <link href="https://Wei715547.github.io/post/wei-tuo-shi-jian-shi-xian-guang-bo-jian-ting-di-ceng-shi-xian/">
        </link>
        <updated>2020-05-26T15:22:36.000Z</updated>
        <content type="html"><![CDATA[<p>//广播者<br>
using System;<br>
using System.Collections.Generic;<br>
using System.Text;</p>
<p>namespace 事件__观察者设计模式<br>
{<br>
class Cat//被观察者（广播着）<br>
{<br>
public string name;<br>
public string color;</p>
<pre><code>    public Cat(string name,string color)
    {
        this.name = name;
        this.color = color;
    }

    public void CatComing()
    {
        Console.WriteLine(&quot;发起广播&quot;);
        if(catCome!=null)
            catCome();
    }

    //public Action catCome;
    public event Action catCome;//声明一个事件，发布一个消息
}
</code></pre>
<p>}</p>
<p>//监听者<br>
using System;<br>
using System.Collections.Generic;<br>
using System.Text;</p>
<p>namespace 事件__观察者设计模式<br>
{<br>
class Moust//观察者（监听着）<br>
{<br>
public string name;<br>
public string color;</p>
<pre><code>    public Moust(string name,string color,Cat c)
    {
        this.name = name;
        this.color = color;
        c.catCome += this.MsRuning;//将自身应对广播“某”事件的方法，注册进广播者的该事件中
    }

    public void MsRuning()
    {
        Console.WriteLine(&quot;监听着收到广播&quot;);
    }
}
</code></pre>
<p>}</p>
<p>//程序<br>
using System;</p>
<p>namespace 事件__观察者设计模式<br>
{<br>
class Program<br>
{<br>
static void Main(string[] args)<br>
{<br>
Cat c = new Cat(&quot;Super BuleCat&quot;,&quot;Blue&quot;);<br>
Moust m1 = new Moust(&quot;Mk&quot;, &quot;Blake&quot;,c);//将广播者传入监听者，在监听者中注册委托<br>
//c.catCome += m1.MsRuning;//注册委托<br>
Moust m2 = new Moust(&quot;Bt&quot;, &quot;Blue&quot;,c);<br>
//c.catCome += m2.MsRuning;//注册委托<br>
//c.catCome();//事件不能在类的外部进行调用(委托可以)，但可在类的外部注册。<br>
c.CatComing();<br>
}<br>
}<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[正则表达式（字符串格式判定）]]></title>
        <id>https://Wei715547.github.io/post/zheng-ze-biao-da-shi-zi-fu-chuan-ge-shi-pan-ding/</id>
        <link href="https://Wei715547.github.io/post/zheng-ze-biao-da-shi-zi-fu-chuan-ge-shi-pan-ding/">
        </link>
        <updated>2020-05-26T12:05:29.000Z</updated>
        <content type="html"><![CDATA[<p>using System;<br>
using System.Text.RegularExpressions;</p>
<p>namespace 正则表达式<br>
{<br>
class Program<br>
{<br>
static void Main(string[] args)<br>
{<br>
string s = &quot;I amwei&quot;;<br>
string res = Regex.Replace(s,&quot;^&quot;, &quot;start&quot;);//&quot;^&quot;匹配开始字符串<br>
Console.WriteLine(res);</p>
<pre><code>        string res2 = Regex.Replace(s, &quot;$&quot;, &quot;end&quot;);//&quot;$&quot;匹配结尾
        Console.WriteLine(res2);

        string num = Console.ReadLine();
        /*bool isMatch = true;
        for (int i = 0; i &lt; num.Length ; i++)
        {
            if(num[i]&lt;'0'||num[i]&gt;'9')
            {
                isMatch = false;
                break;
            }
        }
        if (isMatch)
        {
            Console.WriteLine(&quot;密码合法&quot;);
        }
        else
        {
            Console.WriteLine( &quot;密码不合法&quot;);
        }*/
        string pattern = @&quot;^\d*$&quot;;//(数字字符串)以数字开头0个或多个，并以数字结尾
        bool issMach = Regex.IsMatch(num, pattern);
        Console.WriteLine(issMach);

    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[拖拽接口]]></title>
        <id>https://Wei715547.github.io/post/tuo-zhuai-jie-kou/</id>
        <link href="https://Wei715547.github.io/post/tuo-zhuai-jie-kou/">
        </link>
        <updated>2020-05-26T09:21:49.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.EventSystems;<br>
using UnityEngine.UI;<br>
public class ItemOnnDrag : MonoBehaviour, IBeginDragHandler, IDragHandler, IEndDragHandler<br>
{<br>
public Transform originatParent;<br>
public Inventory myBag;<br>
private int currentItemID;</p>
<pre><code>public void OnBeginDrag(PointerEventData eventData)
{
    originatParent = transform.parent;
    currentItemID = originatParent.GetComponent&lt;Slot&gt;().slotID;
    transform.SetParent(transform.parent.parent);
    transform.position = eventData.position;
    GetComponent&lt;CanvasGroup&gt;().blocksRaycasts = false;
}

public void OnDrag(PointerEventData eventData)
{
    transform.position = eventData.position;
    //print(eventData.pointerCurrentRaycast.gameObject.name);
}

public void OnEndDrag(PointerEventData eventData)
{
    if (eventData.pointerCurrentRaycast.gameObject != null)
    {
        if (eventData.pointerCurrentRaycast.gameObject.name == &quot;Item Image&quot;)//物品栏有物品时
        {
            transform.SetParent(eventData.pointerCurrentRaycast.gameObject.transform.parent.parent);
            transform.position = eventData.pointerCurrentRaycast.gameObject.transform.parent.parent.position;

            //交换存储位置
            var temp = myBag.itemList[currentItemID];
            myBag.itemList[currentItemID] = myBag.itemList[eventData.pointerCurrentRaycast.gameObject.GetComponentInParent&lt;Slot&gt;().slotID];
            myBag.itemList[eventData.pointerCurrentRaycast.gameObject.GetComponentInParent&lt;Slot&gt;().slotID] = temp;
            //交换存储位置

            eventData.pointerCurrentRaycast.gameObject.transform.parent.SetParent(originatParent);
            eventData.pointerCurrentRaycast.gameObject.transform.parent.position = originatParent.position;
            GetComponent&lt;CanvasGroup&gt;().blocksRaycasts = true;
            return;
        }
        if (eventData.pointerCurrentRaycast.gameObject.name == &quot;Slot(Clone)&quot;)
        {
            //物品栏为空时
            transform.SetParent(eventData.pointerCurrentRaycast.gameObject.transform);
            transform.position = eventData.pointerCurrentRaycast.gameObject.transform.position;

            myBag.itemList[eventData.pointerCurrentRaycast.gameObject.GetComponentInParent&lt;Slot&gt;().slotID] = myBag.itemList[currentItemID];
            if (eventData.pointerCurrentRaycast.gameObject.GetComponent&lt;Slot&gt;().slotID != currentItemID)
                myBag.itemList[currentItemID] = null;

            GetComponent&lt;CanvasGroup&gt;().blocksRaycasts = true;
            return;
        }
    }
    //其他任何位置返回原位
    transform.SetParent(originatParent);
    transform.position = originatParent.position;
    GetComponent&lt;CanvasGroup&gt;().blocksRaycasts = true;
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符、可变字符串，方法]]></title>
        <id>https://Wei715547.github.io/post/zi-fu-chuan-fang-fa/</id>
        <link href="https://Wei715547.github.io/post/zi-fu-chuan-fang-fa/">
        </link>
        <updated>2020-05-24T15:55:23.000Z</updated>
        <content type="html"><![CDATA[<p>using System;<br>
using System.Text;</p>
<p>namespace 字符串方法<br>
{<br>
class Program<br>
{<br>
static void Main(string[] args)<br>
{<br>
//1.<br>
string s = &quot; wei715547&quot;;<br>
int res = s.CompareTo(&quot;wei715547&quot;);//元素相等时，返回值为0，<br>
//调用者字母排序靠后时返回值为1，靠前是返回值为-1<br>
Console.WriteLine(res);</p>
<pre><code>        //2
        string newstring = s.Replace('w', 'z');//替换字符
        Console.WriteLine(newstring );
        //string newstring2 = s.Replace('1', '2');

        //3.字符串从指定字符位置拆分为数组
        string[] stringArray = s.Split('1');
        foreach (var item in stringArray )
        {
            Console.WriteLine(item );
        }

        //4.Substring.截取字符串
        string newcut = s.Substring(2,5);
        Console.WriteLine(newcut);

        //5.清除字符串首尾空白
        string clearspace = s.Trim();
        Console.WriteLine(clearspace );

        //6.返回指定字符的索引
        int newindex = s.IndexOf('1');
        Console.WriteLine(newindex );

        //-------------------------------------------------------------
        //可变字符串StringBuilder 
        //create1.通过构造函数进行构建
        StringBuilder sb = new StringBuilder(&quot;www.wei7157.github.co&quot;);
        Console.WriteLine(sb);
        //create2.声明空间大小
        StringBuilder sb2 = new StringBuilder(20);
        sb2.Append(&quot;www.wei7157.github.co&quot;);
        Console.WriteLine(sb2);
        //creat3.赋值同时声明空间大小
        StringBuilder sb3 = new StringBuilder(&quot;www.wei7157.github.co&quot;, 100);
        Console.WriteLine(sb3);


        //字符串修改与标准字符串对比
        sb.Append(&quot;000000&quot;);//在空余空间链接字符
        Console.WriteLine(sb);
        //对比常规字符串操作，运行效率更高
        string str = &quot;www.wei7157.github.co&quot;;
        str += &quot;000000&quot;;//在堆中创建新的字符，str索引指向新的字符，原来的字符被CLR回收（效率低）
        Console.WriteLine(str);

        //可变字符串Insert()方法
        sb.Insert(0, &quot;http//&quot;);
        Console.WriteLine(sb);
        sb.Remove(0, 6);//根据索引范围移除字符
        Console.WriteLine(sb);
        sb.Replace('w', 'z');//字符替换
        Console.WriteLine(sb);
        Console.WriteLine(sb.ToString());//ToString()转变为不可变字符

    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自定义List集合]]></title>
        <id>https://Wei715547.github.io/post/zi-ding-yi-list-ji-he/</id>
        <link href="https://Wei715547.github.io/post/zi-ding-yi-list-ji-he/">
        </link>
        <updated>2020-05-24T10:00:49.000Z</updated>
        <content type="html"><![CDATA[<p>using System;<br>
using System.Collections.Generic;<br>
using System.Text;</p>
<p>namespace 自定义集合类MyList<br>
{<br>
class MyList<T> where T :IComparable<br>
{<br>
private T[] array;<br>
private int count = 0;</p>
<pre><code>    public MyList(int size)
    {
        if (size &gt; 0)
            array = new T[size];
    }

    public MyList()
    {
        array = new T[0];
    }

    public int Capecity
    {
        get { return array.Length; }
    }

    public int Count
    {
        get { return count; }
    }

    public void Add(T item)
    {
        if (Count == Capecity)//判断元素个数与数组容量
        {
            if (Capecity == 0)
                array = new T[4];
            else
            {
                var newarray = new T[Capecity * 2];
                Array.Copy(array, newarray, Count);
                array = newarray;
            }
        }
        array[Count] = item;
        count++;
    }

    public T GetItem(int index)
    {
        if (index &gt;= 0 &amp;&amp; index &lt;= count-1)
        {
            return array[index];
        }
        else
        {
            Console.WriteLine(&quot;Index outof range&quot;);
            throw new Exception(&quot;索引超出范围&quot;);
        }

    }

    //索引器，属性
    public T this[int index]
    {
        get { return GetItem(index); }
        set
        {
            if (index &gt;= 0 &amp;&amp; index &lt;= count-1)
            {
                array[index] = value;
            }
            else
            {
                Console.WriteLine(&quot;Index outof range&quot;);
                throw new Exception(&quot;索引超出范围&quot;);
            }
        }
    }

    public void Insert(int index, T item)
    {
        if (index &gt;= 0 &amp;&amp; index &lt;= count-1)
        {
            if (Count  == Capecity )//容量不足进行扩容
            {
                var newArray = new T[Capecity * 2];
                Array.Copy(array, newArray, count);
                array = newArray;
            }
            for (int i = count -1; i &gt;= index ; i--)
            {
                array[i+1] = array[i];
            }
            array[index] = item;
            count++;
        }
        else
        {
            Console.WriteLine(&quot;Index outof range&quot;);
            throw new Exception(&quot;索引超出范围&quot;);
        }

    }
    
    public void RemoveAt(int index)
    {
        if (index &gt;= 0 &amp;&amp; index &lt;= count-1)
        {
            for (int i = index +1; i &lt; count ; i++)
            {
                array[i - 1] = array[i];
            }
            count--;
        }
        else
        {
            throw new Exception(&quot;索引超出范围&quot;);
        }
    }

    public int IndexOf(T item)
    {
        for (int i = 0; i &lt; count ; i++)
        {
            if (array[i].Equals(item))
            {
                return i;
            }
        }
        return -1;
    }

    public int LastIndexOf(T item)
    {
        for (int i = count -1; i &gt;=0; i--)
        {
            if (array [i].Equals (item ))
            {
                return i;
            }
        }
        return -1;
    }

    public void Sort()
    {
        for (int j = 0; j &lt; Count -1; j++)
        {
            for (int i = 0; i &lt; Count-1-j; i++)
            {
                if (array[i].CompareTo(array[i + 1]) &gt; 0)//返回值大于0是后面的铋前面的大
                {
                    //打的元素向后排
                    T temp = array[i];
                    array[i] = array[i + 1];
                    array[i + 1] = temp;
                }
            }
        }
        
    }

}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构Base]]></title>
        <id>https://Wei715547.github.io/post/xian-xing-biao/</id>
        <link href="https://Wei715547.github.io/post/xian-xing-biao/">
        </link>
        <updated>2020-05-23T02:33:04.000Z</updated>
        <content type="html"><![CDATA[<p>线性表：相同类型，有限，序列<br>
顺序表：线性表的顺序存储（静态数组（以分配默认大小），动态数组）<br>
单链表：线性表链式存储（链式指针，非顺序存储[数据，地址]对形式）<br>
判断单链表是否为空1，头结点head是否为空。2，头结点的指针head-&gt;next 是否为空<br>
栈：顺序栈，链栈。<br>
队列：先进先出--常用方法：初始化队列，判断队列是否为空（首末指针相同时队列为空），队列长度为末指针-首指针。<br>
入队，出队，读取队头元素，销毁队列。<br>
顺序队列，循环队列。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GameManager重新加载后不销毁]]></title>
        <id>https://Wei715547.github.io/post/gamemanager-chong-xin-jia-zai-hou-bu-xiao-hui/</id>
        <link href="https://Wei715547.github.io/post/gamemanager-chong-xin-jia-zai-hou-bu-xiao-hui/">
        </link>
        <updated>2020-05-20T05:11:49.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
//在其他物体上调用<br>
public class Loder : MonoBehaviour<br>
{<br>
public GameObject gamemenager;</p>
<pre><code>// Start is called before the first frame update
void Awake()
{
    if (Gamemanager.Instence == null)
        GameObject.Instantiate(gamemenager);
}
</code></pre>
<h2 id="">}</h2>
<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.UI;<br>
using UnityEngine.SceneManagement;<br>
public class Gamemanager : MonoBehaviour<br>
{<br>
//单例模式<br>
private static Gamemanager _instence;</p>
<pre><code>public static Gamemanager Instence 
{
    get { return _instence; }
}

private void Awake()
{
    _instence = this;
    DontDestroyOnLoad(gameObject);//加载场景时不销毁
    InitGame();
}

//bool交替执行
private bool sleepStep = true;
    public void OnplayerMove()
{
    if (sleepStep ==true )
    {
        sleepStep =false ;
    }else
    {
        foreach (var enemy in enemyList )
        {
            enemy.Move();
        }
        sleepStep = true;
    }

    //角色移动后
    if (player.targetpos.x == mapmanager.xc - 1.5f &amp;&amp; player.targetpos.y == mapmanager.yc - 1.5f)
    {
        IsEnd = true;
        //加载下一关
        SceneManager.LoadScene(SceneManager .GetActiveScene ().buildIndex );
    }
}


    //场景加载后执行
private void OnLevelWasLoaded(int SceneLevel)
{
    level++;
    InitGame();
}

    //失败后重新开始游戏
private void Restart()
{
    SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);
    food = 100;
    level -= level;
}</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2D线检测]]></title>
        <id>https://Wei715547.github.io/post/2d-xian-jian-ce/</id>
        <link href="https://Wei715547.github.io/post/2d-xian-jian-ce/">
        </link>
        <updated>2020-05-19T07:08:13.000Z</updated>
        <content type="html"><![CDATA[<pre><code>        enemyCl.enabled = false;
        RaycastHit2D hit = Physics2D.Linecast(targertPos , targertPos + new Vector2(x, y));
        enemyCl.enabled = true;
        if (hit.transform == null || hit.collider.tag == &quot;Soda&quot; || hit.collider.tag == &quot;Food&quot;)
            targertPos += new Vector2(x, y);</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[断离销毁子类，状态机-动作融合]]></title>
        <id>https://Wei715547.github.io/post/duan-chi-xiao-hui-zi-lei/</id>
        <link href="https://Wei715547.github.io/post/duan-chi-xiao-hui-zi-lei/">
        </link>
        <updated>2020-05-19T01:18:53.000Z</updated>
        <content type="html"><![CDATA[<pre><code>protected override void Start()
{
    base.Start();
    fR = GetComponent&lt;Rigidbody2D&gt;();
    //cl = GetComponent&lt;CircleCollider2D&gt;();
    l = left.position.x;
    r = right.position.x;
    transform.DetachChildren();
    Destroy(left.gameObject);
    Destroy(right.gameObject);

}

Has Exit Time：当前状态是否播放完再进入下一状态
Setting
            Exit Time 1，(0~1+)当前状态播放一遍在进入下一状态
            Transition Duratio 0，(0~1+)动作融合，2D不需要融合
            Transition Offset 0，(0~1+)下一状态是否需要偏移</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ObjectPool(对象池)]]></title>
        <id>https://Wei715547.github.io/post/objectpooldui-xiang-chi/</id>
        <link href="https://Wei715547.github.io/post/objectpooldui-xiang-chi/">
        </link>
        <updated>2020-05-16T07:54:47.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://Wei715547.github.io/post-images/1589615693691.PNG" alt="" loading="lazy"><br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class ObjectPool : MonoBehaviour<br>
{<br>
public static ObjectPool instence;//单例模式用于外部调用</p>
<pre><code>public GameObject shado;//要生成的预制体（可通过资源管理类获取）
/*[CreateAssetMenu(menuName =&quot;CreatManagerVarsContainer&quot;)]
</code></pre>
<p>public class ManagerVars : ScriptableObject<br>
{<br>
public static ManagerVars GetManagerVars()<br>
{<br>
return Resources.Load<ManagerVars>(&quot;ManagerVarsContainer&quot;);<br>
}*/<br>
<img src="https://Wei715547.github.io/post-images/1589616593470.PNG" alt="" loading="lazy"><br>
//要生成的预制体集合<br>
private List<GameObject> playerShado = new List<GameObject>();</p>
<pre><code>private int InstentCount = 5;//在对象池中默认生成多少个

private void Awake()
{
    instence = this;
    Init();//初始生成
}

public void Init()
{
    for (int i = 0; i &lt; InstentCount ; i++)
    {
        //生成默认个数预制体(go.SetActive(false);，并添加到目标预制体List中
        InstantceObject(shado,ref playerShado );
    }
}
//生成与添加入集合的方法
//（返回值GameObject便于外部调用时，如果对象池中同类物体都处于占用激活状态，则再生成新的预制体并添加到集合中）
private GameObject InstantceObject(GameObject prefab, ref List&lt;GameObject &gt; addlist  )
{
    GameObject go = Instantiate(prefab, transform);
    go.SetActive(false);
    addlist.Add(go);
    return go;
}

//外部调用方法
public GameObject GetShado()
{
    //遍历集合中的物体知否激活/占用，没有则返回应用该物体。
    for (int i = 0; i &lt; InstentCount ; i++)
    {
        if(playerShado [i].activeInHierarchy==false )
        {
            return playerShado[i];
        }
    }
    //如List中的物体均处于占用状态，(对象池中同类物体不够)则生成新的对象返回并添加到List集合(对象池)中
    return InstantceObject(shado ,ref playerShado );
}

//gameObject.SetActive(false)写在预制体/外部脚本上
</code></pre>
<p>}</p>
<p>例：生成残影<br>
<img src="https://Wei715547.github.io/post-images/1589616178256.PNG" alt="" loading="lazy"><br>
残影预制体脚本<br>
<img src="https://Wei715547.github.io/post-images/1589616264550.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1589618003824.PNG" alt="" loading="lazy"><br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using DG.Tweening;</p>
<p>public class PlayerShado : MonoBehaviour<br>
{<br>
[SerializeField]<br>
private bool reset;</p>
<pre><code>private void FixedUpdate()
{
    if (reset)
    {
        gameObject.GetComponent&lt;SpriteRenderer&gt;().sprite = GameObject.FindGameObjectWithTag(&quot;Player&quot;).GetComponent&lt;SpriteRenderer&gt;().sprite;//精灵动作保持一致
        transform.GetComponent&lt;SpriteRenderer&gt;().DOColor(new Color(transform.GetComponent&lt;SpriteRenderer&gt;().color.r,
          transform.GetComponent&lt;SpriteRenderer&gt;().color.g, transform.GetComponent&lt;SpriteRenderer&gt;().color.b, 0), 0.2f).OnComplete(() =&gt;
          {
              gameObject.SetActive(false);   
          });
        reset = false;
        print(&quot;FixedUpdate&quot;);
    }
}
//物体未启用时执行（在Update后执行）
private void OnDisable()
{
    transform.GetComponent&lt;SpriteRenderer&gt;().color = new Color(transform.GetComponent&lt;SpriteRenderer&gt;().color.r,
            transform.GetComponent&lt;SpriteRenderer&gt;().color.g, transform.GetComponent&lt;SpriteRenderer&gt;().color.b, 1);
    reset = true;
    print(&quot;Onsisable&quot;);

}
</code></pre>
<p>}</p>
<p>//物体启用时执行<br>
private void OnEnable()<br>
{<br>
gameObject.GetComponent<SpriteRenderer>().sprite = GameObject.FindGameObjectWithTag(&quot;Player&quot;).GetComponent<SpriteRenderer>().sprite;<br>
transform.GetComponent<SpriteRenderer>().DOColor(new Color(transform.GetComponent<SpriteRenderer>().color.r,<br>
transform.GetComponent<SpriteRenderer>().color.g, transform.GetComponent<SpriteRenderer>().color.b, 0), 0.2f).OnComplete(() =&gt;<br>
{<br>
gameObject.SetActive(false);<br>
});<br>
}</p>
<pre><code>//物体未启用时执行
private void OnDisable()
{
    transform.GetComponent&lt;SpriteRenderer&gt;().color = new Color(transform.GetComponent&lt;SpriteRenderer&gt;().color.r,
            transform.GetComponent&lt;SpriteRenderer&gt;().color.g, transform.GetComponent&lt;SpriteRenderer&gt;().color.b, 1);
    //reset = true;
    //print(&quot;Onsisable&quot;);

}</code></pre>
]]></content>
    </entry>
</feed>