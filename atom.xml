<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Wei715547.github.io</id>
    <title>Wei: Development technology accumulation</title>
    <updated>2020-06-03T06:34:34.264Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Wei715547.github.io"/>
    <link rel="self" href="https://Wei715547.github.io/atom.xml"/>
    <subtitle>年月增长，我宜强盛。
用于Unity+开发的技术积累</subtitle>
    <logo>https://Wei715547.github.io/images/avatar.png</logo>
    <icon>https://Wei715547.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Wei: Development technology accumulation</rights>
    <entry>
        <title type="html"><![CDATA[Socket客户端端口]]></title>
        <id>https://Wei715547.github.io/post/socket-ke-hu-duan-duan-kou/</id>
        <link href="https://Wei715547.github.io/post/socket-ke-hu-duan-duan-kou/">
        </link>
        <updated>2020-06-02T05:45:10.000Z</updated>
        <content type="html"><![CDATA[<p>using System;<br>
using System.Net;<br>
using System.Net.Sockets;<br>
using System.Text;</p>
<p>namespace Socket客户端<br>
{<br>
class Program<br>
{<br>
static void Main(string[] args)<br>
{<br>
//1.创建Socket<br>
Socket tcpClient = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);//网咯、数据流形式、Tcp协议</p>
<pre><code>        //2.发起建立连接的请求
        IPAddress ipaddress = IPAddress.Parse(&quot;192.168.137.1&quot;);//可以将一个字符串的IP地址转化为IPaddress的对象
        EndPoint point = new IPEndPoint(ipaddress, 7788);
        //连接方法
        tcpClient.Connect(point);//通过ip:端口号，定位连接到目标服务器
        
        //接收来自服务器的数据（接收方法）
        byte[] data = new byte[1024]; //创建一个byte数组,(用来接收数据)
         int length = tcpClient.Receive(data);//传递一个byte数组,(用来接收数据)、返回值表示接收了多少字符串
        string message = Encoding.UTF8.GetString(data,0,length);//0~length的字节数据转化为字符串（把接收到的数据转化为字符串）
        Console.WriteLine(message);

        //向服务器端发送消息
        string messagec = Console.ReadLine();//读取用户的输入
        //发送方法
        tcpClient.Send(Encoding.UTF8.GetBytes(messagec));//把字符串转化为byte数组发送到服务器端

        Console.ReadKey();
    }
}
</code></pre>
<p>}<br>
<img src="https://Wei715547.github.io/post-images/1591076933494.PNG" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Socket服务器端口]]></title>
        <id>https://Wei715547.github.io/post/socket-fu-wu-qi-duan-kou/</id>
        <link href="https://Wei715547.github.io/post/socket-fu-wu-qi-duan-kou/">
        </link>
        <updated>2020-06-02T05:40:59.000Z</updated>
        <content type="html"><![CDATA[<p>using System;<br>
using System.Net;<br>
using System.Net.Sockets;<br>
using System.Text;</p>
<p>namespace Socket服务器端<br>
{<br>
class Program<br>
{<br>
static void Main(string[] args)<br>
{<br>
//创建Socket<br>
Socket tcpServer = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);//网络、数据流形式、Tcp协议</p>
<pre><code>        //1.绑定IP端口号
        //IPAddress ipaddress = new IPAddress(new byte[] { 192,168,137,1 });
        IPAddress ipaddress = IPAddress.Parse(&quot;192.168.137.1&quot;);//可以将一个字符串的IP地址转化为IPaddress的对象、同上一行代码
        EndPoint point = new IPEndPoint(ipaddress,7788);//IPEndPoint:IP端口的一层封装类
        //申请方法
        tcpServer.Bind(point);//向系统申请一个可用的ip根端口号，用来做通信
        
        //2.开始监听客户端连接
        //监听方法
        tcpServer.Listen(100);//开始监听等待客户端连接、允许（100）个客户端连接进来。
        Console.WriteLine(&quot;开始监听连接&quot;);

        //使用返回的Socket做通信

        //3.接收客户端的连接//接收连接方法
        //客户端的Socket对象的引用、用来收发客户端的数据
        Socket clientSocket = tcpServer.Accept();//暂停当前线程，直到有一个客户端连接进来，之后进行下面的代码。
        Console.WriteLine(&quot;一个客户端连接&quot;);

        //4.客户端连接后向客户端发送一个消息
        string message = &quot;欢迎接入Socket&quot;;//向客户端传输的信息
        byte[] data = Encoding.UTF8.GetBytes(message);//对一个字符串做编码，转为字节数组
        clientSocket.Send(data);
        Console.WriteLine(&quot;向客户端发送了一条数据&quot;);

        //5.接收客户端的数据
        byte[] datac = new byte[1024];//创建一个字节数组用来接收客户端发过来的数据
        int length = clientSocket.Receive(datac);
        string messagec = Encoding.UTF8.GetString(datac, 0, length);//0~length的字节数据转化为字符串（只把接收到的数据转化为字符串）
        Console.WriteLine(&quot;接收到一条从客户端发来的消息&quot;+messagec);


        Console.ReadKey();
    }
}
</code></pre>
<p>}<br>
<img src="https://Wei715547.github.io/post-images/1591076704544.PNG" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程池/Task类开启线程]]></title>
        <id>https://Wei715547.github.io/post/xian-cheng-chi/</id>
        <link href="https://Wei715547.github.io/post/xian-cheng-chi/">
        </link>
        <updated>2020-06-01T05:11:19.000Z</updated>
        <content type="html"><![CDATA[<p>using System;<br>
using System.Threading;</p>
<p>namespace 线程池<br>
{<br>
class Program<br>
{<br>
static void ThreadMethod(object state)<br>
{<br>
Console.WriteLine(&quot;线程开始&quot;+Thread .CurrentThread .ManagedThreadId);<br>
Thread.Sleep(2000);<br>
Console.WriteLine(&quot;线程结束&quot;);<br>
}</p>
<pre><code>    static void Main(string[] args)
    {
        ThreadPool.QueueUserWorkItem(ThreadMethod);//开启一个工作线程（适合耗时较短的任务）
        ThreadPool.QueueUserWorkItem(ThreadMethod);
        ThreadPool.QueueUserWorkItem(ThreadMethod);
        ThreadPool.QueueUserWorkItem(ThreadMethod);
        ThreadPool.QueueUserWorkItem(ThreadMethod);
        Console.ReadKey();


    }
}
</code></pre>
<p>}<br>
//-------------------------------------------------------------------------<br>
using System;<br>
using System.Threading;<br>
using System.Threading.Tasks;</p>
<p>namespace Task类开启线程<br>
{<br>
class Program<br>
{<br>
static void ThreadMethod()<br>
{<br>
Console.WriteLine(&quot;线程开始&quot; + Thread.CurrentThread.ManagedThreadId);<br>
Thread.Sleep(2000);<br>
Console.WriteLine(&quot;线程结束&quot;);<br>
}</p>
<pre><code>    static void Main(string[] args)
    {
        //1.开启方式
        /*Task t = new Task(ThreadMethod);
        t.Start();*/

        //2.开启方式
        /*TaskFactory tf = new TaskFactory();
        Task t = tf.StartNew(ThreadMethod);*/

        Console.WriteLine(&quot;Main&quot;);
        Console.ReadKey();
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Thread类开启线程]]></title>
        <id>https://Wei715547.github.io/post/thread-lei-kai-qi-xian-cheng/</id>
        <link href="https://Wei715547.github.io/post/thread-lei-kai-qi-xian-cheng/">
        </link>
        <updated>2020-05-31T15:49:26.000Z</updated>
        <content type="html"><![CDATA[<p>using System;<br>
using System.Threading;<br>
using System.Threading.Tasks;<br>
namespace 线程_通过Thread类开启<br>
{<br>
class Program<br>
{<br>
static void Downloading(object fileName)<br>
{<br>
Console.WriteLine(&quot;startDownloadong&quot;+Thread .CurrentThread .ManagedThreadId +fileName );<br>
Thread.Sleep(2000);<br>
Console.WriteLine(&quot;END&quot;);<br>
}<br>
static void Main(string[] args)<br>
{<br>
//方式1.直接赋值一个方法引用<br>
/<em>Thread t = new Thread(Downloading);<br>
t.Start();//开始执行线程<br>
Console.WriteLine(&quot;Main&quot;);</em>/</p>
<pre><code>        //开启方式2。赋值一个表达式（匿名方法）
        /*Thread t = new Thread(() =&gt;
       {
           Console.WriteLine(&quot;startDownloadong&quot; + Thread.CurrentThread.ManagedThreadId);
           Thread.Sleep(2000);
           Console.WriteLine(&quot;END&quot;);
       });
        t.Start();*/

        /*//方式1.传递参数
        Thread t = new Thread(Downloading);
        t.Start(&quot;XXX&quot;);//开始执行线程
        Console.WriteLine(&quot;Main&quot;);*/

        //2.创建一个对象，将要传递的数据放到对象里进行传递
        Mythread my = new Mythread(&quot;wei7&quot;, &quot;github.io&quot;);
        Thread t = new Thread(my.DownloadFile);//以类里的普通方法作为线程方法
        t.Start();//开启线程
        Console.ReadKey();
    }
}
</code></pre>
<p>}</p>
<p>//用来传递参数的类<br>
using System;<br>
using System.Collections.Generic;<br>
using System.Text;<br>
using System.Threading;</p>
<p>namespace 线程_通过Thread类开启<br>
{<br>
class Mythread<br>
{<br>
private string filename;<br>
private string filepath;</p>
<pre><code>    public Mythread(string name,string path)
    {
        this.filename = name;
        this.filepath = path;
    }
    public void DownloadFile()
    {
        Console.WriteLine(&quot;开始下载&quot;+filepath+filename);
        Thread.Sleep(2000);
        Console.WriteLine(&quot;下载完成&quot;);
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[委托开启线程]]></title>
        <id>https://Wei715547.github.io/post/wei-tuo-kai-qi-xian-cheng/</id>
        <link href="https://Wei715547.github.io/post/wei-tuo-kai-qi-xian-cheng/">
        </link>
        <updated>2020-05-31T15:05:12.000Z</updated>
        <content type="html"><![CDATA[<p>using System;<br>
using System.Threading;</p>
<p>namespace 线程_委托线程<br>
{<br>
class Program<br>
{<br>
public static int Test1(int i,string str)<br>
{<br>
Console.WriteLine(&quot;Test1&quot;+i+str );<br>
Thread.Sleep(100);//线程休眠 单位ms<br>
return 100;<br>
}<br>
static void Main(string[] args)<br>
{<br>
Func&lt;int,string ,int &gt; a = Test1;<br>
IAsyncResult ar = a.BeginInvoke(100,&quot;wei&quot;,null,null);//VS运行异常<br>
Console.WriteLine(&quot;main&quot;);<br>
while (ar .IsCompleted ==false )//线程是否结束<br>
{<br>
Console.WriteLine(&quot;.&quot;);<br>
}<br>
int res = a.EndInvoke(ar);//异步线程返回值<br>
Console.ReadKey();</p>
<pre><code>        //检测线程结束
        bool isEnd = ar.AsyncWaitHandle.WaitOne(1000);//1000毫秒表示超时，如果等待了1000ms线程还没有结束的时，这个方法会返回false。
        //如在10001ms内结束了则返回的为true。
        if (isEnd )
        {
            int r = a.EndInvoke(ar);
            Console.WriteLine(r);
        }
        Console.ReadKey();
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自定义特性]]></title>
        <id>https://Wei715547.github.io/post/zi-ding-yi-te-xing/</id>
        <link href="https://Wei715547.github.io/post/zi-ding-yi-te-xing/">
        </link>
        <updated>2020-05-30T07:34:50.000Z</updated>
        <content type="html"><![CDATA[<p>using System;<br>
using System.Collections.Generic;<br>
using System.Text;</p>
<p>namespace 自定义特性<br>
{<br>
//1.也行类的后缀以Attribute结尾<br>
//2.需要继承自:System.Attribute<br>
//3.一般情况下声明为 sealed(不需要被继承)<br>
//4.一般情况下特性类用来表示目标结构的一些状态（定义一些字段/属性，一般不需要定义方法）<br>
[AttributeUsage(AttributeTargets.Class)]//表示特性类的使用目标,(表示特性类可以应用到程序的那些结构)<br>
sealed class MyTestAttribute :System.Attribute<br>
{<br>
public string Description { get; set; }<br>
public string VersionNumber { get; set; }<br>
public int ID { get; set; }</p>
<pre><code>    public MyTestAttribute(string des)
    {
        Description = des;
    }
}
</code></pre>
<p>}<br>
//---------------------------------使用---------------------<br>
using System;</p>
<p>namespace 自定义特性<br>
{<br>
[MyTest(&quot;自定义特性类&quot;,ID = 100)]<br>
class Program<br>
{<br>
static void Main(string[] args)<br>
{<br>
Type type = typeof(Program);//通过typeof+类名，获取类的type对象<br>
object[] array = type.GetCustomAttributes(false);//获取类的所有特性（false）不包括父类的<br>
MyTestAttribute mytest = array[0] as MyTestAttribute;<br>
Console.WriteLine(mytest.Description);<br>
Console.WriteLine(mytest .ID );<br>
}<br>
}<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Conditional特性(方法)，调用者信息特性(字段/属性)，DebuggerStepThrough(方法）)]]></title>
        <id>https://Wei715547.github.io/post/conditional-te-xing/</id>
        <link href="https://Wei715547.github.io/post/conditional-te-xing/">
        </link>
        <updated>2020-05-30T06:39:19.000Z</updated>
        <content type="html"><![CDATA[<p>//#define Istest //定义一个宏</p>
<p>using System;<br>
using System.Diagnostics;</p>
<p>namespace Contional特性//禁用方法<br>
{<br>
class Program<br>
{<br>
[Conditional(&quot;IsTest&quot;)]//宏被定义时，方法才可被调用(方法仍会被编译放入程序集当中)<br>
static void Text1()<br>
{<br>
Console.WriteLine(&quot;Text1&quot;);<br>
}</p>
<pre><code>    static void Text2()
    {
        Console.WriteLine(&quot;Text2&quot;);
    }
</code></pre>
<p>//调用者信息特性，DebuggerStepThrough特性<br>
[DebuggerStepThrough]//可以跳过Debugger的单步调试 调试时略过该方法(确定该方法无错误是可以使用)<br>
static void PrintOut(string str,<br>
[CallerFilePath]string fileName=&quot;&quot;,[CallerLineNumber]int lineNumber=0,[CallerMemberName]string methodName=&quot;&quot;)<br>
{<br>
Console.WriteLine(str);<br>
Console.WriteLine(fileName);//调用者文件路径<br>
Console.WriteLine(lineNumber);//调用行<br>
Console.WriteLine(methodName);//调用方法名<br>
}</p>
<pre><code>    static void Main(string[] args)
    {
        Text1();
        Text1();
        Text2();

        PrintOut(&quot;123&quot;);//断点
    }
}
</code></pre>
<p>}<br>
<img src="https://Wei715547.github.io/post-images/1590822404207.jpg" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1590822413420.jpg" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[反射特性]]></title>
        <id>https://Wei715547.github.io/post/fan-she-te-xing/</id>
        <link href="https://Wei715547.github.io/post/fan-she-te-xing/">
        </link>
        <updated>2020-05-30T03:57:11.000Z</updated>
        <content type="html"><![CDATA[<p>using System;<br>
using System.Reflection;</p>
<p>namespace 反射与特性<br>
{<br>
class Program<br>
{<br>
[Obsolete(&quot;过时的方法，请使用新的方法&quot;)]//弃用标记特性 Obsolete<br>
static void OldNethod()<br>
{<br>
Console.WriteLine(&quot;OM&quot;);<br>
}<br>
static void Main(string[] args)<br>
{<br>
MyClass my = new MyClass();<br>
Type type = my.GetType();<br>
Console.WriteLine(type .Name);//类的名字<br>
Console.WriteLine(type .Namespace);//类峰命名空间<br>
Console.WriteLine(type .Assembly );//类峰程序集命名空间</p>
<pre><code>        FieldInfo[] array = type.GetFields();//获取类的字段
        foreach (FieldInfo info in array )
        {
            Console.WriteLine(info .Name+&quot; &quot;);
        }

        PropertyInfo[] array2 = type.GetProperties();//获取类属性
        foreach (PropertyInfo info in array2 )
        {
            Console.WriteLine(info .Name +&quot; &quot;);
        }

        MethodInfo[] array3 = type.GetMethods();//获取类的方法
        foreach (MethodInfo info in array3)
        { 
            Console.WriteLine(info .Name +&quot; &quot;);
        }
</code></pre>
<p>//-----------------------------------------------------------------------------<br>
MyClass my = new MyClass();<br>
Assembly assem = my.GetType().Assembly;//通过类的Type对象，获取它所在的抽象集 Assembly<br>
Console.WriteLine(assem.FullName);<br>
Type[] types = assem.GetTypes();//程序集中所有类的Type对象<br>
foreach (var type in types)<br>
{<br>
Console.WriteLine(type);//利用Type对象输出程序集中所有类名字<br>
}<br>
//OldNethod();<br>
}<br>
}<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[泛型类/方法/委托]]></title>
        <id>https://Wei715547.github.io/post/fan-xing-lei-fang-fa-wei-tuo/</id>
        <link href="https://Wei715547.github.io/post/fan-xing-lei-fang-fa-wei-tuo/">
        </link>
        <updated>2020-05-30T02:55:40.000Z</updated>
        <content type="html"><![CDATA[<p>using System;<br>
using System.Collections.Generic;<br>
using System.Text;</p>
<p>namespace 泛型类<br>
{<br>
//泛型类<br>
class ClassA<T><br>
{<br>
private T a;<br>
private T b;</p>
<pre><code>    public ClassA (T a,T b)
    {
        this.a = a;
        this.b = b;
    }

    public string Show()
    {
        return a +&quot; &quot;+ b;
    }

}
</code></pre>
<h2 id="">}</h2>
<p>/*using System;</p>
<p>namespace 泛型类<br>
{<br>
class Program<br>
{<br>
public static string  GetSum&lt;T,T2,T3&gt;(T a,T b)//泛型方法,可指定多个泛型，在调用是指定类型<br>
{<br>
return a +&quot; &quot;+ b;<br>
}</p>
<pre><code>    static void Main(string[] args)
    {

        var o1 = new ClassA &lt;int&gt;(22,53);

        Console.WriteLine(  o1.Show());

        var s1 = new ClassA&lt;string&gt;(&quot;wei&quot;, &quot;715&quot;);

        Console.WriteLine(s1.Show());

        Console.WriteLine(GetSum &lt;int ,int ,int &gt;(123,314));//有多个泛型时，调用要指定所有类型
        Console.WriteLine( GetSum&lt;string ,string ,string &gt; (&quot;da&quot;,&quot;werr&quot;));


        //Console.ReadKey();

    }
}
</code></pre>
<p>}*/<br>
using System;<br>
using System.Collections.Generic;</p>
<p>//泛型委托<br>
delegate T NumberChanger<T>(T n);//返回值与参数类型为T<br>
namespace GenericDelegateAppl<br>
{<br>
class TestDelegate<br>
{<br>
static int num = 10;<br>
public static int AddNum(int p)<br>
{<br>
num += p;<br>
return num;<br>
}</p>
<pre><code>    public static int MultNum(int q)
    {
        num *= q;
        return num;
    }
    public static int getNum()
    {
        return num;
    }

    static void Main(string[] args)
    {
        // 创建委托实例
        //NumberChanger&lt;int&gt; nc1 = new NumberChanger&lt;int&gt;(AddNum);
        NumberChanger&lt;int&gt; nc1 = AddNum;//上一行简写
        NumberChanger&lt;int&gt; nc2 = new NumberChanger&lt;int&gt;(MultNum);
        // 使用委托对象调用方法
        nc1(25);
        Console.WriteLine(&quot;Value of Num: {0}&quot;, getNum());
        nc2(5);
        Console.WriteLine(&quot;Value of Num: {0}&quot;, getNum());
        Console.ReadKey();
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[长按/下蹲状态跳跃增量]]></title>
        <id>https://Wei715547.github.io/post/chang-an-xia-dun-zhuang-tai-tiao-yue-zeng-liang/</id>
        <link href="https://Wei715547.github.io/post/chang-an-xia-dun-zhuang-tai-tiao-yue-zeng-liang/">
        </link>
        <updated>2020-05-29T14:58:33.000Z</updated>
        <content type="html"><![CDATA[<p>public void MidAirMovement()<br>
{<br>
if (jumpPressed&amp;&amp;isOnground &amp;&amp;!isJump&amp;&amp;!isHeadBlocked )//普通状态--在地面上，非跳跃状态，上部没有遮挡、按下跳跃键<br>
{<br>
if (isCrouch)//下蹲状态，增量<br>
{<br>
StandUp();<br>
playerRGB.AddForce(Vector2.up * crouchJumpBoost, ForceMode2D.Impulse);//F1+F2<br>
}<br>
isOnground = false;<br>
isJump = true;<br>
jumpTime = Time.time + jumpHodeDuration;<br>
playerRGB.AddForce(Vector2.up * jumpForce, ForceMode2D.Impulse);//F1<br>
}<br>
else if (isJump )//长按状态<br>
{<br>
if (jumpHeld)//长按跳跃键<br>
playerRGB.AddForce(Vector2.up * jumpHpdeFpoce, ForceMode2D.Impulse);//F1+F3<br>
if (jumpTime &lt; Time.time)<br>
isJump = false;<br>
}<br>
}</p>
]]></content>
    </entry>
</feed>