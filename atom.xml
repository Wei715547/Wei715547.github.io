<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Wei715547.github.io</id>
    <title>Weiwei的个人网站</title>
    <updated>2020-04-05T05:58:18.822Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Wei715547.github.io"/>
    <link rel="self" href="https://Wei715547.github.io/atom.xml"/>
    <subtitle>7</subtitle>
    <logo>https://Wei715547.github.io/images/avatar.png</logo>
    <icon>https://Wei715547.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Weiwei的个人网站</rights>
    <entry>
        <title type="html"><![CDATA[俯视较移动旋转]]></title>
        <id>https://Wei715547.github.io/post/fu-shi-jiao-yi-dong-xuan-zhuan/</id>
        <link href="https://Wei715547.github.io/post/fu-shi-jiao-yi-dong-xuan-zhuan/">
        </link>
        <updated>2020-04-05T05:57:42.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class Move : MonoBehaviour<br>
{<br>
public float speed = 5;<br>
private void Update()<br>
{<br>
float v = Input.GetAxis(&quot;Vertical&quot;);<br>
float h = Input.GetAxis(&quot;Horizontal&quot;);<br>
if (v != 0 || h != 0)<br>
Movement(v, h);<br>
}<br>
private void Movement(float v, float h)<br>
{<br>
this.transform.Translate(0, 0, speed*Time .deltaTime );<br>
Quaternion dir = Quaternion.LookRotation(new Vector3(h, 0, v));<br>
this.transform.rotation =<br>
Quaternion.Lerp(this.transform.rotation, dir, 0.1f);<br>
}<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Boom向量/三角函数应用]]></title>
        <id>https://Wei715547.github.io/post/boom-xiang-liang-san-jiao-han-shu-ying-yong/</id>
        <link href="https://Wei715547.github.io/post/boom-xiang-liang-san-jiao-han-shu-ying-yong/">
        </link>
        <updated>2020-04-04T14:34:23.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class Boom : MonoBehaviour<br>
{<br>
public GameObject player;<br>
private Vector3 dp;<br>
//private Vector3 ldp;<br>
private Vector3 liftdp;<br>
private Vector3 rightdp;<br>
private float dt;<br>
private float sin;<br>
private float rd;<br>
// Start is called before the first frame update<br>
void Start()<br>
{<br>
rd = player.GetComponent<CapsuleCollider>().radius ;<br>
}</p>
<pre><code>// Update is called once per frame
void Update()
{
    Draw();
}

private void VectorCt()
{
    
    dp = player.transform.position - this.transform.position;
    dt = dp.magnitude;
    sin = Mathf.Rad2Deg * Mathf.Asin(rd / dt);
    //ldp = Quaternion.Euler(0, sin, 0) *dp.normalized * dt * Mathf.Cos(sin);
    liftdp = this.transform.position + Quaternion.Euler(0, sin, 0) * dp;
   
    rightdp = this.transform.position + Quaternion.Euler(0, -sin, 0) * dp;
    
}

private void CalculateTangent()
{
    Vector3 playerToBoom = this.transform.position - player.transform.position;
    Vector3 playerToExplpsionDirection = playerToBoom.normalized * rd;
    float angle = Mathf.Acos(rd / playerToBoom.magnitude) * Mathf.Rad2Deg;
    liftdp = player.transform.position + Quaternion.Euler(0, -angle , 0) * playerToExplpsionDirection;
    rightdp = player.transform.position + Quaternion.Euler(0, angle, 0) * playerToExplpsionDirection;

}

private void Draw()
{
    //VectorCt();
    CalculateTangent();
    Debug.DrawLine(this.transform.position, player.transform.position);
    Debug.DrawLine(this.transform.position, liftdp,Color .blue );
    Debug.DrawLine(this.transform.position, rightdp,Color .red );
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[四元数API]]></title>
        <id>https://Wei715547.github.io/post/si-yuan-shu-api/</id>
        <link href="https://Wei715547.github.io/post/si-yuan-shu-api/">
        </link>
        <updated>2020-04-04T14:33:23.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class QuaternionAPI : MonoBehaviour<br>
{<br>
public Transform  tf;<br>
public AnimationCurve a;<br>
private float x;</p>
<pre><code>private void OnGUI()
{
    if (GUILayout.Button (&quot;&quot;))
    {
        //1.欧拉角转换为四元数
        //Quaternion.Euler(欧拉角);

        //2/四元数转欧拉角
        Quaternion qt = this.transform.rotation;
        Vector3 auler = qt.eulerAngles;

        //3.轴/角
        //Quaternion.Euler(0, 50, 0);
        this .transform .rotation = Quaternion.AngleAxis(50, Vector3.up);

    }
    
    if (GUILayout.Button(&quot;LookRotation&quot;))
    {
        //4.注视旋转
        //Z轴指向一个方向
        //当前物体注视 tf 旋转
        Vector3 dir = tf.position - this.transform.position;
        this.transform.rotation  = Quaternion.LookRotation (dir);
        //this.transform.LookAt(tf);//效果与上两行代码相同----下一帧立即执行

    }

    if (GUILayout.RepeatButton(&quot;LookRotationLerp&quot;))
    {
        //5.插值旋转
        x += Time.deltaTime;
        Quaternion dir = Quaternion.LookRotation(tf.position - this.transform.position);            
        this .transform .rotation = Quaternion.Lerp(this.transform.rotation, dir, a.Evaluate (x));

        //6.匀速旋转
        //this.transform.rotation = Quaternion.RotateTowards(this.transform.rotation, dir, 0.1f);//匀速朝向旋转
    }

    if (GUILayout.RepeatButton(&quot;AngleR90&quot;))
    {
        Quaternion dir = Quaternion.Euler(0, 90, 0);
        this.transform.rotation =
            Quaternion.Lerp(this.transform.rotation, dir, 0.1f);
        //7.如果当前旋转角度 接近目标旋转角度
        if (Quaternion .Angle (this .transform .rotation ,dir )&lt;10)
        {
            this.transform.rotation = dir;
        }
    }

    if (GUILayout.RepeatButton(&quot;Right&quot;))
    {
        //8.x轴注视旋转 t1
        //this.transform.right = tf.position - this.transform.position;
        //x正方向---注视目标物体方向
        Quaternion dir = Quaternion.FromToRotation(Vector3 .right  , tf.position - this.transform.position);
        //this.transform.rotation = dir;
        this.transform.rotation = Quaternion.Lerp(this.transform.rotation, dir, 0.1f);


    }
}

// Update is called once per frame
void Update()
{
    
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[向量API]]></title>
        <id>https://Wei715547.github.io/post/xiang-liang-api/</id>
        <link href="https://Wei715547.github.io/post/xiang-liang-api/">
        </link>
        <updated>2020-04-04T14:33:02.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class VectorAPI : MonoBehaviour<br>
{<br>
public AnimationCurve cuver;<br>
private float x;<br>
public  float psTime=3;<br>
private Vector3 targetPoint = new Vector3 (0, 0, 10);<br>
private void OnGUI()<br>
{<br>
if (GUILayout.RepeatButton (&quot;Move&quot;))<br>
{<br>
//将物体移动至（0，0,10）<br>
//匀速移动<br>
this.transform.position = Vector3.MoveTowards(this.transform.position,targetPoint , 2);<br>
//先快后慢--终点与比例固定<br>
this.transform.position = Vector3.Lerp (this.transform.position, targetPoint , 2 );</p>
<pre><code>    }
    if (GUILayout.RepeatButton(&quot;Lerp&quot;))
    {
        x += Time.deltaTime/psTime ;
        //自然变化，起点，终点固定，比例根据曲线变化
        this.transform.position =
            Vector3.LerpUnclamped (Vector3.zero, targetPoint, cuver.Evaluate(x));
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第一人称镜头旋转]]></title>
        <id>https://Wei715547.github.io/post/di-yi-ren-cheng-jing-tou-xuan-zhuan/</id>
        <link href="https://Wei715547.github.io/post/di-yi-ren-cheng-jing-tou-xuan-zhuan/">
        </link>
        <updated>2020-04-04T14:31:08.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
/// <summary><br>
/// 控制摄像机随鼠标旋转<br>
/// </summary><br>
public class DoRotation : MonoBehaviour<br>
{<br>
public float rotateSpeed = 1;<br>
private void FixedUpdate()<br>
{<br>
float x = Input.GetAxis(&quot;Mouse X&quot;);<br>
float y = Input.GetAxis(&quot;Mouse Y&quot;);</p>
<pre><code>    if (x!=0||y!=0)
    RotateView(x, y);
}

private void RotateView(float x, float y)
{
    x *= rotateSpeed;
    y *= rotateSpeed;

    this.transform.Rotate(0, x, 0, Space.World);//左右旋转按照世界坐标
    //this.transform.Rotate(-y, 0, 0, Space.Self);//上下旋转按自身坐标
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[镜头缩放]]></title>
        <id>https://Wei715547.github.io/post/jing-tou-suo-fang/</id>
        <link href="https://Wei715547.github.io/post/jing-tou-suo-fang/">
        </link>
        <updated>2020-04-04T14:30:16.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
/// <summary><br>
/// 镜头缩放<br>
/// </summary><br>
public class CareamZoom : MonoBehaviour<br>
{<br>
public bool isDown;<br>
public bool keyDown;<br>
public bool cvDown;<br>
public Transform l1;</p>
<pre><code>public bool isFar = true;
private Camera camera;

public int[] zoomLevel;
private int index;
private Vector3 lo;
private Quaternion ro;



private void Start()
{
    camera = GetComponent&lt;Camera&gt;();
    lo = this.transform.position;
    ro = this.transform.rotation;
}

private void Update()
{
    isDown = Input.GetMouseButton(0);//左键

    keyDown = Input.GetKey(KeyCode.Q);

    CamerPosition();

    if (keyDown)
        Zoom4();


    cvDown = Input.GetKey(KeyCode.C) &amp;&amp; Input.GetKey(KeyCode.V);


}

private void CamerPosition()
{

    if (keyDown)
    {
        this.transform.position = this.transform.parent.position;
        this.transform.rotation = this.transform.parent.rotation;
    }
    else
    {
        this.transform.position = l1.position;
        this.transform.rotation = l1.rotation;
        index = 0;
        camera.fieldOfView = zoomLevel[index ];
    }
}

private void Zoom1()
{
    if (Input.GetMouseButtonDown(1))
    {
        //拉近：10
        isFar = !isFar;

        if (isFar)
        {
            camera.fieldOfView = 50;
            //拉远：50
        }
        else
        {
            camera.fieldOfView = 10;
        }

    }
}

private void Zoom2()
{
    if (Input.GetMouseButtonDown(1))
    {
        isFar = !isFar;
    }
    if (isFar)
    {
        if (camera.fieldOfView &lt; 50)
            camera.fieldOfView += 2;
        //拉远：10--&gt;50
    }
    else
    {
        //拉近：50--&gt;10
        if (camera.fieldOfView &gt; 10)
            camera.fieldOfView -= 2;
    }
}

private void Zoom3()//先快后慢 Lerp (起点，终点，比例0.1)第一次返回起点到终点0.1的值
{
    if (Input.GetMouseButtonDown(1))
    {
        isFar = !isFar;
    }
    if (isFar)
    {
        //拉远：10--&gt;50
        camera.fieldOfView = Mathf.Lerp(camera.fieldOfView, 50, 0.1f);//无限接近50，不等于
        if (Mathf.Abs(camera.fieldOfView - 50) &lt; 0.1) camera.fieldOfView = 50;//使无限接近时，等于
    }
    else
    {
        //拉近：50--&gt;10
        camera.fieldOfView = Mathf.Lerp(camera.fieldOfView, 10, 0.1f);
        if (Mathf.Abs(camera.fieldOfView - 10) &lt; 0.1) camera.fieldOfView = 10;
    }
}

private void Zoom4()//
{
    if (Input.GetMouseButtonDown(1))
    {
        //index = index &lt; zoomLevel.Length - 1 ? index + 1 : 0;
        index = (index + 1) % zoomLevel.Length;
        //index++;
        //if (index &gt;= zoomLevel.Length)
        //index = 0;
    }

    camera.fieldOfView = Mathf.Lerp(camera.fieldOfView, zoomLevel[index], 0.1f);//无限接近50，不等于
    if (Mathf.Abs(camera.fieldOfView - zoomLevel[index]) &lt; 0.1) camera.fieldOfView = zoomLevel[index];//使无限接近时，等于

}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Time类]]></title>
        <id>https://Wei715547.github.io/post/time-lei/</id>
        <link href="https://Wei715547.github.io/post/time-lei/">
        </link>
        <updated>2020-04-04T14:29:07.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class TimeDemo : MonoBehaviour<br>
{<br>
public float deltatime;<br>
public float unscaledeltatime;<br>
public float time;<br>
public float unscaledtime;<br>
public float c;<br>
public float speed = 100;<br>
private void Update()<br>
{<br>
deltatime = Time.deltaTime;//受TimeScale影响的每帧间隔时间<br>
unscaledeltatime = Time.unscaledDeltaTime;//不受TimeScale影响每帧间隔时间</p>
<pre><code>    time = Time.time;//受TimeScale影响的游戏运行时间
    unscaledtime = Time.unscaledTime;//不受TimeScale影响的游戏运行时间
    c = Time.realtimeSinceStartup;//实际的游戏运行时间

    //每渲染帧 执行1次，旋转1度
    //this.transform.Rotate(0, 1, 0);
    //1秒旋转 ？度
    //帧多 1秒旋转速度快        希望1帧旋转量小
    //少     慢                     大
    //this.transform.Rotate(0, speed *Time .deltaTime, 0);
    //当旋移动/转速度*每帧消耗时间，可以保证旋转速度不受机器性能，及渲染影响。

    //个别物体不受影响 代码要放到updata中 spee * Time.unscaledDeltaTime 不受缩放影响的每帧间隔
    this.transform.Rotate(0, speed * Time.unscaledDeltaTime , 0);

}
//固定0.02s 执行一次，与渲染无关，受TimeScale影响
public void FixedUpdate()
{
    //this.transform.Rotate(0, speed, 0);
}

//游戏暂停  个别物体不受影响  代码要放到updata中

private void OnGUI()
{
    if (GUILayout .Button (&quot;暂停游戏&quot;))
    {
        Time.timeScale = 0;
    }

    if(GUILayout.Button(&quot;继续游戏&quot;))
    {
        Time.timeScale = 1;
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[获取同类物体]]></title>
        <id>https://Wei715547.github.io/post/huo-qu-tong-lei-wu-ti/</id>
        <link href="https://Wei715547.github.io/post/huo-qu-tong-lei-wu-ti/">
        </link>
        <updated>2020-04-04T14:28:03.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class FindEnemyDeom : MonoBehaviour<br>
{</p>
<pre><code>private void OnGUI()
{
    if (GUILayout .Button (&quot;查找血量最低的敌人&quot;))
    {
        //查找场景中所有Enemy类型的引用
        Enemy[] allEnemy = Object.FindObjectsOfType&lt;Enemy&gt;();
        //获取血量最低的对象的引用
        Enemy min = FindEnemyByMinHp(allEnemy);
        //根据Enemy类型的引用 获取其他组件类型引用
        min.GetComponent&lt;MeshRenderer&gt;().material.color = Color.blue;
    }
    if (GUILayout.Button (&quot;层级位置获取子物体&quot;))
    {
        var childTF = TransformHelper.GetChild(this.transform , &quot;Cube3&quot;);
        childTF.GetComponent&lt;MeshRenderer&gt;().material.color = Color.blue;
        //print(childTF.name);
        
    }
}

public Enemy FindEnemyByMinHp(Enemy [] allEnemy)
{
    Enemy min = allEnemy[0];

    for (int i = 1; i &lt; allEnemy .Length ; i++)
    {
        if (min.Hp &gt; allEnemy[i].Hp)
            min = allEnemy[i];
    }
    return min;

}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[点击+/-播放动画]]></title>
        <id>https://Wei715547.github.io/post/dian-ji-bo-fang-dong-hua/</id>
        <link href="https://Wei715547.github.io/post/dian-ji-bo-fang-dong-hua/">
        </link>
        <updated>2020-04-04T14:25:03.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
/// <summary><br>
/// 门<br>
/// </summary><br>
public class Door : MonoBehaviour<br>
{</p>
<pre><code>public bool doorStart = false ;

public string animName = &quot;Door&quot;;

private Animation anim;

private void Start()
{
    anim = GetComponent&lt;Animation&gt;();
}

//点击当前物体是调用
private void OnMouseDown()
{
    //如果开门状态
    if (doorStart)
    {
        //关门
        if (anim.isPlaying == false)
        {
            anim[animName].time = anim[animName].length;//从最后开始播
        }

        anim[animName].speed = -1;//倒叙播放
    }
    else
    {          
        //开门
        anim[animName].speed = 1;
    }
    //播放动画
    anim.Play(animName);
    doorStart =! doorStart;
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[倒计时-每隔固定时间重复执行]]></title>
        <id>https://Wei715547.github.io/post/dao-ji-shi-mei-ge-gu-ding-shi-jian-chong-fu-zhi-xing/</id>
        <link href="https://Wei715547.github.io/post/dao-ji-shi-mei-ge-gu-ding-shi-jian-chong-fu-zhi-xing/">
        </link>
        <updated>2020-04-04T14:23:32.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.UI;<br>
/// <summary><br>
/// 倒计时<br>
/// </summary><br>
public class CountdownTimer : MonoBehaviour<br>
{<br>
//需求：1秒修改1次Text文本内容<br>
//1.查找组件引用<br>
//2.定义变量秒second<br>
//3.120 --&gt;  02:00<br>
//4.修改文本</p>
<pre><code>private Text textTimer;
public int second = 120;
private void Start()
{
    textTimer = GetComponent&lt;Text&gt;();
    //Time3
    //重复调用（被执行的方法名称，第一次执行时机，每次执行间隔）
    InvokeRepeating(&quot;Timer3&quot;, 1, 1);
    //invoke(被执行的方法，开始调用时机);

}



private void Update()
{
    //Timer2();
}

private float nextTime = 1;//下次修改时间
//方法1：Time.time
//先做 再等
private void Timer1()
{
    //如果到了修改时间
    if (Time.time &gt; nextTime)
    {
        second--;
        textTimer.text = string.Format(&quot;{0:d2}:{1:d2}&quot;, second / 60, second % 60);

        if (second &lt;= 10)
        {
            this.textTimer.color = Color.red;
        }

        //设置下次修改时间
        nextTime = Time.time + 1;
    }
}

private float totalTime;
//方法2：Time.deltatime
//先等 再做
private void Timer2()
{
    //累加每帧间隔
    totalTime += Time.deltaTime;

    if (totalTime &gt;= 1)
    {
        second--;
        textTimer.text = string.Format(&quot;{0:d2}:{1:d2}&quot;, second / 60, second % 60);

        if (second &lt;= 10)
        {
            this.textTimer.color = Color.red;
        }

        totalTime = 0;
    }
   

}

//方法3：invoke()
//每隔固定时间，重复执行
private void Timer3()
{

    second--;
    textTimer.text = string.Format(&quot;{0:d2}:{1:d2}&quot;, second / 60, second % 60);

    if (second &lt;= 10)
    {
        this.textTimer.color = Color.red;
    }

    if (second &lt;=0)
    {
        //print(&quot;stop&quot;);
        CancelInvoke(&quot;Timer3&quot; );//取消方法调用
    }

}

//5.如何一秒修改一次
//重点：在Updata每帧执行的方法中，个别语句实现制定间隔执行一次
</code></pre>
<p>}</p>
]]></content>
    </entry>
</feed>