<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Wei715547.github.io</id>
    <title>Wei: Development technology accumulation</title>
    <updated>2020-06-12T07:49:52.407Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Wei715547.github.io"/>
    <link rel="self" href="https://Wei715547.github.io/atom.xml"/>
    <subtitle>年月增长，我宜强盛。
用于Unity+开发的技术积累</subtitle>
    <logo>https://Wei715547.github.io/images/avatar.png</logo>
    <icon>https://Wei715547.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Wei: Development technology accumulation</rights>
    <entry>
        <title type="html"><![CDATA[Next Scence Don't Destroy]]></title>
        <id>https://Wei715547.github.io/post/next-scence-dont-destroy/</id>
        <link href="https://Wei715547.github.io/post/next-scence-dont-destroy/">
        </link>
        <updated>2020-06-11T08:38:18.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class CanvasDS : MonoBehaviour<br>
{<br>
//声明单例，判断其在场景中是否已存在（被赋值）<br>
public static CanvasDS instance;</p>
<pre><code>void Awake()
{
    if (instance != null)
    {
        Destroy(gameObject);//已存在与场景中时销毁此对象，保证场景中只有一个此类对象
        return;
    }
    instance = this;
    DontDestroyOnLoad(this);
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Audio Mixer]]></title>
        <id>https://Wei715547.github.io/post/audio-mixer/</id>
        <link href="https://Wei715547.github.io/post/audio-mixer/">
        </link>
        <updated>2020-06-11T02:36:35.000Z</updated>
        <content type="html"><![CDATA[<p>void Awake()<br>
{<br>
//Nomal Slider Ct<br>
Vo.value = FindObjectOfType<AudioSource>().volume;</p>
<pre><code>    //Pvo = transform.Find(&quot;Player_Slider&quot;).GetComponent&lt;Slider&gt;();

    auM.GetFloat(&quot;MainVolume&quot;,out float v);
    Pvo.value = v;//Audio Mixer output value  to Slider
}

private void Update()
{
    //Panel enable update the value
    FindObjectOfType&lt;AudioSource&gt;().volume = Vo.value;
    auM .SetFloat(&quot;MainVolume&quot;, Pvo.value);
}
</code></pre>
<p><img src="https://Wei715547.github.io/post-images/1591860911716.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1591860919096.PNG" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UI图标冷却]]></title>
        <id>https://Wei715547.github.io/post/ui-tu-biao-leng-que/</id>
        <link href="https://Wei715547.github.io/post/ui-tu-biao-leng-que/">
        </link>
        <updated>2020-06-11T02:23:02.000Z</updated>
        <content type="html"><![CDATA[<p>private void FixedUpdate()<br>
{<br>
coodTime += Time.deltaTime;</p>
<pre><code>    if (Input.GetKeyDown(KeyCode.Z) &amp;&amp; coodTime &gt; setcoodtime)
    {
        au.PlayOneShot(russ, 1f);
        Russing();
        coodTime = 0;
    }
}

// Update is called once per frame
void Update()
{
    //UI显示
    if (coodTime &gt; setcoodtime)
    {
        coodUI.fillAmount = 0;
    }else
    {
        coodUI.fillAmount = 1-coodTime/setcoodtime ;
    }
}
![](https://Wei715547.github.io/post-images/1591842421156.PNG)</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Post Process Effect/Camer Shake]]></title>
        <id>https://Wei715547.github.io/post/post-process-effectcamer-shake/</id>
        <link href="https://Wei715547.github.io/post/post-process-effectcamer-shake/">
        </link>
        <updated>2020-06-07T07:05:12.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://Wei715547.github.io/post-images/1591513702359.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1591513708909.PNG" alt="" loading="lazy"></p>
<p><img src="https://Wei715547.github.io/post-images/1591514562757.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1591514569006.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1591514575527.PNG" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C#中调用Lua程序]]></title>
        <id>https://Wei715547.github.io/post/czhong-diao-yong-lua-cheng-xu/</id>
        <link href="https://Wei715547.github.io/post/czhong-diao-yong-lua-cheng-xu/">
        </link>
        <updated>2020-06-07T04:56:04.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using XLua;<br>
public class HW2 : MonoBehaviour<br>
{<br>
// Start is called before the first frame update<br>
void Start()<br>
{<br>
//1.通过资源加载执行Lua程序<br>
/<em>TextAsset ta = Resources.Load<TextAsset>(&quot;面向对象实现.lua&quot;);<br>
//print(ta);<br>
LuaEnv env = new LuaEnv();<br>
env.DoString(ta.text);<br>
env.Dispose();</em>/</p>
<pre><code>    //2.通过require 'XXX'执行Lua程序
    LuaEnv env = new LuaEnv();
    env.DoString(&quot;require '面向对象实现'&quot;);
    //访问Lua中的全局变量
    /*int num = env.Global.Get&lt;int&gt;(&quot;num1&quot;);
    print(num);
    string s = env.Global.Get&lt;string&gt;(&quot;str&quot;);
    print(s);
    bool t = env.Global.Get&lt;bool&gt;(&quot;isOn&quot;);
    print(t);*/
    //env.Dispose();

    //映射到类
    /*Person p = env.Global.Get&lt;Person&gt;(&quot;person&quot;);//值拷贝，耗费性能，
    print(p.name + &quot;-&quot; + p.age);
    p.name = &quot;ZZ&quot;;
    env.DoString(&quot;print(person.name)&quot;);//不改变Lua中的变量值*/

    //映射到接口
    IPerson p = env.Global.Get&lt;IPerson&gt;(&quot;person&quot;);//引用拷贝，可改变Lua中的值
    print(p.name + &quot;-&quot; + p.age);
    p.name = &quot;ZL&quot;;
    env.DoString(&quot;print(person.name)&quot;);

    env.Dispose();

}

//将Lua中的table映射到类（耗费性能）
class Person
{
    public string name;
    public int age;
}

//将Lua中的变量映射到接口
[CSharpCallLua]
interface IPerson
{
    string name { get; set; }
    int age { get; set; }

}
</code></pre>
<p>}</p>
<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using System.IO;<br>
using UnityEngine;<br>
using XLua;<br>
public class Loader : MonoBehaviour<br>
{<br>
// Start is called before the first frame update<br>
void Start()<br>
{<br>
LuaEnv env = new LuaEnv();</p>
<pre><code>    env.AddLoader(MyLoader);//先执行自定义的Loader，自定义Loader中有返回Lua程序时，将不再执行系统加载的Lua程序
    env.DoString(&quot;require 'text01'&quot;);//加载的文件会传递给Lodader
    env.Dispose();
}
</code></pre>
<p>//自定义Loader<br>
private byte [] MyLoader(ref string filePath)<br>
{<br>
print(filePath);</p>
<pre><code>    //通过自定义Loader返回Lua程序
    //string s = &quot;print(123)&quot;;
    //return System .Text .Encoding.UTF8 .GetBytes (s);

    print(Application.streamingAssetsPath);

    //通过路径读取返回Lua程序
    string absPath = Application.streamingAssetsPath + &quot;/&quot; + filePath + &quot;.lua.txt&quot;;
    return System.Text.Encoding.UTF8.GetBytes(File.ReadAllText( absPath));
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[生命周期]]></title>
        <id>https://Wei715547.github.io/post/sheng-ming-zhou-qi/</id>
        <link href="https://Wei715547.github.io/post/sheng-ming-zhou-qi/">
        </link>
        <updated>2020-06-06T08:23:03.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://Wei715547.github.io/post-images/1591431791506.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[视角缩放/跟随]]></title>
        <id>https://Wei715547.github.io/post/shi-jiao-suo-fang-gen-sui/</id>
        <link href="https://Wei715547.github.io/post/shi-jiao-suo-fang-gen-sui/">
        </link>
        <updated>2020-06-06T05:34:56.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class CamerCT : MonoBehaviour<br>
{<br>
public Transform target;<br>
public Vector3 offset;</p>
<pre><code>//视角范围，缩放速度
public float zoomSpeed = 4f;
public float minZoom = 5f;
public float maxZoom = 10f;

public float pitch=2f;//视角高度值

private float currentZoom = 10f;//焦距

public float YawSpeed = 100f;//旋转速度
private float currentYaw = 0f;//旋转角度

// Update is called once per frame
void Update()
{
    currentZoom -= Input.GetAxis(&quot;Mouse ScrollWheel&quot;)*zoomSpeed *Time .deltaTime;
    currentZoom = Mathf.Clamp(currentZoom, minZoom, maxZoom);//限定缩放范围

    currentYaw += Input.GetAxis(&quot;Horizontal&quot;) * YawSpeed * Time.deltaTime;

}

private void LateUpdate()
{
    transform.position = target.position - offset * currentZoom;
    transform.LookAt(target.position + Vector3.up*pitch);

    transform.RotateAround(target.position, Vector3.up, currentYaw);
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自动寻路]]></title>
        <id>https://Wei715547.github.io/post/zi-dong-xun-lu/</id>
        <link href="https://Wei715547.github.io/post/zi-dong-xun-lu/">
        </link>
        <updated>2020-06-06T04:58:09.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.AI;</p>
<p>public class PlayerCT : MonoBehaviour<br>
{</p>
<pre><code>public LayerMask movementMask;
NavMeshAgent navMeshAgent;

// Start is called before the first frame update
void Start()
{
    animator = this.transform.GetComponent&lt;Animator&gt;();
    navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();
}

// Update is called once per frame
void Update()
{
    if (Input.GetMouseButtonDown(1))
    {
        Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
        RaycastHit hit;
        if (!Physics.Raycast(ray, out hit,100,movementMask))
        {
            //hit.collider .gameObject //射线打到的物体
            return;
        }
        navMeshAgent.destination = hit.point;
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[File类，R/W]]></title>
        <id>https://Wei715547.github.io/post/file-lei-rw/</id>
        <link href="https://Wei715547.github.io/post/file-lei-rw/">
        </link>
        <updated>2020-06-03T15:48:34.000Z</updated>
        <content type="html"><![CDATA[<p>using System;<br>
using System.IO;</p>
<p>namespace FileClass_Read_and_Wright<br>
{<br>
class Program<br>
{<br>
static void Main(string[] args)<br>
{<br>
/<em>string[] strarray = File.ReadAllLines(&quot;TextFile1.txt&quot;);//读取文件，把每一行文本文件读取成一个字符串，<br>
//最后主城一个字符串数组<br>
foreach (var s in strarray )<br>
{<br>
Console.WriteLine(s);<br>
}</em>/</p>
<pre><code>        /*string s = File.ReadAllText(&quot;TextFile1.txt&quot;);
        Console.WriteLine(s);*/

        byte[] byteArray = File.ReadAllBytes(&quot;20191103200554.jpg&quot;);
        foreach (var b in byteArray)
        {
            Console.Write(b);
        }

        /*File.WriteAllText(&quot;TextFile2.txt&quot;, &quot;WEI&quot;);

        File.WriteAllLines(&quot;TextFile3.txt&quot;, new string[] { &quot;wei&quot;, &quot;zzz&quot; });*/

        //读取文件二进制数据
        //byte[] data = File.ReadAllBytes(&quot;20191103200554.jpg&quot;);
        //写入文件二进制数据（复制）
        //File.WriteAllBytes(&quot;1.png&quot;, data);

    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Socket客户端端口]]></title>
        <id>https://Wei715547.github.io/post/socket-ke-hu-duan-duan-kou/</id>
        <link href="https://Wei715547.github.io/post/socket-ke-hu-duan-duan-kou/">
        </link>
        <updated>2020-06-02T05:45:10.000Z</updated>
        <content type="html"><![CDATA[<p>using System;<br>
using System.Net;<br>
using System.Net.Sockets;<br>
using System.Text;</p>
<p>namespace Socket客户端<br>
{<br>
class Program<br>
{<br>
static void Main(string[] args)<br>
{<br>
//1.创建Socket<br>
Socket tcpClient = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);//网咯、数据流形式、Tcp协议</p>
<pre><code>        //2.发起建立连接的请求
        IPAddress ipaddress = IPAddress.Parse(&quot;192.168.137.1&quot;);//可以将一个字符串的IP地址转化为IPaddress的对象
        EndPoint point = new IPEndPoint(ipaddress, 7788);
        //连接方法
        tcpClient.Connect(point);//通过ip:端口号，定位连接到目标服务器
        
        //接收来自服务器的数据（接收方法）
        byte[] data = new byte[1024]; //创建一个byte数组,(用来接收数据)
         int length = tcpClient.Receive(data);//传递一个byte数组,(用来接收数据)、返回值表示接收了多少字符串
        string message = Encoding.UTF8.GetString(data,0,length);//0~length的字节数据转化为字符串（把接收到的数据转化为字符串）
        Console.WriteLine(message);

        //向服务器端发送消息
        string messagec = Console.ReadLine();//读取用户的输入
        //发送方法
        tcpClient.Send(Encoding.UTF8.GetBytes(messagec));//把字符串转化为byte数组发送到服务器端

        Console.ReadKey();
    }
}
</code></pre>
<p>}<br>
<img src="https://Wei715547.github.io/post-images/1591076933494.PNG" alt="" loading="lazy"></p>
]]></content>
    </entry>
</feed>