<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Wei715547.github.io</id>
    <title>Wei开发日志</title>
    <updated>2020-05-30T03:57:48.119Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Wei715547.github.io"/>
    <link rel="self" href="https://Wei715547.github.io/atom.xml"/>
    <subtitle>年月增长，我宜强盛。
用于Unity+开发的技术积累</subtitle>
    <logo>https://Wei715547.github.io/images/avatar.png</logo>
    <icon>https://Wei715547.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Wei开发日志</rights>
    <entry>
        <title type="html"><![CDATA[反射特性]]></title>
        <id>https://Wei715547.github.io/post/fan-she-te-xing/</id>
        <link href="https://Wei715547.github.io/post/fan-she-te-xing/">
        </link>
        <updated>2020-05-30T03:57:11.000Z</updated>
        <content type="html"><![CDATA[<p>using System;<br>
using System.Reflection;</p>
<p>namespace 反射与特性<br>
{<br>
class Program<br>
{<br>
static void Main(string[] args)<br>
{<br>
MyClass my = new MyClass();<br>
Type type = my.GetType();<br>
Console.WriteLine(type .Name);//类的名字<br>
Console.WriteLine(type .Namespace);//类峰命名空间<br>
Console.WriteLine(type .Assembly );//类峰程序集命名空间</p>
<pre><code>        FieldInfo[] array = type.GetFields();//获取类的字段
        foreach (FieldInfo info in array )
        {
            Console.WriteLine(info .Name+&quot; &quot;);
        }

        PropertyInfo[] array2 = type.GetProperties();//获取类属性
        foreach (PropertyInfo info in array2 )
        {
            Console.WriteLine(info .Name +&quot; &quot;);
        }

        MethodInfo[] array3 = type.GetMethods();//获取类的方法
        foreach (MethodInfo info in array3)
        { 
            Console.WriteLine(info .Name +&quot; &quot;);
        }
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[泛型类/方法/委托]]></title>
        <id>https://Wei715547.github.io/post/fan-xing-lei-fang-fa-wei-tuo/</id>
        <link href="https://Wei715547.github.io/post/fan-xing-lei-fang-fa-wei-tuo/">
        </link>
        <updated>2020-05-30T02:55:40.000Z</updated>
        <content type="html"><![CDATA[<p>using System;<br>
using System.Collections.Generic;<br>
using System.Text;</p>
<p>namespace 泛型类<br>
{<br>
//泛型类<br>
class ClassA<T><br>
{<br>
private T a;<br>
private T b;</p>
<pre><code>    public ClassA (T a,T b)
    {
        this.a = a;
        this.b = b;
    }

    public string Show()
    {
        return a +&quot; &quot;+ b;
    }

}
</code></pre>
<h2 id="">}</h2>
<p>/*using System;</p>
<p>namespace 泛型类<br>
{<br>
class Program<br>
{<br>
public static string  GetSum&lt;T,T2,T3&gt;(T a,T b)//泛型方法,可指定多个泛型，在调用是指定类型<br>
{<br>
return a +&quot; &quot;+ b;<br>
}</p>
<pre><code>    static void Main(string[] args)
    {

        var o1 = new ClassA &lt;int&gt;(22,53);

        Console.WriteLine(  o1.Show());

        var s1 = new ClassA&lt;string&gt;(&quot;wei&quot;, &quot;715&quot;);

        Console.WriteLine(s1.Show());

        Console.WriteLine(GetSum &lt;int ,int ,int &gt;(123,314));//有多个泛型时，调用要指定所有类型
        Console.WriteLine( GetSum&lt;string ,string ,string &gt; (&quot;da&quot;,&quot;werr&quot;));


        //Console.ReadKey();

    }
}
</code></pre>
<p>}*/<br>
using System;<br>
using System.Collections.Generic;</p>
<p>//泛型委托<br>
delegate T NumberChanger<T>(T n);//返回值与参数类型为T<br>
namespace GenericDelegateAppl<br>
{<br>
class TestDelegate<br>
{<br>
static int num = 10;<br>
public static int AddNum(int p)<br>
{<br>
num += p;<br>
return num;<br>
}</p>
<pre><code>    public static int MultNum(int q)
    {
        num *= q;
        return num;
    }
    public static int getNum()
    {
        return num;
    }

    static void Main(string[] args)
    {
        // 创建委托实例
        //NumberChanger&lt;int&gt; nc1 = new NumberChanger&lt;int&gt;(AddNum);
        NumberChanger&lt;int&gt; nc1 = AddNum;//上一行简写
        NumberChanger&lt;int&gt; nc2 = new NumberChanger&lt;int&gt;(MultNum);
        // 使用委托对象调用方法
        nc1(25);
        Console.WriteLine(&quot;Value of Num: {0}&quot;, getNum());
        nc2(5);
        Console.WriteLine(&quot;Value of Num: {0}&quot;, getNum());
        Console.ReadKey();
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[长按/下蹲状态跳跃增量]]></title>
        <id>https://Wei715547.github.io/post/chang-an-xia-dun-zhuang-tai-tiao-yue-zeng-liang/</id>
        <link href="https://Wei715547.github.io/post/chang-an-xia-dun-zhuang-tai-tiao-yue-zeng-liang/">
        </link>
        <updated>2020-05-29T14:58:33.000Z</updated>
        <content type="html"><![CDATA[<p>public void MidAirMovement()<br>
{<br>
if (jumpPressed&amp;&amp;isOnground &amp;&amp;!isJump )//普通状态--在地面上，非跳跃状态，按下跳跃键<br>
{<br>
if (isCrouch)//下蹲状态，增量<br>
{<br>
StandUp();<br>
playerRGB.AddForce(Vector2.up * crouchJumpBoost, ForceMode2D.Impulse);//F1+F2<br>
}<br>
isOnground = false;<br>
isJump = true;<br>
jumpTime = Time.time + jumpHodeDuration;<br>
playerRGB.AddForce(Vector2.up * jumpForce, ForceMode2D.Impulse);//F1<br>
}<br>
else if (isJump )//长按状态<br>
{<br>
if (jumpHeld)//长按跳跃键<br>
playerRGB.AddForce(Vector2.up * jumpHpdeFpoce, ForceMode2D.Impulse);//F1+F3<br>
if (jumpTime &lt; Time.time)<br>
isJump = false;<br>
}<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[冒泡排序+(泛型/委托)]]></title>
        <id>https://Wei715547.github.io/post/mou-pao-pai-xu-fan-xing-wei-tuo/</id>
        <link href="https://Wei715547.github.io/post/mou-pao-pai-xu-fan-xing-wei-tuo/">
        </link>
        <updated>2020-05-28T15:53:37.000Z</updated>
        <content type="html"><![CDATA[<p>using System;</p>
<p>namespace int类冒泡排序<br>
{<br>
class Program<br>
{<br>
static void Sort(int[] sortArray)<br>
{<br>
bool isChang = true;<br>
do<br>
{<br>
isChang = false;<br>
for (int i = 0; i &lt; sortArray.Length - 1; i++)<br>
{<br>
if (sortArray[i] &lt; sortArray[i + 1])<br>
{<br>
int temp = sortArray[i];<br>
sortArray[i] = sortArray[i + 1];<br>
sortArray[i + 1] = temp;<br>
isChang = true;<br>
}<br>
}<br>
} while (isChang);<br>
}</p>
<pre><code>    static void CommonSort&lt;T&gt;(T[] sortArray, Func&lt;T, T, bool&gt; compart)
    {
        bool isChang = true;
        do
        {
            isChang = false;
            for (int i = 0; i &lt; sortArray.Length - 1; i++)
            {
                if (compart(sortArray[i], sortArray[i + 1]))
                {
                    T temp = sortArray[i];
                    sortArray[i] = sortArray[i + 1];
                    sortArray[i + 1] = temp;
                    isChang = true;
                }
            }
        } while (isChang);
    }

    static void Main(string[] args)
    {
        /*int[] array = { 31, 423, 543, 35, 24, 454,6 };
        Sort(array);
        foreach (int i in array)
        {
            Console.WriteLine(i);
        }*/

        /*Employee e1 = new Employee(&quot;wei&quot;, 12000);
        Employee e2 = new Employee(&quot;zz&quot;, 10000);
        Employee e3 = new Employee(&quot;zh&quot;, 11000);
        Employee[] earray = { e1, e2, e3 };*/
        //组类声明
        Employee[] earray = new Employee[]
        {
            new Employee(&quot;wei&quot;, 12000),
            new Employee(&quot;zz&quot;, 10000),
            new Employee(&quot;h&quot;, 11000)
        };

        CommonSort&lt;Employee&gt;(earray, Employee.Compare);
        foreach (Employee e in earray)
        {
            Console.WriteLine(e);
        }

    }
}
</code></pre>
<p>}</p>
<p>//泛型类<br>
using System;<br>
using System.Collections.Generic;<br>
using System.Text;</p>
<p>namespace int类冒泡排序<br>
{<br>
class Employee<br>
{<br>
public override string ToString()<br>
{<br>
return this .Name +&quot;:&quot;+this .Salary;<br>
}</p>
<pre><code>    public string Name { get; private set; }
    public int Salary { get; private set; }

    public Employee(string name ,int salary)
    {
        this.Name = name;
        this.Salary = salary;
    }

    public static bool Compare(Employee e1,Employee e2)
    {
        if (e1.Salary &gt; e2.Salary) return true;
        return false;
    }

}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Bool交替执行]]></title>
        <id>https://Wei715547.github.io/post/bool-jiao-ti-zhi-xing/</id>
        <link href="https://Wei715547.github.io/post/bool-jiao-ti-zhi-xing/">
        </link>
        <updated>2020-05-28T06:32:17.000Z</updated>
        <content type="html"><![CDATA[<p>private bool bagShow;<br>
private void Awake()<br>
{<br>
myBagPanel.SetActive(false);<br>
}<br>
private void Update()<br>
{<br>
if (Input .GetKeyDown (KeyCode.B ))<br>
{<br>
bagShow = !bagShow;<br>
myBagPanel.SetActive(bagShow);</p>
<pre><code>    }
}</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2D Bag System]]></title>
        <id>https://Wei715547.github.io/post/2d-bag-system/</id>
        <link href="https://Wei715547.github.io/post/2d-bag-system/">
        </link>
        <updated>2020-05-27T02:45:24.000Z</updated>
        <content type="html"><![CDATA[<p>以本地资源类(ScriptableObject)实现数据存储/读取<br>
//背包资源类<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
[CreateAssetMenu(fileName = &quot;New Item&quot;, menuName = &quot;Inventory/Inventory&quot;)]<br>
//背包类<br>
public class Inventory : ScriptableObject<br>
{<br>
#region<br>
/<em>public static Inventory GetInventory()<br>
{<br>
return Resources.Load<Inventory>(&quot;Mybag&quot;);<br>
}</em>/<br>
#endregion</p>
<pre><code>//物品类列表
public List&lt;Items&gt; itemList = new List&lt;Items&gt;();
</code></pre>
<p>}</p>
<p>//物品类<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
[CreateAssetMenu(fileName = &quot;New Item&quot; ,menuName = &quot;Inventory/New Item&quot;)]<br>
//物品类<br>
public class Items : ScriptableObject<br>
{<br>
public string  itemName ;//物品名称<br>
public Sprite ItemImage;//物品图标<br>
public int ItemHild;//物品数量<br>
[TextArea]//文本框，存储多字符串<br>
public string ItemInfo;//物品信息<br>
public bool equip;//可可装备属性<br>
}<br>
<img src="https://Wei715547.github.io/post-images/1590550667528.PNG" alt="" loading="lazy"></p>
<p>//UI预制件<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.UI;</p>
<p>public class Slot : MonoBehaviour<br>
{<br>
public int slotID;//空格的ID<br>
//public Items slotItem;<br>
public Image slotImage;//物品图标<br>
public Text slotNum;//物品数量<br>
private Button itemButton;//可点击物体按钮<br>
public GameObject itemInSlot;//物品整体UI<br>
public string slotInfo;//物品信息</p>
<pre><code>private void Awake()
{
    itemButton = this.gameObject.GetComponentInChildren&lt;Button&gt;();
    itemButton.onClick.AddListener(ItemOnClecked);
}

public void ItemOnClecked()
{
    InventoryManager.UpdateItemInfo(slotInfo );//点击时显示物品信息，
    //（物品位置交换后UI预制件中仍存储原来物品的信息，调用的也是创建时赋值的信息）场景重新加载 时UI预制件中的信息得到更新
}

public void SetupSlot (Items item)//刷新背包时传过来的本地资源中的物品对象
{
    if(item == null )//本地背包列表中物品为空时吟唱空白的物品对象，然后返回
    {
        itemInSlot.SetActive(false);
        return;
    }
    //不为空时对UI预制件进行赋值
    slotImage.sprite = item.ItemImage;//图标
    slotNum.text = item.ItemHild.ToString();//数量
    slotInfo = item.ItemInfo;//物品信息
}
</code></pre>
<p>}<br>
<img src="https://Wei715547.github.io/post-images/1590550908057.PNG" alt="" loading="lazy"></p>
<p>//世界中的物品<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>//世界中的物品脚本<br>
public class ItemOnWord : MonoBehaviour<br>
{<br>
public Items thisItem;//物品种类<br>
public Inventory platerInventer;//要加入的背包</p>
<pre><code>private void OnTriggerEnter2D(Collider2D collision)
{
    if (collision.gameObject .CompareTag (&quot;Player&quot;))//Tag相同时返回TRUE,
    {
        AddItems();
    }
    Destroy(this.gameObject);
}

public void AddItems()
{
    if (!platerInventer.itemList.Contains (thisItem ))//List方法包含此元素时返回TRUE,不包含返回FALSE
    {
        for (int i = 0; i &lt; platerInventer.itemList.Count; i++)//背包中没有该物品时遍历
        {
            if (platerInventer .itemList[i]==null) //将物品添加到第一个空位置
            {
                platerInventer.itemList[i] = thisItem;
                break;//跳出循环
            }
        }
    }else
    {
        thisItem.ItemHild += 1;//背包中有该物品时数量加一
    }
    InventoryManager.RefreshItem();//刷新背包
}
</code></pre>
<p>}<br>
<img src="https://Wei715547.github.io/post-images/1590552509280.PNG" alt="" loading="lazy"></p>
<p>//背包管理脚本<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.UI;<br>
//背包管理脚本<br>
public class InventoryManager : MonoBehaviour<br>
{<br>
public static InventoryManager instance;</p>
<pre><code>public Inventory myBag;
public GameObject parentPanle;
//public Slot slotPrefab;
public GameObject prefab;
public Text itemInfromation;

//运行时的物品List,与本地数据保持一致
public List&lt;GameObject&gt; slot = new List&lt;GameObject&gt;();


private void Awake()//单例模式
{
    if (instance != null)
        Destroy(this);
    instance = this;
}

private void OnEnable()//启用时刷新一次
{
    //print(&quot;refs&quot;);
    //print(parentPanle.transform.childCount);
    RefreshItem();
    instance.itemInfromation.text = &quot; &quot;;
}

public static void UpdateItemInfo(string ItemInfo)
{
    instance.itemInfromation.text = ItemInfo;
}

public static void RefreshItem()
{
    //清空背包
    ClearBag();
    //清空后，再根据本地资源类重新生成UI预制件设置其中的Items相关属性
    for (int i=0;i&lt; instance.myBag.itemList.Count;i++)
    {
        //CreateNewItem(item);
        instance.slot.Add(Instantiate(instance.prefab));
        instance.slot[i].transform.SetParent(instance.parentPanle.transform);
        instance.slot[i].GetComponent&lt;Slot&gt;().slotID = i;
        instance.slot[i].GetComponent&lt;Slot&gt;().SetupSlot(instance.myBag.itemList[i]);

    }
}
//清空UI中背包所有物品的方法
public static void ClearBag()
{
    if (instance.parentPanle.transform.childCount == 0)
        return;
    for (int i = 0; i &lt; instance .parentPanle .transform .childCount ; i++)
    {
        Destroy(instance.parentPanle.transform.GetChild(i).gameObject);
        instance.slot.Clear();
    }
}
</code></pre>
<p>}<br>
<img src="https://Wei715547.github.io/post-images/1590552901698.PNG" alt="" loading="lazy"></p>
<p>//------------------------物品拖拽/交换位置-----------------------------------//<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.EventSystems;<br>
using UnityEngine.UI;<br>
public class ItemOnnDrag : MonoBehaviour, IBeginDragHandler, IDragHandler, IEndDragHandler//拖拽接口<br>
{<br>
public Transform originatParent;<br>
public Inventory myBag;<br>
private int currentItemID;</p>
<pre><code>public void OnBeginDrag(PointerEventData eventData)//按下时
{
    originatParent = transform.parent;//记录初始所在父物体
    currentItemID = originatParent.GetComponent&lt;Slot&gt;().slotID;//记录初始父物体在界面/本地数据List中位置
    transform.SetParent(transform.parent.parent);//点击后将物体UI的父物体设置为与抽屉的父物体同级，方便显示
    transform.position = eventData.position;//物体UI位置跟随屏幕滚光标
    GetComponent&lt;CanvasGroup&gt;().blocksRaycasts = false;//隐藏物品图标屏幕射线检测，使射线可检测到下层父级物体
}

public void OnDrag(PointerEventData eventData)//拖拽时
{
    transform.position = eventData.position;//拖拽时物体UI根数屏幕光标
    print(eventData.pointerCurrentRaycast.gameObject.name);//屏幕射线检测到的物体名称
}

public void OnEndDrag(PointerEventData eventData)//拖拽结束时
{
    if (eventData.pointerCurrentRaycast.gameObject != null)//如果屏幕射线检测到的物体不为空时
    {
        if (eventData.pointerCurrentRaycast.gameObject.name == &quot;Item Image&quot;)//物品栏有物品时，物品未隐藏可被检测到（物品UI的图标）
        {
            //原物体UI移动到背包中目标物体UI位置
            transform.SetParent(eventData.pointerCurrentRaycast.gameObject.transform.parent.parent);//物品UI图标的父级的父级（Slot）
            transform.position = eventData.pointerCurrentRaycast.gameObject.transform.parent.parent.position;
            //将目标物体UI移动到原物体UI位置
            eventData.pointerCurrentRaycast.gameObject.transform.parent.SetParent(originatParent);
            eventData.pointerCurrentRaycast.gameObject.transform.parent.position = originatParent.position;

            //交换本地数据中物体的存储位置
            var temp = myBag.itemList[currentItemID];//本地数据中原物体保存为中间值
            //本地数据中原物体移动到目标物体位置
            myBag.itemList[currentItemID] = myBag.itemList[eventData.pointerCurrentRaycast.gameObject.GetComponentInParent&lt;Slot&gt;().slotID];
            //本地数据中目标物体位置变为中间值（原物体）
            myBag.itemList[eventData.pointerCurrentRaycast.gameObject.GetComponentInParent&lt;Slot&gt;().slotID] = temp;
            //交换存储位置

            GetComponent&lt;CanvasGroup&gt;().blocksRaycasts = true;//交换完成开启屏幕射线检测，可再次拖拽
            return;//目标栏有物体，交换完成退出方法
        }
        if (eventData.pointerCurrentRaycast.gameObject.name == &quot;Slot(Clone)&quot;)//目标栏为空时（检测到的是抽屉）
        {
            //原物体之间放入目标抽屉
            transform.SetParent(eventData.pointerCurrentRaycast.gameObject.transform);
            transform.position = eventData.pointerCurrentRaycast.gameObject.transform.position;
            //将本地数据中的空物体赋值为，本地数据库中的目标物体
            myBag.itemList[eventData.pointerCurrentRaycast.gameObject.GetComponentInParent&lt;Slot&gt;().slotID] = myBag.itemList[currentItemID];
            //如果如表抽屉不是原来的抽屉时执行
            if (eventData.pointerCurrentRaycast.gameObject.GetComponent&lt;Slot&gt;().slotID != currentItemID)
                myBag.itemList[currentItemID] = null;//之后本地数据中的目标物体设为空

            GetComponent&lt;CanvasGroup&gt;().blocksRaycasts = true;//交换完成开启屏幕射线检测，可再次拖拽
            return;//目标栏有物体，交换完成退出方法
        }
    }
    //其他任何位置返回原位(非UI元素时)
    transform.SetParent(originatParent);
    transform.position = originatParent.position;
    GetComponent&lt;CanvasGroup&gt;().blocksRaycasts = true;
}
</code></pre>
<p>}<br>
<img src="https://Wei715547.github.io/post-images/1590553039734.PNG" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[委托事件实现广播/监听（底层实现）]]></title>
        <id>https://Wei715547.github.io/post/wei-tuo-shi-jian-shi-xian-guang-bo-jian-ting-di-ceng-shi-xian/</id>
        <link href="https://Wei715547.github.io/post/wei-tuo-shi-jian-shi-xian-guang-bo-jian-ting-di-ceng-shi-xian/">
        </link>
        <updated>2020-05-26T15:22:36.000Z</updated>
        <content type="html"><![CDATA[<p>//广播者<br>
using System;<br>
using System.Collections.Generic;<br>
using System.Text;</p>
<p>namespace 事件__观察者设计模式<br>
{<br>
class Cat//被观察者（广播着）<br>
{<br>
public string name;<br>
public string color;</p>
<pre><code>    public Cat(string name,string color)
    {
        this.name = name;
        this.color = color;
    }

    public void CatComing()
    {
        Console.WriteLine(&quot;发起广播&quot;);
        if(catCome!=null)
            catCome();
    }

    //public Action catCome;
    public event Action catCome;//声明一个事件，发布一个消息（不能在类的外部被调用）
}
</code></pre>
<p>}</p>
<p>//监听者<br>
using System;<br>
using System.Collections.Generic;<br>
using System.Text;</p>
<p>namespace 事件__观察者设计模式<br>
{<br>
class Moust//观察者（监听着）<br>
{<br>
public string name;<br>
public string color;</p>
<pre><code>    public Moust(string name,string color,Cat c)
    {
        this.name = name;
        this.color = color;
        c.catCome += this.MsRuning;//将自身应对广播“某”事件的方法，注册进广播者的该事件中(订阅消息)
        //c.catCome();//事件不能在类的外部进行调用(委托可以)，但可在类的外部注册。
    }

    public void MsRuning()
    {
        Console.WriteLine(&quot;监听着收到广播&quot;);
    }
}
</code></pre>
<p>}</p>
<p>//程序<br>
using System;</p>
<p>namespace 事件__观察者设计模式<br>
{<br>
class Program<br>
{<br>
static void Main(string[] args)<br>
{<br>
Cat c = new Cat(&quot;Super BuleCat&quot;,&quot;Blue&quot;);<br>
Moust m1 = new Moust(&quot;Mk&quot;, &quot;Blake&quot;,c);//将广播者传入监听者，在监听者中注册委托<br>
//c.catCome += m1.MsRuning;//注册委托<br>
Moust m2 = new Moust(&quot;Bt&quot;, &quot;Blue&quot;,c);<br>
//c.catCome += m2.MsRuning;//注册委托<br>
//c.catCome();//事件不能在类的外部进行调用(委托可以)，但可在类的外部注册。<br>
c.CatComing();<br>
}<br>
}<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[正则表达式（字符串格式判定）]]></title>
        <id>https://Wei715547.github.io/post/zheng-ze-biao-da-shi-zi-fu-chuan-ge-shi-pan-ding/</id>
        <link href="https://Wei715547.github.io/post/zheng-ze-biao-da-shi-zi-fu-chuan-ge-shi-pan-ding/">
        </link>
        <updated>2020-05-26T12:05:29.000Z</updated>
        <content type="html"><![CDATA[<p>using System;<br>
using System.Text.RegularExpressions;</p>
<p>namespace 正则表达式<br>
{<br>
class Program<br>
{<br>
static void Main(string[] args)<br>
{<br>
string s = &quot;I amwei&quot;;<br>
string res = Regex.Replace(s,&quot;^&quot;, &quot;start&quot;);//&quot;^&quot;匹配开始字符串<br>
Console.WriteLine(res);</p>
<pre><code>        string res2 = Regex.Replace(s, &quot;$&quot;, &quot;end&quot;);//&quot;$&quot;匹配结尾
        Console.WriteLine(res2);

        string num = Console.ReadLine();
        /*bool isMatch = true;
        for (int i = 0; i &lt; num.Length ; i++)
        {
            if(num[i]&lt;'0'||num[i]&gt;'9')
            {
                isMatch = false;
                break;
            }
        }
        if (isMatch)
        {
            Console.WriteLine(&quot;密码合法&quot;);
        }
        else
        {
            Console.WriteLine( &quot;密码不合法&quot;);
        }*/
        string pattern = @&quot;^\d*$&quot;;//(数字字符串)以数字开头0个或多个，并以数字结尾
        bool issMach = Regex.IsMatch(num, pattern);
        Console.WriteLine(issMach);

    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[拖拽接口]]></title>
        <id>https://Wei715547.github.io/post/tuo-zhuai-jie-kou/</id>
        <link href="https://Wei715547.github.io/post/tuo-zhuai-jie-kou/">
        </link>
        <updated>2020-05-26T09:21:49.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.EventSystems;<br>
using UnityEngine.UI;<br>
public class ItemOnnDrag : MonoBehaviour, IBeginDragHandler, IDragHandler, IEndDragHandler<br>
{<br>
public Transform originatParent;<br>
public Inventory myBag;<br>
private int currentItemID;</p>
<pre><code>public void OnBeginDrag(PointerEventData eventData)
{
    originatParent = transform.parent;
    currentItemID = originatParent.GetComponent&lt;Slot&gt;().slotID;
    transform.SetParent(transform.parent.parent);
    transform.position = eventData.position;
    GetComponent&lt;CanvasGroup&gt;().blocksRaycasts = false;
}

public void OnDrag(PointerEventData eventData)
{
    transform.position = eventData.position;
    //print(eventData.pointerCurrentRaycast.gameObject.name);
}

public void OnEndDrag(PointerEventData eventData)
{
    if (eventData.pointerCurrentRaycast.gameObject != null)
    {
        if (eventData.pointerCurrentRaycast.gameObject.name == &quot;Item Image&quot;)//物品栏有物品时
        {
            transform.SetParent(eventData.pointerCurrentRaycast.gameObject.transform.parent.parent);
            transform.position = eventData.pointerCurrentRaycast.gameObject.transform.parent.parent.position;

            //交换存储位置
            var temp = myBag.itemList[currentItemID];
            myBag.itemList[currentItemID] = myBag.itemList[eventData.pointerCurrentRaycast.gameObject.GetComponentInParent&lt;Slot&gt;().slotID];
            myBag.itemList[eventData.pointerCurrentRaycast.gameObject.GetComponentInParent&lt;Slot&gt;().slotID] = temp;
            //交换存储位置

            eventData.pointerCurrentRaycast.gameObject.transform.parent.SetParent(originatParent);
            eventData.pointerCurrentRaycast.gameObject.transform.parent.position = originatParent.position;
            GetComponent&lt;CanvasGroup&gt;().blocksRaycasts = true;
            return;
        }
        if (eventData.pointerCurrentRaycast.gameObject.name == &quot;Slot(Clone)&quot;)
        {
            //物品栏为空时
            transform.SetParent(eventData.pointerCurrentRaycast.gameObject.transform);
            transform.position = eventData.pointerCurrentRaycast.gameObject.transform.position;

            myBag.itemList[eventData.pointerCurrentRaycast.gameObject.GetComponentInParent&lt;Slot&gt;().slotID] = myBag.itemList[currentItemID];
            if (eventData.pointerCurrentRaycast.gameObject.GetComponent&lt;Slot&gt;().slotID != currentItemID)
                myBag.itemList[currentItemID] = null;

            GetComponent&lt;CanvasGroup&gt;().blocksRaycasts = true;
            return;
        }
    }
    //其他任何位置返回原位
    transform.SetParent(originatParent);
    transform.position = originatParent.position;
    GetComponent&lt;CanvasGroup&gt;().blocksRaycasts = true;
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符、可变字符串，方法]]></title>
        <id>https://Wei715547.github.io/post/zi-fu-chuan-fang-fa/</id>
        <link href="https://Wei715547.github.io/post/zi-fu-chuan-fang-fa/">
        </link>
        <updated>2020-05-24T15:55:23.000Z</updated>
        <content type="html"><![CDATA[<p>using System;<br>
using System.Text;</p>
<p>namespace 字符串方法<br>
{<br>
class Program<br>
{<br>
static void Main(string[] args)<br>
{<br>
//1.<br>
string s = &quot; wei715547&quot;;<br>
int res = s.CompareTo(&quot;wei715547&quot;);//元素相等时，返回值为0，<br>
//调用者字母排序靠后时返回值为1，靠前是返回值为-1<br>
Console.WriteLine(res);</p>
<pre><code>        //2
        string newstring = s.Replace('w', 'z');//替换字符
        Console.WriteLine(newstring );
        //string newstring2 = s.Replace('1', '2');

        //3.字符串从指定字符位置拆分为数组
        string[] stringArray = s.Split('1');
        foreach (var item in stringArray )
        {
            Console.WriteLine(item );
        }

        //4.Substring.截取字符串
        string newcut = s.Substring(2,5);
        Console.WriteLine(newcut);

        //5.清除字符串首尾空白
        string clearspace = s.Trim();
        Console.WriteLine(clearspace );

        //6.返回指定字符的索引
        int newindex = s.IndexOf('1');
        Console.WriteLine(newindex );

        //-------------------------------------------------------------
        //可变字符串StringBuilder 
        //create1.通过构造函数进行构建
        StringBuilder sb = new StringBuilder(&quot;www.wei7157.github.co&quot;);
        Console.WriteLine(sb);
        //create2.声明空间大小
        StringBuilder sb2 = new StringBuilder(20);
        sb2.Append(&quot;www.wei7157.github.co&quot;);
        Console.WriteLine(sb2);
        //creat3.赋值同时声明空间大小
        StringBuilder sb3 = new StringBuilder(&quot;www.wei7157.github.co&quot;, 100);
        Console.WriteLine(sb3);


        //字符串修改与标准字符串对比
        sb.Append(&quot;000000&quot;);//在空余空间链接字符
        Console.WriteLine(sb);
        //对比常规字符串操作，运行效率更高
        string str = &quot;www.wei7157.github.co&quot;;
        str += &quot;000000&quot;;//在堆中创建新的字符，str索引指向新的字符，原来的字符被CLR回收（效率低）
        Console.WriteLine(str);

        //可变字符串Insert()方法
        sb.Insert(0, &quot;http//&quot;);
        Console.WriteLine(sb);
        sb.Remove(0, 6);//根据索引范围移除字符
        Console.WriteLine(sb);
        sb.Replace('w', 'z');//字符替换
        Console.WriteLine(sb);
        Console.WriteLine(sb.ToString());//ToString()转变为不可变字符

    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
</feed>