<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Wei715547.github.io</id>
    <title>WeiBlog</title>
    <updated>2020-10-12T09:06:19.301Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Wei715547.github.io"/>
    <link rel="self" href="https://Wei715547.github.io/atom.xml"/>
    <subtitle>年月增长，我宜强盛。
用于Unity+开发的技术积累</subtitle>
    <logo>https://Wei715547.github.io/images/avatar.png</logo>
    <icon>https://Wei715547.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, WeiBlog</rights>
    <entry>
        <title type="html"><![CDATA[洗牌算法，洪水填充算法]]></title>
        <id>https://Wei715547.github.io/post/xi-pai-suan-fa/</id>
        <link href="https://Wei715547.github.io/post/xi-pai-suan-fa/">
        </link>
        <updated>2020-10-12T02:57:36.000Z</updated>
        <content type="html"><![CDATA[<p>public class Utilities<br>
{<br>
/// <summary><br>
/// 洗牌算法，<br>
/// </summary><br>
/// <param name="dateArray">随机重排的数组</param><br>
/// <returns></returns><br>
public static Coord[] ShuffleCoords(Coord[] dateArray)<br>
{<br>
for (int i = 0; i &lt; dateArray.Length; i++)<br>
{<br>
//将每次随机到的元素放到首位，第二次随机从“队首+1~最后元素”开始随机，这样每次随机到的即不为同一元素<br>
int random = Random.Range(i, dateArray.Length);<br>
//SWAP<br>
Coord temp = dateArray[random];<br>
dateArray[random] = dateArray[i];<br>
dateArray[i] = temp;<br>
}<br>
return dateArray;<br>
}<br>
}<br>
//应用程序<br>
<img src="https://Wei715547.github.io/post-images/1602493526529.PNG" alt="" loading="lazy"><br>
shuffleCoords = new Queue<Coord>(Utilities.ShuffleCoords(allTilesCoord.ToArray()));<br>
public Coord GetRandomCoord()<br>
{<br>
Coord randomCoord = shuffleCoords.Dequeue();<br>
shuffleCoords.Enqueue(randomCoord);<br>
return randomCoord;<br>
}<br>
——————————————————————————————————————————————————<br>
/// <summary><br>
/// 洪水填充算法<br>
/// </summary><br>
/// <param name="_mapObstacles">地图上的位置是否存在障碍物</param><br>
/// <param name="_currentObsCount">应该时候能承担障碍物数量</param><br>
/// <returns>是否可以在此处生成障碍物</returns><br>
public bool MapIsFullyAccessible(bool[,] _mapObstacles, int _currentObsCount)<br>
{<br>
bool[,] mapFlag = new bool[_mapObstacles.GetLength(0), _mapObstacles.GetLength(1)];<br>
Queue<Coord> queue = new Queue<Coord>();//存储所有筛选后的坐标<br>
queue.Enqueue(mapCenter);<br>
mapFlag[mapCenter.x, mapCenter.y] = true;//中心点标记为已检测<br>
int accessibleCount = 1;//可以行走的格子数量<br>
while(queue.Count&gt;0)<br>
{<br>
Coord currentTile = queue.Dequeue();<br>
for (int x = -1; x &lt;=1; x++)<br>
{<br>
for (int y = -1; y &lt;=1; y++)<br>
{<br>
int neighborX = currentTile.x + x;<br>
int neighborY = currentTile.y + y;</p>
<pre><code>                if (x==0||y==0)//检测上下左右四个相邻的位置是否可行
                {
                    if(neighborX &gt;=0&amp;&amp;neighborX&lt;_mapObstacles.GetLength(0)
                        &amp;&amp; neighborY&gt;=0&amp;&amp;neighborY&lt;_mapObstacles.GetLength(1))//范围限定在地图范围内
                    {
                        //该位置未检测，且不存在障碍物时
                        if(!mapFlag[neighborX,neighborY]&amp;&amp;!_mapObstacles[neighborX,neighborY])
                        {
                            mapFlag[neighborX, neighborY] = true;
                            accessibleCount++;
                            queue.Enqueue(new Coord(neighborX, neighborY));
                        }
                    }
                }
            }
        }
    }
    int walkableCount = (int)(mapSize.x * mapSize.y - _currentObsCount);//地图上应该可行走位置的数量
    return accessibleCount == walkableCount;//联通路径总的可行走数量与目标值相同时则可依据_mapObstacles中位置生成障碍物
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DgR]]></title>
        <id>https://Wei715547.github.io/post/dgr/</id>
        <link href="https://Wei715547.github.io/post/dgr/">
        </link>
        <updated>2020-10-03T10:54:03.000Z</updated>
        <content type="html"><![CDATA[<p>1.单一职责原则：类的职责要单一，不能将太多的职责放到一个类中。<br>
2.开闭原则：软件实体对扩展时开放的，但对修改是关闭的，即在不修改一个软件实体的基础上去扩展器功能。<br>
3.里转转换原则：在软件系统中一个可以接受基类对象的地方必然可以接受其子类对象（父类中装入子类）<br>
4.依赖倒转原则：要针对抽象对象编程，而不是对具体类编程。<br>
5.接口隔离原则：使用多个专门的接口 来取代一个统一的接口。<br>
6.合成复用原则：在系统中应多使用组合聚合关系，尽量少使用或不使用继承关系。<br>
7.迪米特法则：一个软件实体对其他实体的引用越少越好，或者说如果两个类不必彼此自黑通信，那么，两个类就不应当直接发生作用，而是通过引入中间体发生间接交互。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AStar-Base]]></title>
        <id>https://Wei715547.github.io/post/astar-base/</id>
        <link href="https://Wei715547.github.io/post/astar-base/">
        </link>
        <updated>2020-09-30T02:50:05.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://Wei715547.github.io/post-images/1601434274880.jpg" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1601434281055.jpg" alt="" loading="lazy"></p>
<p>//节点类<br>
//节点类型枚举<br>
public enum NodeTyp<br>
{<br>
//可用格子<br>
Able,<br>
//不可用格子<br>
Unable<br>
}<br>
public class AStartNode<br>
{<br>
//格子坐标<br>
public int x;<br>
public int y;</p>
<pre><code>//寻路消耗
public float f;

//起点距离
public float g;
//终点距离
public float h;

//父对象
public AStartNode father;
//格子类型
public NodeTyp type;

public AStartNode(int x,int y, NodeTyp type)
{
    this.x = x;
    this.y = y;
    this.type = type;
}
</code></pre>
<p>}</p>
<p>//单例基类<br>
public class BaseManager<T><br>
where T:new()//限定T有一个无参数的构造函数<br>
{<br>
private static T instence;</p>
<pre><code>public static T Instence
{
    get
    {
        if (instence == null)
            instence = new T();
        return instence;
    }
}
</code></pre>
<p>}</p>
<p>//管理器类（单例）<br>
public class AStartManager :BaseManager<AStarManager><br>
{<br>
/*private static AStartManager instence;<br>
public static AStartManager Instence<br>
{<br>
get<br>
{<br>
if (instence == null)<br>
instence = new AStartManager();<br>
return instence;<br>
}<br>
}<br>
*/<br>
//地图大小<br>
private int mapw;<br>
private int maph;<br>
//所有格子容器<br>
public AStartNode[,] nodes;<br>
//开启类表<br>
private List<AStartNode> openList = new List<AStartNode>();<br>
//关闭类表<br>
private List<AStartNode> closeList = new List<AStartNode>();<br>
/// <summary><br>
/// 初始化地图信息<br>
/// </summary><br>
/// <param name="mapw"></param><br>
/// <param name="maph"></param><br>
public void InitMapInfo(int mapw, int maph)<br>
{<br>
this.mapw = mapw;<br>
this.maph = maph;<br>
nodes = new AStartNode[mapw, maph];<br>
for (int i = 0; i &lt; mapw; i++)<br>
{<br>
for (int j = 0; j &lt; maph; j++)<br>
{<br>
//格子20%概率为阻挡<br>
AStartNode node = new AStartNode(i, j, Random.Range(0, 101) &lt; 20 ? NodeTyp.Unable : NodeTyp.Able);<br>
nodes[i, j] = node;<br>
}<br>
}<br>
}</p>
<pre><code>/// &lt;summary&gt;
/// 寻路方法
/// &lt;/summary&gt;
/// &lt;param name=&quot;startPos&quot;&gt;&lt;/param&gt;
/// &lt;param name=&quot;endPos&quot;&gt;&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public List&lt;AStartNode&gt; FindPath(Vector2 startPos, Vector2 endPos)
{

    /*/判断传入顶点是否合法*/
    //1.1传入顶点噪mapz范围内
    if (startPos.x &lt; 0 || startPos.x &gt;= mapw || startPos.y &lt; 0 || startPos.y &gt;= maph
       || endPos.x &lt; 0 || endPos.x &gt;= mapw || endPos.y &lt; 0 || endPos.y &gt;= maph)
    {
        Debug.Log(&quot;OutRange&quot;);
        return null;
    }
    AStartNode start = nodes[(int)startPos.x, (int)startPos.y];
    AStartNode end = nodes[(int)endPos.x, (int)endPos.y];
    //2.传入顶点不为阻挡
    //不合法则返回null
    if (start.type == NodeTyp.Unable ||
       end.type == NodeTyp.Unable)
    {
        Debug.Log(&quot;非法位置&quot;);
        return null;
    }

    //清空上一次相关数据，避免影响此次计算

    //清空开始/关闭类表
    openList.Clear();
    closeList.Clear();

    //把开始点放入关闭类表中
    start.father = null;
    start.g = 0;
    start.h = 0;
    start.f = 0;
    closeList.Add(start);
    while (true)
    {
        //从起点开始寻找周围的点
        //左上
        FindNearlyNodeToOpenList(start.x - 1, start.y - 1, 1.4f, start, end);
        //上
        FindNearlyNodeToOpenList(start.x, start.y - 1, 1f, start, end);
        //右上
        FindNearlyNodeToOpenList(start.x + 1, start.y - 1, 1.4f, start, end);
        //左
        FindNearlyNodeToOpenList(start.x - 1, start.y, 1f, start, end);
        //右
        FindNearlyNodeToOpenList(start.x + 1, start.y, 1f, start, end);
        //左下
        FindNearlyNodeToOpenList(start.x - 1, start.y + 1, 1.4f, start, end);
        //下
        FindNearlyNodeToOpenList(start.x, start.y + 1, 1f, start, end);
        //右下
        FindNearlyNodeToOpenList(start.x + 1, start.y + 1, 1.4f, start, end);
        //判断周围的点是否合法，是否在开启或关闭类表，不是则放入开始了表

        //死路判定：开启类表为空时中非那不可达
        if (openList.Count == 0)
        {
            Debug.Log(&quot;死路&quot;);
            return null;
        }
        //选出开启类表中寻路消耗最小的点
        openList.Sort(SortOpenList);//排序后openList[0]为f值最小的点
                                    //放入关闭类表中然后从开始了表中移除
        closeList.Add(openList[0]);
        //找到的点作为下一次寻找开始的起点
        start = openList[0];
        openList.RemoveAt(0);
        //如果这个点是终点则返回出去
        //不是终点则继续寻找
        if (start == end)
        {
            List&lt;AStartNode&gt; path = new List&lt;AStartNode&gt;();
            path.Add(end);
            while (end.father != null)
            {
                path.Add(end.father);
                end = end.father;
            }
            path.Reverse();
            return path;
        }

    }
}
/// &lt;summary&gt;
/// 排序函数
/// &lt;/summary&gt;
/// &lt;param name=&quot;a&quot;&gt;&lt;/param&gt;
/// &lt;param name=&quot;b&quot;&gt;&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
private int SortOpenList(AStartNode a, AStartNode b)
{
    if (a.f &gt; b.f)
        return 1;
    else if (a.f == b.f)
        return 1;
    else
        return -1;
}
/// &lt;summary&gt;
/// 把临近点放入开启类表中的函数
/// &lt;/summary&gt;
/// &lt;param name=&quot;x&quot;&gt;&lt;/param&gt;
/// &lt;param name=&quot;y&quot;&gt;&lt;/param&gt;
private void FindNearlyNodeToOpenList(int x, int y, float g, AStartNode fatherNode, AStartNode endNode)
{
    //边界判定
    if (x &lt; 0 || x &gt;= mapw ||
        y &lt; 0 || y &gt;= maph)
        return;
    //在map范围内在取点
    AStartNode node = nodes[x, y];
    if (node == null || node.type == NodeTyp.Unable
        || openList.Contains(node) || closeList.Contains(node))
        return;

    //计算f值：f=g+h
    //记录父对象
    node.father = fatherNode;
    //计算g（距离起点距离）值：父对象里欠点距离+距离父对象距离
    node.g = fatherNode.g + g;
    //计算h值（距离终点距离）：曼哈顿街区算法二维坐标差值
    node.h = Mathf.Abs(endNode.x - node.x) + Mathf.Abs(endNode.y - node.y);
    node.f = node.g + node.h;
    //通过验证则存入开始了表中
    openList.Add(node);
}
</code></pre>
<p>}</p>
<p><img src="https://Wei715547.github.io/post-images/1601435509787.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1601435519694.PNG" alt="" loading="lazy"><br>
//测试脚本<br>
public class TextA : MonoBehaviour<br>
{<br>
public int beginX = -2;<br>
public int beginY = -2;</p>
<pre><code>public int offSetX = 2;
public int OffSetY = 2;

public int mapW = 5;
public int mapY = 5;

public Material bnary;
public Material start;
public Material path;
public Material normal;

//存储格子容器（x_y,GameObject）
private Dictionary&lt;string, GameObject&gt; cubes = new Dictionary&lt;string, GameObject&gt;();

private Vector2 beginPos = Vector2.right * -1;
private Vector2 endPos;

//存储路径节点
List&lt;AStartNode&gt; pathList = new List&lt;AStartNode&gt;();

// Start is called before the first frame update
void Start()
{
    AStartManager.Instence.InitMapInfo(mapW, mapY);
    for (int i = 0; i &lt; mapW; i++)
    {
        for (int j = 0; j &lt; mapY; j++)
        {
            GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Cube);
            obj.transform.position = new Vector3(beginX + i * offSetX, beginY + j * OffSetY, 0);
            obj.name = i + &quot;_&quot; + j;
            cubes.Add(obj.name, obj);
            //判断格子是否阻挡
            AStartNode node = AStartManager.Instence.nodes[i, j];
            if(node.type == NodeTyp.Unable)
            {
                obj.GetComponent&lt;MeshRenderer&gt;().material= bnary ;
                Debug.Log(&quot;Br&quot;);
            }
        }
    }
}

// Update is called once per frame
void Update()
{
    if(Input.GetMouseButtonDown(0))
    {
        //射线检测返回值
        RaycastHit hit;
        //相机视角从鼠标位置发出的射线
        Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
        //射线检测，检测到物体返回true
        if (Physics.Raycast(ray, out hit, 1000))
        {
            //得到点击到的立方体
            //hit.collider.gameObject;
            //记录开始点与结束点
            if(beginPos == Vector2.right*-1)
            {
                //清理上一次路径
                if (pathList != null)
                {
                    for (int i = 0; i &lt; pathList.Count; i++)
                    {
                        cubes[pathList[i].x + &quot;_&quot; + pathList[i].y].GetComponent&lt;MeshRenderer&gt;().material = normal;
                    }
                }

                string[] str = hit.collider.gameObject.name.Split('_');
                beginPos = new Vector2(int.Parse(str[0]), int.Parse(str[1]));
                hit.collider.gameObject.GetComponent&lt;MeshRenderer&gt;().material = start;
            }
            else
            {
                string[] str = hit.collider.gameObject.name.Split('_');
                endPos = new Vector2(int.Parse(str[0]), int.Parse(str[1]));
                //hit.collider.gameObject.GetComponent&lt;MeshRenderer&gt;().material = end;

                pathList = AStartManager.Instence.FindPath(beginPos, endPos);
                if(pathList !=null)
                {
                    for (int i = 0; i &lt; pathList.Count; i++)
                    {
                        cubes[pathList[i].x + &quot;_&quot; + pathList[i].y].GetComponent&lt;MeshRenderer&gt;().material = path;
                    }
                }
                //清除开始点
                beginPos = Vector2.right * -1;
            }
        }
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[24.]]></title>
        <id>https://Wei715547.github.io/post/24/</id>
        <link href="https://Wei715547.github.io/post/24/">
        </link>
        <updated>2020-09-25T15:20:11.000Z</updated>
        <content type="html"><![CDATA[<p>class SL<br>
{<br>
public bool JudgePoint24(int[] nums)<br>
{<br>
List<double> list = new List<double>();<br>
foreach (int i in nums) list.Add((double)i); //为dfs做准备<br>
return dfs(list);<br>
}<br>
private bool dfs(List<double> list)<br>
{<br>
if (list.Count == 1)<br>
{//一个数时判断相等<br>
if (Math.Abs(list[0] - 24.0) &lt; 0.001) return true; //考虑除法造成的小数点<br>
return false;<br>
}<br>
for (int i = 0; i &lt; list.Count; ++i)<br>
{<br>
for (int j = i + 1; j &lt; list.Count; ++j)<br>
{<br>
foreach (double c in generatePossibleResults(list[i], list[j]))<br>
{<br>
List<double> nextRound = new List<double>();<br>
nextRound.Add(c); //遍历两个数的所有可能性<br>
for (int k = 0; k &lt; list.Count; ++k)<br>
{ //添加剩余项到next round<br>
if (k == i || k == j) continue;<br>
nextRound.Add(list[k]);<br>
}<br>
if (dfs(nextRound)) return true;<br>
}<br>
}<br>
}<br>
return false;<br>
}<br>
//生成两个数所有的组合<br>
private List<double> generatePossibleResults(double a, double b)<br>
{<br>
List<double> res = new List<double>();<br>
res.Add(a + b);<br>
res.Add(a - b);<br>
res.Add(b - a);<br>
res.Add(a * b);<br>
res.Add(a / b);<br>
res.Add(b / a);<br>
return res;<br>
}<br>
}</p>
<pre><code>C#改JAVA
</code></pre>
<p>class Solution<br>
{<br>
public boolean judgePoint24(int[] nums)<br>
{<br>
ArrayList<Double> list = new ArrayList&lt;&gt;();<br>
for (int n:nums)<br>
{<br>
list.add((double)n);<br>
}<br>
return Prm(list);<br>
}<br>
public boolean Prm(ArrayList<Double> list)<br>
{<br>
if (list.size() == 1)<br>
{<br>
return Math.abs(list.get(0) - 24) &lt; 1e-6;<br>
}<br>
for (int i = 0; i &lt; list.size(); i++)<br>
{<br>
for (int j = i + 1; j &lt; list.size(); j++)<br>
{<br>
for (double k:AllTowRes(list.get(i), list.get(j)))<br>
{<br>
ArrayList<Double> nextRound = new ArrayList&lt;&gt;();<br>
nextRound.add(k);<br>
for (int v = 0; v &lt; list.size(); v++)<br>
{<br>
if (v == i || v == j) continue;<br>
nextRound.add(list.get(v));<br>
}<br>
if (Prm(nextRound)) return true;<br>
}<br>
}<br>
}<br>
return false;<br>
}<br>
public ArrayList<Double> AllTowRes(double a, double b)<br>
{<br>
ArrayList<Double> res = new ArrayList&lt;&gt;();<br>
res.add(a + b);<br>
res.add(a - b);<br>
res.add(b - a);<br>
if (b != 0) res.add(a / b);<br>
if (a != 0) res.add(b / a);<br>
return res;<br>
}<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DGT]]></title>
        <id>https://Wei715547.github.io/post/dgt/</id>
        <link href="https://Wei715547.github.io/post/dgt/">
        </link>
        <updated>2020-09-22T09:56:23.000Z</updated>
        <content type="html"><![CDATA[<p>1.//变量插值方法<br>
DOTween.To(() =&gt; dtV, x =&gt; dtV = x, new Vector3(10, 10, 10), 2);//            DoTween.To(表达式1()目标变量，表达式2(目标变量=变量，变量值)，变化时间，)<br>
//当前位置到世界坐标下移动<br>
bgt.transform.DOMove(s, 0.5f, true ).OnComplete(() =&gt;<br>
{<br>
UM.bagPanel.SetActive(false);<br>
UM.UI_btns.SetActive(true);<br>
});<br>
2.//当前位置到局部坐标下移动<br>
bgt.transform.DOLocalMove(s, 0.5f, true ).OnComplete(() =&gt;<br>
{<br>
UM.bagPanel.SetActive(false);<br>
UM.UI_btns.SetActive(true);<br>
});<br>
3.//DGT倒放<br>
bgt.transform.DOMove(e, 0.25f, true );<br>
//Tweener对象保存DG返回的动画，设置动画不被销毁时可倒叙播放<br>
Tweener tweener = bgg.transform.DOMove(pe, 0.5f, true);//重复执行时会创建多个动画对象耗费性能，（不接收动画对象直接运行）<br>
tweener.SetAutoKill(false);<br>
tweener.Pause();//暂停<br>
//bgt.transform.DOPlayForward();//+<br>
bgt.transform.DOPlayBackwards();//-<br>
4.//From()<br>
bgt.transform.DOMoveX(5, 1f)//默认从初始位置移动到5，<br>
bgt.transform.DOMoveX(5, 1f).From();//添加From()从5移动到初始位置<br>
bgt.transform.DOMoveX(5, 1f).From(true);//填入参数时：从相“对位”置移动到初始位置<br>
5.//曲线/事件函数<br>
Tweener//DG返回对象<br>
tweener.SetEase(Ease.InBack);//设置曲线(枚举类型)<br>
public enum Ease<br>
{<br>
Unset = 0,<br>
Linear = 1,<br>
InSine = 2,<br>
OutSine = 3,<br>
InOutSine = 4,<br>
InQuad = 5,<br>
OutQuad = 6,<br>
InOutQuad = 7,<br>
InCubic = 8,<br>
OutCubic = 9,<br>
InOutCubic = 10,<br>
InQuart = 11,<br>
OutQuart = 12,<br>
InOutQuart = 13,<br>
InQuint = 14,<br>
OutQuint = 15,<br>
InOutQuint = 16,<br>
InExpo = 17,<br>
OutExpo = 18,<br>
InOutExpo = 19,<br>
InCirc = 20,<br>
OutCirc = 21,<br>
InOutCirc = 22,<br>
InElastic = 23,<br>
OutElastic = 24,<br>
InOutElastic = 25,<br>
InBack = 26,<br>
OutBack = 27,<br>
InOutBack = 28,<br>
InBounce = 29,<br>
OutBounce = 30,<br>
InOutBounce = 31,<br>
Flash = 32,<br>
InFlash = 33,<br>
OutFlash = 34,<br>
InOutFlash = 35,<br>
INTERNAL_Zero = 36,<br>
INTERNAL_Custom = 37<br>
}<br>
tweener.SetLoops(2);//设置循环次数<br>
tweener.OnComplete(() =&gt;//表达式形式在大括号中直接写入语句/或直接传入“方法”<br>
{<br>
UM.bagPanel.SetActive(false);<br>
UM.UI_btns.SetActive(true);<br>
});<br>
6.//生命周期//与其他脚本语言相似常用OnComplete()<br>
7.//文字动画<br>
text.DOText(&quot;文字动画&quot;,2f)/参数：文本动画时间<br>
8.//相机震动<br>
transform.DOShakePosition(1);//参数震动强度<br>
transform.DOShakePosition(1,new Vector3(1,1,0));//参数震动强度，方向约束Vector3(3,3,0)约束的值也可以控制强度<br>
9.//颜色/阿尔法通道(UI)<br>
text.DOColor(Color.cyan, 1f);<br>
text.DOFade(1, 1f);</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Lua面向对象实现]]></title>
        <id>https://Wei715547.github.io/post/lua-mian-xiang-dui-xiang-shi-xian/</id>
        <link href="https://Wei715547.github.io/post/lua-mian-xiang-dui-xiang-shi-xian/">
        </link>
        <updated>2020-09-16T09:28:03.000Z</updated>
        <content type="html"><![CDATA[<p><cood>print(&quot;<strong><strong><strong><strong><strong><strong>封装</strong></strong></strong></strong></strong></strong>__&quot;)<br>
Object = {}<br>
Object.ID = 1<br>
function Object:Text()--&quot;:&quot;自动传入调用这个函数的对象，作为第一个参数传入方法<br>
print(self.ID)--“self”代表默认传入的第一个参数<br>
end</p>
<p>function Object:new( )--类用于创建对象的方法--构造函数<br>
--function Object:new(o)--充当构造函数，返回空表，将本身设为空表的原表来继承类的属性与函数<br>
--local obj= o or {}--o填写时在填入子类的属性/函数基础上创建对象，不填时为空继承父类默认所有属性/函数创建对象（）p1 = Object:new(weight = 100) 或 p1 = Object:new()<br>
local obj = {}<br>
--原表的__index指向自身<br>
self.__index =self--__index:当在自己的表中找不到目标属性时，就会在元表的__index中寻找<br>
setmetatable(obj ,self)<br>
--setmetatable (obj,{__index=self})--与上两句作用相同<br>
return obj<br>
end</p>
<p>local myObj = Object:new()<br>
print(myObj)<br>
print(myObj.ID)<br>
myObj:Text()--myObj调用则传入myObj</p>
<p>print(&quot;_<strong><strong><strong><strong><strong><strong><strong><strong>继承</strong></strong></strong></strong></strong></strong></strong></strong>&quot;)</p>
<p>--构造用于继承的方法<br>
function Object:subClass(className)--声明类的方法<br>
--_G表存储所有的全局变量<br>
_G[className] = {}<br>
local obj = _G[className]<br>
self.__index = self<br>
--为子类定义一个父类属性base<br>
obj.base = self<br>
setmetatable(obj,self)<br>
end</p>
<p>Object:subClass(&quot;Person&quot;)<br>
--print(Person)--此时是通过类名访问属性，类似静态变量<br>
--Person:Text()<br>
--通过对象访问属性<br>
local p1 = Person:new ()--Person继承自Object的new方法。self使Person为第一变量传入<br>
p1:Text()--原表中不存在，会继续查找原表的原表</p>
<p>print(&quot;____________多态————————————————————————————&quot;)</p>
<p>Object:subClass(&quot;GameObject&quot;)--声明游戏对象类<br>
GameObject.posX = 0<br>
GameObject.posY = 0<br>
function GameObject:Move()<br>
self .posX = self.posX+1<br>
self.posY = self.posY+1<br>
print(self.posX)<br>
print(self.posX)</p>
<p>end</p>
<p>GameObject:subClass(&quot;Player&quot;)--声明角色类</p>
<p>function Player:Move()--与父类方法“重名&quot;即相当于重写方法<br>
--此时base指GameObject类，使用“：”调用相当于把基类作为第一参数传入方法中，则此时创建pl2时会输出2，2<br>
--self.base:Move()<br>
--因此为了避免把基类表传入方法中，不使用“：”调用<br>
self.base.Move(self)--使用.进行调用自行填入第一个传入的参数<br>
print(&quot;子类重写&quot;)<br>
end</p>
<p>local pl1 = Player:new()--角色类对象<br>
pl1:Move()</p>
<p>local pl2 = Player:new()<br>
pl2:Move()<cood></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Grass批量生成]]></title>
        <id>https://Wei715547.github.io/post/grass-pi-liang-sheng-cheng/</id>
        <link href="https://Wei715547.github.io/post/grass-pi-liang-sheng-cheng/">
        </link>
        <updated>2020-09-14T15:09:33.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://Wei715547.github.io/post-images/1600096518618.PNG" alt="" loading="lazy"><br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
[ExecuteInEditMode]<br>
public class ProceduralGrass : MonoBehaviour<br>
{<br>
#region Terrain Data<br>
[Range(0, 1000)]<br>
public int terrainSize = 250;          //地形大小<br>
[Range(0, 100f)]<br>
public float terrainHeight = 10f;          //地形高度<br>
public Material terrainMat;          //地形材质</p>
<pre><code>private float xOffset;
private float zOffset;

[Range(1f, 100f)]
public float scaleFatter = 10f;          //地形缩放
[Range(1f, 100f)]
public float offsetFatter = 10f;          //地形偏移

List&lt;Vector3&gt; vertexs = new List&lt;Vector3&gt;();          //顶点列表，存储网格顶点信息
List&lt;int&gt; triangles = new List&lt;int&gt;();          //三角形面列表，存储网格三角形信息
float[,] perlinNoise;          //存储每个顶点的高度值

Vector3[] terrainNormals;          //存储地形的顶点法线的一维数组
Vector3[,] terrainNormals2D;          //存储地形的顶点法线的二维数组
#endregion 
//___________________________________________________________________________
#region Grass Data
[Range(0, 100)]
public int grassRowCount = 50;          //草根集,定义草的广度
[Range(1, 1000)]
public int grassCountPerPatch = 100;          //定义每一堆 草根集 的草密度
public Material grassMat;           //草的材质
public Mesh grassMesh;          //草的网格
List&lt;Vector3&gt; grassVerts = new List&lt;Vector3&gt;();          //存储草的顶点

Vector3[] grassNormals;          //存储草的顶点法线
List&lt;Vector3&gt; grassNormalList = new List&lt;Vector3&gt;();          //存储草的顶点法线列表
#endregion

void Start()
{
    xOffset = transform.position.x;
    zOffset = transform.position.z;
    terrainNormals = new Vector3[terrainSize * terrainSize];//顶点法线数组容量250*250
    terrainNormals2D = new Vector3[terrainSize, terrainSize];//2D顶点法线数组容量250*250
    perlinNoise = new float[terrainSize, terrainSize];//顶点高度数组容量250*250
    GenerateTerrain();//生成地形

    GenerateGrassArea(grassRowCount, grassCountPerPatch);//生成草地（广度，密度）

    
}

void CreateVertsAndTris()
{
    //遍历每一个顶点，并用列表 vertexs 和 triangles 存储
    for (int i = 0; i &lt; terrainSize; i++)
    {
        for (int j = 0; j &lt; terrainSize; j++)
        {
            float noiseHeight = GeneratePerlinNoise(i, j);//顶点随机高度
            perlinNoise[i, j] = noiseHeight;//该坐标下的顶点高度存入数组

            vertexs.Add(new Vector3(i, noiseHeight * terrainHeight, j));//顶点坐标（x,y,z）

            //不算上坐标轴的顶点
            if (i == 0 || j == 0)
                continue;

            //每三个顶点作为一个索引建立三角形
            triangles.Add(terrainSize * i + j);
            triangles.Add(terrainSize * i + j - 1);
            triangles.Add(terrainSize * (i - 1) + j - 1);
            triangles.Add(terrainSize * (i - 1) + j - 1);
            triangles.Add(terrainSize * (i - 1) + j);
            triangles.Add(terrainSize * i + j);
        }
    }

    //清空grassVerts的数据    
    grassVerts.Clear();
}

//生成地形高度的随机 Perlin 值
float GeneratePerlinNoise(int i, int j)
{
    float xCoord = (float)(i + xOffset) / terrainSize * scaleFatter + offsetFatter;
    float zCoord = (float)(j + zOffset) / terrainSize * scaleFatter + offsetFatter;

    return Mathf.PerlinNoise(xCoord, zCoord);
}

//生成地形网格数据
void GenerateTerrain()
{
    CreateVertsAndTris();

    //计算UV(二维向量-顶点坐标作为法线方向)
    Vector2[] uvs = new Vector2[vertexs.Count];
    for (int i = 0; i &lt; vertexs.Count; i++)
    {
        uvs[i] = new Vector2(vertexs[i].x, vertexs[i].z);
    }

    //添加一个 MyTerrain 的物体，并添加 MeshFilter / MeshRenderer 两个组件
    //MeshFilter 存储物体的网格信息
    //MeshRenderer 负责接收这些信息并把这些信息渲染出来
    GameObject Myterrain = new GameObject(&quot;Terrain0&quot;);
    Myterrain.transform.position = this.gameObject.transform.position;
    Myterrain.AddComponent&lt;MeshFilter&gt;();
    MeshRenderer renderer = Myterrain.AddComponent&lt;MeshRenderer&gt;();
    //开启地面的阴影投射和接受
    renderer.receiveShadows = true;
    renderer.shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.On;
    //添加Mesh Collider
    MeshCollider collider = Myterrain.AddComponent&lt;MeshCollider&gt;();

    //添加材质
    renderer.sharedMaterial = terrainMat;

    //创建一个 Mesh 网格
    Mesh groundMesh = new Mesh//网格构造函数
    {
        //输入网格顶点数据
        vertices = vertexs.ToArray(),
        //输入网格三角面数据
        triangles = triangles.ToArray(),
        uv = uvs
    };

    //为了得到正确的光照需要重新计算得到正确的法线信息
    groundMesh.RecalculateNormals();
    terrainNormals = groundMesh.normals;

    //将存储地形法线数组从一维数组转为二维，便于索引
    for (int i = 0; i &lt; terrainSize; i++)
    {
        for (int j = 0; j &lt; terrainSize; j++)
        {
            terrainNormals2D[i, j] = terrainNormals[i * terrainSize + j];
        }
    }
    //网格赋值到渲染器/碰撞体
    Myterrain.GetComponent&lt;MeshFilter&gt;().mesh = groundMesh;
    collider.sharedMesh = groundMesh;
}

void GenerateGrassArea(int rowCount, int perPatchSize)
{
    //最大顶点数为 65000
    List&lt;int&gt; indices = new List&lt;int&gt;();
    for (int i = 0; i &lt; 65000; i++)
    {
        indices.Add(i);
    }

    //初始位置
    Vector3 currentPos = transform.position;
    //草根集 每一次循环偏移的距离
    Vector3 patchSize = new Vector3(terrainSize / rowCount, 0, terrainSize / rowCount);

    //每一堆 草根集 进行循环
    for (int i = 0; i &lt; rowCount; i++)
    {
        for (int j = 0; j &lt; rowCount; j++)
        {
            GenerateGrass(currentPos, patchSize, perPatchSize);
            currentPos.x += patchSize.x;
        }
        currentPos.x = transform.position.x;
        currentPos.z += patchSize.z;
    }

    //生成 GrassLayerGruop 来成为父级管理物理
    GameObject grassLayerGroup1 = new GameObject(&quot;GrassLayerGroup1&quot;);
    //生成 GrassLayer 物体来存储草数据
    GameObject grassLayer;
    MeshFilter grassMeshFilter;
    //Mesh grassMesh;
    MeshRenderer grassMeshRenderer;
    int a = 0;

    //当 grassVerts.Count 的数量即草的全部顶点数超过 65000 个时
    //创立多个网格处理
    while (grassVerts.Count &gt; 65000)
    {
        Debug.Log(&quot;More65000&quot;);
        grassMesh = new Mesh();
        grassMesh.vertices = grassVerts.GetRange(0, 65000).ToArray();
        //存储每个草顶点的法线（当顶点超过 65000个）
        grassNormals = new Vector3[65000];
        grassNormalList.GetRange(0, 65000);
        for (int i = 0; i &lt; 65000; i++)
        {
            grassNormals[i] = grassNormalList[i];
        }

        //设置子网格的索引缓冲区,相关官方文档：https://docs.unity3d.com/ScriptReference/Mesh.SetIndices.html
        //每一个创建的网格的顶点数目不会超过 65000 个
        grassMesh.SetIndices(indices.ToArray(), MeshTopology.Points, 0);

        //创建一个新的 GameObject 来承载这些点
        grassLayer = new GameObject(&quot;GrassLayer &quot; + a++);
        grassLayer.transform.SetParent(grassLayerGroup1.transform);
        grassMeshFilter = grassLayer.AddComponent&lt;MeshFilter&gt;();
        grassMeshRenderer = grassLayer.AddComponent&lt;MeshRenderer&gt;();
        //关闭草地的阴影投射和接受
        grassMeshRenderer.receiveShadows = false;
        grassMeshRenderer.shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.Off;
        grassMeshRenderer.sharedMaterial = grassMat;
        grassMesh.normals = grassNormals;
        grassMeshFilter.mesh = grassMesh;
        //移除前 65000 个顶点
        grassVerts.RemoveRange(0, 65000);
        grassNormalList.RemoveRange(0, 65000);
    }
    #region 草的数量少于6500时
    //当 grassVerts.Count 的数量即草的全部顶点数没有超过 65000 个时
    grassLayer = new GameObject(&quot;GrassLayer&quot; + a);
    grassLayer.transform.SetParent(grassLayerGroup1.transform);
    grassMeshFilter = grassLayer.AddComponent&lt;MeshFilter&gt;();
    grassMeshRenderer = grassLayer.AddComponent&lt;MeshRenderer&gt;();
    
    //关闭草地的阴影投射和接受
    grassMeshRenderer.receiveShadows = false;
    grassMeshRenderer.shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.Off;
    grassMesh = new Mesh
    {
        vertices = grassVerts.ToArray()
    };

    //存储每个草顶点的法线（当顶点没有超过 65000个）
    grassNormals = new Vector3[grassMesh.vertexCount];
    grassNormalList.GetRange(0, grassMesh.vertexCount);
    for (int i = 0; i &lt; grassMesh.vertexCount; i++)
    {
        grassNormals[i] = grassNormalList[i];
    }
    grassMesh.normals = grassNormals;
    //设立子网格数据
    grassMesh.SetIndices(indices.GetRange(0, grassVerts.Count).ToArray(), MeshTopology.Points, 0);

    grassMeshFilter.mesh = grassMesh;
    grassMeshRenderer.sharedMaterial = grassMat;
    #endregion
}

//生成草
void GenerateGrass(Vector3 vertPos, Vector3 patchSize, int grassCountPerPatch)
{
    //每一堆 草根集 里的草进行循环
    for (int i = 0; i &lt; grassCountPerPatch; i++)
    {
        //Random.value 返回 0~1 之间的随机值
        //得到在两个 草根集 之间的草的随机位置并用索引值
        float randomX = Random.value * patchSize.x;
        float randomZ = Random.value * patchSize.z;

        int indexX = (int)((vertPos.x - transform.position.x) + randomX);
        int indexZ = (int)((vertPos.z - transform.position.z) + randomZ);

        //防止草种出地形
        if (indexX &gt;= terrainSize)
        {
            Debug.Log(&quot;Full&quot;);
            indexX = (int)terrainSize - 1;
        }

        if (indexZ &gt;= terrainSize)
        {
            Debug.Log(&quot;Full&quot;);
            indexZ = (int)terrainSize - 1;
        }

        //添加每一个草的顶点位置到 grassVert 列表里
        grassVerts.Add(new Vector3(vertPos.x + randomX, perlinNoise[indexX, indexZ] * terrainHeight, vertPos.z + randomZ));//包括草地Mesh网格顶点高度值

        //添加每一个草的顶点法线到 grassNormalList 列表里
        grassNormalList.Add(terrainNormals2D[indexX, indexZ]);//草地Mesh网格顶点法线，与同坐标的地面网格法线相同
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unet局域网连接]]></title>
        <id>https://Wei715547.github.io/post/unet-ju-yu-wang-lian-jie/</id>
        <link href="https://Wei715547.github.io/post/unet-ju-yu-wang-lian-jie/">
        </link>
        <updated>2020-09-12T03:14:28.000Z</updated>
        <content type="html"><![CDATA[<p>NetWorkManager:<br>
<img src="https://Wei715547.github.io/post-images/1599881098982.PNG" alt="" loading="lazy"></p>
<p>Player:<br>
<img src="https://Wei715547.github.io/post-images/1599881197525.PNG" alt="" loading="lazy"><br>
PlayerCT Cood:<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.Networking;</p>
<p>//[System.Obsolete]<br>
public class PlayerCT : NetworkBehaviour<br>
{</p>
<pre><code>public int rotateSpeed = 120;
public int moveSpeed = 3;

public GameObject Bullet;
public Transform firePoint;

// Update is called once per frame
void Update()
{
    if (isLocalPlayer == false)//控制本地角色
        return;
    float h = Input.GetAxis(&quot;Horizontal&quot;);
    float v = Input.GetAxis(&quot;Vertical&quot;);

    transform.Rotate(Vector3.up * h * rotateSpeed * Time.deltaTime); 
    transform.Translate(Vector3.forward * v * moveSpeed * Time.deltaTime);

    if (Input.GetKeyDown(KeyCode.Space))
    {
        CmdFire();
    }

}
[Command]//客户端发起调用，服务端执行
void CmdFire()//服务端调用的方法以Cmd开头
{
    GameObject bullet = Instantiate(Bullet, firePoint.position, firePoint.rotation);
    bullet.GetComponent&lt;Rigidbody&gt;().velocity = transform.forward * 10;//Bulet预制体添加Network Transform监测刚体组件（初始监测一次施加速度）
    Destroy(bullet, 2f);//2s后销毁

    NetworkServer.Spawn(bullet);//服务端执行同步到客户端
}

public override void OnStartLocalPlayer()//回调函数：加角色时执行
{
    GetComponent&lt;MeshRenderer&gt;().material.color = Color.blue;
    //firePoint = transform.Find(&quot;FirePoint&quot;).GetComponent&lt;Transform&gt;();
}
</code></pre>
<p>}</p>
<hr>
<p>Player Health Cood:<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.UI;<br>
using UnityEngine.Networking;</p>
<p>[System.Obsolete]<br>
public class Health : NetworkBehaviour<br>
{<br>
private Slider hpSl;<br>
public const int hp = 100;<br>
[SyncVar(hook =&quot;OnChangeHealth&quot;)]//特性：变量数据同步到客户端，变量变化时调用方法“方法名”<br>
private int currentHp = hp;<br>
private void Start()<br>
{<br>
hpSl = transform.Find(&quot;Canvas/HpSlider&quot;).GetComponent <Slider >();</p>
<pre><code>}
public void TakeDamage(int damege)
{
    if (isServer == false)//服务端执行，同步到客户端
        return;
    currentHp -= damege;
    if (currentHp &lt;=0)
    {
        currentHp = hp;
        Debug.Log(&quot;Dead&quot;);
        //Destroy(this.gameObject);
        RpcRespown();//角色复位
    }
    
}
void OnChangeHealth(int health)//[SyncVar hook=&quot;方法&quot;]特性标记的变量值发生变化时执行
{
    hpSl.value = health / (float)hp;
}
[ClientRpc]//客户端调用
void RpcRespown()//客户端调用以Rpc开头
{
    if (isLocalPlayer == false)//本地角色执行
        return;
    transform.position = Vector3.zero;
}
</code></pre>
<p>}</p>
<hr>
<p><img src="https://Wei715547.github.io/post-images/1599881655946.PNG" alt="" loading="lazy"><br>
Bullet Cood:<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class Bullet : MonoBehaviour<br>
{<br>
[System.Obsolete]<br>
private void OnCollisionEnter(Collision collision)<br>
{<br>
GameObject hit = collision.gameObject;<br>
Health health = hit.GetComponent<Health>();<br>
if (health !=null)<br>
{<br>
health.TakeDamage(Random.Range(10, 21));<br>
Destroy(this.gameObject);<br>
}<br>
}<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shader,屏幕后处理(Post Effect)]]></title>
        <id>https://Wei715547.github.io/post/shaderping-mu-hou-chu-li-post-effect/</id>
        <link href="https://Wei715547.github.io/post/shaderping-mu-hou-chu-li-post-effect/">
        </link>
        <updated>2020-09-08T07:34:21.000Z</updated>
        <content type="html"><![CDATA[<p>挂在主相机上的脚本：<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
[ExecuteInEditMode]//在编译器下执行脚本（不用点击开始即执行）<br>
public class Post : MonoBehaviour<br>
{<br>
public Material EffectMat;//承载后处理Shader的材质</p>
<pre><code>private void OnRenderImage(RenderTexture source, RenderTexture destination)//该函数在所有的渲染完成后由monobehavior自动调用。
//官方解释：该函数允许我们使用着色器滤波操作来修改最终的图像，输入原图像source，输出的图像放在desitination里。
{
    if (EffectMat !=null)
    {
        Graphics.Blit(source, destination, EffectMat);//该函数的作用就是通过一个shader将原图的像素放置到destionation中。
    }
}
</code></pre>
<p>}<br>
——————————————————————————————————————<br>
<img src="https://Wei715547.github.io/post-images/1599552275469.PNG" alt="" loading="lazy"><br>
Shader1画面溶解流动效果：<br>
Shader &quot;Shader104/Distortion&quot;<br>
{<br>
Properties<br>
{<br>
_MainTex(&quot;Texture&quot;, 2D) = &quot;white&quot; {}<br>
_DisplaceTex(&quot;Displacement Texture&quot;, 2D) = &quot;white&quot; {}<br>
_Magnitude(&quot;Magnitude&quot;, Range(0,0.1)) = 1</p>
<pre><code>}

SubShader
{
    Tags
    {
        &quot;Queue&quot; = &quot;Transparent&quot;
    }

    Pass{
        Blend SrcAlpha OneMinusSrcAlpha

        CGPROGRAM
        #pragma vertex vert
        #pragma fragment frag

        #include &quot;UnityCG.cginc&quot;

        struct appdata
        {
            float4 vertex : POSITION;
            float2 uv : TEXCOORD0;
        };

        struct v2f
        {
            float4 vertex : SV_POSITION;
            float2 uv : TEXCOORD0;
        };

        v2f vert(appdata v)
        {
            v2f o;
            o.vertex = UnityObjectToClipPos(v.vertex);
            o.uv = v.uv;
            return o;
        };

        sampler2D _MainTex;
        sampler2D _DisplaceTex;//噪波贴图
        float _Magnitude;

        float4 frag(v2f i): SV_Target//画面流动效果
        {
            float2 distuv = float2(i.uv.x + _Time.x * 2, i.uv.y + _Time.x * 2);
            float2 disp = tex2D(_DisplaceTex, distuv).xy;//噪波贴图的.rg
            disp = ((disp * 2) - 1) * _Magnitude;
            float4 col = tex2D(_MainTex, i.uv + disp);
            return col;
        }
        ENDCG
    }
}
</code></pre>
<p>}<br>
————————————————————————————————————————<br>
<img src="https://Wei715547.github.io/post-images/1599552284677.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1599552463055.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1599553049020.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1599553279813.PNG" alt="" loading="lazy"><br>
Shader2屏幕黑白、反色、RGB分离、像素效果：<br>
Shader &quot;Shader104/GreyScale&quot;<br>
{<br>
Properties<br>
{<br>
_MainTex(&quot;Texture&quot;, 2D) = &quot;white&quot; {}<br>
_Slider(&quot;Slider&quot;,Range(0,1)) = 0.5<br>
}</p>
<pre><code>SubShader
{
	Tags
	{
		&quot;PreviewType&quot; = &quot;Plane&quot;
	}
	Pass
	{
		CGPROGRAM
		#pragma vertex vert
		#pragma fragment frag

		#include &quot;UnityCG.cginc&quot;

		struct appdata
		{
			float4 vertex : POSITION;
			float2 uv: TEXCOORD0;
		};

		struct v2f
		{
			float4 vertex : SV_POSITION;
			float2 uv: TEXCOORD0;
		};

		sampler2D _MainTex;
		float _Slider;

		v2f vert(appdata v)
		{
			v2f o;
			o.vertex = UnityObjectToClipPos(v.vertex);
			o.uv = v.uv;
			return o;
		}

		float4 frag(v2f i) : SV_Target
		{
            /*pixelate像素效果对UV进行变换
            float2 uv = i.uv;
            uv.x *= _PixelateAmt;
            uv.y *= _PixelateAmt;
            uv.x = round(uv.x);
            uv.y = round(uv.y);
            uv.x /= _PixelateAmt;
            uv.y /= _PixelateAmt;*/
			float4 color = tex2D(_MainTex,i.uv);//默认混合颜色(白色)：不进行后处理
			float average = 0.212 * color.r + 0.7152 * color.g + 0.0722 * color.b;//颜色黑白化
			if (i.uv.x &gt; _Slider)//大于Slidr的部分进行后处理
				return float4(average, average, average, 1);
                //return float4(1-color.r, 1-color.g, 1-color.b, 1);//反色
			else
				return color;
             /*chromatic aberration RGB分离
            float4 red = tex2D(_MainTex , i.uv - _Offset);           
            float4 green = tex2D(_MainTex, i.uv);
            float4 blue = tex2D(_MainTex, i.uv + _Offset);
            float4 color = float4(red.r,green.g,blue.b,1);
            return color;*/
		}
		ENDCG
	}
}
</code></pre>
<p>}<br>
————————————————————————————————————————<br>
<img src="https://Wei715547.github.io/post-images/1599552847954.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1599553788615.PNG" alt="" loading="lazy"><br>
Shader3Kernal矩阵边缘检测、渐变着色:<br>
Shader &quot;Shader104/Kernal&quot;<br>
{<br>
Properties<br>
{<br>
_MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}<br>
_Matrix00 (&quot;Matrix00&quot;,float) = 1<br>
_Matrix01 (&quot;Matrix01&quot;,float) = 1<br>
_Matrix02 (&quot;Matrix02&quot;,float) = 1<br>
_Matrix10 (&quot;Matrix10&quot;,float) = 1<br>
_Matrix11 (&quot;Matrix11&quot;,float) = -8<br>
_Matrix12 (&quot;Matrix12&quot;,float) = 1<br>
_Matrix20 (&quot;Matrix20&quot;,float) = 1<br>
_Matrix21 (&quot;Matrix21&quot;,float) = 1<br>
_Matrix22 (&quot;Matrix22&quot;,float) = 1<br>
_Slider(&quot;Slider&quot;,Range(0,1)) = 0.5<br>
_Threshold(&quot;_Threshold&quot;,Range(0,1)) = 0.1<br>
_EdgeColor(&quot;_EdgeColor&quot;,Color) = (1,1,1,1)<br>
_BackColor(&quot;_BackColor&quot;,Color) = (0,0,0,0)</p>
<pre><code>}
SubShader
{
    Tags
    {
        &quot;PreviewType&quot; = &quot;Plane&quot;
    }

    Pass
    {
        CGPROGRAM
        #pragma vertex vert
        #pragma fragment frag
        
        #include &quot;UnityCG.cginc&quot;

        struct appdata
        {
            float4 vertex : POSITION;
            float2 uv : TEXCOORD0;
        };

        struct v2f
        {
            float2 uv : TEXCOORD0;
            float4 vertex : SV_POSITION;
        };

        v2f vert (appdata v)
        {
            v2f o;
            o.vertex = UnityObjectToClipPos(v.vertex);
            o.uv = v.uv;
            return o;
        }
        
        sampler2D _MainTex;
        float4 _MainTex_TexelSize;
        float _Matrix00;
        float _Matrix01;
        float _Matrix02;
        float _Matrix10;
        float _Matrix11;
        float _Matrix12;
        float _Matrix20;
        float _Matrix21;
        float _Matrix22;
        float _Slider;
        float _Threshold;
        float4 _EdgeColor;//边缘色
        float4 _BackColor;//背景色

        float4 box(sampler2D tex, float2 uv, float4 size)//检测函数
        {
            float4 c = tex2D(tex, uv + float2(-size.x, size.y))*_Matrix00 + tex2D(tex, uv + float2(0, size.y))*_Matrix01 
            + tex2D(tex, uv + float2(size.x, size.y)) *_Matrix02 + tex2D(tex, uv + float2(-size.x, 0)) * _Matrix10
            + tex2D(tex, uv + float2(0, 0))*_Matrix11 + tex2D(tex, uv + float2(size.x, 0))*_Matrix12 
            + tex2D(tex, uv + float2(-size.x, -size.y))*_Matrix20 + tex2D(tex, uv + float2(0, -size.y))*_Matrix21
            + tex2D(tex, uv + float2(size.x, -size.y))*_Matrix22;

            return c / (_Matrix00+_Matrix01+_Matrix02+_Matrix10+_Matrix11+_Matrix12+_Matrix20+_Matrix21+_Matrix22);
        }

        float4 frag (v2f i) : SV_Target
        {
            float4 color = tex2D(_MainTex, i.uv);
            if(i.uv.x&gt;_Slider)
			{//边缘检测
                color = box(_MainTex, i.uv, _MainTex_TexelSize);
                if (color.r &lt;= _Threshold &amp;&amp; color.g &lt;= _Threshold &amp;&amp; color.b &lt;= _Threshold)//渐变着色
                    return _EdgeColor;
                else
                    return _BackColor;
            }
            else
                if (color.r &lt;= _Threshold &amp;&amp; color.g &lt;= _Threshold &amp;&amp; color.b &lt;= _Threshold)//渐变着色
                    return color;
                else
                    return float4(1, 1, 1, 1);//未上色部分为白色
        }
        ENDCG
    }
}
</code></pre>
<p>}<br>
————————————————————————————————————<br>
<img src="https://Wei715547.github.io/post-images/1599556756456.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1599556177672.PNG" alt="" loading="lazy"><br>
Shader深度值渲染/范围扫描：<br>
相机脚本：<br>
using UnityEngine;<br>
using System.Collections;<br>
using System.Collections.Generic;</p>
<p>[ExecuteInEditMode]<br>
public class ReplacementShaderEffect : MonoBehaviour<br>
{<br>
public Color color;<br>
public float slider;<br>
public Shader ReplacementShader;</p>
<pre><code>void OnValidate()
{
    Shader.SetGlobalColor(&quot;_Color_1&quot;, color);//获取Shader中未公开的全局变量
}

private void Update()
{
    Shader.SetGlobalFloat(&quot;_Temp&quot;, slider);//获取Shader中未公开的全局变量
}

void OnEnable()
{
    if (ReplacementShader != null)
        GetComponent&lt;Camera&gt;().SetReplacementShader(ReplacementShader, &quot;&quot;);
}

void OnDisable()
{
    GetComponent&lt;Camera&gt;().ResetReplacementShader();
}
</code></pre>
<p>}<br>
————————————————————————————————<br>
Shader程序：<br>
Shader &quot;Shader102/Depth&quot;<br>
{<br>
SubShader<br>
{<br>
Tags<br>
{<br>
&quot;RenderType&quot; = &quot;Opaque&quot;<br>
}</p>
<pre><code>	ZWrite On


	Pass
	{
		CGPROGRAM
		#pragma vertex vert
		#pragma fragment frag

		#include &quot;UnityCG.cginc&quot;

		struct appdata
		{
			float4 vertex : POSITION;
		};

		struct v2f
		{
			float4 vertex : SV_POSITION;
			float depth : DEPTH;
		};

		v2f vert(appdata v)
		{
			v2f o;
			o.vertex = UnityObjectToClipPos(v.vertex);
			o.depth = -(mul(UNITY_MATRIX_MV, v.vertex).z) * _ProjectionParams.w;//相机坐标空间下的深度值
			return o;
		}
		//未公开的全局变量
		float4 _Color_1;
		float _Temp;
        //根据深度值切换渲染方式
		/*fixed4 frag(v2f i) : SV_Target
		{
			float invert = 1 - i.depth;//近处颜色为白色

		if (i.depth &lt;_Temp / 2)//不同深度下实现不同的渲染方式
			return fixed4(invert, invert, invert, 1);
		else
			return fixed4(invert*1.5, 0.3, 0.3,1) ;
		}*/
        //范围扫描
        fixed4 frag(v2f i) : SV_Target
		{
			float invert = 1 - i.depth;//近处颜色为白色

		if (abs(i.depth- _Temp / 2)&lt;0.005)//深度范围绝对值内扫描的渲染方式
			return fixed4(invert*2, 0.2, 0.2, 1);
		else//正常渲染方式
			return fixed4(invert, 0.3, 0.3,1) ;
		}
		ENDCG
	}
}
</code></pre>
<p>}<br>
数值动画/代码：<br>
timer += Time.deltaTime;<br>
if (timer &gt;2.0f)<br>
{<br>
ht += Time.deltaTime*(1/5f);<br>
slider = Mathf.Lerp(0f, 10f, 0.5f * ht);<br>
if (ht&gt;=1f)<br>
{<br>
ht = 0;<br>
slider = 0;<br>
timer = 0;<br>
}<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UGUI 背包模块(事件订阅/渗透)]]></title>
        <id>https://Wei715547.github.io/post/ugui-bei-bao-mo-kuai-shi-jian-ding-yue-shen-tou/</id>
        <link href="https://Wei715547.github.io/post/ugui-bei-bao-mo-kuai-shi-jian-ding-yue-shen-tou/">
        </link>
        <updated>2020-09-02T14:26:34.000Z</updated>
        <content type="html"><![CDATA[<p>UI搭建：<img src="https://Wei715547.github.io/post-images/1599057822367.PNG" alt="" loading="lazy"><br>
————————————————————————————————<br>
代码：</p>
<p>装备共有属性类：<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public enum ArticleType//装备种类<br>
{<br>
Weapon,<br>
Drag,<br>
Collect,<br>
Pick<br>
}</p>
<p>public class Article //装备属性类(装备共有参数)<br>
{<br>
public string name;//装备名称<br>
public string spritPath;//装备UI图路径<br>
public ArticleType articleType;//装备类型<br>
public int count;//装备数量</p>
<pre><code>//构造函数
public Article(string name,string spritPath,ArticleType articleType,int count)
{
    this.name = name;
    this.spritPath = spritPath;
    this.articleType = articleType;
    this.count = count;
}
</code></pre>
<p>}<br>
——————————————————————————————<br>
装备“物品”类<br>
using System;<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.UI;</p>
<p>public class ArticleItem : MonoBehaviour<br>
{<br>
private Image articleSprit;<br>
private Text count;<br>
public Article article;<br>
private UIDrag UIDrag;//实现拖拽的类<br>
private Canvas canvas;//物体上的Canvas组件，用于物体显示在上层<br>
//private CanvasGroup canvasGroup;//拖拽此物体是取消其射线检测,代替事件渗透<br>
private int defortSort;<br>
//private Transform Origentparent;</p>
<pre><code>private Vector3 currentLocalPosition;
private float moveTimer;
public float moveTime = 0.2f;

private bool isMoving = false;

private Action onMoveEnd;

// Start is called before the first frame update
void Awake()
{
    articleSprit = transform.GetComponent&lt;Image&gt;();
    count = transform.Find(&quot;ItemCount&quot;).GetComponent&lt;Text&gt;();
    //将对应拖拽状态时要掉用的方法注册到拖拽类的委托链
    UIDrag = transform.GetComponent&lt;UIDrag&gt;();
    UIDrag.onStartDrag += OnStartDrag;
    UIDrag.onDrag += OnDrag;
    UIDrag.onEndDrag += OnEndDrag;
    
    canvas = transform.GetComponent&lt;Canvas&gt;();
    defortSort = canvas.sortingOrder;
    //canvasGroup = transform.GetComponent&lt;CanvasGroup&gt;();
    
    //currentLocalPosition = transform.localPosition;
}
private void Start()
{
    transform.localPosition = Vector3.zero;
    currentLocalPosition = transform.localPosition;
}
private void Update()
{
    MoveBack();
}
//Lerpg固定时间内完成执行
private void MoveBack()
{
    if (isMoving)
    {
        moveTimer += Time.deltaTime * (1 / moveTime);//0.2秒后为1
        transform.localPosition = Vector3.Lerp(currentLocalPosition, Vector3.zero, moveTimer);
        if (moveTimer &gt;= 1)
        {
            isMoving = false;
            //MoveToOrigin方法导致的事件完成后执行自身委托
            onMoveEnd?.Invoke();
        }
    }
}
//执行Lerp
public void MoveToOrigin(Action onMoveEnd)
{
    isMoving = true;
    moveTimer = 0;
    currentLocalPosition = transform.localPosition;
    this.onMoveEnd = onMoveEnd;//将之后要执行的方法方到自身委托链上
}
//设置装备属性(UI图标，数量等)
public void SetArticle(Article article)
{
    this.article = article;

    //显示数据
    articleSprit.sprite = Resources.Load&lt;Sprite&gt;(this.article.spritPath);
    count.text = this.article.count.ToString();
}
//开始拖拽时执行
public void OnStartDrag()
{
    canvas.sortingOrder = defortSort + 1;//显示在同级上层
    //transform.SetParent(transform.parent.parent);
    BagPanel.instence.curretnAricle = this;//正在拖拽的为此物体
}
public void OnDrag()
{

}
//拖拽结束时执行
public void OnEndDrag()
{
    //结束拖拽时所选格子不为空时，物品进入格子，
    if (BagPanel.instence.currtenHoverGrid != null &amp;&amp; !BagPanel.instence.currtenHoverGrid.gameObject.Equals(transform.parent.gameObject))
    {
        BagPanel.instence.currtenHoverGrid.DragIntoGride(BagPanel.instence.curretnAricle);//格子的方法
        canvas.sortingOrder = defortSort;//恢复层级
    }
    else//为空则返回
    {
        //transform.SetParent(Origentparent);
        //使用委托实现结束后执行
        MoveToOrigin(() =&gt; { canvas.sortingOrder = defortSort; });//表达式内为方法结束后要执行的语句
    }
    BagPanel.instence.curretnAricle = null;//结束拖拽时正在拖拽的物体为空
}    
</code></pre>
<p>}<br>
——————————————————————————————<br>
实现拖拽的类：<br>
using System;<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.EventSystems;</p>
<p>public class UIDrag : MonoBehaviour,IBeginDragHandler,ICanvasRaycastFilter ,IDragHandler,IEndDragHandler<br>
{<br>
private Vector3 mousePosition;<br>
private RectTransform rect;</p>
<pre><code>public Action onDrag;
public Action onStartDrag;
public Action onEndDrag;

private bool isDraging = false;

private void Awake()
{
    rect = GetComponent&lt;RectTransform&gt;();
    if (rect ==null)
    {
        throw new System.Exception(&quot;只能拖拽UI物体&quot;);
    }
}
//使用事件渗透监听不到拖拽事件时可用下面代码
/*private void Update()
{
    if (isDraging)
    {
        *//*rect.anchoredPosition += (Vector2)(Input.mousePosition - mousePosition);
        mousePosition = Input.mousePosition;
        //transform.position = eventData.position; //中心随光标移动
        //锚点的位置加上鼠标移动
        //rect.anchoredPosition += eventData.delta;
        //if (onDrag != null) onDrag();
        onDrag?.Invoke();*//*
    }
    if(Input .GetMouseButtonUp(0)&amp;&amp;isDraging==true)
    {
        onEndDrag?.Invoke();
        isDraging = false;
    }
}*/

public void OnBeginDrag(PointerEventData eventData)
{
    mousePosition = Input.mousePosition;
    onStartDrag?.Invoke();
    isDraging = true;
}
//事件渗透接口：渗透过当前事件向下进行事件检测（背包系统渗透装备UI图标向下检测所在物品栏）
public bool IsRaycastLocationValid(Vector2 sp, Camera eventCamera)//事件渗透接口：返回值TRUE时：检测，返回值为FALES：渗透事件。
{
    return !isDraging;
}
//事件渗透监听不到此接口事件(实际监听的到)，但要保留接口实现拖拽
public void OnDrag(PointerEventData eventData)//参数为相机与点击物体的射线检测点
{
    rect.anchoredPosition += (Vector2)(Input.mousePosition - mousePosition);
    mousePosition = Input.mousePosition;
    //transform.position = eventData.position; //中心随光标移动
    //锚点的位置加上鼠标移动
    //rect.anchoredPosition += eventData.delta;
    //if (onDrag != null) onDrag();
    onDrag?.Invoke();
}
//事件渗透监听不到此接口事件(实际监听的到)
public void OnEndDrag(PointerEventData eventData)
{
    onEndDrag?.Invoke();
    isDraging = false;
}
</code></pre>
<p>}<br>
——————————————————————————————<br>
格子类：<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.EventSystems;<br>
using UnityEngine.UI;</p>
<p>public class BagGrde : MonoBehaviour , IPointerEnterHandler,IPointerExitHandler<br>
{<br>
private ArticleItem articleItem;</p>
<pre><code>private Image bgImage;
private Color defortColor;

public ArticleItem ArticleItem
{
    get { return articleItem; }
}

private void Awake()
{
    bgImage = transform.GetComponent&lt;Image&gt;();
    defortColor = bgImage.color;
}
//设置格子内的装备物品方法
public void SetArticleItem(ArticleItem articleItem)
{
    this.articleItem = articleItem;//此格子装着的物品
    this.articleItem.gameObject.SetActive(true);
    //将此物品栏设置父物体
    this.articleItem.transform.SetParent(transform);
    //刷新背包时直接设置位置，取消物品UI缓动效果
    articleItem.transform.localPosition = Vector3.zero;

    //防止发生变化
    //设置位置
    //this.articleItem.transform.localPosition = Vector3.zero;
    this.articleItem.MoveToOrigin(() =&gt;//用物品类里面的方法实现拖拽到格子时的缓动效果
   {//设置5px的边界值
       this.articleItem.GetComponent&lt;RectTransform&gt;().offsetMin = new Vector2(5, 5);
       this.articleItem.GetComponent&lt;RectTransform&gt;().offsetMax = new Vector2(-5, -5);
   });
    //设置大小
    this.articleItem.transform.localScale = Vector3.one;
    //设置
    //this.articleItem.GetComponent&lt;RectTransform&gt;().offsetMin = new Vector2(5, 5);
    //this.articleItem.GetComponent&lt;RectTransform&gt;().offsetMax = new Vector2(-5, -5);
}
//清空格子
public void ClearGride()
{
    articleItem.gameObject.SetActive(false);
    articleItem.transform.SetParent(null);
    articleItem = null;
}

//物品填入格子
public void DragIntoGride(ArticleItem articleItem)
{
    //物品原来所在的格子
    BagGrde lastGride = articleItem.transform.parent.GetComponent&lt;BagGrde&gt;();
    if (this.articleItem==null)//如果这个格子中没有物品
    {
        //清空之前的格子
        lastGride.ClearGride();

        //设置拖拽到的此格子
        SetArticleItem(articleItem);
        //lastGride.ClearGride();
    }
    else//此格子不为空时将物品进行交换
    {
        //当前格子内物品设置到之前的格子
        lastGride.SetArticleItem(this.articleItem);
        //设置拖拽过来的新物品到的此格子
        SetArticleItem(articleItem);
    }
}
//鼠标进入格子时接口调用的函数
public void OnPointerEnter(PointerEventData eventData)
{
    if(BagPanel.instence .curretnAricle!=null)//拖拽的物品不为空时
    {
        BagPanel.instence.currtenHoverGrid = this;//光标进入此格子则选中此格子
        bgImage.color = Color.white;//该变选中格子的颜色
    }
    //此格子布为空时显示此格子物品的信息界面
    if (this.articleItem != null)
    {
        UIManager.Instence.articleInformation.gameObject.SetActive(true);
        UIManager.Instence.articleInformation.panel.transform.position = transform.position;
        UIManager.Instence.articleInformation.info.text = this.articleItem.article.name + &quot;\n&quot; + this.articleItem.article.count.ToString ();
    }
}
//光标退出时
public void OnPointerExit(PointerEventData eventData)
{
    BagPanel.instence.currtenHoverGrid = null;
    bgImage.color = defortColor;
    //隐藏信息界面
    UIManager.Instence.articleInformation.gameObject.SetActive(false);
    UIManager.Instence.articleInformation.panel.transform.position = Vector3.zero;
    UIManager.Instence.articleInformation.info.text = &quot; &quot;;
}
</code></pre>
<p>}<br>
———————————————————————————————————<br>
背包模块类：<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.UI;</p>
<p>public class BagPanel : MonoBehaviour<br>
{</p>
<pre><code>private List&lt;Article&gt; articlesList = new List&lt;Article&gt;();//背包中所有物品的属性

private List&lt;GameObject&gt; articleObjectPool = new List&lt;GameObject&gt;();//储存物品预制件的对象池

public GameObject articleItemPrafab;//物品UI预制件
private BagGrde[] bagGrdes;//物品栏

public BagGrde currtenHoverGrid;//当前鼠标所悬浮所在格子
public ArticleItem curretnAricle;//当前拖拽物品
//单例
public static BagPanel instence;//单例，在外部访问公开属性

//private Button btn_Back;
// Start is called before the first frame update
void Awake()
{
    /*if (instence !=null)
    {
        Destroy(gameObject);
        return;
    }*/
    instence = this;
    //DontDestroyOnLoad(gameObject);

    //btn_Back = transform.Find(&quot;btn_Back&quot;).GetComponent&lt;Button&gt;();
    //btn_Back.onClick.AddListener(UIManager.Instence.ExtBagPanel);
    InitArticleDate();
    bagGrdes = transform.GetComponentsInChildren&lt;BagGrde&gt;();//获取所有格子
    LoadDate();//初始加载全部数据
}
</code></pre>
<p>/*    private void Start()<br>
{<br>
LoadDate();<br>
}*/<br>
//加载全部数据<br>
public void LoadDate()<br>
{<br>
ClearGrideAndHideItems();<br>
for (int i = 0; i &lt; articlesList.Count; i++)<br>
{<br>
//将列表中所有物品的属性生成对应物品装入空着的格子<br>
GetBagGrid().SetArticleItem(LoadArticleItem(articlesList[i]));<br>
}<br>
}<br>
//按类加载的重载方法<br>
public void LoadDate(ArticleType articleType)<br>
{<br>
ClearGrideAndHideItems();<br>
for (int i = 0; i &lt; articlesList.Count; i++)<br>
{<br>
if (articlesList[i].articleType == articleType)<br>
{<br>
//将列表中某类物品生成对应物品装入空着的格子<br>
GetBagGrid().SetArticleItem(LoadArticleItem(articlesList[i]));<br>
}<br>
}<br>
}<br>
//获取空着的格子<br>
public BagGrde GetBagGrid()<br>
{<br>
for (int i = 0; i &lt; bagGrdes.Length; i++)<br>
{<br>
if (bagGrdes[i].ArticleItem == null)<br>
return bagGrdes[i];<br>
}<br>
return null;<br>
}<br>
//加载ArticleItem物品：根据属性创建对应装备物品<br>
public ArticleItem LoadArticleItem(Article article)<br>
{<br>
GameObject go = GetGameObject();<br>
ArticleItem articleItem = go.GetComponent<ArticleItem>();<br>
articleItem.SetArticle(article);<br>
return articleItem;<br>
}<br>
//获取GameObject：获取对象池中空闲物品预制件<br>
public GameObject GetGameObject()<br>
{<br>
for (int i = 0; i &lt; articleObjectPool.Count; i++)<br>
{<br>
if (articleObjectPool[i].activeSelf==false)<br>
{<br>
articleObjectPool[i].SetActive(true);<br>
return articleObjectPool[i];<br>
}<br>
}<br>
GameObject go = Instantiate(articleItemPrafab);<br>
articleObjectPool.Add(go);<br>
return go;</p>
<pre><code>}
//重新加载背包时物品栏清空
public void ClearGrideAndHideItems()
{
    for (int i = 0; i &lt; bagGrdes.Length; i++)
    {
        if (bagGrdes[i].ArticleItem!=null)
        {
            bagGrdes[i].ClearGride();
        }
    }
}

//初始化物品数据：加载拥有的制备数据应从服务器获取，此处实验性加载部分装备
public void InitArticleDate()
{
    //武器
    articlesList.Add(new Article(&quot;刀刀&quot;,&quot;at0&quot;, ArticleType.Weapon, 2));
    articlesList.Add(new Article(&quot;剑剑&quot;, &quot;at1&quot;, ArticleType.Weapon, 1));
    articlesList.Add(new Article(&quot;春药&quot;, &quot;at2&quot;, ArticleType.Drag, 7));
    articlesList.Add(new Article(&quot;夏药&quot;, &quot;at3&quot;, ArticleType.Drag, 6));
    articlesList.Add(new Article(&quot;秋药&quot;, &quot;at4&quot;, ArticleType.Drag, 5));
    articlesList.Add(new Article(&quot;冬药&quot;, &quot;at5&quot;, ArticleType.Drag, 4));
    articlesList.Add(new Article(&quot;典藏种子&quot;, &quot;at6&quot;, ArticleType.Collect, 1001));
    articlesList.Add(new Article(&quot;玻璃碎片&quot;, &quot;at7&quot;, ArticleType.Pick, 12));
}


#region 点击标签事件(所有标签都在同一个标签组-只有一个标签可选。勾选标签是执行)
public void OnAllToggleValueChange(bool v)//v为标签是否被勾选
{
    if (v) LoadDate();
}
public void OnWepanToggleValueChange(bool v)
{
    if (v) LoadDate(ArticleType.Weapon);
}
public void OnDragToggleValueChange(bool v)
{
    if (v) LoadDate(ArticleType.Drag);
}
public void OnClctorToggleValueChange(bool v)
{
    if (v) LoadDate(ArticleType.Collect);
}
public void OnPickToggleValueChange(bool v)
{
    if (v) LoadDate(ArticleType.Pick);
}
#endregion
</code></pre>
<p>}</p>
]]></content>
    </entry>
</feed>