<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Wei715547.github.io</id>
    <title>WeiBlog</title>
    <updated>2020-12-25T07:40:49.637Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Wei715547.github.io"/>
    <link rel="self" href="https://Wei715547.github.io/atom.xml"/>
    <subtitle>年月增长，我宜强盛。
用于Unity+开发的技术积累</subtitle>
    <logo>https://Wei715547.github.io/images/avatar.png</logo>
    <icon>https://Wei715547.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, WeiBlog</rights>
    <entry>
        <title type="html"><![CDATA[BaseMVC_UI]]></title>
        <id>https://Wei715547.github.io/post/basemvc_ui/</id>
        <link href="https://Wei715547.github.io/post/basemvc_ui/">
        </link>
        <updated>2020-12-13T11:28:39.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://Wei715547.github.io/post-images/1607863048846.jpg" alt="" loading="lazy"><br>
<strong>M：数据模型</strong>//此例两界面共用一个数据模型<br>
using System;<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.Events;<br>
/// <summary><br>
/// 数据模型<br>
/// </summary><br>
public class PlayerMode<br>
{<br>
#region//数据层<br>
private string playername;<br>
public string Playername<br>
{<br>
get<br>
{<br>
return playername;<br>
}<br>
}<br>
private int lev;<br>
public int Lev<br>
{<br>
get<br>
{<br>
return lev;<br>
}<br>
}</p>
<pre><code>private int money;
public int Money
{
    get
    {
        return money;
    }
}

private int power;
public int Power
{
    get
    {
        return power;
    }
}


private int hp;
public int Hp
{
    get { return hp; }
}
private int atk;
public int Atk
{
    get { return atk; }
}
private int def;
public int Def
{
    get { return def; }
}
private int miss;
public int Miss
{
    get { return miss; }
}

//通过事件与外部联系
public event Action&lt;PlayerMode&gt; updateEvent;

//数据模型类单例，达到数据唯一，与获取数据
private static PlayerMode date;
public static PlayerMode Date
{
    get
    {
        if(date==null)
        {
            date = new PlayerMode();
            date.Init();
        }
        return date;
    }
}
#endregion

//初始化
public void Init()
{
    playername = PlayerPrefs.GetString(&quot;Playername&quot;, &quot;Wei&quot;);//PlayerPrefs类场景中存储值
    lev = PlayerPrefs.GetInt(&quot;Lev&quot;, 17);
    money = PlayerPrefs.GetInt(&quot;Money&quot;, 100);
    power = PlayerPrefs.GetInt(&quot;Power&quot;, 100);

    hp = PlayerPrefs.GetInt(&quot;Hp&quot;, 100);
    atk = PlayerPrefs.GetInt(&quot;Atk&quot;, 100);
    def = PlayerPrefs.GetInt(&quot;Def&quot;, 100);
    miss = PlayerPrefs.GetInt(&quot;Miss&quot;, 100);
}
//更新
public void LeveUp()
{
    lev += 1;

    hp += 10;
    atk += 10;
    def += 10;
    miss += 10;

    SaveDate();//更新后保存数据

    
}
//保存
public void SaveDate()
{
    PlayerPrefs.SetString(&quot;Playername&quot;, playername);
    PlayerPrefs.SetInt(&quot;Lev&quot;, lev);
    PlayerPrefs.SetInt(&quot;Money&quot;, money);
    PlayerPrefs.SetInt(&quot;Power&quot;, power);

    PlayerPrefs.SetInt(&quot;Hp&quot;, hp);
    PlayerPrefs.SetInt(&quot;Atk&quot;, atk);
    PlayerPrefs.SetInt(&quot;Def&quot;, def);
    PlayerPrefs.SetInt(&quot;Miss&quot;, miss);

    UpdateInfo();
}
//外部注册事件
public void AddEventLissent(Action&lt;PlayerMode&gt; function)
{
    updateEvent += function;
}
//外部取消注册事件
public void RemoveEventLissent(Action&lt;PlayerMode&gt; function)
{
    updateEvent -= function;
}
//通知更新数据的方法（调用数据更新时执行的事件）
public void UpdateInfo()
{
    updateEvent?.Invoke(this);
}
</code></pre>
<h2 id="">}</h2>
<p><strong>V：界面脚本</strong>//获取控件，更新控件数据<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.UI;<br>
//VM<br>
public class PlayerMainView : MonoBehaviour<br>
{<br>
//获取控件<br>
public Button btnRole;<br>
public Button btnSkill;</p>
<pre><code>public Text txtName;
public Text txtLev;
public Text txtMoney;
public Text txtPower;

//提供面板更新相关方法给外部
public void UpdateInfo(PlayerMode date)
{
    txtName.text = date.Playername;
    txtLev.text = &quot;Lv:&quot; + date.Lev.ToString();
    txtMoney.text = date.Money.ToString();
    txtPower.text = date.Power.ToString();
}
</code></pre>
<p>}</p>
<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.UI;<br>
//VR<br>
public class PlayerRoleView : MonoBehaviour<br>
{<br>
//获取控件<br>
public Button btnBack;<br>
public Button btnLeveUp;</p>
<pre><code>public Text txtHp;
public Text txtAtk;
public Text txtDef;
public Text txtMiss;

//提供面板更新相关方法给外部
public void UpdateInfo(PlayerMode date)
{
    txtHp.text = date.Hp.ToString();
    txtAtk.text = date.Atk.ToString();
    txtDef.text = date.Def.ToString();
    txtMiss.text = date.Miss.ToString();
}
</code></pre>
<h2 id="-2">}</h2>
<p><strong>C：界面控制脚本</strong>//显隐，初始化，界面逻辑，数据更新时调用的事件<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
/// <summary><br>
/// 处理主界面业务逻辑<br>
/// </summary><br>
public class MainController : MonoBehaviour<br>
{<br>
//能够在Controller中获取View界面<br>
private PlayerMainView mainView;</p>
<pre><code>private static MainController contorller;

public static MainController Controller
{
    get
    {
        return contorller;
    }
}
//界面显示隐藏
public static void ShowPanel()
{
    if(contorller==null)
    {
        GameObject res = Resources.Load&lt;GameObject&gt;(&quot;UI/MainPanel&quot;);
        GameObject obj = Instantiate(res);
        obj.transform.SetParent(GameObject.Find(&quot;Canvas&quot;).transform);
        contorller = obj.GetComponent&lt;MainController&gt;();
    }
}
public static void HeadPanel()
{
    contorller.gameObject.SetActive(false);
}

private void Start()
{
    //获取挂载同一物体上的View脚本
    mainView = this.GetComponent&lt;PlayerMainView&gt;();
    //第一次界面更新
    mainView.UpdateInfo(PlayerMode.Date);

    mainView.btnRole.onClick.AddListener(OnRoleBtnClick);

    //数据更新时同时更新界面
    PlayerMode.Date.AddEventLissent(UpdateInfo);
}

private void OnRoleBtnClick()
{
    RoleController.ShowPanel();
}

//界面事件监听，逻辑处理
//界面更新
private void UpdateInfo(PlayerMode date)
{
    if(mainView!=null)
        mainView.UpdateInfo(date);
}
</code></pre>
<p>}</p>
<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
/// <summary><br>
/// 处理属性界面业务逻辑<br>
/// </summary><br>
public class RoleController : MonoBehaviour<br>
{<br>
//能够在Controller中获取View界面<br>
private PlayerRoleView roleView;</p>
<pre><code>private static RoleController contorller;

public static RoleController Controller
{
    get
    {
        return contorller;
    }
}
//界面显示隐藏
public static void ShowPanel()
{
    if (contorller == null)
    {
        GameObject res = Resources.Load&lt;GameObject&gt;(&quot;UI/RolePanel&quot;);
        GameObject obj = Instantiate(res);
        obj.transform.SetParent(GameObject.Find(&quot;Canvas&quot;).transform);
        contorller = obj.GetComponent&lt;RoleController&gt;();
    }
}
public static void HeadPanel()
{
    contorller.gameObject.SetActive(false);
}

private void Start()
{
    //获取挂载同一物体上的View脚本
    roleView = this.GetComponent&lt;PlayerRoleView&gt;();
    //第一次界面更新
    roleView.UpdateInfo(PlayerMode.Date);

    roleView.btnBack.onClick.AddListener(OnClickBack);
    roleView.btnLeveUp.onClick.AddListener(OnClickLeveUp);

    //数据更新时同时更新界面
    PlayerMode.Date.AddEventLissent(UpdataInfo);
    //PlayerMode.Date.AddEventLissent(roleView.UpdateInfo);
    //PlayerMode.Date.updateEvent += roleView.UpdateInfo;
}
private void OnClickBack()
{
    HeadPanel();
}
private void OnClickLeveUp()
{
    //通过事件模块，改变数据。
    PlayerMode.Date.LeveUp();
}

//界面事件监听，逻辑处理
//界面更新
private void UpdataInfo(PlayerMode date)
{
    if(roleView!=null)
        roleView.UpdateInfo(date);
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Particle System]]></title>
        <id>https://Wei715547.github.io/post/particle-system/</id>
        <link href="https://Wei715547.github.io/post/particle-system/">
        </link>
        <updated>2020-12-09T11:07:27.000Z</updated>
        <content type="html"><![CDATA[<p><a href = "https://docs.unity3d.com/Manual/PartSysMainModule.html"><strong>Main</strong></a><br>
<img src="https://Wei715547.github.io/post-images/1607512192204.jpg" alt="" loading="lazy"><br>
<strong>单一粒子</strong><br>
<strong>Firefly</strong><br>
<img src="https://Wei715547.github.io/post-images/1607513562693.png" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1607514533865.png" alt="" loading="lazy"><br>
<strong>Sparks</strong><br>
<img src="https://Wei715547.github.io/post-images/1607515384766.png" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1607515390739.png" alt="" loading="lazy"><br>
<strong>组合粒子</strong><br>
<strong>Fire</strong><br>
<img src="https://Wei715547.github.io/post-images/1607515642296.PNG" alt="" loading="lazy"><br>
BackGround/Front<br>
<img src="https://Wei715547.github.io/post-images/1607673107804.png" alt="" loading="lazy"><br>
Start<br>
<img src="https://Wei715547.github.io/post-images/1607673641050.png" alt="" loading="lazy"><br>
<strong>Cartoon Boom</strong><br>
<img src="https://Wei715547.github.io/post-images/1607515820679.png" alt="" loading="lazy"><br>
<strong>Her</strong><br>
<img src="https://Wei715547.github.io/post-images/1607515954518.PNG" alt="" loading="lazy"><br>
<strong>Sub PTS</strong><br>
<img src="https://Wei715547.github.io/post-images/1607516146807.PNG" alt="" loading="lazy"><br>
<strong>DrawLine</strong><br>
<img src="https://Wei715547.github.io/post-images/1607517065579.PNG" alt="" loading="lazy"><br>
<cood><br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>[RequireComponent(typeof(ParticleSystem))]<br>
[ExecuteInEditMode]<br>
public class ParticleSystemLine : MonoBehaviour<br>
{<br>
/// <summary><br>
/// 粒子系统<br>
/// </summary><br>
private ParticleSystem mParticleSystem;<br>
/// <summary><br>
/// 线的材质<br>
/// </summary><br>
public Material mMaterial;<br>
/// <summary><br>
/// 粒子数组<br>
/// </summary><br>
private ParticleSystem.Particle[] particles;<br>
/// <summary><br>
/// LineRenderer数组<br>
/// </summary><br>
private List<LineRenderer> linePool = new List<LineRenderer>();<br>
/// <summary><br>
/// 当前存活的粒子<br>
/// </summary><br>
private int numParticlesAlive;<br>
/// <summary><br>
/// 连线距离<br>
/// </summary><br>
public float MinDist = 5;<br>
/// <summary><br>
/// 线的宽度<br>
/// </summary><br>
public float LineWidth = 0.1f;</p>
<pre><code>/// &lt;summary&gt;
/// 已经使用的LineRender位置
/// &lt;/summary&gt;
private int index = 0;

//public AnimationCurve LineWidthOverLifetime = AnimationCurve.Constant(0,1,1);
void Start()
{
    mParticleSystem = GetComponent&lt;ParticleSystem&gt;();
    //初始化粒子数组
    particles = new ParticleSystem.Particle[mParticleSystem.main.maxParticles];
}

void LateUpdate()
{
    //获取粒子数据
    numParticlesAlive = mParticleSystem.GetParticles(particles);

    //两个粒子的距离小于MinDist就连线
    for(int i = 0;i &lt; numParticlesAlive; i++)
    {
        for (int j = i + 1; j &lt; numParticlesAlive; j++)
        {
            //粒子直接距离的平方
            float SqrDis = (particles[j].position - particles[i].position).sqrMagnitude;

            if (SqrDis &lt; MinDist * MinDist)
            {
                ParticleSystem.Particle particle = particles[j];
                ParticleSystem.Particle cur_particle = particles[i];
                //获取粒子的颜色
                Color sColor = cur_particle.GetCurrentColor(mParticleSystem);
                Color eColor = particle.GetCurrentColor(mParticleSystem);
                //计算宽度
                //float width = LineWidth*LineWidthOverLifetime.Evaluate(cur_particle.remainingLifetime/cur_particle.startLifetime);
                //绘制线
                DrawLine(cur_particle.position, particle.position, sColor, eColor, LineWidth);

            }
        }
    }

    mParticleSystem.SetParticles(particles, numParticlesAlive);
    for(int i=index;i&lt;linePool.Count;i++)
    {
        linePool[i].gameObject.SetActive(false);
    }
    index = 0;
}

/// &lt;summary&gt;
/// 绘制线条
/// &lt;/summary&gt;
/// &lt;param name=&quot;startPos&quot;&gt;&lt;/param&gt;
/// &lt;param name=&quot;endPos&quot;&gt;&lt;/param&gt;
/// &lt;param name=&quot;startColor&quot;&gt;&lt;/param&gt;
/// &lt;param name=&quot;endColor&quot;&gt;&lt;/param&gt;
/// &lt;param name=&quot;width&quot;&gt;&lt;/param&gt;
void DrawLine(Vector3 startPos,Vector3 endPos,Color startColor,Color endColor,float width = 0.1f)
{
    LineRenderer line;

    if(linePool.Count==index)
    {
        GameObject go = new GameObject(&quot;tempLine&quot;);
        go.transform.parent = transform;
        line = go.AddComponent&lt;LineRenderer&gt;();
        line.useWorldSpace = true;
        line.material = mMaterial;
        linePool.Add(line);
        index++;
    }
    else
    {
        line = linePool[index++];
        line.gameObject.SetActive(true);
    }

    //点的数量
    line.positionCount = 2;
    
    //设置线的位置
    line.SetPosition(0,startPos);
    line.SetPosition(1,endPos);

    //线的颜色
    line.startColor = startColor;
    line.endColor = endColor;

    //线的宽度
    line.startWidth = width;
    line.endWidth = width;
}
</code></pre>
<p>}<br>
</cood></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++泛型/STL]]></title>
        <id>https://Wei715547.github.io/post/cfan-xing-stl/</id>
        <link href="https://Wei715547.github.io/post/cfan-xing-stl/">
        </link>
        <updated>2020-11-28T12:20:41.000Z</updated>
        <content type="html"><![CDATA[<p><strong>函数模板</strong><br>
与普通函数区别：<br>
1.普通函数调用存在隐式类型转换<br>
2.自动类型推导调用时，不发生隐式类型转换<br>
3.显示指定类型调用可以发生隐式类型转换<br>
与普通函数重名时：<br>
1,.默认调用普通函数<br>
2.通过空模板参数类表(Max&lt;&gt;)强制调用函数模板<br>
3.函数模板可发生重载(参数个数不同)<br>
4.函数模板可产生更好的匹配时优先调用函数模板<br>
例：普通函数：void Fun(int a,int b){}<br>
函数模板：template<class T> viod Fun (T a,T b){};<br>
调用Fun(a,b)//a,b为char类型时普通函数需隐式转换int为char，函数模板只需将T制定为char类型，即优先调用函数模板。<br>
模板局限性：如自定义类型对比（解决方法1.在自定义类型中重置内置运算符，2.利用具体化模板实现代码）=&gt;template &lt;&gt; bool Compare(Person p1,Person p2)<br>
{<br>
if(p1.name ==p2.name&amp;&amp;p1.age == p2.age)<br>
return true;<br>
else<br>
return false;<br>
};<br>
声明格式：<br>
template <class T>//或写成<typename T>与class无区别<br>
//需要不同类型参数时&lt;typename T1,typename T2&gt;u77<br>
返回值 函数名 （形参表）<br>
{<br>
函数体；<br>
}<br>
template <class T><br>
T Max(T Inpute1, T Inpuet2)<br>
{<br>
return (Inpute1 &gt; Inpute2) ? Inpute1 : Inpute2;<br>
}<br>
使用：<br>
1.自动类型推导<br>
Max(a,b);<br>
2.显示指定类型<br>
Max<int>(a,b);<br>
<strong>类模板</strong>//与函数模板区别：1.没有自动类型推导，<br>
2.在模板参数列表中可以有默认参数template <typename T = int>//未指定类型是默认为int</p>
<p>template <typename T><br>
class 类名<br>
{<br>
类定义；<br>
}<br>
template &lt;class T1,class T2&gt;<br>
class Person<br>
{<br>
public:<br>
Person(T1 name,T2 age)<br>
{<br>
this-&gt;Name = name;<br>
this-&gt;Age =age;<br>
}<br>
void ShowPerson(T1 name,T2 age);<br>
private:<br>
T1 Name;<br>
T2 Age;<br>
}<br>
在类外定义成员函数时：<br>
template <typename T><br>
返回值类型 类名<T>::函数名(T x,T y)<br>
{<br>
函数体；<br>
}<br>
template &lt;typename T1, typenme T2&gt;<br>
void Person&lt;T1,T2&gt;::ShowPerson(T1 name,T2 age)<br>
{<br>
cout&lt;&lt;name&lt;&lt;age&lt;&lt;endl;<br>
}<br>
类模板声明对象：<br>
类名&lt;泛型数据类型&gt; 对象名；<br>
Person&lt;string,int&gt; p (&quot;Wei&quot;,17);</p>
<p><strong>类模板对象作为函数参数</strong><br>
1.指定传入类型<br>
void PrintPerson(Person&lt;string ,int&gt; &amp;p)<br>
{<br>
p.ShowPerson(p.name,p.age);<br>
}<br>
2.参数模板化<br>
template &lt;class T1,class T2&gt;<br>
void PrintPerson(Person&lt;T1 ,T3&gt; &amp;p)<br>
{<br>
p.ShowPerson(p.name,p.age);<br>
}<br>
3.整个类模板化<br>
template <class T><br>
void PrintPerson(T &amp;p)<br>
{<br>
p.ShowPerson(p.name,p.age);<br>
}</p>
<p><strong>类模板与继承</strong><br>
1.当子类继承的父类为一个类模板时，子类在声明时必须指定父类中T的类型。<br>
template <class T><br>
class Base<br>
{<br>
T m;<br>
}<br>
class Son :public Base<int>//指定父类T类型<br>
{</p>
<p>};<br>
2.如果不指定 ，编译器无法为子类分配内存。<br>
3.如想灵活指定父类T类型，则需将子类也定义为类模板。<br>
template &lt;class T1, class T2&gt;//子类也定义为类模板<br>
class Son :public Base<T2><br>
{<br>
T1 obj;<br>
};<br>
Son&lt;int,char&gt; s1;<br>
——————————————————————————————————————<br>
<strong>STL</strong></p>
<p><strong>Vector</strong>:单端数组，动态拓展：开辟一块更大的空间拷贝数据，释放原来空间。<br>
迭代器：v.begin()//指向容器首位置<br>
v.end()//指向容器最后一位的下一个位置<br>
v.rend()//首位的前一位置<br>
v.rbegin()//指向最后一位元素<br>
支持随机访问<br>
构造函数：<br>
vector<T> v;//              默认构造函数<br>
vector(v.begin(),v.end())//         将v的首末拷贝到本身<br>
vector(n,elem)//            将n个elem拷贝给本身<br>
vector(const vector &amp;vec)//         拷贝构造函数<br>
赋值操作：<br>
operator=<br>
v.assign(v1.begin(), v1.end())<br>
v.assign(n,elem);<br>
容量大小方法：<br>
empty()//判断容易是否为空；<br>
capacity()//容器容量<br>
size()//容器中元素的个数<br>
resize(int num)//重新制定容器的长度为num<br>
resize(int num elem)//重新定义容器长度，并默认以elem填充<br>
插入/删除方法：<br>
push_back(ele);//在尾部插入数据<br>
pop_back()//在尾部删除数据<br>
insert(const_iterator  pos, ele)//在迭代器所指向位置插入ele<br>
insert(const_iterator  pos, int count, ele)//在迭代器所指向位置插入count个ele<br>
erase(const_iterator pos);//删除迭代器所指向的元素<br>
erase(const_iterator start, const_iterator end)//清除迭代器s-e之间的元素<br>
clear();//清空元素</p>
<p>#include <iostream><br>
#include &quot;pch.cpp&quot;<br>
#include<vector><br>
#include<algorithm><br>
using namespace std;</p>
<p>int main()<br>
{<br>
//cout &lt;&lt; &quot;WEI&quot; &lt;&lt; endl;<br>
Fun1();<br>
return 0;</p>
<p>}<br>
void Fun1()<br>
{<br>
//创建Vector容器<br>
vector<int> v;</p>
<pre><code>//向容器中插入数据
v.push_back(10);
v.push_back(20);
v.push_back(30);
v.push_back(40);
v.push_back(50);

////通过迭代器访问容器中的数据
//vector&lt;int &gt;::iterator itBegin = v.begin();//起始迭代器，指向容器第一个元素
//vector&lt;int &gt;::iterator itEnd = v.end();//结束迭代器，指向最后一个元素的下一个位置

////遍历方式
//while (itBegin != itEnd)
//{
//	cout &lt;&lt; *itBegin &lt;&lt; endl;
//	itBegin++;
//}

//遍历方式二
for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)
{
	cout &lt;&lt; *it &lt;&lt; endl;
}

//第三种 STL提供的遍历算法
for_each (v.begin(), v.end(), MyPrint);
</code></pre>
<h2 id="void-myprintint-varcout-var-endl">}<br>
void MyPrint(int var)<br>
{<br>
cout &lt;&lt; var &lt;&lt; endl;<br>
}</h2>
<p><strong>C++链表List</strong><br>
优点：可在任意位置插入大量元素，修改指针即可不需要移动大量元素；动态内存分配，不会造成内存浪费和溢出<br>
缺点：空间(占用空间比较大)，时间(遍历速度慢)的额外消耗较大；插入和删除操作不会造成原来的迭代器失效，这在vector中是不成立的（数组装满后会开辟新的更大的空间拷贝源数据，但迭代器仍指向原地址）<br>
//遍历方法<br>
void MyList::printList(const list<int>&amp; L)<br>
{<br>
for (list<int>::const_iterator it = L.begin(); it!= L.end(); it++)<br>
{<br>
cout &lt;&lt; *it &lt;&lt; &quot; &quot;;<br>
}<br>
cout &lt;&lt; endl;<br>
}<br>
void MyList::List()<br>
{<br>
//创建Lis容器<br>
list<int> Li; //默认构造</p>
<pre><code>	//添加数据
	Li.push_back(10);
	Li.push_back(20);
	Li.push_back(30);
	Li.push_back(40);

	//遍历容器
	printList(Li);

	//区间构造
	list&lt;int&gt; L2(Li.begin(), Li.end());
	printList(L2);

	//拷贝构造
	list&lt;int &gt; L3 (L2);
	printList(L3);

	//N个ELE构造
	list&lt;int&gt; L4(10, 999);
	printList(L4);

    //**赋值 **=
	list&lt;int&gt; L5;
	L5 = L4;
	//区间
	list&lt;int&gt; L6;
	L6.assign(L4.begin(), L4.end());
	//n*Ele
	list&lt;int&gt; L7;
	L7.assign(5, 7);

	//交换
	printList(L6);
	printList(L7);
	L7.swap(L6);
	printList(L6);
	printList(L7);

    //**list大小操作**
	cout&lt;&lt;L7.size()&lt;&lt;endl;//返回容器元素个数
	cout &lt;&lt; L7.empty()&lt;&lt;endl;//容器是否为空
	L7.resize(7);//重新定义容器长度，多则0填充，少则从末尾删除
	printList(L7);
	L7.resize(10, 777);//重新定义容器长度，多则ele填充，少则从末尾删除
	printList(L7);

    //**插入/删除**
	list&lt;int&gt; insDle(5,7);
	//头插
	insDle.push_front(3);
	insDle.push_front(2);
	insDle.push_front(1);
	//尾插
	insDle.push_back(7);
	insDle.push_back(8);
	insDle.push_back(9);
	printList(insDle);
	//尾删除
	insDle.pop_back();
	//头部删除
	insDle.pop_front();
	printList(insDle);

	//insert插入
	list&lt;int&gt;::iterator it = insDle.begin();
	insDle.insert(++it, 23);
	printList(insDle);
	//删除
	it = insDle.begin();
	insDle.erase(it);
	printList(insDle);
	//移除所有同样的元素
	insDle.remove(7);
	printList(insDle);
	//清空
	insDle.clear();
	printList(insDle);
    //数据存取
	L7.front();
	L7.back();
	list&lt;int&gt;::iterator Linklist_it = L7.begin();
	Linklist_it++;//支持双向
	Linklist_it--;//不支持--则为单相访问
	//Linklist_it = Linklist_it + 1;//可以这样写着表示可以支持随机访问，链表不支持随机访问。

	//链表反转/排序
	printList(L7);
	L7.reverse();
	printList(L7);
	//排序
	list&lt;int&gt; ls;
	ls.push_back(3);
	ls.push_back(1);
	ls.push_back(2);
	//所有不支持随机访问到迭代器的容器，不支持标准算法
	//容器内部会提供对应的一些算法
	ls.sort();//默认升生序排序
	//MyList l;
	//ls.sort(l.MyCompare);
	printList(ls);
}
}
例：两数之和LC
list&lt;int&gt; TowAddList(list&lt;int&gt;* l1, list&lt;int&gt;* l2)
</code></pre>
<p>{<br>
list<int> res;<br>
list<int>::iterator pos1 = l1-&gt;begin();<br>
list<int>::iterator pos2 = l2-&gt;begin();<br>
int digit = 0;<br>
while (pos1!=l1-&gt;end()||pos2!=l2-&gt;end())<br>
{<br>
int total = digit;<br>
if (pos1 != l1-&gt;end())<br>
{<br>
total += *pos1;<br>
pos1++;<br>
}<br>
if (pos2 != l2-&gt;end())<br>
{<br>
total += *pos2;<br>
pos2++;<br>
}<br>
digit = total / 10;<br>
res.push_back(total % 10);<br>
}<br>
if (digit != 0)<br>
{<br>
res.push_back(digit);<br>
}<br>
return res;<br>
}<br>
—————————————————————————————————————————<br>
<strong>哈希表/(键值对)</strong><br>
map/multimap：元素为pair键值对，底层容器由二叉树实现<br>
优点：根据key可以快速找到value<br>
map不允许有重复的key<br>
multimap允许有重复的key<br>
class MyTable<br>
{<br>
public:<br>
void MapText()<br>
{<br>
//默认构造<br>
map&lt;int, string&gt; m1;//map会根据键的值进行默认的排序，与先后插入顺序无关<br>
m1.insert(pair&lt;int, string&gt;(1, &quot;A&quot;));<br>
m1.insert(pair&lt;int, string&gt;(3, &quot;C&quot;));<br>
m1.insert(map&lt;int, string&gt;::value_type(2,&quot;B&quot;));<br>
//m1.insert(pair&lt;int, string&gt;(3, &quot;C&quot;));<br>
m1.insert(pair&lt;int, string&gt;(7, &quot;W&quot;));<br>
printMap(m1);</p>
<pre><code>		//拷贝构造
		map&lt;int, string&gt;m2(m1);
		printMap(m2);
		//赋值
		map&lt;int, string&gt; m3 = m2;
		m3.erase(7);
		m3.insert(pair&lt;int ,string&gt;(11, &quot;Z&quot;));
		printMap(m3);

		//大小和交换
		cout &lt;&lt; m1.size()&lt;&lt;endl;
		cout &lt;&lt; m1.empty()&lt;&lt;endl;

		m2.swap(m3);
		printMap(m2);
		printMap(m3);

		//插入/删除
		map&lt;int, string&gt; m7;
		m7.insert(pair&lt;int ,string&gt;(1, &quot;A&quot;));			
		m7.insert(pair(2, &quot;B&quot;));
		m7.insert(make_pair(3, &quot;C&quot;));
		m7.insert(map&lt;int, string&gt;::value_type(7, &quot;W&quot;));
		m7[5] = &quot;Z&quot;;//不存在Key时，会创建该键值为类型默认值，不建议使用，可以用来读取键中的值
		printMap(m7);

		//删除
		m7.erase(m7.begin());
		m7.erase(3);//按照key删除
		//m7.erase(m7.begin(), m7.end());
		//m7.clear();
		m7.insert(pair(17, &quot;Z&quot;));
		printMap(m7);

		//查找,返回值为迭代器，未找到2时返回容器的end()
		map&lt;int, string&gt;::iterator pos = m7.find(7);
		if (pos != m7.end())
			cout &lt;&lt; (*pos).first &lt;&lt;&quot; &quot;&lt;&lt;(*pos).second &lt;&lt; endl;
		//统计,1/0，multimap允许键重复适用此方法
		int n = m7.count(7);
		cout &lt;&lt; n &lt;&lt; endl;
	}
	void printMap(map&lt;int, string&gt; m)
	{
		for (map&lt;int, string&gt;::iterator it = m.begin(); it != m.end(); it++)
		{
			cout &lt;&lt; &quot;KEY: &quot;&lt;&lt;(*it).first &lt;&lt;&quot; &quot;&lt;&lt; &quot;Value:&quot;&lt;&lt;(*it).second&lt;&lt;endl;
		}
		cout &lt;&lt; endl;
	}
};

//改为降序排序的仿函数
</code></pre>
<p>class MyMapSort<br>
{<br>
public:<br>
bool operator() (int a,int b)<br>
{<br>
//降序：第一个数大于第二个数<br>
return a &gt; b;<br>
}<br>
};<br>
void textmap()<br>
{<br>
map&lt;int, int,MyMapSort&gt; m;//默认按照键从小到大排序<br>
m.insert(pair(1, 1));<br>
m.insert(pair(3, 3));<br>
m.insert(pair(2, 2));</p>
<pre><code>//m.insert(pair(3, 3));
m.insert(pair(4, 4));
m.insert(pair(5, 5));

for (map&lt;int,int, MyMapSort&gt;::iterator it = m.begin(); it!=m.end(); it++)
{
	cout &lt;&lt; &quot;key:&quot; &lt;&lt; (*it).first &lt;&lt; &quot; &quot; &lt;&lt; (*it).second &lt;&lt; endl;
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++运算符重载]]></title>
        <id>https://Wei715547.github.io/post/cyun-suan-fu-chong-zai/</id>
        <link href="https://Wei715547.github.io/post/cyun-suan-fu-chong-zai/">
        </link>
        <updated>2020-11-26T10:39:57.000Z</updated>
        <content type="html"><![CDATA[<h3 id="45-运算符重载">4.5 运算符重载</h3>
<p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>
<h4 id="451-加号运算符重载">4.5.1 加号运算符重载</h4>
<p>作用：实现两个自定义数据类型相加的运算</p>
<pre><code class="language-C++">class Person {
public:
	Person() {};
	Person(int a, int b)
	{
		this-&gt;m_A = a;
		this-&gt;m_B = b;
	}
	//成员函数实现 + 号运算符重载
	Person operator+(const Person&amp; p) {
		Person temp;
		temp.m_A = this-&gt;m_A + p.m_A;
		temp.m_B = this-&gt;m_B + p.m_B;
		return temp;
	}


public:
	int m_A;
	int m_B;
};

//全局函数实现 + 号运算符重载
//Person operator+(const Person&amp; p1, const Person&amp; p2) {
//	Person temp(0, 0);
//	temp.m_A = p1.m_A + p2.m_A;
//	temp.m_B = p1.m_B + p2.m_B;
//	return temp;
//}

//运算符重载 可以发生函数重载 
Person operator+(const Person&amp; p2, int val)  
{
	Person temp;
	temp.m_A = p2.m_A + val;
	temp.m_B = p2.m_B + val;
	return temp;
}

void test() {

	Person p1(10, 10);
	Person p2(20, 20);

	//成员函数方式
	Person p3 = p2 + p1;  //相当于 p2.operaor+(p1)
	cout &lt;&lt; &quot;mA:&quot; &lt;&lt; p3.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p3.m_B &lt;&lt; endl;


	Person p4 = p3 + 10; //相当于 operator+(p3,10)
	cout &lt;&lt; &quot;mA:&quot; &lt;&lt; p4.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p4.m_B &lt;&lt; endl;

}

int main() {

	test();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p>
</blockquote>
<blockquote>
<p>总结2：不要滥用运算符重载</p>
</blockquote>
<hr>
<h4 id="452-左移运算符重载">4.5.2 左移运算符重载</h4>
<p>作用：可以输出自定义数据类型</p>
<pre><code class="language-C++">class Person {
	friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p);//友元：全局运算符重载函数访问类的私有成员

public:

	Person(int a, int b)
	{
		this-&gt;m_A = a;
		this-&gt;m_B = b;
	}

	//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果
	//void operator&lt;&lt;(Person&amp; p){
	//}

private:
	int m_A;
	int m_B;
};

//全局函数实现左移重载
//ostream对象只能有一个
ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p) {
	out &lt;&lt; &quot;a:&quot; &lt;&lt; p.m_A &lt;&lt; &quot; b:&quot; &lt;&lt; p.m_B;
	return out;
}

void test() {

	Person p1(10, 20);

	cout &lt;&lt; p1 &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; //链式编程
}

int main() {

	test();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p>
</blockquote>
<hr>
<h4 id="453-递增运算符重载">4.5.3 递增运算符重载</h4>
<p>作用： 通过重载递增运算符，实现自己的整型数据</p>
<pre><code class="language-C++">
class MyInteger {

	friend ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint);

public:
	MyInteger() {
		m_Num = 0;
	}
	//前置++
	MyInteger&amp; operator++() {
		//先++
		m_Num++;
		//再返回
		return *this;
	}

	//后置++
	MyInteger operator++(int) {
		//先返回
		MyInteger temp = *this; //记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；
		m_Num++;
		return temp;
	}

private:
	int m_Num;
};


ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint) {
	out &lt;&lt; myint.m_Num;
	return out;
}


//前置++ 先++ 再返回
void test01() {
	MyInteger myInt;
	cout &lt;&lt; ++myInt &lt;&lt; endl;
	cout &lt;&lt; myInt &lt;&lt; endl;
}

//后置++ 先返回 再++
void test02() {

	MyInteger myInt;
	cout &lt;&lt; myInt++ &lt;&lt; endl;
	cout &lt;&lt; myInt &lt;&lt; endl;
}

int main() {

	test01();
	//test02();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结： 前置递增返回引用，后置递增返回值</p>
</blockquote>
<h4 id="454-赋值运算符重载">4.5.4 赋值运算符重载</h4>
<p>c++编译器至少给一个类添加4个函数</p>
<ol>
<li>默认构造函数(无参，函数体为空)</li>
<li>默认析构函数(无参，函数体为空)</li>
<li>默认拷贝构造函数，对属性进行值拷贝</li>
<li>赋值运算符 operator=, 对属性进行值拷贝</li>
</ol>
<p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">class Person
{
public:

	Person(int age)
	{
		//将年龄数据开辟到堆区
		m_Age = new int(age);
	}

	//重载赋值运算符 
	Person&amp; operator=(Person &amp;p)
	{
		if (m_Age != NULL)
		{
			delete m_Age;
			m_Age = NULL;
		}
		//编译器提供的代码是浅拷贝
		//m_Age = p.m_Age;

		//提供深拷贝 解决浅拷贝的问题
		m_Age = new int(*p.m_Age);

		//返回自身
		return *this;
	}


	~Person()
	{
		if (m_Age != NULL)
		{
			delete m_Age;
			m_Age = NULL;
		}
	}

	//年龄的指针
	int *m_Age;

};


void test01()
{
	Person p1(18);

	Person p2(20);

	Person p3(30);

	p3 = p2 = p1; //赋值操作

	cout &lt;&lt; &quot;p1的年龄为：&quot; &lt;&lt; *p1.m_Age &lt;&lt; endl;

	cout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; *p2.m_Age &lt;&lt; endl;

	cout &lt;&lt; &quot;p3的年龄为：&quot; &lt;&lt; *p3.m_Age &lt;&lt; endl;
}

int main() {

	test01();

	//int a = 10;
	//int b = 20;
	//int c = 30;

	//c = b = a;
	//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;
	//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;
	//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h4 id="455-关系运算符重载">4.5.5 关系运算符重载</h4>
<p>**作用：**重载关系运算符，可以让两个自定义类型对象进行对比操作</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">class Person
{
public:
	Person(string name, int age)
	{
		this-&gt;m_Name = name;
		this-&gt;m_Age = age;
	};

	bool operator==(Person &amp; p)
	{
		if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)
		{
			return true;
		}
		else
		{
			return false;
		}
	}

	bool operator!=(Person &amp; p)
	{
		if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)
		{
			return false;
		}
		else
		{
			return true;
		}
	}

	string m_Name;
	int m_Age;
};

void test01()
{
	//int a = 0;
	//int b = 0;

	Person a(&quot;孙悟空&quot;, 18);
	Person b(&quot;孙悟空&quot;, 18);

	if (a == b)
	{
		cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;
	}

	if (a != b)
	{
		cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;
	}
}


int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h4 id="456-函数调用运算符重载">4.5.6 函数调用运算符重载</h4>
<ul>
<li>函数调用运算符 ()  也可以重载</li>
<li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li>
<li>仿函数没有固定写法，非常灵活</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">class MyPrint
{
public:
	void operator()(string text)
	{
		cout &lt;&lt; text &lt;&lt; endl;
	}

};
void test01()
{
	//重载的（）操作符 也称为仿函数
	MyPrint myFunc;
	myFunc(&quot;hello world&quot;);
}


class MyAdd
{
public:
	int operator()(int v1, int v2)
	{
		return v1 + v2;
	}
};

void test02()
{
	MyAdd add;
	int ret = add(10, 10);
	cout &lt;&lt; &quot;ret = &quot; &lt;&lt; ret &lt;&lt; endl;

	//匿名对象调用  
	cout &lt;&lt; &quot;MyAdd()(100,100) = &quot; &lt;&lt; MyAdd()(100, 100) &lt;&lt; endl;
}

int main() {

	test01();
	test02();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++构造/析构]]></title>
        <id>https://Wei715547.github.io/post/cgou-zao-xi-gou/</id>
        <link href="https://Wei715547.github.io/post/cgou-zao-xi-gou/">
        </link>
        <updated>2020-11-24T11:22:50.000Z</updated>
        <content type="html"><![CDATA[<h3 id="42-对象的初始化和清理">4.2 对象的初始化和清理</h3>
<ul>
<li>生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全</li>
<li>C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。</li>
</ul>
<h4 id="421-构造函数和析构函数">4.2.1 构造函数和析构函数</h4>
<p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p>
<p>​	一个对象或者变量没有初始状态，对其使用后果是未知</p>
<p>​	同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p>
<p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p>
<p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p>
<p><strong>编译器提供的构造函数和析构函数是空实现。</strong></p>
<ul>
<li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li>
<li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li>
</ul>
<p><strong>构造函数语法：</strong><code>类名(){}</code></p>
<ol>
<li>构造函数，没有返回值也不写void</li>
<li>函数名称与类名相同</li>
<li>构造函数可以有参数，因此可以发生重载</li>
<li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li>
</ol>
<p><strong>析构函数语法：</strong> <code>~类名(){}</code></p>
<ol>
<li>析构函数，没有返回值也不写void</li>
<li>函数名称与类名相同,在名称前加上符号  ~</li>
<li>析构函数不可以有参数，因此不可以发生重载</li>
<li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li>
</ol>
<pre><code class="language-C++">class Person
{
public:
	//构造函数
	Person()
	{
		cout &lt;&lt; &quot;Person的构造函数调用&quot; &lt;&lt; endl;
	}
	//析构函数
	~Person()
	{
		cout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl;
	}

};

void test01()
{
	Person p;
}

int main() {
	
	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h4 id="422-构造函数的分类及调用">4.2.2 构造函数的分类及调用</h4>
<p>两种分类方式：</p>
<p>​	按参数分为： 有参构造和无参构造</p>
<p>​	按类型分为： 普通构造和拷贝构造</p>
<p>三种调用方式：</p>
<p>​	括号法</p>
<p>​	显示法</p>
<p>​	隐式转换法</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">//1、构造函数分类
// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数
// 按照类型分类分为 普通构造和拷贝构造

class Person {
public:
	//无参（默认）构造函数
	Person() {
		cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;
	}
	//有参构造函数
	Person(int a) {
		age = a;
		cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;
	}
	//拷贝构造函数
	Person(const Person&amp; p) {
		age = p.age;
		cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;
	}
	//析构函数
	~Person() {
		cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;
	}
public:
	int age;
};

//2、构造函数的调用
//调用无参构造函数
void test01() {
	Person p; //调用无参构造函数
}

//调用有参的构造函数
void test02() {

	//2.1  括号法，常用
	Person p1(10);
	//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明
	//Person p2();

	//2.2 显式法
	Person p2 = Person(10); 
	Person p3 = Person(p2);
	//Person(10)单独写就是匿名对象  当前行结束之后，马上析构

	//2.3 隐式转换法
	Person p4 = 10; // Person p4 = Person(10); 
	Person p5 = p4; // Person p5 = Person(p4); 

	//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明
	//Person p5(p4);
}

int main() {

	test01();
	//test02();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h4 id="423-拷贝构造函数调用时机">4.2.3 拷贝构造函数调用时机</h4>
<p>C++中拷贝构造函数调用时机通常有三种情况</p>
<ul>
<li>使用一个已经创建完毕的对象来初始化一个新对象</li>
<li>值传递的方式给函数参数传值</li>
<li>以值方式返回局部对象</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">class Person {
public:
	Person() {
		cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;
		mAge = 0;
	}
	Person(int age) {
		cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;
		mAge = age;
	}
	Person(const Person&amp; p) {
		cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;
		mAge = p.mAge;
	}
	//析构函数在释放内存之前调用
	~Person() {
		cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;
	}
public:
	int mAge;
};

//1. 使用一个已经创建完毕的对象来初始化一个新对象
void test01() {

	Person man(100); //p对象已经创建完毕
	Person newman(man); //调用拷贝构造函数
	Person newman2 = man; //拷贝构造

	//Person newman3;
	//newman3 = man; //不是调用拷贝构造函数，赋值操作
}

//2. 值传递的方式给函数参数传值
//相当于Person p1 = p;
void doWork(Person p1) {}
void test02() {
	Person p; //无参构造函数
	doWork(p);
}

//3. 以值方式返回局部对象
Person doWork2()
{
	Person p1;
	cout &lt;&lt; (int *)&amp;p1 &lt;&lt; endl;
	return p1;
}

void test03()
{
	Person p = doWork2();
	cout &lt;&lt; (int *)&amp;p &lt;&lt; endl;
}


int main() {

	//test01();
	//test02();
	test03();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h4 id="424-构造函数调用规则">4.2.4 构造函数调用规则</h4>
<p>默认情况下，c++编译器至少给一个类添加3个函数</p>
<p>1．默认构造函数(无参，函数体为空)</p>
<p>2．默认析构函数(无参，函数体为空)</p>
<p>3．默认拷贝构造函数，对属性进行值拷贝</p>
<p>构造函数调用规则如下：</p>
<ul>
<li>
<p>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造</p>
</li>
<li>
<p>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</p>
</li>
</ul>
<p>示例：</p>
<pre><code class="language-C++">class Person {
public:
	//无参（默认）构造函数
	Person() {
		cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;
	}
	//有参构造函数
	Person(int a) {
		age = a;
		cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;
	}
	//拷贝构造函数
	Person(const Person&amp; p) {
		age = p.age;
		cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;
	}
	//析构函数
	~Person() {
		cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;
	}
public:
	int age;
};

void test01()
{
	Person p1(18);
	//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作
	Person p2(p1);

	cout &lt;&lt; &quot;p2的年龄为： &quot; &lt;&lt; p2.age &lt;&lt; endl;
}

void test02()
{
	//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造
	Person p1; //此时如果用户自己没有提供默认构造，会出错
	Person p2(10); //用户提供的有参
	Person p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供

	//如果用户提供拷贝构造，编译器不会提供其他构造函数
	Person p4; //此时如果用户自己没有提供默认构造，会出错
	Person p5(10); //此时如果用户自己没有提供有参，会出错
	Person p6(p5); //用户自己提供拷贝构造
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h4 id="425-深拷贝与浅拷贝">4.2.5 深拷贝与浅拷贝</h4>
<p>深浅拷贝是面试经典问题，也是常见的一个坑</p>
<p>浅拷贝：简单的赋值拷贝操作</p>
<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">class Person {
public:
	//无参（默认）构造函数
	Person() {
		cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;
	}
	//有参构造函数
	Person(int age ,int height) {
		
		cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;

		m_age = age;
		m_height = new int(height);
		
	}
	//拷贝构造函数  
	Person(const Person&amp; p) {
		cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;
		//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题
		m_age = p.m_age;
		m_height = new int(*p.m_height);
		
	}

	//析构函数
	~Person() {
		cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;
		if (m_height != NULL)
		{
			delete m_height;
		}
	}
public:
	int m_age;
	int* m_height;
};

void test01()
{
	Person p1(18, 180);

	Person p2(p1);

	cout &lt;&lt; &quot;p1的年龄： &quot; &lt;&lt; p1.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p1.m_height &lt;&lt; endl;

	cout &lt;&lt; &quot;p2的年龄： &quot; &lt;&lt; p2.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p2.m_height &lt;&lt; endl;
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Graphic Raycaster：检测所有Canvas上的UI]]></title>
        <id>https://Wei715547.github.io/post/graphic-raycasterjian-ce-suo-you-canvas-shang-de-ui/</id>
        <link href="https://Wei715547.github.io/post/graphic-raycasterjian-ce-suo-you-canvas-shang-de-ui/">
        </link>
        <updated>2020-11-14T12:31:11.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://Wei715547.github.io/post-images/1605357183735.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1605357192515.PNG" alt="" loading="lazy"></p>
<p>The Graphic Raycaster is used to raycast against a Canvas. The Raycaster looks at all Graphics on the canvas and determines if any of them have been hit.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[点击事件 UI/Scene]]></title>
        <id>https://Wei715547.github.io/post/dian-ji-shi-jian-uiscene/</id>
        <link href="https://Wei715547.github.io/post/dian-ji-shi-jian-uiscene/">
        </link>
        <updated>2020-11-11T12:50:02.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEditor;<br>
using UnityEngine;<br>
using UnityEngine.EventSystems;</p>
<p>public class AniRayTest : MonoBehaviour<br>
{<br>
List<RaycastResult> list = new List<RaycastResult>();</p>
<pre><code>// Update is called once per frame
void Update()
{
    /// 鼠标左键没有点击，就不执行判断逻辑
    if (!Input.GetMouseButtonDown(0))
    {
        return;
    }

    ///相应的GameObject对象
    GameObject go = null;

    ///判断是否点再ui上
    if (EventSystem.current.IsPointerOverGameObject())
    {
        go = ClickUI();
    }
    else
    {
        go = ClickScene();
    }

    if (go == null)
    {
        Debug.Log(&quot;Click Nothing&quot;);
    }
    else
    {
        // 高亮点中GameObject
        EditorGUIUtility.PingObject(go);
        Selection.activeObject = go;
        Debug.Log(go, go);
    }

}

/// &lt;summary&gt;
/// 点中ui
/// &lt;/summary&gt;
private GameObject ClickUI()
{
    //场景中的EventSystem

    PointerEventData eventData = new PointerEventData(EventSystem.current);

    //鼠标位置
    eventData.position = Input.mousePosition;

    //调用所有GraphicsRacaster里面的Raycast，然后内部会进行排序，
    //直接拿出来，取第一个就可以用了
    EventSystem.current.RaycastAll(eventData, list);

    //这个函数抄的unity源码的，就是取第一个值
    var raycast = FindFirstRaycast(list);

    //获取父类中事件注册接口
    //如Button，Toggle之类的，毕竟我们想知道哪个Button被点击了，而不是哪张Image被点击了
    //当然可以细分为IPointerClickHandler, IBeginDragHandler之类细节一点的，各位可以自己取尝试
    var go = ExecuteEvents.GetEventHandler&lt;IEventSystemHandler&gt;(raycast.gameObject);

    //既然没拿到button之类的，说明只有Image挡住了，取点中结果即可
    if (go == null)
    {
        go = raycast.gameObject;
    }
    return go;


}

/// &lt;summary&gt;
/// Return the first valid RaycastResult.
/// &lt;/summary&gt;
private RaycastResult FindFirstRaycast(List&lt;RaycastResult&gt; candidates)
{
    for (var i = 0; i &lt; candidates.Count; ++i)
    {
        if (candidates[i].gameObject == null)
            continue;

        return candidates[i];
    }
    return new RaycastResult();
}

/// &lt;summary&gt;
/// 点中场景中对象
/// 然后无聊嘛，顺便把点场景的也顺手做了，不过这部分网上介绍挺多的，就不展开说了。
/// &lt;/summary&gt;
private GameObject ClickScene()
{
    Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
    RaycastHit hit;
    if (Physics.Raycast(ray, out hit))
    {
        GameObject go = hit.collider.gameObject;
        return go;
    }

    return null;
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++：静态，常量，内存申请，构造/析构，继承多态，友元]]></title>
        <id>https://Wei715547.github.io/post/cclass/</id>
        <link href="https://Wei715547.github.io/post/cclass/">
        </link>
        <updated>2020-11-03T12:37:47.000Z</updated>
        <content type="html"><![CDATA[<p>int a[3] = { 0,1,2 };//数组<br>
char cl[3];//类C字符串逐个位赋值，cl = &quot;zla&quot;不合法--C++提供字符串类&quot;string&quot;<br>
cl[0] = 'z';<br>
cl[1] = 'l';<br>
cl[2] = 'a';<br>
//cin &gt;&gt; cl;<br>
for (int i = 0; i &lt; 3; i++)<br>
{<br>
cout &lt;&lt; cl[i]&lt;&lt; endl;<br>
}<br>
struct Person<br>
{<br>
string name;<br>
int age;<br>
char sex;<br>
float height;<br>
};<br>
Person p1 = { &quot;Wei&quot;,27,'W',175};<br>
声明：<br>
class 类名<br>
{<br>
public:<br>
外部调用方法<br>
属性get,set;<br>
private:<br>
属性<br>
}<br>
//在类外部定义“类中声明的方法”（必须加以“::”作为域限定符，用于声明函数属于哪个类）<br>
函数返回值  类名::函数名（参数）<br>
{<br>
方法体；//在类内实现定义的函数系统能够默认为内联函数。<br>
}<br>
内联函数(避免方法在栈空间中频繁存取释放)：只有在类外定义的成员函数规模较且调用频率较高时，才将成员函数指定为内联函数，(返回值2加inline ,类中的声明同样加上inline)。<br>
成员访问：<br>
1.对象名.成员名；<br>
2.指针-&gt;成员名<br>
3.引用名.成员名<br>
类：get,set方法：读写类的私有成员（保护作用）。<br>
类：成员函数：</p>
<p>类的成员函数声明与实现，分离；<br>
在头文件&quot;.h&quot;文件中进行类的声明；<br>
在源代码/程序文件&quot;.cpp&quot;文件中进行类成员函数的实现；<br>
在主函数&quot;main.cpp&quot;文件中使用类 的成员函数；</p>
<p>Re.h文件<br>
cood&lt;&gt;<br>
using namespace std;<br>
calss Re<br>
{<br>
public:<br>
int Area();<br>
int Perimeter;<br>
int getLength();<br>
void setLength(int Len);<br>
int getWidth();<br>
void setWidth（int Wid）;<br>
private:<br>
int length,width,<br>
}</p>
<p>Re.cpp文件：<br>
#include &quot;Re.h&quot;//引入要实现类的头文件<br>
int Re::Area()<br>
{<br>
return length*width;<br>
}<br>
int Re::getLength ()<br>
{<br>
return length;<br>
}<br>
void Re::setLength(int Len)<br>
{<br>
length = Len;<br>
}</p>
<p>main.cpp主函数<br>
#include &quot;Re.h&quot;//引入使用类头文件,预编译时使用Re.h中的内容替换引用<br>
using namespace std;<br>
int main (int arge,char *argv[])<br>
{</p>
<p>}<br>
构造函数：类名（）；{}<br>
1）无返回值，非void<br>
2）可以有多个构造函数，根据参数类型重载<br>
3）类对象创建时自动调用（new调用，delete调用析构函数）<br>
1、在类类内定义<br>
class Re<br>
{<br>
public:<br>
Re()//构造<br>
{<br>
length = 1;<br>
width = 1;<br>
}<br>
}<br>
2、在类外定义<br>
Re::Re()<br>
{<br>
length = 1;<br>
width = 1;<br>
}<br>
带参数构造函数：类名（类型 形参）；<br>
class Re<br>
{<br>
public:<br>
Re(int Len,int Wid)//构造<br>
{<br>
length = Len;<br>
width = Wid;<br>
}<br>
}<br>
参数初始化表对数据成员初始化：<br>
class Re<br>
{<br>
public:<br>
Re(int Len,int Wid):length(Len),width(Wid) {}//&quot;{}&quot;不能省略<br>
private:<br>
int length,windle;<br>
}<br>
默认参数值构造函数：用户不指定是，编译器使用默认值<br>
Re(int Len = 1,int Wid = 2)//构造<br>
{<br>
length = Len;<br>
width = Wid;<br>
}<br>
析构函数：~与类名相同 （）前面加上“~”<br>
1）与构造函数对应用于释放对象所占用内存(并不是删除对象)，由delete调用<br>
2）析构函数同样没有返回值，但也没有参数由于没有参数也不能重载，一个类存在多个构造函数但只存在一个析构函数。<br>
3）析构函数也可用于最后一次使用类对象后执行的操作（写在方法体中）<br>
4）后创建的对象先被释放<br>
5）静态局部对象在函数执行结束时不调用析构函数，只在main函数结束或调用exit函数时才调用。<br>
6）对于全局对象，当程序离开其作区域时调用i构造函数。<br>
class Re<br>
{<br>
public:<br>
Re(){}<br>
~Re(){}<br>
}</p>
<pre><code>new malloc区别
</code></pre>
<p>1、	new分配内存按照数据类型进行分配，malloc分配内存按照指定的大小分配；<br>
malloc 是函数，开辟内存需要传入字节数，如 malloc(100)；表示在堆上开辟了 100 个字 节的内存，返回 void*，表示分配的堆内存的起始地址，因此 malloc 的返回值需要强转成指 定类型的地址；new 是运算符，开辟内存需要指定类型，返回指定类型的地址，因此不需要 进行强转。<br>
2、	malloc 和 new 都是在堆上开辟内存的，malloc 只负责开辟内存，没有初始化功能，需要 用户自己初始化；new 不但开辟内存，还可以进行初始化，<br>
3、	malloc 开辟内存失败返回 NULL，new 开辟内存失败抛出 bad_alloc 类型的异常，需要捕 获异常才能判断内存开辟成功或失败，new 运算符其实是 operator new 函数的调用，它底 层调用的也是 malloc 来开辟内存的，new 它比 malloc 多的就是初始化功能，对于类类型来 说，所谓初始化，就是调用相应的构造函数。<br>
4、	new分配的内存要用delete销毁，malloc要用free来销毁；delete销毁的时候会调用对象的析构函数，而free则不会。</p>
<p>CONST<br>
共有数据<br>
常量数据成员：const在不同位置标示不同含义：<br>
const int aa//使用const的普通数据成员常量<br>
const int * bb//在int前使用const的指针数据成员<br>
int <em>const cc//在int后使用const的指针数据成员<br>
const int <em>const dd//在int类型前后使用const的指针数据成员<br>
const int &amp;cc //使用const的引用类型成员<br>
1）aa为整型常量，初始化后不能被改变，（在类中，必须在构造函数的初始化列表中进行初始化（不能在类定义时初始化：const int aa = 5//错误））<br>
2）在指针数据类型前时：指针指向的值不能改变<br>
3）在指针数据类型后时：指针变量值不能改变<br>
4）在指针数据类型前后时：指针指向值与指针值都不改变<br>
常量创建后不能将整型常量的地址赋值给一个int</em>指针，应赋值给cosnt int</em>指针。<br>
const int mm = 30；<br>
int *pp = &amp;mm;//应改为：const int *pp = &amp;mm<br>
C++允许创建指针常量，所指向的普通变量不是常量：<br>
int mm = 30;<br>
const int *pp = &amp;mm;//可以将非常量赋值给指针常量，但不能通过pp改变mm值。<br>
常成员函数：<br>
声明：<br>
void showDate() const;//const在参数列表后。<br>
定义：<br>
void Class::showDate() cosnt//在调用时不需加const<br>
{<br>
方法体;<br>
}<br>
常类对象：<br>
声明<br>
Re const r1 = {len = 2; wid = 3;}//定义常队形时必须进行初始化，而且其数据成员不能被更新（数据成员变为const）。<br>
注意：如果一个对象被声明为常对象，则通过该常对象只能调用它的常成员函数（不能调用非const型成员函数）(系统自动隐式调用的)构造/析构除外).<br>
静态成员：<br>
声明：<br>
static flot AccounntSum;<br>
初始化：<br>
float AccountRecord::AccountSum = 0;//C++中静态成员必须在类外进行，不能在构造函数中(C#中可定义静态构造函数用于初始化静态成员)</p>
<pre><code>1）静态字段 仅仅存储一份 所有对象共享 常驻内存中
2）静态方法只能访问静态成员（非静态成员依赖于对象生成） ，非静态方法静态非静态都可以访问，
3）*不能实例化，只能包含静态成员， 静态类不能被继承（工具类）
 /* 静态适用
    * 利：单独空间存储，所有对象共享，可直接被类名调用
    * 弊：静态方法中只能访问静态成员，共享数据被多个对象访问时会出现并发。
    * 适用场合：
    * 1.所有对象需要共享的数据。
    * 2.在没有对象是就要访问成员。
    * 3.工具类适合做静态类（常用，不需要过多数据）
</code></pre>
<p>继承，派生：<br>
继承的语法：<code>class 子类 : 继承方式 父类</code><br>
多继承语法：：class 派生类 ：继承方式1 基类1，继承方式2 基类2....<br>
{<br>
派生类新成员；<br>
}</p>
<p><strong>继承方式一共有三种：</strong></p>
<ul>
<li>公共继承</li>
<li>保护继承</li>
<li>私有继承<br>
<img src="https://Wei715547.github.io/post-images/1604666547871.png" alt="" loading="lazy"></li>
</ul>
<p>**问题：**从父类继承过来的成员，哪些属于子类对象中？<br>
父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到（子类的sizeof包括子类成员以及所有父类成员//包括私有成员）<br>
父类的方法也是单独储存的，子类调用时由this指针指向调用的对象实现调用。</p>
<p>**问题：父类和子类的构造和析构顺序是谁先谁后？<br>
继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p>
<p>派生类构造函数：<br>
派生类名::派生类名（arg_derived_list）：基类名（arg_base_list）<br>
{<br>
//派生类新增数据成员初始化语句；<br>
}<br>
派生类存在与基类同名函数时使用，基类::函数名()来调用基类同名函数 （::作用域符）</p>
<p><strong>多态</strong>（C++以(纯)/虚函数实现多态:C#则在C++的虚函数基础上分出虚函数，抽象类接口(纯虚函数）</p>
<p>1）虚函数<br>
class 基类<br>
{<br>
public:<br>
virtural 函数返回值 虚函数名（形式参数表）<br>
{<br>
函数体<br>
}<br>
}<br>
class 派生类： public 基类<br>
{<br>
public:<br>
virtual 函数返回值 虚函数名（形参表）//virtual可不写出，派生类中与基类同名函数默认为虚函数<br>
{<br>
函数体；<br>
}<br>
}<br>
C++中不采用虚函数时，通过定义多个指向各派生类的指针来调用派生类中同名的函数。<br>
pt&gt;函数名();<br>
虚函数，指针指向派生类时，调用同名方法为运行期绑定（动态）非编译期绑定。(动态绑定通过实际指向类的虚函数表获取函数地址)<br>
运行期绑定只通过指针/引用来操作，采用定向直接调用函数将采用编译期绑定来调用虚函数</p>
<p>构造函数与析构函数<br>
构造函数不能时虚函数，析构函数可以是虚函数。<br>
<strong>（1）为什么父类的析构函数必须是虚函数？（虚析构）</strong><br>
当我们动态申请一个子类对象时，使用基类指针指向该对象，如果不用虚函数，基类指针在析构时，子类的析构函数不能得到调用，也就是为了在释放基类指针时可以释放掉子类申请的空间，防止内存泄漏.<br>
析构函数声明为虚函数后，通过指针来删除所指向的对象时，编译器进行运行期绑定，由于基类型指针实际指向的是派生类对象，则派生类析构函数被调用，随后基类析构函数被调用，(析构函数调用时沿着继承树自下而上进行，通过将析构函数声明为虚函数，来保证下层派生类析构函数得到调用，防止内存泄漏)<br>
<strong>纯虚析构</strong>：<br>
virtual Animal() =0;//在类中声明纯虚析构后需在类外实现纯虚析构，<br>
Animal::Animal()<br>
[<br>
函数体;<br>
]<br>
<strong>（2）为什么C++默认的析构函数不是虚函数？</strong><br>
因为虚函数需要额外的虚表指针指向虚函数表，占用额外的内存4字节。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。</p>
<p><strong>纯虚函数</strong>：在虚函数声明的结尾加上“=0”（派生类必须实现基类的纯虚数）（公共接口）<br>
一个类只要拥有一个纯虚函数，它就是抽象类（包含纯虚函数的类时无法创建对象的）<br>
基类<br>
public:<br>
virtual float SurfaceArea()=0;<br>
vitual float Volme()=0;<br>
派生类<br>
public Cube:public Base<br>
{<br>
public:<br>
Cube(float len):length(len){}<br>
float SurfaceArea();<br>
float Volume();</p>
<pre><code>private:
float length;
</code></pre>
<p>};<br>
float Cube::SurfaceArea()<br>
[<br>
函数体<br>
]</p>
<p><strong>友元/friend</strong> （使外部，全局/局部函数，类，作为本类的友元，使其可以访问本类中的私有成员）<br>
1）全局函数做友元</p>
<pre><code class="language-C++">class Building
{
	//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容
	**friend void goodGay(Building * building);**

public:

	Building()
	{
		this-&gt;m_SittingRoom = &quot;客厅&quot;;
		this-&gt;m_BedRoom = &quot;卧室&quot;;
	}


public:
	string m_SittingRoom; //客厅

private:
	string m_BedRoom; //卧室
};


void goodGay(Building * building)
{
	cout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;
	cout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;
}


void test01()
{
	Building b;
	goodGay(&amp;b);
}

int main(){

	test01();

	system(&quot;pause&quot;);
	return 0;
}
</code></pre>
<p>2）类做友元</p>
<pre><code class="language-C++">class Building;
class goodGay
{
public:

	goodGay();
	void visit();

private:
	Building *building;
};


class Building
{
	//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容
	**friend class goodGay;**

public:
	Building();

public:
	string m_SittingRoom; //客厅
private:
	string m_BedRoom;//卧室
};

Building::Building()
{
	this-&gt;m_SittingRoom = &quot;客厅&quot;;
	this-&gt;m_BedRoom = &quot;卧室&quot;;
}

goodGay::goodGay()
{
	building = new Building;
}

void goodGay::visit()
{
	cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;
	cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;
}

void test01()
{
	goodGay gg;
	gg.visit();

}

int main(){

	test01();

	system(&quot;pause&quot;);
	return 0;
}
</code></pre>
<p>3）成员函数做友元</p>
<pre><code class="language-C++">
class Building;
class goodGay
{
public:

	goodGay();
	void visit(); //只让visit函数作为Building的好朋友，可以发访问Building中私有内容
	void visit2(); 

private:
	Building *building;
};


class Building
{
	//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容
	**friend void GoodGay::visit();**

public:
	Building();

public:
	string m_SittingRoom; //客厅
private:
	string m_BedRoom;//卧室
};

Building::Building()
{
	this-&gt;m_SittingRoom = &quot;客厅&quot;;
	this-&gt;m_BedRoom = &quot;卧室&quot;;
}

goodGay::goodGay()
{
	building = new Building;
}

void goodGay::visit()
{
	cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;
	cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;
}

void goodGay::visit2()
{
	cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;
	//cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;
}

void test01()
{
	goodGay  gg;
	gg.visit();

}

int main(){
    
	test01();

	system(&quot;pause&quot;);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C指针]]></title>
        <id>https://Wei715547.github.io/post/c-zhi-zhen/</id>
        <link href="https://Wei715547.github.io/post/c-zhi-zhen/">
        </link>
        <updated>2020-10-29T07:25:10.000Z</updated>
        <content type="html"><![CDATA[<p>定义：type * p_address; (type:数据类型)<br>
p_address = &amp; valu; (&amp;取引用)<br>
*p_address； 表示地址中的值（解引用）</p>
<p>值帧/数组  int array[3] = [7,1,5];<br>
int* p_array = array;<br>
(int类型(4字节)数组array所指向的是array[0]的地址，即&amp;array[0],<br>
一旦将array赋值给p_array，此时array和p_array都指向数组的第一个元素的地址，可以通过指针像数组一样操作数组，p_array[0] , array[0]含义相同)<br>
指针运算：p_array++ 和p_array+1都指向数组的下一个元素（int类型占4个字节+1地址偏移4位(C++不会进行数组越界检测)）<br>
如上所有数组索引表达式可以写成指针镓屁啊你量形式：<br>
array[1] 与 <em>(p_array+1)相同<br>
数组声明：type array [n];<br>
array含义1：代表这个数组其类型时type[n];<br>
array含义2：代表一个“常量”指针，指针类型时type</em> ,指向的类型是type，指向的存区域是数组第一个元素(0号单元)，该指针占有单独的内存区域，指针值不可修改，即类似array++的表达式错误。<br>
引用：(本质常量指针)<br>
数据类型 &amp;别名 = 原名<br>
type &amp;b = a;<br>
指针与引用：声明：double x = 7.5;<br>
double* p = &amp;x;<br>
//引用声明 （引用声明时必须指定引用对象，且绑定关系不可改变）<br>
double&amp; y = x;<br>
上述“&amp;”“<em>”为定义引用与指针，非取址与解引用。通过</em>p与y都可对x值进行更改；<br>
指针与函数：指针作为函数参数<br>
void swap (int * a ,int * b)//<br>
{<br>
int temp = *a;<br>
*a = *b;<br>
*b = temp;<br>
}<br>
int a = 10;<br>
int b - 20;<br>
swap(&amp;a,&amp;b); //C#,ref<br>
指针指向函数：<br>
void (*funcp)()//声明一个无参数无返回值的函数指针<br>
funcp = &amp;TheFunction;//<br>
funcp = TheFunction；//函数指针赋值<br>
funcp();//与函数调用书写方式无异，下式表示更明确<br>
(*funcp)()；//间接调用</p>
<p>C++内存分区模型：<br>
程序运行前存在<br>
//代码区：存放函数体的二进制代码，有系统进行管理。<br>
存放及其指令<br>
特点：共享，只读。<br>
全局区：存放全局变量和静态变量以及常量。<br>
常量包括：字符串常量，const修饰变量：修饰 的全局变量，(const修饰的局部变量不再全局区)。<br>
//运行后<br>
栈区：（指针本质局部变量放在栈上，保存堆区数据的地址）由编译器自动分配释放，存放函数参数值，形参，局部变量等。（不要返回局部变量的地址，栈区开辟的数据由编译器自动释放）：函数中的局部变量存放在栈区，栈区的数据在“函数”执行完成后会自动释放，在此、次访问时地址中的数据已发生改变。（只保留一次）<br>
堆区：由程序员分配释放，若不释放，程序结束时由系统进行回收。由new type;与delete申请/释放。<br>
动态内存分配：（在“堆”区开辟空间，由程序员管理，开辟/释放）new typr,（new返回type类型的指针）<br>
int* p_int;<br>
p_int = new int ;//或p_int = new(int)<br>
delete p_int</p>
<p>int* p_arrayint ;<br>
p_arrayint - new int[10]//声明数组内存空间，不能分配时返回NULL<br>
delete[] p_arrayint;<br>
分配到的内存系统不会自动回收，需要调用delete[] p_arrayint;来释放内存。<br>
不释放则导致内存泄漏。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[洗牌算法，洪水填充算法，C#重置内置运算符]]></title>
        <id>https://Wei715547.github.io/post/xi-pai-suan-fa/</id>
        <link href="https://Wei715547.github.io/post/xi-pai-suan-fa/">
        </link>
        <updated>2020-10-12T02:57:36.000Z</updated>
        <content type="html"><![CDATA[<p>public class Utilities<br>
{<br>
/// <summary><br>
/// 洗牌算法，<br>
/// </summary><br>
/// <param name="dateArray">随机重排的数组</param><br>
/// <returns></returns><br>
public static Coord[] ShuffleCoords(Coord[] dateArray)<br>
{<br>
for (int i = 0; i &lt; dateArray.Length; i++)<br>
{<br>
//将每次随机到的元素放到首位，第二次随机从“队首+1~最后元素”开始随机，这样每次随机到的即不为同一元素<br>
int random = Random.Range(i, dateArray.Length);<br>
//SWAP<br>
Coord temp = dateArray[random];<br>
dateArray[random] = dateArray[i];<br>
dateArray[i] = temp;<br>
}<br>
return dateArray;<br>
}<br>
}<br>
//应用程序<br>
<img src="https://Wei715547.github.io/post-images/1602493526529.PNG" alt="" loading="lazy"><br>
shuffleCoords = new Queue<Coord>(Utilities.ShuffleCoords(allTilesCoord.ToArray()));<br>
public Coord GetRandomCoord()<br>
{<br>
Coord randomCoord = shuffleCoords.Dequeue();<br>
shuffleCoords.Enqueue(randomCoord);<br>
return randomCoord;<br>
}<br>
——————————————————————————————————————————————————<br>
/// <summary><br>
/// 洪水填充算法<br>
/// </summary><br>
/// <param name="_mapObstacles">地图上的位置是否存在障碍物</param><br>
/// <param name="_currentObsCount">应该时候能承担障碍物数量</param><br>
/// <returns>是否可以在此处生成障碍物</returns><br>
public bool MapIsFullyAccessible(bool[,] _mapObstacles, int _currentObsCount)<br>
{<br>
bool[,] mapFlag = new bool[_mapObstacles.GetLength(0), _mapObstacles.GetLength(1)];<br>
Queue<Coord> queue = new Queue<Coord>();//存储所有筛选后的坐标<br>
queue.Enqueue(mapCenter);<br>
mapFlag[mapCenter.x, mapCenter.y] = true;//中心点标记为已检测<br>
int accessibleCount = 1;//可以行走的格子数量<br>
while(queue.Count&gt;0)<br>
{<br>
Coord currentTile = queue.Dequeue();<br>
for (int x = -1; x &lt;=1; x++)<br>
{<br>
for (int y = -1; y &lt;=1; y++)<br>
{<br>
int neighborX = currentTile.x + x;<br>
int neighborY = currentTile.y + y;</p>
<pre><code>                if (x==0||y==0)//检测上下左右四个相邻的位置是否可行
                {
                    if(neighborX &gt;=0&amp;&amp;neighborX&lt;_mapObstacles.GetLength(0)
                        &amp;&amp; neighborY&gt;=0&amp;&amp;neighborY&lt;_mapObstacles.GetLength(1))//范围限定在地图范围内
                    {
                        //该位置未检测，且不存在障碍物时
                        if(!mapFlag[neighborX,neighborY]&amp;&amp;!_mapObstacles[neighborX,neighborY])
                        {
                            mapFlag[neighborX, neighborY] = true;
                            accessibleCount++;
                            queue.Enqueue(new Coord(neighborX, neighborY));
                        }
                    }
                }
            }
        }
    }
    int walkableCount = (int)(mapSize.x * mapSize.y - _currentObsCount);//地图上应该可行走位置的数量
    return accessibleCount == walkableCount;//联通路径总的可行走数量与目标值相同时则可依据_mapObstacles中位置生成障碍物
}
------------------------重置内置运算符“operator”--------------------------
**C#支持的运算符重载**
可重载的一元运算符 (overloadable unary operator) 有：
</code></pre>
<ul>
<li>
<ul>
<li>!   ~   ++   --   true   false<br>
可重载的二元运算符 (overloadable binary operator) 有：</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>/   %   &amp;   |   ^   &lt;&lt;   &gt;&gt;   ==   !=   &gt;   &lt;   &gt;=   &lt;=<br>
struct Human<br>
{<br>
public int s1;<br>
public int s2;<br>
public Human(int a, int b)<br>
{<br>
s1 = a;<br>
s2 = b;<br>
}<br>
public static Human operator + (Human a,Human b)<br>
{<br>
Human temp = new Human(a.s1 + b.s1, a.s2 + b.s2);<br>
return temp;<br>
}<br>
public static Human operator - (Human a,Human b)<br>
{<br>
Human temp = new Human(a.s1 - b.s1, a.s2 - b.s2);<br>
return temp;<br>
}<br>
public static bool operator == (Human a,Human b)<br>
{<br>
return a.s1 == b.s1 &amp;&amp; a.s2 == b.s2;<br>
}<br>
public static bool operator !=(Human a,Human b)<br>
{<br>
return !(a == b);<br>
}<br>
}<br>
public struct Coord<br>
{<br>
public int x;<br>
public int y;</li>
</ul>
</li>
</ul>
<p>public Coord(int _x, int _y)<br>
{<br>
this.x = _x;<br>
this.y = _y;<br>
}<br>
//operator：重置内置运算符，C#要求成对重载比较运算符<br>
public static bool operator !=(Coord _c1,Coord _c2)<br>
{<br>
return !(_c1 == _c2);<br>
}<br>
public static bool operator ==(Coord _c1,Coord _c2)<br>
{<br>
return (_c1.x == _c2.x &amp;&amp; _c1.y == _c2.y);<br>
}<br>
}</p>
</li>
</ul>
]]></content>
    </entry>
</feed>