<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Wei715547.github.io</id>
    <title>WeiBlog</title>
    <updated>2021-04-13T10:56:26.911Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Wei715547.github.io"/>
    <link rel="self" href="https://Wei715547.github.io/atom.xml"/>
    <subtitle>年月增长，我宜强盛。
用于Unity+开发的技术积累</subtitle>
    <logo>https://Wei715547.github.io/images/avatar.png</logo>
    <icon>https://Wei715547.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, WeiBlog</rights>
    <entry>
        <title type="html"><![CDATA[Shader纹理/顶点动画]]></title>
        <id>https://Wei715547.github.io/post/shader-wen-li-ding-dian-dong-hua/</id>
        <link href="https://Wei715547.github.io/post/shader-wen-li-ding-dian-dong-hua/">
        </link>
        <updated>2021-04-13T08:34:59.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://Wei715547.github.io/post-images/1618303098602.PNG" alt="" loading="lazy"></figure>
<p><strong>1.纹理序列帧动画</strong><br>
<code><br>
Shader &quot;Unlit/TcAnimition&quot;<br>
{<br>
Properties<br>
{<br>
_MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}<br>
_Color(&quot;ColorTint&quot;,Color) = (1,1,1,1)<br>
_HCount(&quot;HCount&quot;,Float) = 4<br>
_VCount(&quot;VCount&quot;,Float) = 4<br>
_Speed(&quot;Speed&quot;,Range(1,100)) = 1<br>
_A(&quot;Alp&quot;,Range(0,1))=0.5<br>
}<br>
SubShader<br>
{	<br>
Tags{&quot;Queue&quot; = &quot;Transparent&quot;/<em>设置模型渲染队列为透明度混合</em>/ &quot;IngnoreProjector&quot; = &quot;True&quot; &quot;RanderType&quot; = &quot;Transparent&quot;}<br>
Pass<br>
{<br>
//Tags{&quot;LightMode&quot; = &quot;ForwardBase&quot;}<br>
ZWrite Off<br>
Blend SrcAlpha OneMinusSrcAlpha</p>
<pre><code>        CGPROGRAM
		sampler2D _MainTex;
		float4 _MainTex_ST;
		float4 _Color;
		float _HCount;
		float _VCount;
		float _Speed;
		float _A;

        #pragma vertex vert
        #pragma fragment frag
		#include &quot;UnityCG.cginc&quot;
        struct a2v
        {
            float4 vertex : POSITION;
            float2 uv : TEXCOORD0;
        };

        struct v2f
        {
            float2 uv : TEXCOORD0;
            float4 vertex : SV_POSITION;
        };


        v2f vert (a2v v)
        {
            v2f o;
            o.vertex = UnityObjectToClipPos(v.vertex);
            o.uv = TRANSFORM_TEX(v.uv, _MainTex);
			
            return o;
        }

        fixed4 frag (v2f i) : SV_Target
        {
			float time = floor(_Time.y*_Speed);
			float row = floor(time/_HCount);
			float column = time- row*_HCount;

			half2 uv = i.uv+half2(column,-row);
			uv.x /=_HCount;
			uv.y /= _VCount;
            fixed4 col = tex2D(_MainTex, uv);
			col *=_Color;
            return float4( col.xyz,_A*col.w);
        }
        ENDCG
    }
}
FallBack &quot;Transparent/VertexLit&quot;
</code></pre>
<p>}</code><br>
<img src="https://Wei715547.github.io/post-images/1618305332948.PNG" alt="" loading="lazy"><br>
<strong>2.纹理平移</strong><br>
<code><br>
Shader &quot;Unlit/TcMoveAni&quot;<br>
{<br>
Properties<br>
{<br>
_MainTex (&quot;BaseLayer&quot;, 2D) = &quot;white&quot; {}<br>
_DetaliTex (&quot;UpLayer&quot;, 2D) = &quot;white&quot; {}<br>
_ScrollX(&quot;BaseSpeed&quot;,Float) = 1.0<br>
_Scroll2X(&quot;UpSpeed&quot;,Float) = 1.0<br>
_Multipler(&quot;LayerHLT&quot;,fLOAT) = 1<br>
}<br>
SubShader<br>
{			<br>
Pass<br>
{</p>
<pre><code>        CGPROGRAM
		sampler2D _MainTex;
		float4 _MainTex_ST;
		sampler2D _DetaliTex;
		float4 _DetaliTex_ST;
		float _ScrollX;
		float _Scroll2X;
		float _Multipler;

        #pragma vertex vert
        #pragma fragment frag
		#include &quot;UnityCG.cginc&quot;
        struct a2v
        {
            float4 vertex : POSITION;
            float2 uv : TEXCOORD0;
        };

        struct v2f
        {
            float4 uv : TEXCOORD0;
            float4 vertex : SV_POSITION;
        };


        v2f vert (a2v v)
        {
            v2f o;
            o.vertex = UnityObjectToClipPos(v.vertex);
            o.uv.xy = TRANSFORM_TEX(v.uv, _MainTex)+frac(float2(_ScrollX,0.0)*_Time.y);
			o.uv.zw = TRANSFORM_TEX(v.uv,_DetaliTex)+frac(float2(_Scroll2X,0.0)*_Time.y);				
            return o;
        }

        fixed4 frag (v2f i) : SV_Target
        {
			fixed4 baseLayer = tex2D(_MainTex,i.uv.xy);
			fixed4 upLayer = tex2D(_DetaliTex,i.uv.zw);

            fixed4 col = lerp(baseLayer,upLayer,upLayer.a);
			col.rgb *=_Multipler;
            return col;
        }
        ENDCG
    }
}
FallBack &quot;Diffuse&quot;
</code></pre>
<p>}</code><br>
<strong>3.顶点动画</strong><br>
<img src="https://Wei715547.github.io/post-images/1618311312093.PNG" alt="" loading="lazy"><br>
<code><br>
Shader &quot;Custom/VTAni&quot;<br>
{<br>
Properties<br>
{<br>
_Color (&quot;Color&quot;, Color) = (1,1,1,1)<br>
_MainTex (&quot;Albedo (RGB)&quot;, 2D) = &quot;white&quot; {}<br>
_Manitude(&quot;Mangitude&quot;, Float) = 1<br>
_Frequency(&quot;Frequency&quot;,Float) = 1<br>
_InvWaveLength(&quot;InvWaveLength&quot;,Float) = 10<br>
_Speed(&quot;Speed&quot;,Float) = 0.5<br>
}<br>
SubShader<br>
{<br>
Tags{&quot;Queue&quot; = &quot;Transparent&quot; &quot;IgnoreProjector&quot; = &quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot;<br>
&quot;DisableBatching&quot; = &quot;True&quot;}//该模型依靠模型空间计算顶点动画，不进行批处理合并<br>
Pass{<br>
//Tags{&quot;LightMode&quot; = &quot;ForwardBase&quot;}<br>
ZWrite Off<br>
Blend SrcAlpha OneMinusSrcAlpha<br>
Cull Off//双面可见</p>
<pre><code>    CGPROGRAM

    sampler2D _MainTex;
	float4 _MainTex_ST;
	float4 _Color;
	float _Manitude;
	float _Frequency;
	float _InvWaveLength;
	float _Speed;
	#pragma vertex vert
    #pragma fragment frag
	#include &quot;UnityCG.cginc&quot;

    struct a2v
        {
            float4 vertex : POSITION;
            float2 uv : TEXCOORD0;
        };

        struct v2f
        {
            float2 uv : TEXCOORD0;
            float4 pos : SV_POSITION;
        };

	v2f vert(a2v v){
		v2f o;
		float4 offset ;
		offset.xzw = float3(0.0,0.0,0.0);
		offset.y = sin(_Frequency*_Time.y + v.vertex.x * _InvWaveLength + v.vertex.y*_InvWaveLength + v.vertex.z*_InvWaveLength )*_Manitude;
		o.pos = UnityObjectToClipPos(v.vertex+offset);
		o.uv = TRANSFORM_TEX(v.uv,_MainTex);
		o.uv += float2(0.0,_Time.y*_Speed);
		return o;
	}
	fixed4 frag(v2f i):SV_Target{
		fixed4 c = tex2D(_MainTex,i.uv);
		c.rgb *= c;
		return c;
	}
	ENDCG
}
}
FallBack &quot;Transparent/VertexLit&quot;
</code></pre>
<p>}</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图形学：向量/矩阵/空间变换]]></title>
        <id>https://Wei715547.github.io/post/tu-xing-xue-xiang-liang-ju-zhen/</id>
        <link href="https://Wei715547.github.io/post/tu-xing-xue-xiang-liang-ju-zhen/">
        </link>
        <updated>2021-04-04T08:14:03.000Z</updated>
        <content type="html"><![CDATA[<p><strong>向量：点乘，叉乘</strong><br>
//点乘：a<em>b = axbx+ayby+azbz =|a| |b|cos(x),ab夹角：<br>
//b在a上的投影：|b|cos(x) = (a</em>b)/|a| = b<em>a(A),//单位矢量a<br>
应用：<br>
a为平面法线，求b在平面上的投影<br>
b在a向量上的投影向量为c = Vector.Dot(a,b)/a.magintude ()<em>a.normalized<br>
则b在平面上的投影为：b-c;<br>
<img src="https://Wei715547.github.io/post-images/1617524585593.png" alt="" loading="lazy"><br>
//点乘Vector3.Dot();v2在v1上投影的标量。V1( x1, y1)   V2(x2, y2) = x1</em>x2 + y1</em>y2<br>
//叉乘Vector3.Cross();v1v2平面的法线向量。V1(x1, y1) X V2(x2, y2) = x1y2 – y1x2<br>
（右手顺时v1指向v2）。即叉乘的第一个向量在第二个向量右边时为正，否则为负。<br>
A x B = |A||B|Sin(θ)<br>
<img src="https://Wei715547.github.io/post-images/1617524798354.png" alt="" loading="lazy"><br>
<strong>矩阵</strong><br>
矩阵相乘：A（rxc）,B（cxn）矩阵只允许A的列数等于B的行数时两矩阵才能相乘得到r行n列的新矩阵<br>
新矩阵C的i行j列元素等于A的i行与B的j列点乘<br>
<img src="https://Wei715547.github.io/post-images/1617525313203.PNG" alt="" loading="lazy"><br>
<strong>特殊矩阵</strong><br>
方块矩阵：行列数相同的矩阵<br>
对角矩阵：除了对角元素m11,m22,m33等其他元素都为0的矩阵<br>
单位矩阵：对角元素为1的矩阵{[1 0 0],[0 1 0],[0 0 1]}任何矩阵与其相乘还是原来的矩阵</p>
<p>转置矩阵：  对矩阵的一种运算，将元素的行变为列，列变为行<br>
<img src="https://Wei715547.github.io/post-images/1617525786685.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1617525838429.PNG" alt="" loading="lazy"><br>
逆矩阵：原矩阵与其逆矩阵(纯在逆矩阵，元素都为0的矩阵不存在逆矩阵)相乘=单位矩阵<br>
一个矩阵有对应的逆矩阵即是可逆的又称非奇异的  ，没有逆矩阵则是不可逆的，奇异的<br>
<img src="https://Wei715547.github.io/post-images/1617526690926.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1617526823864.PNG" alt="" loading="lazy"><br>
正交矩阵：若矩阵与该矩阵的转置矩阵相乘得到单位矩阵，即该矩阵的转置正交也是该矩阵的逆矩阵<br>
<img src="https://Wei715547.github.io/post-images/1617527574679.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1617527627513.PNG" alt="" loading="lazy"><br>
由上得出对于3x3的正交矩阵实际上即是三维空间坐标轴，若它们长度为1构成标准正交基则被称为标准正交矩阵<br>
正交矩阵可用于构造变换矩阵，对应的逆变换(逆矩阵计算复杂)可直接由转置矩阵得到。</p>
<p><strong>关于矢量变为行矩阵还是列矩阵</strong>：在U3D中将矢量放在矩阵右边进行相乘计算（当做列矩阵）。<br>
<img src="https://Wei715547.github.io/post-images/1617528382482.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1617528390964.PNG" alt="" loading="lazy"></p>
<p><strong>变换</strong><br>
线性变换：那些可以保留矢量相加标量相乘的变换。包括缩放、旋转、正交投影等。<br>
仿射变换：由于平移不是线性变换，因此仿射变换是合并线性变换和平移变换的变换类型。<br>
仿射变换可以使用4x4的矩阵来表示-齐次坐标空间：三维转四维：对于点w=1；对于矢量w=0(当平移作用于矢量时不会产生影响)<br>
<img src="https://Wei715547.github.io/post-images/1617529382160.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1617529442695.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1617529477199.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1617529549995.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1617529575805.PNG" alt="" loading="lazy"></p>
<p><strong>复合变换</strong>：矢量转为列矩阵计算，顺序从右到左<br>
<img src="https://Wei715547.github.io/post-images/1617530502589.PNG" alt="" loading="lazy"><br>
绝大多数下先进行缩放，再旋转，最后平移<br>
关于xyz轴的旋转顺序：U3D中的旋转顺序是z,x,y，但矩阵的计算顺序不需要从右到左(由于坐标系的旋转)<br>
<img src="https://Wei715547.github.io/post-images/1617530788048.PNG" alt="" loading="lazy"></p>
<p><strong>空间变换</strong><br>
模型空间-&gt;世界空间-&gt;观察空间-&gt;裁剪空间-&gt;屏幕空间NDC<br>
M：m-&gt;w变换矩阵 平移<em>旋转</em>缩放（移动整个坐标系坐标系中的点也跟随移动）<br>
<img src="https://Wei715547.github.io/post-images/1617778015972.PNG" alt="" loading="lazy"><br>
V：w-&gt;v变换矩阵 根据参数对相机进行逆变换移动到世界原点(对z取反)<br>
<img src="https://Wei715547.github.io/post-images/1617778125927.PNG" alt="" loading="lazy"><br>
P：<br>
透视投影，<br>
<img src="https://Wei715547.github.io/post-images/1617778934812.PNG" alt="" loading="lazy"><br>
正交投影。<br>
<img src="https://Wei715547.github.io/post-images/1617778988783.PNG" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leet Code持续更新（2）]]></title>
        <id>https://Wei715547.github.io/post/leet-code-chi-xu-geng-xin-2/</id>
        <link href="https://Wei715547.github.io/post/leet-code-chi-xu-geng-xin-2/">
        </link>
        <updated>2021-03-26T09:50:25.000Z</updated>
        <content type="html"><![CDATA[<p><strong>//1035.不相交的线：动态规划</strong><br>
public static int MaxUncrossLines(int[] A,int[] B)<br>
{<br>
int[,] dp = new int[A.Length + 1, B.Length + 1];//动态规划数组<br>
for (int i = 1; i &lt;= A.Length; i++)//遍历规划数组并赋值0行与列初始为0<br>
{<br>
for (int j = 1; j &lt;= B.Length; j++)<br>
{<br>
//a=b时:  dp(a, b) = dp(a - 1, b - 1) + 1<br>
//a!=b时: dp(a, b) = max(dp(a - 1, b), dp(a, b - 1))</p>
<pre><code>                dp[i, j] = A[i - 1] == B[j - 1] ? dp[i - 1, j - 1] + 1 : (int)MathF.Max(dp[i - 1, j], dp[i, j - 1]);
            }
        }
        return dp[A.Length, B.Length];
    }
</code></pre>
<p><strong>//419:甲板上的军舰</strong><br>
//DFS<br>
public int CountBattleships(char[][] board)<br>
{<br>
if (board == null || board.Length == 0) return 0;</p>
<pre><code>        int res = 0;
        for (int i = 0; i &lt; board.Length; i++)
        {
            for (int j = 0; j &lt; board[0].Length; j++)
            {
                if (board[i][j] == 'X')
                {
                    res++;
                    DFSZ(board, i, j);
                }
            }
        }
        return res;
    }
    static void DFSZ(char[][] grid, int i, int j)
    {
        if (i &lt; 0 || j &lt; 0 || i &gt;= grid.Length || j &gt;= grid[0].Length || grid[i][j] == '.')
        {
            return;
        }
        grid[i][j] = '.';
        DFSZ(grid, i + 1, j);
        DFSZ(grid, i - 1, j);
        DFSZ(grid, i, j + 1);
        DFSZ(grid, i, j - 1);
    }
//进阶：用一次扫描算法，只使用O(1)额外空间，并且不修改甲板的值来解决这个问题吗？
    public int CountBattleships2(char[][] board)
    {
        if (board == null || board.Length == 0) return 0;

        int res = 0;
        for (int i = 0; i &lt; board.Length; i++)
        {
            for (int j = 0; j &lt; board[0].Length; j++)
            {
                if (board[i][j] == 'X')
                {
                    //战舰只能水平或垂直分布，自诩找战舰的头部（或尾部）中间的甲板不计数
                    if (i &gt; 0 &amp;&amp; board[i - 1][j] == 'X' ||j&gt;0&amp;&amp;board[i][j-1]=='X')
                        continue;
                    res++;                        
                }
            }
        }
        return res;
    }
</code></pre>
<p><strong>509：斐波那契数列</strong><br>
public int Fib(int n)<br>
{<br>
if (n &lt; 2) return n == 1 ? 1 : 0;</p>
<pre><code>        int sum = Fib(n - 1) + Fib(n - 2);
        return sum;
    }
</code></pre>
<p><strong>70：爬楼梯</strong>-<br>
public int NumWays2(int n)<br>
{<br>
if (n &lt; 2) return 1;</p>
<pre><code>        int[] res = new int[n + 1];
        res[1] = 1;
        res[2] = 2;
        for (int i = 3; i &lt;= n; i++)
        {
            res[i] = res[i - 1] + res[i - 2];
        }
        return res[n];
    }
</code></pre>
<p><strong>//80：删除有序数组中的重复项:每个元素最多出现两次</strong><br>
public int RemoveDuplicates(int[] nums)<br>
{<br>
/*int n = nums.Length;<br>
if (n &lt;= 2) return n;<br>
int slow = 2,fast =2;<br>
while(fast&lt;n)<br>
{<br>
if(nums[slow-2]!=nums[fast])<br>
{<br>
nums[slow] = nums[fast];<br>
slow++;<br>
}<br>
fast++;<br>
}<br>
return slow; */</p>
<pre><code>        int i = 0;
        foreach (int n in nums)
            if (i &lt; 2 || n &gt; nums[i - 2])//覆盖重复的第三的元素
                nums[i++] = n;
        return i;
    }
</code></pre>
<p><strong>LC148:链表排序</strong><br>
public ListNode SortList(ListNode head)<br>
{<br>
if (head == null||head.next==null) return head;<br>
//1:使用数组排序后输出<br>
/*List<int> reslist = new List<int>();</p>
<pre><code>        while(head!=null)
        {
            reslist.Add(head.val);
            head = head.next;
        }

        reslist.Sort((a, b) =&gt; a &lt; b ? -1 : 1);
        ListNode p = new ListNode();
        ListNode newhead = new ListNode(reslist[0]);
        p.next = newhead;
        for (int i = 1; i &lt; reslist.Count; i++)
        {
            newhead.next = new ListNode();
            newhead.next.val = reslist[i];
            newhead = newhead.next;
        }
        return p.next;*/

        //2.归并排序，递归，快慢指针
        //快慢指针将链表分成两部分
        ListNode fast = head.next;
        ListNode slow = head;
        while(fast!=null&amp;&amp;fast.next!=null)
        {
            slow = slow.next;
            fast = fast.next.next;
        }
        ListNode temp = slow.next;
        slow.next = null;
        //对两部分进行递归排序，分为一个节点时返回
        ListNode left = SortList(head);
        ListNode right = SortList(temp);
        //对比两部分大小，小的排在前面
        ListNode h = new ListNode();
        ListNode res = h;
        while(left!=null&amp;&amp;right!=null)
        {
            if (left.val &lt; right.val)
            {
                h.next = left;
                left = left.next;
            }
            else
            {
                h.next = right;
                right = right.next;
            }
            h = h.next;
        }
        h.next = left == null ? right : left;
        return res.next;    
    }
//LC560:给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。
    public int SubarraySum(int[] nums, int k)
    {
        int count = 0;
        for (int start = 0; start &lt; nums.Length; start++)
        {
            int sum = 0;
            for (int end = start; end &gt;= 0; end--)//从start开始计算之前所有元素的和，出现结果等于k则连续子数组和=k的个数加一
            {
                sum += nums[end];
                if (sum == k)
                    count++;
            }
        }
        return count;
    }</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Grass交互]]></title>
        <id>https://Wei715547.github.io/post/grass-jiao-hu/</id>
        <link href="https://Wei715547.github.io/post/grass-jiao-hu/">
        </link>
        <updated>2021-03-21T13:28:37.000Z</updated>
        <content type="html"><![CDATA[<p><a href = "https://www.bilibili.com/video/BV1kv411r7x2?p=3">视频</a><br>
色位置脚本<br>
private void Update()<br>
{<br>
grassMateral.SetVector(&quot;_PlayerPos&quot;, this.transform.position + Vector3.up * 0.5f);<br>
}<br>
<strong>————————————————————</strong><br>
Shader &quot;Unlit/Grass+Wind+Cashing&quot;<br>
{<br>
Properties<br>
{<br>
[HDR]_GrassColor(&quot;GrassColor&quot;, Color) = (1,1,1,1)          //控制草的颜色<br>
_SpecualarColor(&quot;SpecularColor&quot;, Color) = (1,1,1,1)          //控制草的高光颜色<br>
_Specular(&quot;_Specular&quot;, Range(0, 1)) = 1          //控制草的高光程度<br>
_Gloss(&quot;Gloss&quot;, Range(0,20)) = 1          //控制草的高光<br>
[HDR]_FresnelColor(&quot;FresnelColor&quot;, Color) = (1,1,1,1)          //控制草的边缘高光颜色<br>
_FresnelPower(&quot;FresnelPower&quot;, Range(0, 5)) = 1          //控制草的边缘高光程度<br>
_MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}          //草的颜色贴图<br>
_AlphaTex(&quot;AlphaTexture&quot;, 2D) = &quot;white&quot; {}          //草的透明贴图<br>
_GrassHeight(&quot;GrassHeight&quot;, Range(0.5, 5)) = 2.5          //控制草的高度<br>
_GrassWidth(&quot;GrassWidth&quot;, Range(0.001, 0.5)) = 0.05          //控制草的宽度<br>
_BladeForward(&quot;BladeForward&quot;, Range(0, 2)) = 1          //控制草的弯曲程度</p>
<pre><code>	_WindTex(&quot;WindTex&quot;, 2D) = &quot;white&quot; {}          //风的采样贴图
    _WindVector(&quot;WindVector&quot;, Vector) = (1,1,1,0)          //控制风的方向
    _WindTimeScale(&quot;WindTimeScale&quot;, float) = 1          //控制风的速度
    _WindTexMapSize(&quot;WindTexMapSize&quot;, float) = 80          //控制风的采样贴图大小
    _WindXZStrength(&quot;WindXZStrength&quot;, float) = 10          //控制风在草的XZ轴上的偏移
    _WindYStrength(&quot;WindYStrength&quot;, float) = 10          //控制风在草的Y轴上的偏移          */

	//交互
	_InteracRadius(&quot;InteracRadius&quot;,Range(0.5,20))=1
	_InteracStrength(&quot;InteracStrength&quot;,Range(0.5,20))=1
}

SubShader
{
    //存在顶点动画，所以要关闭批处理，DisableBatching 设置为 True
    Tags {
        &quot;RenderType&quot; = &quot;TransparentCutout&quot;
        &quot;IgnoreProjector&quot; = &quot;True&quot;
        &quot;Queue&quot; = &quot;AlphaTest&quot;
        &quot;DisableBatching&quot; = &quot;True&quot;
    }

    //设置为双面渲染，关闭背面剔除
    Cull Off
    LOD 100

    Pass
    {
        //设置为前向渲染模式
        Tags { &quot;LightMode&quot; = &quot;ForwardBase&quot; }
        Cull Off
        AlphaToMask On

        CGPROGRAM
        //引入头文件
        #include &quot;UnityCG.cginc&quot;
        #include &quot;Lighting.cginc&quot;
        #include &quot;AutoLight.cginc&quot;

        //要应用几何着色器必须要将编译目标设置为 4.0 
        #pragma target 4.0
        #pragma multi_compile_fwdbase
        #pragma vertex vert
        #pragma fragment frag
        //定义几何着色器
        #pragma geometry geom
		
        fixed4 _GrassColor;
        fixed4 _SpecualarColor;
        fixed _Specular;
        float _Gloss;
        fixed4 _FresnelColor;
        half _FresnelPower;
        sampler2D _MainTex;
        float4 _MainTex_ST;
        sampler2D _AlphaTex;
        fixed _GrassHeight;
        fixed _GrassWidth;
		fixed _BladeForward;

		sampler2D _WindTex;
        float4 _WindTex_ST;
        half4 _WindVector;
        half _WindTimeScale;
        float _WindTexMapSize;
        half _WindXZStrength;
        half _WindYStrength;

		float4 _PlayerPos;
		half _InteracRadius;
		half _InteracStrength;

        struct a2v {
            float4 pos : POSITION;
            float3 normal : NORMAL;
            float2 uv : TEXCOORD0;
        };

        //顶点着色器传给几何着色器的数据结构
        struct v2g {
            float4 pos : POSITION;
            float3 normal : NORMAL;
            float2 uv : TEXCOORD0;
        };

        //几何着色器传给片元着色器的数据结构
        struct g2f {
            float4 pos : SV_POSITION;
            float3 normal : NORMAL;
            float2 uv : TEXCOORD0;
            float3 worldPos : TEXCOORD1;
        };

		static const float oscillateDelta = 0.05;

        //顶点着色器
        //直接将从网格得到的数据传给传入几何着色器的结构体 v2g
        v2g vert(a2v v) {
            v2g o;
            o.pos = v.pos;
            o.normal = v.normal;
            o.uv = v.uv;
            return o;
        }

        //创建 CreatG2fOut() 函数
        //初始化从几何着色器传入片元着色器的结构体 g2f
        g2f CreatG2fOut() {
            g2f output;
            output.pos = float4(0, 0, 0, 0);
            output.normal = float3(0, 0, 0);
            output.uv = float2(0, 0);
            output.worldPos = float3(0, 0, 0);
            return output;
        }

        g2f GetVertex(float4 pos, float3 normal, float2 uv) {
            g2f output;

            output.pos = UnityObjectToClipPos(pos);    
            output.normal = UnityObjectToWorldNormal(normal);
            output.uv = uv;
            output.worldPos = UnityObjectToWorldDir(pos);

            return output;
        }

        //几何着色器
        [maxvertexcount(30)]//限制几何着色器输出的最大顶点数目。每当输入一个图元，几何着色器可以输出 0~N 个图元。不论是什么结构的图元都是由顶点构成的，而这个语句就是用来限制输出最大的顶点数量（只要小于等于这个数量就可以，多余的顶点会被剔除）
        void geom(point v2g points[1], inout TriangleStream&lt;g2f&gt; triStream) {

            //顶点着色器输入的顶点位置
            float4 root = points[0].pos;

            //生成一个伪随机数
            float random = sin(UNITY_HALF_PI * frac(root.x) + UNITY_HALF_PI * frac(root.z));
            //给每根草的长宽加上这个随机值，我们希望草的宽度不要太宽或者太窄
            _GrassWidth = _GrassWidth + (random / 50);
            _GrassHeight = _GrassHeight + (random / 5);

            //设置草的网格顶点一共有12个
            const int vertexCount = 12;

            //创建12个 g2f 输出数组
            g2f v[vertexCount] = {
                CreatG2fOut(), CreatG2fOut(), CreatG2fOut(), CreatG2fOut(),
                CreatG2fOut(), CreatG2fOut(), CreatG2fOut(), CreatG2fOut(),
                CreatG2fOut(), CreatG2fOut(), CreatG2fOut(), CreatG2fOut()
            };

            //初始化每个顶点的位置 pos 和 uv
            float4 pos = float4(0, 0, 0, 0);
            float2 uv = float2(0, 0);

            //顶点的 UV 在竖直方向上的当前值和偏移值
            float currentV = 0;
            float offsetV = 1.0 / (vertexCount / 2 - 1);

            //顶点的 y 坐标在竖直方向上的当前值的偏移值
            float currentVertexHeight = 0;
            float currentHeightOffset = 0;
            float verticalEff = 0;
			
			//BlendCood
			//让草绕着自身的 y 轴进行旋转
            //生成一个随机角度
            fixed randomAngle = frac(sin(root.x)*10000.0) * UNITY_HALF_PI;

            //根据矩阵旋转的定理，分别创建旋转矩阵
            //平移矩阵，先将所有点平移到原点
            float4x4 firstTransformMatrix = float4x4(
                1.0, 0.0, 0.0, -root.x,
                0.0, 1.0, 0.0, -root.y,
                0.0, 0.0, 1.0, -root.z,
                0.0, 0.0, 0.0, 1.0
                );

            //旋转矩阵
            float4x4 rotateMatrix = float4x4(
                cos(randomAngle), 0, sin(randomAngle), 0,
                0, 1, 0, 0,
                -sin(randomAngle), 0, cos(randomAngle), 0,
                0, 0, 0, 1
                );

            //再平移回去
            float4x4 lastTransformMatrix = float4x4(
                1.0, 0.0, 0.0, root.x,
                0.0, 1.0, 0.0, root.y,
                0.0, 0.0, 1.0, root.z,
                0.0, 0.0, 0.0, 1.0
                );
				//BlendCood

            //进行生成全部草顶点的循环
            for (int i = 0; i &lt; vertexCount; i++)
            {
                //fmod(a,b) 返回 a 除 b 的余数
                //如果返回值为偶数，顶点 UV 坐标均为(0,V)
                if (fmod(i, 2) == 0) {
                    pos = float4(root.x - _GrassWidth, root.y + currentVertexHeight, root.z, 1);
                    uv = fixed2(0, currentV) * _MainTex_ST.xy + _MainTex_ST.zw;
                }
                else {
                    pos = float4(root.x + _GrassWidth, root.y + currentVertexHeight, root.z, 1);
                    uv = fixed2(1, currentV) * _MainTex_ST.xy + _MainTex_ST.zw;

                    currentV += offsetV;
                    currentVertexHeight += currentV * _GrassHeight;
                }
				 //对顶点 XZ 轴进行偏移
                float2 randomDir = float2(sin((random * 15)), sin((random * 10)));
                float2 forward = (sin((root.x * 10 + root.z / 5) * random)* verticalEff + randomDir * sin((random * 15)))* verticalEff;
                pos.xz += forward * _BladeForward;
                if (fmod(i, 2) == 1) {
                    verticalEff += offsetV;
                }

                //对顶点 Y 轴进行旋转
                //pos = mul(lastTransformMatrix, mul(rotateMatrix, mul(firstTransformMatrix, pos)));

                 //对顶点 Y 轴进行旋转
                pos = mul(lastTransformMatrix, mul(rotateMatrix, mul(firstTransformMatrix, pos)));
				
				//交互
				//--与玩家的交互
				float3 worldPos = mul(unity_ObjectToWorld, pos).xyz;
                //每根草的顶点与玩家的距离
                float3 dis = distance(_PlayerPos, worldPos);
                //将这段距离由进到远的范围缩小为 0~1
                float3 circle = 1 - saturate(dis / _InteracRadius);
                //每根草的顶点倒下的方向
                float3 dir = normalize(worldPos - _PlayerPos);
                float3 strength = dir * circle;
                //XZ 轴上的移动
                pos.xz += strength * _InteracStrength * uv.y;
                //Y 轴上的移动
                float2 InterOffsetXZ = strength * _InteracStrength * uv.y;
                pos.y -= pos.y - sqrt(pos.y * pos.y - (InterOffsetXZ.x * InterOffsetXZ.x + InterOffsetXZ.y * InterOffsetXZ.y));
				
				/*/风随机偏移
				float2 wind = float2(sin(_Time.x * UNITY_PI * 5), sin(_Time.x * UNITY_PI * 5));
				wind.x += (sin(_Time.x + root.x / 25) + sin((_Time.x + root.x / 15) + 50)) * 0.5;
				wind.y += cos(_Time.x + root.z / 80);
				wind *= lerp(0.7, 1.0, 1.0 - random);

				float oscillationStrength = 2.5f;
				float sinSkewCoeff = random;
				float lerpCoeff = (sin(oscillationStrength * _Time.x + sinSkewCoeff) + 1.0) / 2;
				float2 leftWindBound = wind * (1.0 - oscillateDelta);
				float2 rightWindBound = wind * (1.0 + oscillateDelta);

				wind = lerp(leftWindBound, rightWindBound, lerpCoeff);

				float randomAngle = lerp(-UNITY_PI, UNITY_PI, random);
				float randomMagnitude = lerp(0, 1., random);
				float2 randomWindDir = float2(sin(randomAngle), cos(randomAngle));
				wind += randomWindDir * randomMagnitude;

				float windForce = length(wind);

				pos.xz += wind.xy * verticalEff;
				pos.y -= windForce * verticalEff * 0.8;

				pos = UnityObjectToClipPos(pos);

				if (fmod(i, 2) == 1) {

					verticalEff += offsetV;
				}*/
                //--风
                //将世界坐标下的风的方向转化为局部坐标
                float4 localWindDir = normalize(mul(unity_WorldToObject, _WindVector));
                //控制风速（实际上为采样 uv 的移动速度）
                float time = (_Time.y)*(_WindTimeScale);
                //对风贴图进行采样
                half4 rootWorldPos = mul(unity_ObjectToWorld, root);
                //windmutation 一直在 0~1 之间变化 
                float windmutation = 1 - tex2Dlod(_WindTex, float4(rootWorldPos.x / _WindTexMapSize + time, rootWorldPos.z / _WindTexMapSize, 0, 0)).g;
                //sin(time + windmutation * 10) * cos(time * 2 / 3 + 1 + windmutation * 10) -1~1
                //localWindDir.xz 控制风的方向
                //clamp(uv.y - 0.1, 0, 1) UV.y 范围在 0.1 以下的顶点不发生移动 
                //xz 轴上的偏移
                half2 xzOffset = sin(time + windmutation * 10) * cos(time * 2 / 3 + 1 + windmutation * 10) * localWindDir.xz * clamp(uv.y - 0.1, 0, 1);
                pos.xz += xzOffset * _WindXZStrength;
                //根据 XZ 轴上的偏移算出在 Y 轴上
                //直角三角形定理
                //Y轴的偏移
                half yOffset = pos.y - sqrt(pos.y * pos.y - (xzOffset.x * xzOffset.x + xzOffset.y * xzOffset.y));
                pos.y -= yOffset * _WindYStrength * clamp(uv.y - 0.35, 0, 1);
				
                //pos.xz += sin(_Time.y * _WindTimeScale) * uv.y;

                v[i] = GetVertex(pos, points[0].normal, uv);


            }

            //inout TriangleStream&lt;g2f&gt; triStream 输出三角形，即三个顶点数据
            //将每三个顶点转化为三角形输出到片元着色器
            for (int p = 0; p &lt; (vertexCount - 2); p++)
            {
                //triStream.Append(vertex); 该方法将输入的三个顶点自动构建成三角形
                triStream.Append(v[p]);
                triStream.Append(v[p + 2]);
                triStream.Append(v[p + 1]);
            }
        }

        //片元着色器
        //简单的 Blin-Phong 光照模型
        float4 frag(g2f i) : SV_Target{

            //对_MainTex纹理和_AlphaTex纹理进行采样
            fixed4 texColor = tex2D(_MainTex, i.uv);
            fixed alpha = tex2D(_AlphaTex, i.uv).a;

            //将法线归一化
            float3 worldNormal = normalize(i.normal);
            float3 worldSpecNormal = worldNormal;
            worldNormal = worldNormal * 0.5 + 0.5;

            //得到环境光
            fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;
            //得到世界空间下光照方向
            fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));

            //Diffuse 漫反射颜色
            fixed NdotL = saturate(dot(worldNormal, worldLightDir));
            fixed3 diffuse = _LightColor0.rgb * NdotL;

            //Specular 高光颜色
            //得到世界空间下的视线方向
            fixed3 worldViewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));
            //得到半角向量
            fixed3 halfDir = normalize(worldLightDir + worldViewDir);
            fixed3 NdotH = saturate(dot(worldSpecNormal, halfDir));
            float spec = pow(NdotH, _Specular * 128.0) * _Gloss;
            fixed3 specular = _SpecualarColor * _LightColor0.rgb * spec;

            //Fresnel
            fixed fresnel = saturate(1 - dot(worldSpecNormal, worldViewDir));
            //fresnel = clamp(fresnel - 0.2, 0, 1);
            fresnel = pow(fresnel, _FresnelPower) * clamp(i.uv.y - 0.5, 0, i.uv.y);
            fixed3 fresnelColor =	 fresnel * _FresnelColor;

            //得到并输出最终颜色
            fixed3 finalColor = ambient + diffuse + specular;
            return fixed4(texColor * _GrassColor.rgb * finalColor, alpha);
            //return fixed4(worldNormal, alpha);
        }
        ENDCG
    }
}
FallBack &quot;Diffuse&quot;
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[渲染管线]]></title>
        <id>https://Wei715547.github.io/post/xuan-ran-guan-xian/</id>
        <link href="https://Wei715547.github.io/post/xuan-ran-guan-xian/">
        </link>
        <updated>2021-03-19T07:04:00.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://Wei715547.github.io/post-images/1617077796123.jpg" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1616211232568.png" alt="" loading="lazy"><br>
<a href = "https://b23.tv/BV1L54y1s7xw/p2">渲染管线参考视频</a><br>
一、应用程序:-准备基本场景数据-加速算法粗粒度剔除-设置渲染状态-调用DrawCall输出渲染图元到显存<br>
1.基本场景数据包括：物体位置/网格；光源信息类型/位置（设置阴影逐光源绘制阴影贴图）；相机参数<br>
2.加速算法粗粒度剔除：可见光裁剪；可见场景裁剪（八叉树，BSP/K——D树，BVH）<br>
3.渲染设置：绘制设置（使用着色器，合批方式）；绘制物体顺序（相对摄像机距离，渲染队列，UI设置）渲染目标（输出到帧缓存或渲染贴图）；渲染模式（前项渲染/延迟渲染）<br>
/*<br>
1.CPU将数据加载到显存：顶点位置信息，法线方向，顶点颜色，uv坐标<br>
2.设置渲染状态：使用哪个顶点着色器，片元着色器，光源属性材质等<br>
3.调用Draw Call：由CPU发起命令GPU渲染图像。指向一个需要被渲染的图元列表(以传入显存中)。<br>
*/<br>
二、几何阶段：顶点着色器-曲面细分着色器-几何着色器-投影-裁剪-屏幕映射<br>
其中曲面，几何着色器可选分别用于细分图元，着色或产生新图元（网格细分/粒子点生成新图元）。。最后屏幕映射，将顶点坐标转换到屏幕坐标系中。<br>
顶点着色器：将顶点坐标从模型空间转换到齐次裁剪空间<br>
如：v2f.pos = UnityObjectToClipPos(a2v.pos);  或  mul(UNITY_MVP, a2v.pos)//通过MVP矩阵转换得到齐次裁剪坐标，<br>
投影：再由硬件做透视除法，得到设备坐标NDC（OpenGL中z分量[-1,1]，DX中[0,1]）。<br>
裁剪：CVV剔除视平面外的顶点，正面/背面剔除可配置<br>
屏幕映射：将每个图元的x,y坐标（不对z进行操作）转换到屏幕坐标系下/OpenGL从左下到右上，DX从左上到右下，实际上屏幕坐标系与z坐标组成窗口坐标系，这些值一起被传递到光栅化阶段。</p>
<p>三、光栅化阶段：三角形设置-三角形遍历-片元着色器-逐片元操作（计算每个图元覆盖了那些像素，计算着些像素的颜色）<br>
三角形设置：计算光栅化一个三角形所需的信息<br>
三角形遍历：检查每个像素是否被一个三角形覆盖，如果都被一个三角形所覆盖，就会生成一个片元。同时也会根据三个顶点信息对所覆盖的像素的深度插值计算。这一阶段也称扫描变换。即输出是一系列片元序列（包含很多状态集合：屏幕坐标，深度信息及顶点信息）。（抗锯齿MSAA：1.SSAA：渲染到放大n倍的buffer然后对其采样。2.MSAA：只有此方式在光栅化阶段，计算多个覆盖样本。3.FXAA/TXAA：后处理技术不再此阶段）<br>
片元着色器：颜色插值，纹理采样（此时的片元并不是真正意义上的像素）<br>
逐片元操作(输出合并阶段)：主要进行片元可见性判断和颜色混合<br>
透明测试：有时会与提前测试发生冲突。API:clip(tex.r-_Cutoff);<br>
模板测试：（蒙版/遮罩）<br>
<a href="https://b23.tv/BV1NJ41167Ec">参考视频</a><br>
<img src="https://Wei715547.github.io/post-images/1616214031623.jpg" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1616214040771.jpg" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1616214048833.jpg" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1616214055096.jpg" alt="" loading="lazy"><br>
深度测试：（可以指定是否开启深度测试与深度写入）与深度缓冲区中的值进行对比，小于深度缓冲中的值(更近)时有权利是否写入Z-Buffer。（Early-Z提前执行）<br>
合并：得到的目标颜色根据是否进行混合，半透明物体-与颜色缓冲区中的颜色值进行混合得到新颜色，或直接覆盖原颜色缓冲区中的颜色。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Blender材质节点(更新ing)]]></title>
        <id>https://Wei715547.github.io/post/blender-cai-zhi-jie-dian/</id>
        <link href="https://Wei715547.github.io/post/blender-cai-zhi-jie-dian/">
        </link>
        <updated>2021-01-23T05:35:19.000Z</updated>
        <content type="html"><![CDATA[<p><strong>一、输入</strong><br>
<strong>1.物体信息</strong><br>
位置：模型中心到世界原点的距离<br>
颜色：物体属性中视图显示中的物体颜色与材质无关<br>
物体编号<br>
材质编号<br>
随机：物体生成时随机产生的0~1之间的值<br>
变化不同位置产生颜色变化示例<br>
<img src="https://Wei715547.github.io/post-images/1611381548318.PNG" alt="" loading="lazy"><br>
<strong>2.属性</strong>：可获取顶点颜色<br>
<img src="https://Wei715547.github.io/post-images/1611383219732.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1611383224559.PNG" alt="" loading="lazy"><br>
<strong>3.倒角</strong>：Cycles适用，在视图显示中产生倒角效果（使用连接至着色器法相）<br>
<strong>4.顶点颜色</strong>：低点颜色与Alpha通道，多用于遮罩<br>
<img src="https://Wei715547.github.io/post-images/1611466142579.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1611466149778.PNG" alt="" loading="lazy"><br>
<strong>6.黑体节点</strong>：色温黑体辐射K，可用于Cycles光源色温标准输出，自发光物体发光颜色<br>
<img src="https://Wei715547.github.io/post-images/1611475715838.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1611477570439.PNG" alt="" loading="lazy"><br>
<strong>7.波长</strong><br>
<img src="https://Wei715547.github.io/post-images/1611479151358.PNG" alt="" loading="lazy"><br>
<strong>8.映射</strong>：纹理空间在模型面上的投影，包括，位置旋转缩放<br>
类型：点，先计算缩放然后旋转位置<br>
纹理，先计算位置然后旋转缩放<br>
矢量，不计算位置<br>
法向，归一化后的矢量<br>
<img src="https://Wei715547.github.io/post-images/1611808408345.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1611808414557.PNG" alt="" loading="lazy"><br>
<strong>9.矢量变换</strong>：对矢量(点包含位置)进行不同空间坐标系下的转换：物体、世界、相机(屏幕剪切空间)<br>
<img src="https://Wei715547.github.io/post-images/1611833642696.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1611841772393.PNG" alt="" loading="lazy"><br>
<strong>10.钳制</strong>：对数值范围进行限制<br>
<img src="https://Wei715547.github.io/post-images/1611890049132.PNG" alt="" loading="lazy"><br>
<strong>11.映射范围</strong>：从a,b映射到c,d。包含：线性，阶梯，平滑等插值类型<br>
<img src="https://Wei715547.github.io/post-images/1611892237631.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1611892245272.PNG" alt="" loading="lazy"><br>
<strong>12.透明着色器</strong><br>
<img src="https://Wei715547.github.io/post-images/1611893692097.PNG" alt="" loading="lazy"><br>
<strong>13.线框</strong>显示网格线框<br>
<img src="https://Wei715547.github.io/post-images/1611978489940.PNG" alt="" loading="lazy"><br>
<strong>14.白噪波纹理</strong>：随机值生成1-4D<br>
<img src="https://Wei715547.github.io/post-images/1611981742064.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1611981746778.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1611981752413.PNG" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[卡通Shader]]></title>
        <id>https://Wei715547.github.io/post/qia-tong-shader/</id>
        <link href="https://Wei715547.github.io/post/qia-tong-shader/">
        </link>
        <updated>2021-01-22T15:02:01.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://Wei715547.github.io/post-images/1611328235122.PNG" alt="" loading="lazy"><br>
//渐变纹理贴图与梯度渐变函数，<br>
//轮廓线使用法线与视线点乘。</p>
<p>Shader &quot;Shader103.5/Rimlight&quot;<br>
{<br>
Properties<br>
{<br>
_MainTex(&quot;Base texture&quot;, 2D) = &quot;white&quot; {}<br>
_RampTex(&quot;Ramp texture&quot;, 2D) = &quot;white&quot; {}</p>
<pre><code>	_AmbientStrength(&quot;Ambient Strength&quot;,Range(0,1.0)) = 0.1
	_DiffStrength(&quot;Diff Strength&quot;,Range(0,1.0)) = 0.1
	_SpecStrength(&quot;Spec Strength&quot;,Range(0,5.0)) = 0.1
	_RimStrength(&quot;Rim Strength&quot;,Range(0,1.0)) = 0.1
	_RimAmount(&quot;Rim Amount&quot;,Range(0,1.0)) = 0.1

	_SpecPow(&quot;Specular Pow&quot;,int) = 0.5
	_Brightness(&quot;Brightness&quot;,Range(0,1.0)) = 0.5
	_TintColor(&quot;Tint Color&quot;,Color) = (1.0,1.0,1.0,1.0)
	_OutlineAmount(&quot;OutlineAmount&quot;,Range(0,1.0)) = 0.1
	_OutlineColor(&quot;OutlineColor&quot;,Color) = (0,0,0,0)
}

SubShader
{
	Tags
	{
		&quot;LightMode&quot; = &quot;ForwardBase&quot;
		&quot;PassFlags&quot; = &quot;OnlyDirectional&quot;
	}
	Pass
	{
		CGPROGRAM
		#pragma vertex vert
		#pragma fragment frag
		#include &quot;UnityLightingCommon.cginc&quot; // for _LightColor0
		#include &quot;UnityCG.cginc&quot;

		struct appdata
		{
			float4 vertex : POSITION;
			float3 normal : NORMAL;
			float2 uv: TEXCOORD0;
		};

		struct v2f
		{
			float4 vertex : SV_POSITION;
			float3 normal : NORMAL;
			float2 uv: TEXCOORD0;
			float3 viewDir : TEXCOORD1;
		};

		v2f vert(appdata v)
		{
			v2f o;
			o.uv = v.uv;
			o.vertex = UnityObjectToClipPos(v.vertex);
			o.normal = UnityObjectToWorldNormal(v.normal);
			o.viewDir = normalize(_WorldSpaceCameraPos.xyz - mul(unity_ObjectToWorld, v.vertex).xyz);
			return o;
		}

		sampler2D _MainTex;
		sampler2D _RampTex;

		float _AmbientStrength;
		float _SpecStrength;
		float _DiffStrength;
		float _RimStrength;
		float _RimAmount;

		float4 _TintColor;
		float4 _RimColor;
		float _SpecPow;
		float _Brightness;
		float _OutlineAmount;
		float4 _OutlineColor;

		float4 frag(v2f i) : SV_Target
		{
			float4 baseColor = tex2D(_MainTex, i.uv) ;
			float3 normal = normalize(i.normal);
			//ambient
			float3 ambient = _LightColor0 * _AmbientStrength;

			//diffuse
			float NdotL = dot(i.normal, _WorldSpaceLightPos0);
			float2 uv = float2((NdotL * 0.5 + 0.5), 0);
			float3 ramp = tex2D(_RampTex, uv);

			//float3 diff = (NdotL &lt; 0) ? 0 : 1 * _LightColor0 * _DiffStrength;
			// 把(NdotL &lt; 0) ? 0 : 1 改成ramp 如果需要用自己的texture
			float diff =  _LightColor0 * _DiffStrength*ramp;

			//specular
			float3 reflectDir = reflect(-_WorldSpaceLightPos0, normal);
			float spec = pow(max(dot(i.viewDir, reflectDir), 0.0), _SpecPow);
			float3 specSmooth = smoothstep(0.005, 0.01, spec) * _LightColor0 * _SpecStrength;

			//rimlight
			float NdotV = 1 - dot(i.normal, i.viewDir);
			float rimSmooth = max(0,NdotL) * smoothstep(_RimAmount - 0.01, _RimAmount + 0.01, NdotV) ;
			float3 rimlight = rimSmooth * _LightColor0 * _RimStrength;

			////Solid color outline
			float4 final_color;
			if (NdotV &lt; _OutlineAmount) {
				final_color = float4((diff + ambient + specSmooth + rimlight), 1.0) * _Brightness * baseColor * _TintColor;
			}
			else {
				final_color = _OutlineColor;
			}

			//final color
			//float4 final_color = float4((diff + ambient+ specSmooth + rimlight),1.0) * _Brightness * baseColor * _TintColor;
			
			return final_color;
		}
		ENDCG
	}
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leet Code持续更新（1）]]></title>
        <id>https://Wei715547.github.io/post/leet-code1~500-chi-xu-geng-xin/</id>
        <link href="https://Wei715547.github.io/post/leet-code1~500-chi-xu-geng-xin/">
        </link>
        <updated>2021-01-02T12:12:34.000Z</updated>
        <content type="html"><![CDATA[<p><a href ="https://leetcode-cn.com/problemset/all/"><strong>LeetCode题库</strong></a><br>
<strong>C#二维数组/参差数组定义</strong><br>
//C#数组-额理性未赋值为初始自int-0;bool-false;引用-null<br>
int[] array = new int[10];<br>
int[] array2 = new int[3] { 1,2,3 };<br>
//2、二维数组<br>
int[,] mar = new int[3, 3];<br>
int[,] mar2 = new int[3, 3] { {1,2,3},{ 4,5,6},{ 7,8,9} };<br>
//3、参差数组<br>
//两行，第一行两列，第二行三列的参差数组<br>
int[][] cc = new int[2][];//先定义两行<br>
cc[0] = new int[2] { 2, 2 };//在定义每行列数<br>
cc[1] = new int[3] { 3, 3, 3 };<br>
<strong>-------------------------------------------------</strong><br>
<strong>排序查找算法、冒泡/选择/插入/快排/二分查找</strong><br>
/// <summary><br>
/// 冒泡排序<br>
/// </summary><br>
/// <param name="array"></param><br>
public static void BubbleSort(int [] nums)<br>
{<br>
for (int i = 0; i &lt; nums.Length; i++)<br>
{<br>
for (int j = 0; j &lt; nums.Length-1-i; j++)<br>
{<br>
if (nums[j] &gt; nums[j + 1])<br>
Swap(ref nums[j], ref nums[j + 1]);<br>
}<br>
}<br>
}<br>
/// <summary><br>
/// 选择排序：默认第一个为最小值，在后面找到更小的时就和默认最小的交换。再默认第二个为最小往下循环。<br>
/// </summary><br>
/// <param name="array"></param><br>
static void ChooseSort(int[] array)<br>
{<br>
for (int i = 0; i &lt; array.Length-1; i++)<br>
{<br>
int minnum = array[i];<br>
int minindex = i;<br>
for (int j = i+1; j &lt; array.Length; j++)<br>
{<br>
if(array[j]&lt;minnum)<br>
{<br>
minnum = array[j];<br>
minindex = j;<br>
}<br>
}<br>
if(minindex!=i)<br>
{<br>
int temp = array[i];<br>
array[i] = minnum;<br>
array[minindex] = temp;<br>
}<br>
}<br>
}<br>
/// <summary><br>
/// 直插排序<br>
/// </summary><br>
/// <param name="array"></param><br>
public static void InsertSort2(int[] nums)<br>
{<br>
int index, value;<br>
for (int i = 1; i &lt; nums.Length; i++)<br>
{<br>
value = nums[i];<br>
index = i-1;<br>
while(index&gt;=0&amp;&amp;nums[index]&gt;value)<br>
{<br>
nums[index+1] = nums[index];<br>
index -= 1;<br>
}<br>
nums[index+1] = value;<br>
}<br>
}<br>
//快速排序<br>
static void Qsort(int[] array,int left,int right)<br>
{<br>
if(left&lt;right)<br>
{<br>
int i = left;<br>
int j = right + 1;<br>
int provt = array[i];<br>
do<br>
{<br>
do i++; while (array[i] &lt; provt &amp;&amp; i &lt; array.Length-1);<br>
do j--; while (array[j] &gt; provt &amp;&amp; j &gt;= 0);<br>
if(i&lt;j)<br>
{<br>
Swap(ref array[i], ref array[j]);<br>
}<br>
} while (i&lt;j);<br>
Swap(ref array[left], ref array[j]);<br>
Qsort(array, left, j - 1);<br>
Qsort(array, j + 1, right);<br>
}<br>
}<br>
//二分查找<br>
static int BinarySearch_R(int[] dateArray, int x, int left, int right)<br>
{<br>
if (left &lt;= right)<br>
{<br>
int mind = (left + right) / 2;<br>
if (x &lt; dateArray[mind])<br>
return BinarySearch_R(dateArray, x, left, mind - 1);<br>
else if (x &gt; dateArray[mind])<br>
return BinarySearch_R(dateArray, x, mind + 1, right);<br>
else if (x == dateArray[mind])<br>
return mind;<br>
}<br>
return -1;<br>
}<br>
<strong>225.队列实现栈-</strong><br>
using System;<br>
using System.Collections.Generic;<br>
using System.Text;</p>
<p>namespace LeetCode复习<br>
{<br>
class MyStack<br>
{<br>
/*#region 双队列实现<br>
Queue<int> q1;<br>
Queue<int> q2;<br>
public MyStack()<br>
{<br>
q1 = new Queue<int>();//入队<br>
q2 = new Queue<int>();//中间队<br>
}</p>
<pre><code>    public void Push(int n)//入栈时直接压入入队
    {
        q1.Enqueue(n);
    }

    public int Pop()//弹出时将入队中的元素弹如中间队，只留下最后进入的-弹出元素，
    {
        if (q1.Count == 1)
            return q1.Dequeue();
        else
        {
            while (q1.Count != 1)
                q2.Enqueue(q1.Dequeue());                
        }
        int temp = q1.Dequeue();
        while (q2.Count != 0)
            q1.Enqueue(q2.Dequeue());
        return temp;
    }
    public int Top()//直接使用弹出，在压入入队
    {
        int temp = Pop();
        q1.Enqueue(temp);
        return temp;
    }

    public bool Empty()//元素全部存在入队中
    {
        return q1.Count == 0;
    }
    #endregion*/
    #region 单队列实现

    Queue&lt;int&gt; QueueInput = new Queue&lt;int&gt;();
    /** Push element x onto stack. */
    public void Push(int x)//压入后，对队列进行移动，将新进入的元素移动到队首
    {
        
         QueueInput.Enqueue(x);

         for (int i = 0; i &lt; QueueInput.Count - 1; ++i)//将新入队的数移动N-1次后队列最前端
         {
             QueueInput.Enqueue(QueueInput.Dequeue());
         }
    }            
    /** Removes the element on top of the stack and returns that element. */
    public int Pop()
    {
        return QueueInput.Dequeue();

    }

    /** Get the top element. */
    public int Top()
    {
        return QueueInput.Peek();
    }

    /** Returns whether the stack is empty. */
    public bool Empty()
    {
        return QueueInput.Count == 0;
    }
    
    #endregion

}
</code></pre>
<p>}<br>
<strong>232.栈实现队列</strong><br>
using System;<br>
using System.Collections.Generic;<br>
using System.Text;</p>
<p>namespace LeetCode复习<br>
{<br>
class MyQueue<br>
{<br>
Stack<int> a;<br>
Stack<int> b;</p>
<pre><code>    /** Initialize your data structure here. */
    public MyQueue()
    {
        a = new Stack&lt;int&gt;();//压入入栈
        b = new Stack&lt;int&gt;();//弹出栈
    }

    /** Push element x to the back of queue. */
    public void Push(int x)//压入直接存入a
    {
        a.Push(x);
    }

    /** Removes the element from in front of queue and returns that element. */
    public int Pop()//a全部弹出压入b得到的b即与a排序相反，通过b弹出即实现队列
    {
        if(b.Count==0)
        {
            while (a.Count != 0)
                b.Push(a.Pop());                    
        }
        return b.Pop();
    }

    /** Get the front element. */
    public int Peek()//
    {
        if(b.Count == 0)
        {
            while (a.Count != 0)
                b.Push(a.Pop());
        }
        return b.Peek();
    }

    /** Returns whether the queue is empty. */
    public bool Empty()
    {
        return a.Count == 0 &amp;&amp; b.Count == 0;
    }
}
</code></pre>
<p>}</p>
<p><strong>/// 三数之和</strong><br>
public static List&lt;List<int>&gt; ThreeSum(int[] nums)<br>
{<br>
List&lt;List<int>&gt; res = new List&lt;List<int>&gt;();//返回值<br>
Array.Sort<int>(nums);//对数组进行排序<br>
if (nums == null || nums[0] &gt;= 0 || nums.Length &lt; 3) return res;//数组为空，排序后最小值大于0，长度小于3，则没有结果返回空列表<br>
for (int i = 0; i &lt; nums.Length-2; i++)//外部总循环次数小于长度减2，由于包含satrt与end两个位置指针<br>
{<br>
if(i<mark>0||nums[i]!=nums[i-1])//首次循环或不重复时执行<br>
{<br>
int start = i + 1;//左指针较小的值，结果小于0时右移<br>
int end = nums.Length - 1;//右指针较大的值，结果大于0时向左移<br>
while(start&lt;end)//内循环左指针小于右指针<br>
{<br>
if (nums[i] + nums[start] + nums[end] == 0)//满足条件将结果加入返回列表<br>
{<br>
res.Add(new List<int> { nums[i], nums[start], nums[end] });<br>
start++;//左指针右移<br>
end--;//右指针左移//寻找其他满足条件的组合<br>
while (start &lt; end &amp;&amp; nums[start] == nums[start - 1])//保证不与之前的值重复<br>
start++;<br>
while (start &lt; end &amp;&amp; nums[end] == nums[end + 1])//保证不与之前的值重复<br>
end--;<br>
}else if(nums[i] + nums[start] + nums[end]&lt;0)//小于0，start右移到更大的数<br>
{<br>
start++;<br>
}else//大于0，end左移到更小的数<br>
{<br>
end--;<br>
}<br>
}<br>
}<br>
}<br>
return res;<br>
}<br>
/// <summary><br>
** /// 19:删除链表d第n个节点**<br>
/// </summary><br>
/// <param name="head"></param><br>
/// <param name="n"></param><br>
/// <returns></returns><br>
public ListNode RemoveNthFromEnd(ListNode head, int n)<br>
{<br>
if (head == null || head.next == null) return null;<br>
ListNode dummy = new ListNode();<br>
dummy.next = head;<br>
ListNode l = dummy;<br>
ListNode r = dummy;<br>
for (int i = 0; i &lt; n; i++)<br>
{<br>
r = r.next;<br>
}<br>
while(r.next!=null)<br>
{<br>
l = l.next;<br>
r = r.next;<br>
}<br>
l.next = l.next.next;<br>
return dummy.next;<br>
}<br>
<strong>20.有效括号(B站面试题)</strong><br>
/// <summary><br>
/// 有效括号<br>
/// </summary><br>
class LeetCode20<br>
{<br>
public static bool IsValid(string s)<br>
{<br>
Stack<char> st = new Stack<char>();<br>
foreach (char c in s)<br>
{<br>
if(c</mark>'('||c=='['||c=='{')<br>
{<br>
st.Push(c);<br>
}else<br>
{<br>
if (st.Count == 0)<br>
return false;<br>
else<br>
{<br>
char temp = st.Pop();<br>
if (c == ')')<br>
{<br>
if (temp != '(')<br>
return false;<br>
}<br>
else if (c == ']')<br>
{<br>
if (temp != '[')<br>
return false;<br>
}<br>
else if (c == '}')<br>
{<br>
if (temp != '{')<br>
return false;<br>
}<br>
}<br>
}<br>
}<br>
return st.Count == 0;<br>
}<br>
}<br>
/// <summary><br>
/// 移除元素：给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。<br>
/// </summary><br>
class LC27<br>
{<br>
//将与val相等的值都移动到数组最右边，<br>
public static int RemoveEle(int [] nums,int value)<br>
{<br>
if (nums == null || nums.Length == 0)<br>
return 0;<br>
int l = 0;<br>
int r = nums.Length - 1;<br>
while(l&lt;r)<br>
{<br>
while(l&lt;r&amp;&amp;nums[l]!=value)//左指针找与val相等的值<br>
{<br>
l++;<br>
}<br>
while(l&lt;r&amp;&amp;nums[r]==value)//右指针找与val不相等的值<br>
{<br>
r--;<br>
}<br>
int temp = nums[l];<br>
nums[l] = nums[r];<br>
nums[r] = temp;<br>
}<br>
return nums[l] == value ? l : l + 1;//最后一个与val相等的值先被左指针找到，左指针位置的索引即移除val后的，前面元素的长度(数组从0开始)。<br>
最后与val相等的值先被右指针找到，则l指向的即是不重复元素的中一个元素，数组索引值比实际长度小1，即返回l+1<br>
}<br>
}<br>
<strong>————————————————————————————————————</strong><br>
<strong>48.旋转图像</strong><br>
class LC48<br>
{<br>
public static void rotate(int[][] matrix)<br>
{<br>
int n = matrix[0].Length;<br>
if (n == 0 || n == 1) return;</p>
<pre><code>        for (int start = 0, end = n - 1; start &lt; end; start++, end--)
        { //控制旋转层数（不断缩小圈的范围）
            int s = start; int e = end;
            while (s &lt; end)
            { //完成一圈的旋转
                int temp = matrix[start][s]; //temp&lt;-左上角值
                matrix[start][s] = matrix[e][start]; //左上角&lt;-左下角
                matrix[e][start] = matrix[end][e];  //左下角&lt;-右下角
                matrix[end][e] = matrix[s][end];  //右下角&lt;-右上角
                matrix[s][end] = temp; //右上角&lt;-temp
                s++; e--; //向右平移该层的圈
            }
        }
    }
}
</code></pre>
<p><strong>————————————————————————————————————</strong><br>
<strong>49.字母异为词分组</strong><br>
class LC49<br>
{<br>
public static List&lt;List<string>&gt; GroupAnagrams(string[] strs)<br>
{<br>
//可变字符串：存储排序后的字符数组转为字符串<br>
StringBuilder key = new StringBuilder();<br>
//字典：键：排序后相同的字符(串有相同字符组成)，值：由相同字符组成的字符串数组<br>
Dictionary&lt;string, List<string>&gt; strsGroupDict = new Dictionary&lt;string, List<string>&gt;();<br>
//遍历字符串数组中每个字符串<br>
foreach (string s in strs)<br>
{<br>
char[] temp = s.ToCharArray();//字符串转为字符数组，用于排序<br>
Array.Sort(temp);//调用数组类静态排序方法<br>
key.Clear();//添加前先请空可变字符串<br>
foreach (char c in temp)//将字符数组的每个字符添加到可变字符串<br>
{<br>
key.Append(c);<br>
}<br>
if (!strsGroupDict.ContainsKey(key.ToString()))//判断字典的键中是否包含此排序后的字符串<br>
{<br>
//不包含则新建键值对，键：此排序后的字符串，值：新建字符串可变数组(存储由相同字符组成的字符串)<br>
strsGroupDict.Add(key.ToString(), new List<string>());<br>
}<br>
//创建后/或已经存在键的情况下，将当前字符添加到可变数组中<br>
strsGroupDict[key.ToString()].Add(s);<br>
}<br>
return new List&lt;List<string>&gt;(strsGroupDict.Values);//返回数组类表，即字典的所有值<br>
}<br>
}<br>
<strong>//LC3无重复最长子串</strong><br>
public int LengthOfLongestSubstring(string s)<br>
{<br>
if (s == null || s.Length == 0) return 0;<br>
int res = 0;<br>
int l = 0;<br>
HashSet<char> set = new HashSet<char>();<br>
for (int i = 0; i &lt; s.Length; i++)<br>
{<br>
if (!set.Contains(s[i]))<br>
{<br>
set.Add(s[i]);<br>
res = Math.Max(res, set.Count);<br>
}<br>
else//包含时，顺序移除字符串中的字符直至不重复，加入集合<br>
{<br>
while (set.Contains(s[i]))<br>
{<br>
set.Remove(s[l]);<br>
l += 1;<br>
}<br>
set.Add(s[i]);<br>
}<br>
}<br>
return res;<br>
}<br>
<strong>//LC4：两有序数组中位数</strong><br>
public static double FindMedianSortedArrays(int[] nums1, int[] nums2)<br>
{<br>
if (nums1.Length == 0 &amp;&amp; nums2.Length == 0) return (double)0;<br>
List<int> res = new List<int>(nums1);<br>
double mid;<br>
foreach (int n in nums2)<br>
res.Add(n);<br>
res.Sort();<br>
if (res.Count % 2 == 1)<br>
mid = res[res.Count / 2];<br>
else<br>
{<br>
mid = (double)(res[res.Count / 2] + res[res.Count / 2 - 1]) / 2;<br>
}<br>
return mid;<br>
}<br>
<strong>LC53.最大子数组和</strong><br>
/// <summary><br>
/// 给定一个整数数组 nums ，<br>
/// 找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>
/// </summary><br>
class LC53最大子数组和<br>
{<br>
public int MaxSubArray(int[] nums)<br>
{<br>
if (nums == null || nums.Length == 0)<br>
return 0;</p>
<pre><code>        int res = nums[0];
        int sum = 0;
        foreach (int n in nums)
        {
            if (sum &gt; 0)//都为正数时所有元素和即为最大
                sum += n;//连续数相加的最大值，小于0时说明有负数加入，
            else//都为负数时即得到最大的负数
                sum = n;//出现和小于0有负数加入，找到下一个从正数开始的元素
            res = Math.Max(res, sum);//每次填入一个数时会取res，sum最大的值
        }
        return res;
    }
}
/// &lt;summary&gt;
    /// 动态规划
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;nums&quot;&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public static int Maxsubarray2(int[] nums)
    {
        List&lt;int&gt; memolist = new List&lt;int&gt;();//动态规划列表
        memolist.Add(nums[0]);
        for (int i = 1; i &lt; nums.Length; i++)            
            memolist.Add(Math.Max(nums[i] + memolist[i - 1], nums[i]));//判断当前元素计入子数组和后，与当前元素值比较，取大值决定计入总和还是从当前开始
        memolist.Sort((a, b) =&gt; a &gt; b?-1:1);//取动态规划数组中的最大值返回，避免首位就值最大
        return memolist[0];
    }
</code></pre>
<p><strong>70.爬楼梯(青蛙跳台阶)</strong>//动态规划/类似斐波那数列-LC509<br>
public class Solution {<br>
public int NumWays(int n) {<br>
if (n &lt; 2) return 1;</p>
<pre><code>        int[] res = new int[n];
        res[0] = 1;
        res[1] = 2;
        for (int i = 2; i &lt; n; i++)
        {
            res[i] = (res[i - 1] + res[i - 2]);//%1000000007;要求取余时
        }
        return res[n - 1];
        //索引对应形式
        int[] res = new int[n + 1];
        res[1] = 1;
        res[2] = 2;
        for (int i = 3; i &lt;= n; i++)
        {
            res[i] = res[i - 1] + res[i - 2];
        }
        return res[n];
}
</code></pre>
<p>}<br>
<strong>//128.最长连续序列</strong><br>
public static int LongestConsecutive(int[] nums)<br>
{<br>
if (nums == null || nums.Length == 0) return 0;</p>
<pre><code>        Array.Sort(nums);//排序后去重
        HashSet&lt;int&gt; set = new HashSet&lt;int&gt;();//使用集合不要求在原数组中连续
        for (int i = 0; i &lt; nums.Length; i++)
        {
            set.Add(nums[i]);
        }

        List&lt;int&gt; reslist = new List&lt;int&gt;();//结果列表，长度即为返回值
        int res = 1;//数组长度大于0则至少返回1；
        foreach (int n in set)
        {
            if (reslist.Count!=0 &amp;&amp; reslist[reslist.Count - 1] + 1 == n)//不为空且连续时，计入返回列表
            {
                reslist.Add(n);
                res = Math.Max(res, reslist.Count);//取返回列表长度最大值
            }
            else
            {
                reslist.Clear();//不连续时清空，重新计入
                reslist.Add(n);
            }
        }
        return res;
    }
</code></pre>
<p><strong>//134.加油站</strong><br>
public int CanCompleteCircuit(int[] gas, int[] cost)<br>
{<br>
int allgas = 0;<br>
int allcast = 0;<br>
for (int i = 0; i &lt; gas.Length; i++)<br>
{<br>
allgas += gas[i];<br>
allcast += cost[i];<br>
}<br>
if (allgas &lt; allcast) return -1;<br>
int gascurten = 0;<br>
int start = 0;<br>
for (int i = 0; i &lt; gas.Length; i++)<br>
{<br>
gascurten = gascurten + gas[i] - cost[i];<br>
if (gascurten &lt; 0)<br>
{<br>
gascurten = 0;<br>
start = i + 1;<br>
}<br>
}<br>
return start;<br>
}<br>
<strong>//152.乘积最大子数组</strong><br>
public static int MaxSubProduct(int[]nums)<br>
{<br>
List<int> memomax = new List<int>();<br>
List<int> memomin = new List<int>();<br>
memomax.Add(nums[0]);<br>
memomin.Add(nums[0]);<br>
for (int i = 1; i &lt; nums.Length; i++)<br>
{<br>
memomax.Add(Math.Max(Math.Max(nums[i]*memomax[i - 1], nums[i]*memomin[i-1]), nums[i]));<br>
memomin.Add(Math.Min( Math.Min(nums[i] * memomin[i - 1],nums[i]*memomax[i-1]), nums[i]));<br>
}<br>
memomax.Sort();<br>
return memomax[memomax.Count - 1];<br>
}<br>
<strong>// 153. 寻找旋转排序数组中的最小值</strong><br>
:假设按照升序排序的数组在预先未知的某个点上进行了旋转。例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] 。<br>
public int FindMin(int[] nums)<br>
{<br>
//长度为1或未旋转时返回首位<br>
if (nums.Length == 1 || nums[nums.Length - 1] &gt; nums[0]) return nums[0];<br>
//二分查找<br>
int left = 0;<br>
int right = nums.Length - 1;</p>
<pre><code>        while(left&lt;right)
        {
            int mid = left + (right - left) / 2;//中间值索引

            if (nums[mid] &gt; nums[mid + 1])//中间值恰好为旋转前的末尾最大值，则mid+1即为最小值
                return nums[mid + 1];
            else if (nums[mid] &lt; nums[mid - 1])//中间值恰好指向旋转前的最小值，则返回m
                return nums[mid];
            else if (nums[mid] &gt; nums[left])//其他情况mid落在旋转后的两端数组中间时
                left = mid + 1;//mid比left大则落在左半边，最小值在右边
            else
                right = mid - 1;//mid比left小则落在右半边，最小值在左边
        }
        return nums[0];//语法条件返回值无意义
    }
</code></pre>
<p><strong>class LC54螺旋矩阵</strong><br>
{<br>
public List<int> SpiralOrder(int[][] matrix)<br>
{<br>
if (matrix == null || matrix.Length == 0) return new List<int>();</p>
<pre><code>        //数组边界值
        int top = 0,left = 0;
        int bottom = matrix.Length - 1, right = matrix[0].Length - 1;

        int direction = 1;//1,2,3,4：右下左上
        List&lt;int&gt; res = new List&lt;int&gt;();
        while (left &lt;= right &amp;&amp; top &lt;= bottom)
        {
            switch (direction)
            {
                case 1://右移
                        for (int i = left; i &lt;= right; i++)//从左到右遍历
                            res.Add(matrix[top][i]);//第一行从左到右加入返回列表
                        top += 1;//第一行遍历结束加一到下一行
                        direction = 2;
                    break;
                case 2://下移
                        for (int i = top; i &lt;= bottom; i++)//从上到下遍历
                            res.Add(matrix[i][right]);//最后一列从上到下
                        right -= 1;//左后一列遍历后减1，下次遍历前一列
                        direction = 3;
                    break;
                case 3://左移
                        for (int i = right; i &gt;=left ; i--)//从右到左遍历
                            res.Add(matrix[bottom][i]);//最后一行从右到左遍历
                        bottom -= 1;//遍历结束，下次从右到左遍历上一行
                        direction = 4;
                    break;
                case 4://上移
                        for (int i = bottom; i &gt;=top ; i--)//从下到上遍历
                            res.Add(matrix[i][left]);//第一列从下到上遍历，
                        left += 1;//下次从下到上遍历下一列
                        direction = 1;
                    break;
            }
        }
        return res;
    }
}
</code></pre>
<p>** // 55.跳跃游戏** ,贪心算法：maxjunp初始为最大索引，当前一个索引与此数组索引值相加大于maxump时则一定可以到达maxjump,maxjump一道前一个索引位置，最后判断maxjump是否等于0则返回true否则说明中间断开返回false<br>
public bool Jump(int [] nums)<br>
{<br>
int maxjump = nums.Length;<br>
for (int i = nums.Length-2; i &gt;=0 ; i--)<br>
{<br>
if (i + nums[i] &gt;= maxjump)<br>
maxjump = i;<br>
}<br>
return maxjump == 0 ? true : false;<br>
}</p>
<p><strong>class LC62不同路径</strong><br>
{<br>
/// <summary><br>
/// 动态规划，dp[m,n] = dp[m-1,n]+dp[m,n-1];<br>
/// </summary><br>
/// <param name="m"></param><br>
/// <param name="n"></param><br>
/// <returns></returns><br>
public int UniquePaths(int m, int n)<br>
{<br>
int[,] dp = new int[m,n];<br>
dp[0,0] = 1;<br>
for (int i = 0; i &lt; m; i++)<br>
{<br>
for (int j = 0; j &lt; n; j++)<br>
{<br>
if (i - 1 &gt;= 0 &amp;&amp; i - 1 &lt; m)<br>
dp[i, j] += dp[i - 1,j];<br>
if (j - 1 &gt;= 0 &amp;&amp; j - 1 &lt; n)<br>
dp[i, j] += dp[i, j - 1];<br>
}<br>
}<br>
return dp[m - 1, n - 1];</p>
<pre><code>    }
}
public int UniquePath2(int m, int n)
    {
        int[,] dp = new int[m, n];
        for (int i = 0; i &lt; m; i++)
            dp[i, 0] = 1;
        for (int i = 0; i &lt; n; i++)
            dp[0, n] = 1;
        for (int i = 1; i &lt; m; i++)
        {
            for (int j = 1; j &lt; n; j++)
            {
                dp[i, j] = dp[i, j - 1] + dp[i - 1, j];
            }
        }
        return dp[m - 1, n - 1];
    }
</code></pre>
<p><strong>66.加一</strong><br>
public int[] PlusOne(int[] digits)<br>
{<br>
for (int i = digits.Length - 1; i &gt;= 0; i--)<br>
{<br>
if (digits[i] != 9)<br>
{<br>
digits[i] += 1;<br>
return digits;<br>
}<br>
else<br>
digits[i] = 0;<br>
}<br>
List<int> res = new List<int>(digits);<br>
res.Insert(0, 1);<br>
return res.ToArray();<br>
}<br>
<strong>70.爬楼梯</strong><br>
public int ClimbStairs(int n)<br>
{<br>
if (n &lt; 2) return 1;<br>
int[] res = new int[n];<br>
res[0] = 1;<br>
res[1] = 2;<br>
for (int i = 2; i &lt; n; i++)<br>
{<br>
res[i] = res[i - 1] + res[i - 2];<br>
}<br>
return res[n - 1];<br>
}<br>
<strong>//73,矩阵置0</strong><br>
public void SetZeroes(int[][] matrix)<br>
{<br>
bool firstoColContentZero = false;<br>
bool firstoRowContentZero = false;<br>
//检测第一列是否有0<br>
for (int i = 0; i &lt; matrix.Length; i++)<br>
{<br>
if (matrix[i][0] == 0)<br>
firstoColContentZero = true;<br>
}<br>
//检查第一行是否有0<br>
for (int i = 0; i &lt; matrix[0].Length; i++)<br>
{<br>
if (matrix[0][i] == 0)<br>
firstoRowContentZero = true;<br>
}<br>
//使用第一行与第一列标记0<br>
for (int i = 1; i &lt; matrix.Length; i++)<br>
{<br>
for (int j = 1; j &lt; matrix[0].Length; j++)<br>
{<br>
if(matrix[i][j]==0)<br>
{<br>
matrix[i][0] = 0;<br>
matrix[0][j] = 0;<br>
}<br>
}<br>
}<br>
//使用第一行列中的0处理矩阵中的元素<br>
for (int i = 1; i &lt; matrix.Length; i++)<br>
{<br>
for (int j = 1; j &lt; matrix[0].Length; j++)<br>
{<br>
if (matrix[i][0] == 0 || matrix[0][j] == 0)<br>
matrix[i][j] = 0;<br>
}<br>
}<br>
//首行存在0，本行全部置为0<br>
if(firstoRowContentZero)<br>
{<br>
for (int i = 0; i &lt; matrix[0].Length; i++)<br>
{<br>
matrix[0][i] = 0;<br>
}<br>
}<br>
//首列存在0，本列全部置为0<br>
if(firstoColContentZero)<br>
{<br>
for (int i = 0; i &lt; matrix.Length; i++)<br>
{<br>
matrix[i][0] = 0;<br>
}<br>
}<br>
}<br>
<strong>//83.删除链表重复元素</strong><br>
public ListNode DeleteDuplicates(ListNode head)<br>
{<br>
if (head == null) return head;<br>
HashSet<int> set = new HashSet<int>();<br>
ListNode res = new ListNode();<br>
res.next = head;<br>
ListNode pov = new ListNode();<br>
pov.next = head;<br>
while (head != null)<br>
{<br>
if (!set.Contains(head.val))<br>
{<br>
set.Add(head.val);<br>
head = head.next;<br>
pov = pov.next;<br>
}<br>
else<br>
{<br>
pov.next = head.next;<br>
head = head.next;<br>
}<br>
}<br>
return res.next;<br>
}<br>
//链表为排好序的链表<br>
public ListNode DeleteDuplicates2(ListNode head)<br>
{<br>
if (head == null || head.next == null) return head;<br>
ListNode res = new ListNode();<br>
res.next = head;<br>
while (head != null &amp;&amp; head.next != null)<br>
{<br>
if (head.val == head.next.val)<br>
{<br>
head.next = head.next.next;<br>
}<br>
else<br>
head = head.next;<br>
}<br>
return res.next;<br>
}<br>
<strong>class LC74搜索矩阵</strong><br>
{<br>
/// <summary><br>
/// 二分法，一维，二维数组索引转换<br>
/// </summary><br>
/// <param name="matrix"></param><br>
/// <param name="target"></param><br>
/// <returns></returns><br>
public bool SearchMatrix(int[][] matrix, int target)<br>
{<br>
if (matrix == null || matrix.Length == 0) return false;</p>
<pre><code>        int row = matrix.Length;
        int col = matrix[0].Length;
        int l = 0;
        int r = row * col - 1;
        while(l&lt;=r)
        {
            int mid = l + (r - l) / 2;
            int ele = matrix[mid / col][mid % col];//一维索引二维
            if (ele == target)
                return true;
            else if (ele &gt; target)
                r = mid;
            else
                l = mid + 1;
        }
        return false;
    }
}
</code></pre>
<p><strong>————————————————————————————————————</strong><br>
<strong>78/90.子集</strong><br>
/// <summary><br>
/// 子集<br>
/// </summary><br>
class LC78<br>
{<br>
/// <summary><br>
/// SubsetI<br>
/// </summary><br>
/// <param name="nums"></param><br>
/// <returns></returns><br>
public static List&lt;List<int>&gt; Subset(int[] nums)<br>
{<br>
List&lt;List<int>&gt; res = new List&lt;List<int>&gt;();<br>
res.Add(new List<int> { });<br>
foreach (int  n in nums)<br>
{<br>
int resLength = res.Count;<br>
for (int i = 0; i &lt; resLength; i++)<br>
{<br>
List<int> cur = new List<int>(res[i]);<br>
cur.Add(n);<br>
res.Add(cur);<br>
}<br>
}<br>
return res;<br>
}<br>
/// <summary><br>
/// SubsetII<br>
/// </summary><br>
/// <param name="nums"></param><br>
/// <returns></returns><br>
public static List&lt;List<int >&gt; SubsetsWithDup(int [] nums)<br>
{<br>
List&lt;List<int>&gt; res = new List&lt;List<int>&gt;();<br>
res.Add(new List<int> {});<br>
Array.Sort<int>(nums);<br>
foreach (int n in nums)<br>
{<br>
int resLength = res.Count;<br>
for (int i = 0; i &lt; resLength; i++)<br>
{<br>
List<int> cur = new List<int>(res[i]);<br>
cur.Add(n);<br>
res.Add(cur);<br>
}<br>
}<br>
List&lt;List<int>&gt; resLast = new List&lt;List<int>&gt;();</p>
<pre><code>        foreach (List&lt;int&gt; list in res)
        {
            if (!Contants(resLast, list))
            {
                resLast.Add(list);
            }
        }
        return resLast;

    }
    public static bool Contants(List&lt;List&lt;int&gt;&gt; res,List&lt;int&gt; slist)
    {
        if (res.Count == 0) return false;
        bool conts = false;
        foreach (var item in res)
        {
            if (CpList(item, slist))
                conts = true;
        }
        return conts;
    }

    public static bool CpList(List&lt;int&gt; l1,List&lt;int&gt; l2)
    {
        bool res = true;
        if (l1.Count != l2.Count)
            return false;
        else
        {                
            for (int i = 0; i &lt; l1.Count; i++)
            {
                if (l1[i] != l2[i])
                    res = false;
            }
        }

        return res;
    }
}
</code></pre>
<p><strong>//121.买股票的最佳时机</strong><br>
public int MaxProfit(int[] prices)<br>
{<br>
if (prices == null || prices.Length == 0) return 0;<br>
int minp = prices[0];<br>
int maxp = 0;<br>
for (int i = 1; i &lt; prices.Length; i++)<br>
{<br>
if (prices[i] &lt; minp)<br>
minp = prices[i];<br>
else if (prices[i] - minp &gt; maxp)<br>
maxp = prices[i] - minp;<br>
}<br>
return maxp;<br>
}<br>
<strong>//122.买股票的最佳时机II</strong><br>
public static int MaxProfitII(int[] prices)<br>
{<br>
if (prices == null || prices.Length == 0) return 0;</p>
<pre><code>        int allprice = 0;
        int lop = prices[0], top = prices[0];
        int i = 0;
        while(i&lt;prices.Length-1)
        {
            while (i&lt;prices.Length-1 &amp;&amp; prices[i] &gt;= prices[i + 1])
                i += 1;
            lop = i;
            while (i &lt; prices.Length - 1 &amp;&amp; prices[i] &lt; prices[i + 1])
                i += 1;
            top = i;
            allprice += prices[top] - prices[lop];
        }
        return allprice;
    }
</code></pre>
<p><strong>class _141环形链表</strong><br>
{<br>
public bool HasCycle(ListNode head)<br>
{<br>
if (head == null || head.next == null)<br>
{<br>
return false;<br>
}</p>
<pre><code>        ListNode slow = head;
        ListNode fast = head.next;
        while (slow != fast)
        {
            if (fast == null || fast.next == null)
            {
                return false;
            }
            slow = slow.next;
            fast = fast.next.next;
        }
        return true;
    }
}
</code></pre>
<p><strong>//160.相交链表</strong><br>
public ListNode GetIntersectionNode(ListNode headA, ListNode headB)<br>
{<br>
if (headA == null || headB == null) return null;<br>
HashSet<ListNode> list = new HashSet<ListNode>();<br>
while(headA!=null)<br>
{<br>
list.Add(headA);<br>
headA = headA.next;<br>
}<br>
while(headB!=null)<br>
{<br>
if (!list.Contains(headB))<br>
{<br>
list.Add(headB);<br>
headB = headB.next;<br>
}<br>
else<br>
return headB;<br>
}<br>
return null;<br>
}<br>
<strong>class LC162寻找峰值</strong><br>
{<br>
/// <summary><br>
/// 峰值元素是指其值大于左右相邻值的元素。二分法<br>
/// </summary><br>
/// <param name="nums"></param><br>
/// <returns></returns><br>
public static int FindPeakElement(int[] nums)<br>
{<br>
if (nums == null || nums.Length == 0) return -1;</p>
<pre><code>        int l = 0;
        int r = nums.Length - 1;
        while (l&lt;r)
        {
            int mid = (r + l) / 2;
            //中间值右边的数小于mid则极值在左边，反之极值在右边
            if (nums[mid] &gt; nums[mid + 1])
                r = mid;
            else 
                l = mid + 1;
        }
        return l;
    }
}
</code></pre>
<p>#region 查找最大重复值<br>
//static Dictionary&lt;int, int&gt; dic = new Dictionary&lt;int, int&gt;();</p>
<pre><code>    //方法1：利用字典统计数组元素出现的次数。元素作为键，值存储数显次数。
    static int SearchMaxRepet1(int[] array)
    {
        Dictionary&lt;int, int&gt; dic = new Dictionary&lt;int, int&gt;();
        int hrefLength = array.Length / 2;

        for (int i = 0; i &lt; array.Length; i++)
        {
            if (!dic.ContainsKey(array[i]))
                dic.Add(array[i], 0);
        }

        for (int i = 0; i &lt; array.Length; i++)
        {
            dic[array[i]] += 1;
        }
        foreach (int k in dic.Keys)
        {
            if (dic[k] &gt; hrefLength)
                return k;
        }
        return -1;
    }
    //方法2：排序发，排序后重复最多的值补丁集中在数组中间。
    static int SearchMaxRepet2(int[] array)
    {
        QSort(new List&lt;int&gt;(array),0,array.Length-1);
        return array[array.Length / 2];
    }
    //分治法
    static int SearchMaxRepet3(int[] nums)
    {
        return GetMajority(nums, 0, nums.Length - 1);
    }
    /// &lt;summary&gt;
    /// 分治法，获取众数
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;nums&quot;&gt;&lt;/param&gt;
    /// &lt;param name=&quot;left&quot;&gt;&lt;/param&gt;
    /// &lt;param name=&quot;right&quot;&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    static int GetMajority(int [] nums,int left,int right)
    {
        if (left == right)//分为只有衣蛾元素时返回
            return nums[left];

        int mid = left + (right - left) / 2;//师爷咱们还是对半分
        int leftMajority = GetMajority(nums, 0, mid);//左半边的中数
        int rightMajority = GetMajority(nums, mid+1, right);//右半边的中数

        if (leftMajority == rightMajority)//左右众数相同 则返回其中任意一个
            return leftMajority;
        //不相同则，则遍历数组统计该递归层左右那边众数出现的次数多
        int leftCount = 0;
        int rightCount = 0;
        for (int i = left; i &lt;=right; i++)
        {
            if (nums[i] == leftMajority)
                leftCount++;
            else if (nums[i] == rightMajority)
                rightCount++;
        }

        return leftCount &gt; rightCount ? leftMajority : rightMajority;
    }
    #endregion
</code></pre>
<p><strong>————————————————————————————————————</strong><br>
public static string Maxnum(int[]nums)<br>
{<br>
StringBuilder snums = new StringBuilder();<br>
for (int i = 0; i &lt; nums.Length; i++)<br>
{<br>
snums.Append(nums[i]);<br>
}<br>
char[] cs = snums.ToString().ToCharArray();<br>
Array.Sort<char>(cs, (a, b) =&gt; { return b.CompareTo(a); });<br>
return string.Join(&quot;&quot;, cs);<br>
}</p>
<p><strong>179.最大数(网易面试题)</strong><br>
/// <summary><br>
///179： 给定一组非负整数 nums，重新排列它们每个数字的顺序（每个数字不可拆分）使之组成一个最大的整数。<br>
/// 用List对string进行排序<br>
/// </summary><br>
/// <param name="nums"></param><br>
/// <returns></returns><br>
public static string LargestNum2(int[] nums)<br>
{<br>
if (nums == null) return &quot;&quot;;<br>
if (nums.Length == 1) return nums[0].ToString();</p>
<pre><code>        List&lt;string&gt; numsList = new List&lt;string&gt;();
        for (int i = 0; i &lt; nums.Length; i++)
        {
            numsList.Add(nums[i].ToString());
        }                       
        numsList.Sort((a, b) =&gt; { return (b + a).CompareTo(a + b); });
    
        if (numsList[0].Equals(&quot;0&quot;)) return &quot;0&quot;;
        else return  string.Join(&quot;&quot;,numsList.ToArray());
    }
</code></pre>
<p>/// </summary><br>
///字符依次前后相加对比，结果大的放在前面<br>
/// <param name="nums"></param><br>
/// <returns></returns><br>
/// <summary><br>
<strong>179.普通方法</strong><br>
public static string LargestNum(int[] nums)<br>
{<br>
if (nums == null) return &quot;&quot;;<br>
if (nums.Length == 1) return nums[0].ToString();<br>
string[] st = new string[nums.Length];<br>
//StringBuilder s = new StringBuilder();<br>
for (int i = 0; i &lt; nums.Length; i++)<br>
{<br>
st[i] = nums[i].ToString();<br>
}<br>
for (int i = 0; i &lt; st.Length; i++)<br>
{<br>
for (int j = i+1; j &lt; st.Length; j++)<br>
{<br>
if((st[i]+st[j]).CompareTo(st[j]+st[i])&lt;0)<br>
//s1.CompareTo(s2):<br>
//s1&gt;s2: 1<br>
//s1=s2: 0<br>
//s1&lt;s2: -1<br>
{<br>
Swap(ref st[i], ref st[j]);<br>
}<br>
}<br>
}<br>
/<em>foreach (string item in st)<br>
{<br>
s.Append(item);<br>
}<br>
return s.ToString();</em>/<br>
if (nums[0].Equals(&quot;0&quot;)) return &quot;0&quot;;<br>
else return string.Join(&quot;-&quot;, st);//使用字符连接字符串数组，返回连接后的字符<br>
}<br>
<strong>187.重复的DNA序列</strong><br>
public static List<string> FindRepeatedDnaSequences2(string s)<br>
{<br>
List<string> res = new List<string>();<br>
if (s == null || s.Length &lt; 11) return res;<br>
Dictionary&lt;string, int&gt; dic = new Dictionary&lt;string, int&gt;();<br>
//StringBuilder ele = new StringBuilder();<br>
int i = 0;<br>
while(i+10&lt;=s.Length)<br>
{<br>
/<em>ele.Clear();<br>
ele.Append(s.Substring(i, 10));</em>/<br>
string ele = s.Substring(i, 10);<br>
if (!dic.ContainsKey(ele.ToString()))<br>
dic.Add(ele.ToString(), 1);<br>
else if(!res.Contains(ele))<br>
res.Add(ele.ToString());<br>
i++;<br>
}<br>
return res;<br>
}<br>
<strong>//200.岛屿数量</strong><br>
/// <summary><br>
/// 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。<br>
/// </summary><br>
/// <param name="grid"></param><br>
/// <returns> 岛屿数量，遍历二维数值，找到1后岛屿数量加1，然后深度优先DFS将与1上下左右相连的1递归变为0。之后继续遍历数组找1</returns><br>
public static int CountIsland(char[][]grid)<br>
{<br>
if (grid == null || grid.Length == 0)<br>
return 0;<br>
int row = grid.Length;<br>
int col = grid[0].Length;<br>
int count = 0;<br>
for (int i = 0; i &lt; row; i++)<br>
{<br>
for (int j = 0; j &lt; col; j++)<br>
{<br>
if (grid[i][j] == '1')<br>
{<br>
count++;<br>
DFS(grid, i, j);<br>
}<br>
}<br>
}<br>
return count;<br>
}<br>
static void DFS(char[][] grid,int i,int j)<br>
{<br>
if(i&lt;0||j&lt;0||i&gt;=grid.Length||j&gt;=grid[0].Length||grid[i][j]=='0')<br>
{<br>
return;<br>
}<br>
grid[i][j] = '0';<br>
DFS(grid, i + 1, j);<br>
DFS(grid, i - 1, j);<br>
DFS(grid, i, j + 1);<br>
DFS(grid, i, j - 1);<br>
}<br>
<strong>//695.岛屿最大面积</strong><br>
public int MaxIsLandAre(int[][]grid)<br>
{<br>
if (grid == null || grid.Length == 0)<br>
return 0;<br>
int res = 0;<br>
for (int i = 0; i &lt; grid.Length; i++)<br>
{<br>
for (int j = 0; j &lt; grid[0].Length; j++)<br>
{<br>
if(grid[i][j]==1)<br>
{<br>
int curentAre = DFS2(grid,i,j);<br>
res = Math.Max(res, curentAre);<br>
}<br>
}<br>
}<br>
return res;<br>
}<br>
public int DFS2(int[][]grid,int i,int j)<br>
{<br>
if (i &lt; 0 || j &lt; 0 || i &gt;= grid.Length || j &gt;= grid[0].Length || grid[i][j] ==0)<br>
{<br>
return 0;<br>
}<br>
grid[i][j] = 0;<br>
int are = 1;<br>
are += DFS2(grid, i + 1, j);<br>
are += DFS2(grid, i , j+1);<br>
are += DFS2(grid, i - 1, j);<br>
are += DFS2(grid, i , j-1);<br>
return are;</p>
<pre><code>    }
}
</code></pre>
<p>//219：重复元素2：数组中存在相同元素，且索引值之差绝对值之多为k(小于等于)<br>
public bool ContainsNearbyDuplicate(int[] nums, int k)<br>
{<br>
Dictionary&lt;int, int&gt; dic = new Dictionary&lt;int, int&gt;();<br>
for (int i = 0; i &lt; nums.Length; i++)<br>
{<br>
if (dic.ContainsKey(nums[i]) &amp;&amp; (i - dic[nums[i]] &lt;= k))<br>
return true;<br>
else<br>
dic[nums[i]] = i;<br>
}<br>
return false;<br>
}<br>
//198<br>
public int Rob(int[] nums)<br>
{<br>
if (nums.Length == 0) return 0;<br>
if (nums.Length == 1) return nums[0];</p>
<pre><code>        int p2 = nums[0];
        int p1 = Math.Max(nums[0], nums[1]);
        for (int i = 2; i &lt; nums.Length; i++)
        {
            int temp = Math.Max(nums[i] + p2,p1);
            p2 = p1;
            p1 = temp;
        }
        return p1;
    }
</code></pre>
<p><strong>206.反转链表</strong><br>
class LC206<br>
{<br>
public static ListNode ReversList(ListNode head)<br>
{<br>
ListNode dummy = new ListNode();<br>
dummy.next = head;<br>
while(head!=null||head.next!=null)<br>
{<br>
ListNode next = head.next;<br>
ListNode temp = dummy.next;<br>
head.next = head.next.next;<br>
dummy.next = next;<br>
next.next = temp;<br>
}<br>
return dummy.next;</p>
<pre><code>    }
    public static ListNode ReversList2(ListNode head)
    {
        if (head == null || head.next == null)
            return head;
        //返回末尾节点
        ListNode res = ReversList2(head.next);
        //节点指向反转：递归栈先入后出，先返回最后递归层的末尾节点
        head.next.next = head;
        head.next = null;

        return res;
    }
}
</code></pre>
<p><strong>————————————————————————————————————</strong><br>
/// <summary><br>
<strong>209.长度最小的子数组</strong><br>
/// 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，<br>
/// 并返回其长度。如果不存在符合条件的子数组，返回 0。<br>
/// </summary><br>
class LC209<br>
{<br>
/// <summary><br>
/// 暴力法，可能输出的值即为1~数组最大长度，长度为n时如存在连续n个数的和&gt;=s，则返回长度n<br>
/// </summary><br>
/// <param name="s"></param><br>
/// <param name="nums"></param><br>
/// <returns></returns><br>
public static int MinSubArrayLen1(int s, int[] nums)<br>
{<br>
if (nums == null || nums.Length == 0)<br>
return 0;<br>
int size = 1;<br>
while(size&lt;=nums.Length)<br>
{<br>
for (int i = 0; i &lt; nums.Length-size+1;i++)<br>
{<br>
int total = 0;<br>
for (int j = i; j &lt; i+size; j++)<br>
{<br>
total += nums[j];<br>
}<br>
if (total &gt;= s)<br>
return size;<br>
}<br>
size++;<br>
}<br>
return 0;<br>
}<br>
/// <summary><br>
/// 滑动窗口法/双指针法<br>
/// </summary><br>
/// <param name="s"></param><br>
/// <param name="nums"></param><br>
/// <returns></returns><br>
public static int MinSubArrayLen2(int s, int[] nums)<br>
{<br>
if (nums == null || nums.Length == 0)<br>
return 0;<br>
int i = 0;//左指针<br>
int j = 0;//右指针<br>
int result = nums.Length + 1;//返回结果默不可能比数组长度长，不变则不存在返回0<br>
int total = 0;//窗口内数字的和<br>
while (j&lt;nums.Length)<br>
{<br>
total += nums[j];//计算窗口内数字和<br>
j++;//右指针滑动<br>
while(total&gt;=s)//当窗口内数字和&gt;=给定值时，更新返回值取最小长度<br>
{<br>
result = Math.Min(result, j - i);</p>
<pre><code>                total -= nums[i];//左指针开始移动，
                i++;
                //和仍大于等于给定时时继续移动，小于则退出循环，移动有指针
            }
        }//j移动到末尾时循环结束
        return result == nums.Length + 1 ? 0 : result;//长度未更新则不存在返回0，更新则为最小值
    }
}
</code></pre>
<p><strong>————————————————————————————————————</strong><br>
<strong>217.重复元素</strong><br>
/// <summary><br>
/// 给定一个整数数组，判断是否存在重复元素。<br>
/// 如果任意一值在数组中出现至少两次，函数返回 true 。<br>
/// 如果数组中每个元素都不相同，则返回 false<br>
/// </summary><br>
class LC217重复元素<br>
{<br>
/// <summary><br>
/// 排序法，排序后存在两个相邻的数相同即存在重复的数<br>
/// </summary><br>
/// <param name="nums"></param><br>
/// <returns></returns><br>
public static bool ContainsDuplicate(int[] nums)<br>
{<br>
if (nums == null || nums.Length == 0)<br>
return false;<br>
Array.Sort(nums);<br>
//方式1<br>
/<em>int i = 0;<br>
int j = i + 1;<br>
while(j&lt;nums.Length)<br>
{<br>
if (nums[i] == nums[j])<br>
return true;<br>
i++;<br>
j++;<br>
}</em>/<br>
//方式2<br>
int prev = nums[0];<br>
for (int i = 1; i &lt; nums.Length; i++)<br>
{<br>
if (nums[i] == prev)<br>
return true;<br>
else<br>
prev = nums[i];<br>
}<br>
return false;<br>
}</p>
<pre><code>    /// &lt;summary&gt;
    /// Set法，集合无法添加重复的元素，
    /// 添加完成后集合长度与原数组长度不相等即存在重复的元素
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;nums&quot;&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public static bool ContainsDuplicate2(int [] nums)
    {
        HashSet&lt;int&gt; set = new HashSet&lt;int&gt;(nums);
        return nums.Length == set.Count ? false : true;
    }
    /// &lt;summary&gt;
    /// 字典法，通过字典统计各元素出现的次数，存在次数大于1,
    /// 即有值重复出现
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;nums&quot;&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public static bool ContainsDuplicate3(int[] nums)
    {
        Dictionary&lt;int, int&gt; dic = new Dictionary&lt;int, int&gt;();
        foreach (int  n in nums)
        {
            if(!dic.ContainsKey(n))
            {
                dic.Add(n, 1);
            }else
            {
                dic[n] += 1;
            }
        }
        foreach (var item in dic.Values)
        {
            if (item &gt; 1)
                return true;
        }
        return false;
    }
}
</code></pre>
<p><strong>//125.回文字符串</strong><br>
public static bool IsPalindrome(string s)<br>
{<br>
string str = Regex.Replace(s, &quot;[^A-Za-z0-9]&quot;, &quot;&quot;).ToLower();<br>
Console.WriteLine(str);<br>
char[] array = str.ToCharArray();<br>
Array.Reverse(array);<br>
return str.Equals(new string(array));<br>
}<br>
<strong>————————————————————————————————————</strong><br>
<strong>234.回文链表</strong><br>
/// <summary><br>
/// 请判断一个链表是否为回文链表。回文正反相同的，1；121；1221.<br>
/// </summary><br>
class LC234回文链表<br>
{<br>
/// <summary><br>
/// 双指针法，由于链表中不能向前移动，所以先将链表中的数，加到数组中<br>
/// 然后左右指针向中间一定进行对比<br>
/// </summary><br>
/// <param name="head"></param><br>
/// <returns></returns><br>
public static bool IsPalindrome(ListNode head)<br>
{<br>
if (head == null || head.next == null)<br>
return true;<br>
List<int> list = new List<int>();<br>
while (head != null)<br>
{<br>
list.Add(head.val);<br>
head = head.next;<br>
}<br>
int l = 0;<br>
int r = list.Count - 1;<br>
while(l&lt;r)<br>
{<br>
if (!list[l].Equals(list[r]))//Equals比较的是值==比较的是索引可能不同<br>
return false;<br>
l++;<br>
r--;<br>
}<br>
return true;<br>
}</p>
<pre><code>    /// &lt;summary&gt;
    /// 递归双指针法，全局变量指向头结点，递归到最后一个节点，
    /// 比较最后一个节点与当前p指向的头结点，不想同则返回false，相同p向后移动，返回true
    /// 回到上一层递归对比最后一个节点之前的节点，与当前p值不同则返回false，相同p继续向后移返回true
    /// 继续回到上一层递归及其没有出现不等则返回true
    /// &lt;/summary&gt;
    static ListNode p = new ListNode();
    public static bool IsPalindrome2(ListNode head)
    {
        p = head;
        return Recursion(head);
    }
    public static bool Recursion(ListNode head)
    {
        if (head == null)
            return true;
        if (!Recursion(head.next))
            return false;

        if (p.val != head.val)
            return false;
        p = p.next;
        return true;
    }
    /// &lt;summary&gt;
    /// 栈，将链表节点压入栈，弹出反序链表对比正序链表值是否一致。
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;head&quot;&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public static bool IsPalindrome3(ListNode head)
    {
        if (head == null || head.next == null)
            return true;
        ListNode temp = head;
        Stack&lt;int&gt; stack = new Stack&lt;int&gt;();
        while(temp!=null)//链表节点压入栈
        {
            stack.Push(temp.val);
            temp = temp.next;
        }
        while (head != null &amp;&amp; stack.Count != 0)//正反序对比
        {
            if (head.val != stack.Pop())
                return false;
            head = head.next;
        }
        return true;
    }
}
</code></pre>
<p><strong>238.除自身外数组的乘积</strong><br>
class LC238除自身外数组的乘积<br>
{<br>
public int[] ProductExceptSelf(int[] nums)<br>
{<br>
int[] res = new int[nums.Length];</p>
<pre><code>        int pr = 1;
        for (int i = 0; i &lt; nums.Length; i++)
        {
            res[i] = pr;//返回数组保存除当前索引值外左边所有元素的乘积  
            pr *= nums[i];
        }
        pr = 1;
        for (int i = nums.Length-1; i &gt;=0; i--)
        {
            res[i] *= pr;//返回数组当前索引值(即除自身外所有元素乘积=左边所有元素乘积*右边所有元素乘积)
            pr *= nums[i];
        }
        return res;


    }
}
</code></pre>
<p><strong>———————————————————————————————————————</strong><br>
<strong>268丢失的数字</strong><br>
/// <summary><br>
/// 给定一个包含 [0, n] 中 n 个数的数组 nums ，<br>
/// 找出 [0, n] 这个范围内没有出现在数组中的那个数。<br>
/// </summary><br>
class LC268丢失的数字<br>
{<br>
/// <summary><br>
/// 排序法 [0,n]，排序后数组与索引值不相等即，缺失索引位置的值<br>
/// </summary><br>
/// <param name="nums"></param><br>
/// <returns></returns><br>
public int MissingNumber(int[] nums)<br>
{<br>
Array.Sort(nums);<br>
for (int i = 0; i &lt; nums.Length; i++)<br>
{<br>
if (i != nums[i])<br>
return i;<br>
}<br>
return nums.Length;<br>
}<br>
/// <summary><br>
/// 集合法，加入集合后，直接遍历判断集合不包含[0,n]中的那个值，<br>
/// </summary><br>
/// <param name="nums"></param><br>
/// <returns></returns><br>
public static int MissingNumber2(int[] nums)<br>
{<br>
HashSet<int> set = new HashSet<int>();<br>
foreach (int  n in nums)<br>
set.Add(n);<br>
for (int i = 0; i &lt; nums.Length; i++)<br>
{<br>
if (!set.Contains(i))<br>
return i;<br>
}<br>
return nums.Length;<br>
}<br>
/// <summary><br>
/// 数学法，[0,n]之和为“n*(n+1)/2“减去数组之和即为等于缺失的数值<br>
/// </summary><br>
/// <param name="nums"></param><br>
/// <returns></returns><br>
public int MissingNumber3(int[] nums)<br>
{<br>
int sum = 0;<br>
for (int i = 0; i &lt; nums.Length; i++)<br>
{<br>
sum += nums[i];<br>
}<br>
return (nums.Length * (nums.Length + 1)) / 2 - sum;<br>
}<br>
}<br>
<strong>class LC283移动0</strong><br>
{<br>
public static void MoveZeroes(int [] nums)<br>
{<br>
int index = 0;<br>
for (int i = 0; i &lt; nums.Length; i++)//遍历数组将不为0的数放在前面<br>
{<br>
if(nums[i]!=0)<br>
{<br>
nums[index] = nums[i];<br>
index++;<br>
}<br>
}<br>
//以上遍历完成后index后面的元素都应该是0<br>
for (int i = index; i &lt; nums.Length; i++)<br>
{<br>
nums[i] = 0;<br>
}<br>
}<br>
}<br>
<strong>//328.奇偶链表</strong><br>
public ListNode OddEvenList(ListNode head)<br>
{<br>
if (head == null||head.next==null) return head;</p>
<pre><code>        ListNode odd = head;
        ListNode even = head.next;
        ListNode evenHead = head.next;
        while (even != null&amp;&amp;even.next!=null)
        {
            odd.next = odd.next.next;
            odd = odd.next;
            even.next = even.next.next;
            even = even.next;
        }
        odd.next = evenHead;
        return head;
    }
</code></pre>
<p><strong>344.反转字符串</strong><br>
/// <summary><br>
///系统函数<br>
/// </summary><br>
/// <param name="s"></param><br>
public void ReverseString(char[] s)<br>
{<br>
Array.Reverse<char>(s);<br>
}<br>
/// <summary><br>
/// 双指针<br>
/// </summary><br>
/// <param name="s"></param><br>
public void ReverseString2(char[] s)<br>
{<br>
if (s == null || s.Length == 0) return;</p>
<pre><code>        int l = 0;
        int r = s.Length - 1;
        while(l&lt;r)
        {
            char temp = s[l];
            s[l] = s[r];
            s[r] = temp;
            l += 1;
            r -= 1;
        }
    }
    /// &lt;summary&gt;
    /// 递归法
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;s&quot;&gt;&lt;/param&gt;
    public void ReverseString3(char[] s)
    {
        if (s == null || s.Length == 0) return;//为空或长度为0返回

        Recursion(s, 0, s.Length - 1);//递归函数

    }
    private void Recursion(char[] s,int l,int r)
    {
        if (l &gt;= r) return;//左右指针相等或相交时返回

        Recursion(s, l + 1, r - 1);//左右两端对称的字符在同一递归层中，
        //递归返回时，交换同递归层中的左右字符完成反转
        char temp = s[l];
        s[l] = s[r];
        s[r] = temp;            
    }
</code></pre>
<p><strong>class LC349相交数组</strong><br>
{<br>
public int[] Intersection(int[] nums1, int[] nums2)<br>
{<br>
List<int> res = new List<int>();<br>
if (nums1 == null || nums1 == null || nums1.Length == 0 || nums2.Length == 0) return res .ToArray();<br>
HashSet<int> set1 = new HashSet<int>(nums1);<br>
HashSet<int> set2 = new HashSet<int>(nums2);</p>
<pre><code>        foreach (var item in set1)
        {
            if (set2.Contains(item))
                res.Add(item);
        }
        return res.ToArray();            
    }        
}
</code></pre>
<p><strong>class LC485.最大连续1的个数</strong><br>
{<br>
public static int FindMaxConsecutiveOnes(int [] nums)<br>
{<br>
int res = 0;<br>
int count = 0;<br>
for (int i = 0; i &lt; nums.Length; i++)<br>
{<br>
if (nums[i] == 1)<br>
count++;<br>
else<br>
{<br>
res = Math.Max(res, count);<br>
count = 0;<br>
}<br>
}<br>
return Math.Max(res,count);<br>
}<br>
}<br>
<strong>496.下一个更大元素_I</strong><br>
/// <summary><br>
/// 给定两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。<br>
/// 找到 nums1 中每个元素在 nums2 中的下一个比其大的值。<br>
/// 输入: nums1 = [4,1,2], nums2 = [1,3,4,2].<br>
/// 输出: [-1,3,-1]<br>
/// </summary><br>
class LC496下一个更大元素_I<br>
{<br>
public int[] NextGreaterElement(int[] nums1, int[] nums2)<br>
{<br>
List<int> res = new List<int>();<br>
Stack<int> stack = new Stack<int>();//nums2栈<br>
for (int i = 0; i &lt; nums2.Length; i++)//nums2装入栈中<br>
{<br>
stack.Push(nums2[i]);<br>
}</p>
<pre><code>        foreach (int n in nums1)//遍历数组1
        {
            Stack&lt;int&gt; temp = new Stack&lt;int&gt;();//临时栈，储存nums2弹出的元素
            bool isFind = false;//默认是否在nums2中找到nums1中的目标值
            int max = -1;//默认右边未找到比n大的值
            while(stack.Count!=0&amp;&amp;!isFind)//nums2不为空并且还2未找到n，进入循环
            {
                int top = stack.Pop();//栈顶元素(最右边的元素)
                if (top &gt; n)//弹出值比目标n大，更新最大值
                    max = top;
                else if (top == n)//与n相等则找到了n
                    isFind = true;
                temp.Push(top);//临时栈中存储nums2弹出的值，最后在返回给nums2栈，保持其不变
            }                
            res.Add(max);//max加入返回数组，未更新则右边没有比n大的值，更新则max保存的即是右边第一个比n大的值
            while (temp.Count != 0)//将临时栈的元素返还给nums2栈，使其保持不变，用于选择下一个num1中比n大的值
                stack.Push(temp.Pop());
        }
        return res.ToArray();//遍历完nums1后返回结果类表转数组
    }
    
}
</code></pre>
<p><strong>class LC509斐波那契数</strong><br>
{<br>
/// <summary><br>
/// 斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。<br>
/// 该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：<br>
/// </summary><br>
/// <param name="n"></param><br>
/// <returns></returns><br>
public int Fib(int n)<br>
{<br>
if (n &lt; 2) return n == 1 ? 1 : 0;</p>
<pre><code>        int sum = Fib(n - 1) + Fib(n - 2);
        return sum;
    }
    /// &lt;summary&gt;
    /// 动态规划：
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;n&quot;&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public int Fib2(int n)
    {
        if (n &lt; 2) return n == 1 ? 1 : 0;

        int[] res = new int[n + 1];
        res[0] = 0;
        res[1] = 1;
        for (int i = 2; i &lt; res.Length; i++)
        {
            res[i] = res[i - 1] + res[i - 2];
        }
        return res[n];
    }
    //动态规划，空间复杂度优化
    public int Fib3(int n)
    {
        if (n &lt;= 1) return n;

        int prev1 = 0;
        int prev2 = 1;
        int res = 0;
        for (int i = 2; i &lt;= n; i++)
        {
            res = prev1 + prev2;
            prev1 = prev2;
            prev2 = res;
        }
        return res;
    }
}
</code></pre>
<p><strong>//680.回文字符串II,允许删除一个字符实现回文字符串</strong><br>
public static bool IsPalindrome2(string s)<br>
{<br>
int left = 0;<br>
int right = s.Length - 1;<br>
while(left&lt;right)<br>
{<br>
if(s[left]!=s[right])<br>
{<br>
return IsPs(s.Remove(left,1)) || IsPs(s.Remove(right,1));<br>
}<br>
left++;<br>
right--;<br>
}<br>
return true;<br>
}<br>
public static bool IsPs(string s)<br>
{<br>
/<em>int left = 0;<br>
int right = s.Length - 1;<br>
while (left &lt; right)<br>
{<br>
if (s[left] != s[right])<br>
{<br>
return false;<br>
}<br>
left++;<br>
right--;<br>
}<br>
return true;</em>/</p>
<pre><code>        char[] sarray = s.ToCharArray();
        Array.Reverse(sarray);

        return s.Equals(new string(sarray));
    }
</code></pre>
<p><strong>class LC720词典中最长的单词</strong><br>
{<br>
/// <summary><br>
/// 暴力法，<br>
/// </summary><br>
/// <param name="words"></param><br>
/// <returns></returns><br>
public static string LongestWord(string[] words)<br>
{<br>
//边界条件<br>
if (words == null || words.Length == 0) return &quot;&quot;;</p>
<pre><code>        string res = &quot;&quot;;//返回值
        //将字符串数组存入集合方便快速查找
        HashSet&lt;string&gt; wordset = new HashSet&lt;string&gt;(words);
        //遍历集合
        foreach (string  word in wordset)
        {
            //如果当前单词的长度大于，预存的结果。或长度相同时排序较小，这可能成为新的res
            if (word.Length &gt; res.Length||(word.Length==res.Length&amp;&amp;word.CompareTo(res)&lt;0))
            {
                bool isword = true;//默认可以是新的res
                for (int i = 0; i &lt; word.Length; i++)//遍历新word的每个word[0~i+1]顺序组合都在字典中存在
                {
                    if(!wordset.Contains(word.Substring(0,i+1)))//有不存在的则不能成为新res，退出循环
                    {
                        isword = false;
                        break;
                    }
                }
                if (isword==true)//遍历后认为true则瞒住条件
                    res = word;//替换当前res
            }                    
        }
        return res;//返回res
    }
}
</code></pre>
<p><strong>876.链表中间节点</strong><br>
//快慢指针法<br>
public ListNode MiddleNode(ListNode head)<br>
{<br>
ListNode slow = head;<br>
ListNode fast = head;<br>
while(fast!=null&amp;&amp;fast.next!=null)<br>
{<br>
slow = slow.next;<br>
fast = fast.next.next;<br>
}<br>
return slow;<br>
}<br>
<strong>881.救生艇</strong><br>
/// <summary><br>
/// 第 i 个人的体重为 people[i]，每艘船可以承载的最大重量为 limit。<br>
/// 每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。<br>
/// 返回载到每一个人所需的最小船数。(保证每个人都能被船载)。<br>
/// </summary><br>
class LC881救生艇<br>
{<br>
public int NumRescueBoats(int[] people, int limit)<br>
{<br>
if (people == null || people.Length == 0) return 0;</p>
<pre><code>        Array.Sort&lt;int&gt;(people);
        int res = 0;
        int l = 0;
        int r = people.Length - 1;
        while(l&lt;=r)
        {
            if (people[l] + people[r] &lt;= limit)
                l += 1;
            r -= 1;
            res += 1;
        }
        return res;
    }
}
</code></pre>
<p><strong>989数组形式的整数加法</strong><br>
public static List<int> AddToArrayForm(int[] A, int K)<br>
{<br>
int ans = 0;<br>
for (int i = 0; i &lt; A.Length; i++)<br>
{<br>
ans = ans * 10 + A[i];<br>
}<br>
ans += K;<br>
List<int> res = new List<int>();<br>
while(ans&gt;0)<br>
{<br>
res.Add(ans % 10);<br>
ans /= 10;<br>
}<br>
res.Reverse();<br>
return res;<br>
}<br>
<strong>——————————————————————————————————</strong><br>
<strong>class LC1456定长子串中元音最大的数目</strong><br>
{<br>
/// <summary><br>
/// 滑动窗口法<br>
/// </summary><br>
/// <param name="s"></param><br>
/// <param name="k"></param><br>
/// <returns></returns><br>
public int MaxVowels(string s, int k)<br>
{<br>
if (s == null || s.Length == 0||s.Length&lt;k) return -1;<br>
HashSet<char> set = new HashSet<char>(new char[] { 'a', 'e', 'i', 'o', 'u' });<br>
int res = 0;<br>
int count = 0;<br>
for (int i = 0; i &lt; k; i++)<br>
{<br>
if (set.Contains(s[i]))<br>
count += 1;<br>
}<br>
res = Math.Max(res, count);<br>
for (int i = k; i &lt; s.Length; i++)<br>
{<br>
if (set.Contains(s[i - k]))<br>
count -= 1;<br>
if (set.Contains(s[i]))<br>
count += 1;<br>
res = Math.Max(res, count);<br>
}<br>
return res;<br>
}<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C#游戏服务器/客户端(TCP/UDP无连接转发位置同步)/Google.Protobuf消息解析]]></title>
        <id>https://Wei715547.github.io/post/cyou-xi-fu-wu-qi-ke-hu-duan-googleprotobuf-xiao-xi-jie-xi/</id>
        <link href="https://Wei715547.github.io/post/cyou-xi-fu-wu-qi-ke-hu-duan-googleprotobuf-xiao-xi-jie-xi/">
        </link>
        <updated>2021-01-02T03:06:58.000Z</updated>
        <content type="html"><![CDATA[<p>基本客户端请求，服务端反馈实现<br>
<strong>服务端</strong><br>
<img src="https://Wei715547.github.io/post-images/1609562480036.png" alt="" loading="lazy"><br>
<strong>Server代码</strong><br>
<code><br>
using System;<br>
using System.Collections.Generic;<br>
using System.Net.Sockets;<br>
using System.Text;<br>
using System.Net;<br>
using Game_Socket_Server.Controller;<br>
using GameSocketServerProtocol;</p>
<p>namespace Game_Socket_Server<br>
{/// <summary><br>
/// 服务器类<br>
/// </summary><br>
class Server<br>
{<br>
private Socket socket;<br>
private UDPServer us;<br>
//客户端列表<br>
private List<Client> clientList = new List<Client>();<br>
//所有房间<br>
private List<Room> roomList = new List<Room>();<br>
//控制类管理器<br>
private ControllerManager controllerManager;<br>
/// <summary><br>
/// 服务端构造<br>
/// </summary><br>
/// <param name="prot">传入端口号</param><br>
public Server(int prot)<br>
{<br>
controllerManager = new ControllerManager(this);<br>
socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);<br>
socket.Bind(new IPEndPoint(IPAddress.Any, prot));//绑定端口<br>
socket.Listen(10);//监听队列长度<br>
StartAccept();//开支接收客户端连接<br>
us = new UDPServer(6667, this, controllerManager);<br>
}</p>
<pre><code>    void StartAccept()
    {
        //开始异步接收客户端Socket
        socket.BeginAccept(AcceptCallBack,null);
    }
    void AcceptCallBack(IAsyncResult iar)
    {
        Socket client = socket.EndAccept(iar);//返回异步操作结果中接收到连入的客户端Socket
        clientList.Add(new Client(client,this,us));//加入客户端List
        StartAccept();//继续异步监听
    }

    public Client CientFromUserName(string user)
    {
        foreach (Client  c in clientList)
        {
            if (c.GetUserInfo.Username == user)
                return c;
        }
        return null;
    }

    /// &lt;summary&gt;
    /// 处理客户端发来的请求
    /// &lt;/summary&gt;  
    /// &lt;param name=&quot;pack&quot;&gt;包&lt;/param&gt;
    /// &lt;param name=&quot;client&quot;&gt;客户端&lt;/param&gt;
    public void HandleRequest(MainPack pack,Client client)
    {
        //通过controllerManager找到对应的，请求控制类
        controllerManager.HandleRequest(pack, client);
    }

    public MainPack CreateRoom(Client client,MainPack pack)
    {
        try
        {
            Room room = new Room(this, client, pack.Roompack[0]);
            roomList.Add(room);
            foreach (PlayerPack p in room.GetPlayerInfo())
            {
                pack.Playerpack.Add(p);
            }
            pack.Returncode = ReturnCode.Succeed;
            return pack;
        }catch
        {
            pack.Returncode = ReturnCode.Fall;
            return pack;
        }            
    }
    public MainPack FindRoom()
    {
        MainPack pack = new MainPack();
        pack.Actioncode = ActionCode.FindRoom;
        try
        {
            if(roomList.Count==0)
            {
                pack.Returncode = ReturnCode.NotRoom;
                return pack;
            }
            foreach (Room room in roomList)
            {
                pack.Roompack.Add(room.GetRoomInfo);
            }
            pack.Returncode = ReturnCode.Succeed;
        }catch
        {
            pack.Returncode = ReturnCode.Fall;
        }
        return pack;
    }

    public MainPack JoinRoom(Client client,MainPack pack)
    {
        foreach (Room r in roomList)
        {
            //客户端加入str房间
            if(r.GetRoomInfo.Roomname.Equals(pack.Str))
            {
                if(r.GetRoomInfo.State==0)
                {
                    //房间可加入
                    r.Join(client);
                    pack.Roompack.Add(r.GetRoomInfo);
                    foreach (PlayerPack p in r.GetPlayerInfo())
                    {
                        pack.Playerpack.Add(p);
                    }
                    pack.Returncode = ReturnCode.Succeed;
                    return pack;
                }else
                {
                    //房间不可加入
                    pack.Returncode = ReturnCode.Fall;
                    return pack;
                }
            }
        }
        //当前无房间可加入
        pack.Returncode = ReturnCode.NotRoom;
        return pack;
    }
    public MainPack Exit(Client client,MainPack pack)
    {
        if(client.GetRoom==null)
        {
            pack.Returncode = ReturnCode.Fall;
            return pack;
        }
        client.GetRoom.Exit(this, client);
        pack.Returncode = ReturnCode.Succeed;
        return pack;
    }
    public void Chat(Client client,MainPack pack)
    {
        pack.Str = client.UserName+&quot;：&quot;+ pack.Str;
        client.GetRoom.Broadcast(client, pack);
    }
    public void RemoveClient(Client client)
    {
        clientList.Remove(client);
    }
    public void RemoveRoom(Room room)
    {
        roomList.Remove(room);
    }
}
</code></pre>
<p>}</p>
<p><strong>服务端UDP转发类</strong></p>
<p>using Game_Socket_Server.Controller;<br>
using Game_Socket_Server.Tool;<br>
using GameSocketServerProtocol;<br>
using System;<br>
using System.Collections.Generic;<br>
using System.Net;<br>
using System.Net.Sockets;<br>
using System.Text;<br>
using System.Threading;</p>
<p>namespace Game_Socket_Server<br>
{<br>
class UDPServer<br>
{<br>
Socket udpServer;//UDPSocket<br>
IPEndPoint bindEP;//本地监听IP<br>
EndPoint remotEP;//远程IP</p>
<pre><code>    Server server;//TCPServer

    ControllerManager controllerManager;//控制管理器调用对应事件防范

    Byte[] buffer = new Byte[1024];//消息接收容器
    Thread receiveThread;//接收线程
    /// &lt;summary&gt;
    /// UDP转发服务器构造
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;port&quot;&gt;监听端口号&lt;/param&gt;
    /// &lt;param name=&quot;server&quot;&gt;TCP服务器&lt;/param&gt;
    /// &lt;param name=&quot;controllerManager&quot;&gt;控制管理器&lt;/param&gt;
    public UDPServer(int port, Server server, ControllerManager controllerManager)
    {
        this.server = server;
        this.controllerManager = controllerManager;
        udpServer = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
        bindEP = new IPEndPoint(IPAddress.Any, port);//监听本地IP端口
        remotEP = (EndPoint)bindEP;//初始远程IP为默认本地,
        udpServer.Bind(bindEP);
        receiveThread = new Thread(ReceiveMag);
        receiveThread.Start();
        Console.WriteLine(&quot;UDP服务器以创建&quot;);

    }
    ~UDPServer()
    {
        if (receiveThread != null)
        {
            receiveThread.Abort();
            receiveThread = null;
        }
    }
    /// &lt;summary&gt;
    /// 服务器UDP接收端建立后即开始接收
    /// &lt;/summary&gt;
    private void ReceiveMag()
    {
        while (true)
        {
            int len = udpServer.ReceiveFrom(buffer, ref remotEP);//UDP接收方法，数据写入buffer，返回另一端通信地址
            MainPack pack = (MainPack)MainPack.Descriptor.Parser.ParseFrom(buffer, 0, len);
            Handlerequest(pack, remotEP);
        }
    }
    /// &lt;summary&gt;
    /// UDP无连接，通过返回客户端地址进行通信
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;buffer&quot;&gt;接收客户端发来的数据&lt;/param&gt;
    /// &lt;param name=&quot;remotEP&quot;&gt;返回到到客户端地址&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public void Handlerequest(MainPack pack, EndPoint ipEndPoint)
    {
        Client client = server.CientFromUserName(pack.User);//通过包中的用户名找到对应的客户端类，对其通信地址赋值
        if(client.IEP==null)
        {
            client.IEP = ipEndPoint;
        }
        controllerManager.HandleRequest(pack, client,true);
    }
    public void SendTo(MainPack pack,EndPoint point)
    {
        byte[] buff = Message.PackDateUDP(pack);
        udpServer.SendTo(buff, buff.Length, SocketFlags.None, point);
    }
}
</code></pre>
<p>}</p>
<p><strong>ControllerManager代码</strong></p>
<p>using System;<br>
using System.Collections.Generic;<br>
using System.Reflection;<br>
using System.Text;<br>
using GameSocketServerProtocol;</p>
<p>namespace Game_Socket_Server.Controller<br>
{<br>
class ControllerManager<br>
{<br>
private Dictionary&lt;RequestCode, BaseController&gt; controlDict = new Dictionary&lt;RequestCode, BaseController&gt;();<br>
private Server server;<br>
public ControllerManager(Server server)<br>
{<br>
this.server = server;<br>
UserController userController = new UserController();<br>
controlDict.Add(userController.GetRequestCode, userController);<br>
RoomController roomController = new RoomController();<br>
controlDict.Add(roomController.GetRequestCode, roomController);<br>
}</p>
<pre><code>    /// &lt;summary&gt;
    /// 服务端消息处理方法，默认处理TCP消息
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;pack&quot;&gt;&lt;/param&gt;
    /// &lt;param name=&quot;client&quot;&gt;&lt;/param&gt;
    /// &lt;param name=&quot;isUDP&quot;&gt;是否为UDP数据报&lt;/param&gt;
    public void HandleRequest(MainPack pack,Client client,bool isUDP = false)
    {
        //根据Requestcode请求类型获取对应的请求类型控制器，如User-UserController
        if (controlDict.TryGetValue(pack.Requestcode,out BaseController controller))
        {
            string mothooname = pack.Actioncode.ToString();//解析具体请求类型中的方法如：User中的Logon
            //通过反射特性获取，处理该请求类型控制器中的方法，如UserController中的Logon
            MethodInfo method = controller.GetType().GetMethod(mothooname);
            if(method == null)
            {
                Console.WriteLine(&quot;没有找到对应的事件处理方法&quot;);
                return;
            }                
            //方法不为空，存在处理方法
            Console.WriteLine(&quot;客户端&quot;+mothooname+&quot;请求&quot;);
            object[] obj;
            if (isUDP)
            {
                obj = new object[] { client, pack };
                method.Invoke(controller, obj);//UDP只负责转发，不需要对客户端进行反馈
            }
            else
            {
                //方法的统一参数，(服务器Socket，客户端Socket，数据包MainPack)
                obj = new object[] { server, client, pack };
                //方法处理后返回的数据包
                object ret = method.Invoke(controller, obj);//通过反射调用请求控制器中处理该请求的方法，返回处理后的的包

                if (ret != null)//请求处理返回的数据包不为空（需要给客户端反馈时）
                {
                    client.Send(ret as MainPack);//将处理结果发给客户端
                }
                //ret为空时即服务器对此请求不需要回复
            }

        }else
        {
            Console.WriteLine(&quot;没有找到对应的Ccontroller处理&quot;);
        }
    }
}
}
</code></pre>
<p>}</p>
<p><strong>Client代码</strong></p>
<p>using System;<br>
using System.Collections.Generic;<br>
using System.Net.Sockets;<br>
using System.Net;<br>
using System.Text;<br>
using Game_Socket_Server.Tool;<br>
using Game_Socket_Server.DAO;<br>
using GameSocketServerProtocol;</p>
<p>namespace Game_Socket_Server<br>
{<br>
class Client<br>
{<br>
private Socket socket;//与远程客户端通信的Socket<br>
private Message message;//消息类<br>
private UserDate userDate;//用户数据类，连接数据库读取写入<br>
private Server server;//服务器<br>
private UDPServer us;//UDPServer<br>
private EndPoint remoetEP;<br>
//private int hp = 100;<br>
public Room GetRoom//自动属性，客户端所在房间<br>
{<br>
get;set;<br>
}<br>
public string UserName//自动属性，用户名<br>
{<br>
get;set;<br>
}<br>
/<em>public int HP<br>
{<br>
get { return hp; }<br>
set { hp = value; }<br>
}</em>/<br>
public UserInfo GetUserInfo<br>
{<br>
get;set;<br>
}<br>
public class UserInfo<br>
{<br>
public string Username<br>
{<br>
get;set;<br>
}<br>
public int Hp<br>
{<br>
get;<br>
set;<br>
}<br>
public PosPack Pos<br>
{<br>
get;set;<br>
}<br>
}</p>
<pre><code>    public EndPoint IEP
    {
        get { return remoetEP; }
        set { remoetEP = value; }
    }

    public UserDate GetUserDate//外部获取用户数据公开属性
    {
        get
        {
            return userDate;
        }
    }
    public Client(Socket socket,Server server,UDPServer us)
    {
        this.server = server;
        this.socket = socket;
        this.us = us;
        message = new Message();
        userDate = new UserDate();
        GetUserInfo = new UserInfo();
        StartReceiveMsg();
    }
    /// &lt;summary&gt;
    /// 客户端异步接收字节流数据
    /// &lt;/summary&gt;
    void StartReceiveMsg()
    {
        //异步接收方法(用于接收的字节数组，开始接收位，可用于接收的长度，Sock标记，回调函数，null)
        socket.BeginReceive(message.Buffer,message.StartIndex,message.Remsize,SocketFlags.None,ReceiveCallBak,null);
        
    }
    void ReceiveCallBak(IAsyncResult iar)
    {
        try
        {
            //如socket为空，或未连接，则返回
            if (socket == null || socket.Connected == false) return;
            //接收到的字节流长度
            int len = socket.EndReceive(iar);
            if (len == 0)//为空则返回
            {
                Close();
                return;
            }
            //不为空时开始解析消息
            message.ReadBuffer(len,HandleRequest);
            StartReceiveMsg();
        }
        catch {
            Close();
        }
    }
    /// &lt;summary&gt;
    /// 客户端发送数据方法
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;pack&quot;&gt;包转字节流&lt;/param&gt;
    public void Send(MainPack pack)
    {
        if (socket == null || socket.Connected == false) return;
        try
        {
            socket.Send(Message.PackDate(pack));
        }
        catch
        { }
    }
    //UDP转发方法，UDP无连接，通过收到的客户端地址发送数据。
    public void SendTo(MainPack pack)
    {
        if (IEP == null) return;
        us.SendTo(pack, IEP);

    }
    //处理客户端发来的请求
    private void HandleRequest(MainPack pack)
    {
        server.HandleRequest(pack, this);
    }

    private void Close()
    {
        Console.WriteLine(&quot;客户端断开&quot;);
        if(GetRoom!=null)
        {
            GetRoom.Exit(server, this);
        }
        server.RemoveClient(this);
        socket.Close();
        
    }
}
</code></pre>
<p>}</p>
<p><strong>Message处理类代码</strong></p>
<p>using System;<br>
using System.Collections.Generic;<br>
using System.Linq;<br>
using System.Text;<br>
using GameSocketServerProtocol;<br>
using Google.Protobuf;</p>
<p>namespace Game_Socket_Server.Tool<br>
{<br>
/// <summary><br>
/// 消息处理类，主要方法，将字节数组解析为MainPack包，将包转为字节数组。<br>
/// </summary><br>
class Message<br>
{<br>
/// <summary><br>
/// 字节数组容器<br>
/// </summary><br>
private byte[] buffer = new byte[1024];<br>
/// <summary><br>
///<br>
/// </summary><br>
private int startIndex;<br>
public byte[] Buffer<br>
{<br>
get<br>
{<br>
return buffer;<br>
}<br>
}</p>
<pre><code>    public int StartIndex
    {
        get
        {
            return startIndex;
        }
    }

    public int Remsize
    {
        get
        {
            return buffer.Length - startIndex;
        }
    }

    /// &lt;summary&gt;
    /// 数据解析，字节流转为MainPack包
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;len&quot;&gt;读取的长度&lt;/param&gt;
    public void ReadBuffer(int len,Action&lt;MainPack&gt; HandleRequest)
    {
        startIndex += len;            
        while (true)//循环解析消息
        {
            if(startIndex&lt;=4) return;//包头一个int类型长度&lt;=4 包体无数据不需解析
            int count = BitConverter.ToInt32(buffer,0);//读取4位返回一个int值
            if (startIndex &gt;= (count + 4))
            {
                //接收数据包
                MainPack pack = (MainPack)MainPack.Descriptor.Parser.ParseFrom(buffer, 4, count);//byte[]容器，偏移(从第几位开始读)，读多少位。
                HandleRequest(pack);
                //读取之后清理解析过的位
                Array.Copy(buffer, count + 4, buffer, 0, startIndex - count - 4);
                startIndex -= (count + 4);
            }
            else
            {
                break;
            }
        }            
    }
    public static byte[] PackDate(MainPack pack)
    {
        byte[] date = pack.ToByteArray();//包体
        byte[] head = BitConverter.GetBytes(date.Length);//包头
        return head.Concat(date).ToArray();
    }
    //UDP MainPack打包不需要包头
    public static byte[] PackDateUDP(MainPack pack)
    {
        return pack.ToByteArray();
    }
}
</code></pre>
<p>}</p>
<p><strong>MainPack，build之前代码(生成GameSocketServerProtocol.cs引入服务端/客户端使用)</strong></p>
<p>syntax = &quot;proto3&quot;;<br>
package GameSocketServerProtocol;<br>
//客户端请求类型枚举<br>
enum RequestCode<br>
{<br>
RequestNone=0;<br>
//用户请求<br>
User = 1;<br>
//房间请求<br>
Room = 2;<br>
//游戏请求<br>
Game = 3;<br>
}<br>
//客户端请求事件类型<br>
enum ActionCode<br>
{<br>
ActionNone=0;<br>
//注册<br>
Logon = 1;<br>
//登录<br>
Login = 2;<br>
//创建房间<br>
CreateRoom = 3;<br>
//查询房间<br>
FindRoom = 4;<br>
//玩家列表：服务器发给客户端解析<br>
PlayerList = 5;<br>
//加入房间<br>
JoinRoom = 6;<br>
//离开<br>
Exit = 7;<br>
//聊天<br>
Chat = 8;<br>
//开始游戏<br>
StartGame = 9;<br>
//服务端发送来的开始游戏<br>
Staring = 10;<br>
//更新位置<br>
UpState = 11;<br>
//离开游戏<br>
ExitGame = 12;<br>
//更新角色和玩家列表<br>
UpDatePlayerList = 13;<br>
//开火<br>
Fire = 14;<br>
}<br>
//服务器返回类型<br>
enum ReturnCode<br>
{<br>
ReturnNone=0;<br>
//成功<br>
Succeed = 1;<br>
//失败<br>
Fall = 2;<br>
//未找到房间<br>
NotRoom = 3;<br>
}</p>
<p>message MainPack<br>
{<br>
RequestCode requestcode=1;<br>
ActionCode actioncode=2;<br>
ReturnCode returncode=3;<br>
//注册/登录信息包<br>
LoginPack loginpack=4;<br>
//防止发送空包占用空间的字符串，也可传输客户端聊天消息等<br>
string str = 5;<br>
//房间列表<br>
repeated RoomPack roompack = 6;<br>
//玩家列表<br>
repeated PlayerPack playerpack = 7;<br>
//子弹位置<br>
BulletPack bulletpack = 8;<br>
//用户名<br>
string user = 9;<br>
}</p>
<p>message LoginPack<br>
{<br>
//用户名<br>
string username=1;<br>
//密码<br>
string password=2;<br>
}<br>
message RoomPack<br>
{<br>
//房间名<br>
string roomname = 1;<br>
//房间最大人数<br>
int32 maxnum = 2;<br>
//房间当前人数<br>
int32 curnum = 3;<br>
//房间状态<br>
int32 state = 4;<br>
}<br>
message PlayerPack<br>
{<br>
//玩家名称<br>
string playername = 1;<br>
//玩家ID<br>
string playerID = 2;<br>
//玩家血量<br>
int32 hp = 3;<br>
//位置信息<br>
PosPack pospack = 4;<br>
}<br>
message PosPack<br>
{<br>
//玩家2D坐标<br>
float PosX = 1;<br>
float PosY = 2;<br>
float RotZ = 3;	<br>
float GunRotZ = 4;	<br>
}<br>
message BulletPack<br>
{<br>
float PosX = 1;<br>
float PosY = 2;<br>
float RotZ = 3;	<br>
//鼠标位置<br>
float MousePosX = 4;<br>
float MousePosY = 5;<br>
}</p>
</code>
<p><img src="https://Wei715547.github.io/post-images/1609573638953.png" alt="" loading="lazy"><br>
<strong>客户端代码</strong><br>
<strong>GameFace</strong><br>
<code><br>
using GameSocketServerProtocol;<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class GameFace : MonoBehaviour<br>
{<br>
private ClientManeger clientManeger;<br>
private RequestManager requestManager;<br>
private UIManager uiManager;<br>
PlayerManager playerManager;</p>
<pre><code>public string UserName//客户端登录时赋值
{
    get;set;    
}

private static GameFace face;

public static GameFace Face
{
    get
    {
        if (face == null)
            face = GameObject.Find(&quot;GameFace&quot;).GetComponent&lt;GameFace&gt;();
        return face;
    }
}
// Start is called before the first frame update
void Start()
{
    //face = this;
    uiManager = new UIManager(this);
    clientManeger = new ClientManeger(this);
    requestManager = new RequestManager(this);
    playerManager = new PlayerManager(this);
    uiManager.OnInit();
    clientManeger.OnInit();
    requestManager.OnInit();
    playerManager.OnInit();
}
private void OnDestroy()
{
    clientManeger.OnDestory();
    requestManager.OnDestory();
    uiManager.OnDestory();
}
public void Send(MainPack pack)
{
    clientManeger.Send(pack);
}
public void SendTo(MainPack pack)
{
    pack.User = UserName;//向包中加入用户名，用于服务端UDP对本客户端通信地址赋值
    clientManeger.SendTo(pack);
}
public void HandleResoonse(MainPack pack)
{
    //处理
    Debug.Log(&quot;服务器返回&quot;+pack.Returncode.ToString());
    requestManager.HandleResponse(pack);
}
public void AddRequest(BaseRequest request)
{
    requestManager.AddRequest(request);
}
public void RemoveReqest(ActionCode action)
{
    requestManager.RemoveRequest(action);
}

public void ShowMessage(string message,bool sync=false)
{
    uiManager.ShowMessage(message,sync);
}
/*public void SetSelfID(string id)
{
    playerManager.CurPlayerID = id;
}*/
public void AddPlayer(MainPack packs)
{
    playerManager.AddPlayer(packs);
}
public void RemovePlayer(string id)
{
    playerManager.RemovePlayer(id);
}
public void GameExit()
{
    playerManager.GameExit();
    uiManager.PopPaneal();
    uiManager.PopPaneal();
    requestManager.RemoveRequest(ActionCode.UpState);
    requestManager.RemoveRequest(ActionCode.Fire);
}
public void UpPos(MainPack pack)
{
    playerManager.UpPos(pack);
}
public void SpawnBullet(MainPack pack)
{
    playerManager.SpawnBullet(pack);
}
</code></pre>
<p>}</p>
<p><strong>BaseRequest基类</strong><br>
using GameSocketServerProtocol;<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class BaseRequest : MonoBehaviour<br>
{<br>
protected RequestCode requestCode;<br>
protected ActionCode actionCode;<br>
protected GameFace face;<br>
public ActionCode GetActionCode<br>
{<br>
get { return actionCode; }<br>
}<br>
public virtual void Awake()<br>
{<br>
face = GameFace.Face;<br>
}<br>
public virtual void Start()<br>
{<br>
face.AddRequest(this);<br>
Debug.Log(actionCode.ToString());<br>
}<br>
public virtual void OnDesttroy()<br>
{<br>
face.RemoveReqest(actionCode);<br>
}</p>
<pre><code>public virtual void OnResponse(MainPack pack)
{

}
//基类TCP发送
public virtual void SendRequest(MainPack pack)
{
    face.Send(pack);
}
//基类UDP发送
public virtual void SendRequestUDP(MainPack pack)
{
    face.SendTo(pack);
}
</code></pre>
<p>}<br>
<strong>ClientManager</strong><br>
using GameSocketServerProtocol;<br>
using System;<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using System.Net.Sockets;<br>
using UnityEngine;</p>
<p>public class ClientManeger : BaseManager<br>
{<br>
private Socket socket;<br>
private Message message;<br>
public ClientManeger(GameFace face) : base(face)  { }</p>
<pre><code>public override void OnInit()
{
    base.OnInit();
    message = new Message();
    InitSocket();//初始化TCP通信
    InitUDP();//初始化UDP通信
}
public override void OnDestory()
{
    base.OnDestory();
    message = null;
    CloseSocket();
}/// &lt;summary&gt;
/// 初始化Socket
/// &lt;/summary&gt;
private void InitSocket()
{
    socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
    try
    {
        socket.Connect(&quot;127.0.0.1&quot;, 6666);
        //连接成功
        face.ShowMessage(&quot;连接成功&quot;);
        StartReceive();
    }
    catch(Exception e)
    {
        Debug.LogWarning(e);
        //连接错误
        face.ShowMessage(&quot;连接失败&quot;);
    }
}
/// &lt;summary&gt;
/// 关闭Socket
/// &lt;/summary&gt;
private void CloseSocket()
{
    if(socket.Connected&amp;&amp;socket!=null)
    {
        socket.Close();
    }
}
private void StartReceive()
{
    socket.BeginReceive(message.Buffer, message.StartIndex, message.Remsize, SocketFlags.None, RecelveClientBack,null);

}

private void RecelveClientBack(IAsyncResult iar)
{
    try
    {
        if (socket == null || socket.Connected == false) return;
        int len = socket.EndReceive(iar);
        if(len==0)
        {
            CloseSocket();
            return;
        }
        message.ReadBuffer(len,HandleResoonse);
        StartReceive();
    }catch(Exception e)
    {
        Debug.Log(e.Message);
    }
}
private void HandleResoonse(MainPack pack)
{
    face.HandleResoonse(pack);
}

public void Send(MainPack pack)
{
    socket.Send(Message.PackDate(pack));
}

//UDP通信**————————————————————————————**
private Socket udpClient;//Socket
private IPEndPoint iPEndPoint;//服务器地址
private EndPoint EPoint;//
private Byte[] buffer = new Byte[1024];

private void InitUDP()
{
    udpClient = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
    iPEndPoint = new IPEndPoint(IPAddress.Parse(ip), 6667);
    EPoint = iPEndPoint;
    try
    {
        udpClient.Connect(EPoint);
    }
    catch 
    {
        Debug.Log(&quot;UPD连接失败&quot;);
        return;
    }
    aucThread = new Thread(ReceiveMsg);
    aucThread.Start();
}
private void ReceiveMsg()
{
    //同步循环接收
    Debug.Log(&quot;UDP开始接收&quot;);
    while(true)
    {
        int len = udpClient.ReceiveFrom(buffer, ref EPoint);
        MainPack pack = (MainPack)MainPack.Descriptor.Parser.ParseFrom(buffer, 0, len);
        Debug.Log(&quot;接收数据&quot; + pack.Actioncode + pack.User);
        HandleResoonse(pack);//收到MainPack包的处理方法与TCP一致，
        //通过RequestManager找到对应的Reeuest,调用对应UDP通信类型的处理方法(根据包中的数据同步位置/其他操作)
    }
}
//UDP发送数据方法
public void SendTo(MainPack pack)
{
    byte[] sendbuffer = Message.PackDateUDP(pack);
    //服务端地址固定，首次连接后即可发送
    udpClient.Send(sendbuffer, sendbuffer.Length, SocketFlags.None);//使用Send必须先连接“110”行代码
    //SendTo需要目的地址EndPoint
}
</code></pre>
<p>}<br>
<strong>RequestManager</strong><br>
using GameSocketServerProtocol;<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class RequestManager : BaseManager<br>
{<br>
public RequestManager(GameFace face):base(face) { }</p>
<pre><code>private Dictionary&lt;ActionCode, BaseRequest&gt; requestDict = new Dictionary&lt;ActionCode, BaseRequest&gt;();

public void AddRequest(BaseRequest request)
{
    requestDict.Add(request.GetActionCode, request);
    Debug.Log(&quot;新请求：&quot; + request.GetActionCode.ToString());
}
public void RemoveRequest(ActionCode action)
{
    requestDict.Remove(action);
}
public void HandleResponse(MainPack pack)
{
    if (requestDict.TryGetValue(pack.Actioncode, out BaseRequest request))
    {
        //基类回应请求方法，已在子类中重写
        request.OnResponse(pack);
    }else
    {
        Debug.Log(&quot;未找到对应处理&quot;);
    }        
}
</code></pre>
<p>}<br>
</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[BaseMVC_UI]]></title>
        <id>https://Wei715547.github.io/post/basemvc_ui/</id>
        <link href="https://Wei715547.github.io/post/basemvc_ui/">
        </link>
        <updated>2020-12-13T11:28:39.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://Wei715547.github.io/post-images/1607863048846.jpg" alt="" loading="lazy"><br>
<strong>M：数据模型</strong>//此例两界面共用一个数据模型<br>
using System;<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.Events;<br>
/// <summary><br>
/// 数据模型<br>
/// </summary><br>
public class PlayerMode<br>
{<br>
#region//数据层<br>
private string playername;<br>
public string Playername<br>
{<br>
get<br>
{<br>
return playername;<br>
}<br>
}<br>
private int lev;<br>
public int Lev<br>
{<br>
get<br>
{<br>
return lev;<br>
}<br>
}</p>
<pre><code>private int money;
public int Money
{
    get
    {
        return money;
    }
}

private int power;
public int Power
{
    get
    {
        return power;
    }
}


private int hp;
public int Hp
{
    get { return hp; }
}
private int atk;
public int Atk
{
    get { return atk; }
}
private int def;
public int Def
{
    get { return def; }
}
private int miss;
public int Miss
{
    get { return miss; }
}

//通过事件与外部联系
public event Action&lt;PlayerMode&gt; updateEvent;

//数据模型类单例，达到数据唯一，与获取数据
private static PlayerMode date;
public static PlayerMode Date
{
    get
    {
        if(date==null)
        {
            date = new PlayerMode();
            date.Init();
        }
        return date;
    }
}
#endregion

//初始化
public void Init()
{
    playername = PlayerPrefs.GetString(&quot;Playername&quot;, &quot;Wei&quot;);//PlayerPrefs类场景中存储值
    lev = PlayerPrefs.GetInt(&quot;Lev&quot;, 17);
    money = PlayerPrefs.GetInt(&quot;Money&quot;, 100);
    power = PlayerPrefs.GetInt(&quot;Power&quot;, 100);

    hp = PlayerPrefs.GetInt(&quot;Hp&quot;, 100);
    atk = PlayerPrefs.GetInt(&quot;Atk&quot;, 100);
    def = PlayerPrefs.GetInt(&quot;Def&quot;, 100);
    miss = PlayerPrefs.GetInt(&quot;Miss&quot;, 100);
}
//更新
public void LeveUp()
{
    lev += 1;

    hp += 10;
    atk += 10;
    def += 10;
    miss += 10;

    SaveDate();//更新后保存数据

    
}
//保存
public void SaveDate()
{
    PlayerPrefs.SetString(&quot;Playername&quot;, playername);
    PlayerPrefs.SetInt(&quot;Lev&quot;, lev);
    PlayerPrefs.SetInt(&quot;Money&quot;, money);
    PlayerPrefs.SetInt(&quot;Power&quot;, power);

    PlayerPrefs.SetInt(&quot;Hp&quot;, hp);
    PlayerPrefs.SetInt(&quot;Atk&quot;, atk);
    PlayerPrefs.SetInt(&quot;Def&quot;, def);
    PlayerPrefs.SetInt(&quot;Miss&quot;, miss);

    UpdateInfo();
}
//外部注册事件
public void AddEventLissent(Action&lt;PlayerMode&gt; function)
{
    updateEvent += function;
}
//外部取消注册事件
public void RemoveEventLissent(Action&lt;PlayerMode&gt; function)
{
    updateEvent -= function;
}
//通知更新数据的方法（调用数据更新时执行的事件）
public void UpdateInfo()
{
    updateEvent?.Invoke(this);
}
</code></pre>
<h2 id="">}</h2>
<p><strong>V：界面脚本</strong>//获取控件，更新控件数据<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.UI;<br>
//VM<br>
public class PlayerMainView : MonoBehaviour<br>
{<br>
//获取控件<br>
public Button btnRole;<br>
public Button btnSkill;</p>
<pre><code>public Text txtName;
public Text txtLev;
public Text txtMoney;
public Text txtPower;

//提供面板更新相关方法给外部
public void UpdateInfo(PlayerMode date)
{
    txtName.text = date.Playername;
    txtLev.text = &quot;Lv:&quot; + date.Lev.ToString();
    txtMoney.text = date.Money.ToString();
    txtPower.text = date.Power.ToString();
}
</code></pre>
<p>}</p>
<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.UI;<br>
//VR<br>
public class PlayerRoleView : MonoBehaviour<br>
{<br>
//获取控件<br>
public Button btnBack;<br>
public Button btnLeveUp;</p>
<pre><code>public Text txtHp;
public Text txtAtk;
public Text txtDef;
public Text txtMiss;

//提供面板更新相关方法给外部
public void UpdateInfo(PlayerMode date)
{
    txtHp.text = date.Hp.ToString();
    txtAtk.text = date.Atk.ToString();
    txtDef.text = date.Def.ToString();
    txtMiss.text = date.Miss.ToString();
}
</code></pre>
<h2 id="-2">}</h2>
<p><strong>C：界面控制脚本</strong>//显隐，初始化，界面逻辑，数据更新时调用的事件<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
/// <summary><br>
/// 处理主界面业务逻辑<br>
/// </summary><br>
public class MainController : MonoBehaviour<br>
{<br>
//能够在Controller中获取View界面<br>
private PlayerMainView mainView;</p>
<pre><code>private static MainController contorller;

public static MainController Controller
{
    get
    {
        return contorller;
    }
}
//界面显示隐藏
public static void ShowPanel()
{
    if(contorller==null)
    {
        GameObject res = Resources.Load&lt;GameObject&gt;(&quot;UI/MainPanel&quot;);
        GameObject obj = Instantiate(res);
        obj.transform.SetParent(GameObject.Find(&quot;Canvas&quot;).transform);
        contorller = obj.GetComponent&lt;MainController&gt;();
    }
}
public static void HeadPanel()
{
    contorller.gameObject.SetActive(false);
}

private void Start()
{
    //获取挂载同一物体上的View脚本
    mainView = this.GetComponent&lt;PlayerMainView&gt;();
    //第一次界面更新
    mainView.UpdateInfo(PlayerMode.Date);

    mainView.btnRole.onClick.AddListener(OnRoleBtnClick);

    //数据更新时同时更新界面
    PlayerMode.Date.AddEventLissent(UpdateInfo);
}

private void OnRoleBtnClick()
{
    RoleController.ShowPanel();
}

//界面事件监听，逻辑处理
//界面更新
private void UpdateInfo(PlayerMode date)
{
    if(mainView!=null)
        mainView.UpdateInfo(date);
}
</code></pre>
<p>}</p>
<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
/// <summary><br>
/// 处理属性界面业务逻辑<br>
/// </summary><br>
public class RoleController : MonoBehaviour<br>
{<br>
//能够在Controller中获取View界面<br>
private PlayerRoleView roleView;</p>
<pre><code>private static RoleController contorller;

public static RoleController Controller
{
    get
    {
        return contorller;
    }
}
//界面显示隐藏
public static void ShowPanel()
{
    if (contorller == null)
    {
        GameObject res = Resources.Load&lt;GameObject&gt;(&quot;UI/RolePanel&quot;);
        GameObject obj = Instantiate(res);
        obj.transform.SetParent(GameObject.Find(&quot;Canvas&quot;).transform);
        contorller = obj.GetComponent&lt;RoleController&gt;();
    }
}
public static void HeadPanel()
{
    contorller.gameObject.SetActive(false);
}

private void Start()
{
    //获取挂载同一物体上的View脚本
    roleView = this.GetComponent&lt;PlayerRoleView&gt;();
    //第一次界面更新
    roleView.UpdateInfo(PlayerMode.Date);

    roleView.btnBack.onClick.AddListener(OnClickBack);
    roleView.btnLeveUp.onClick.AddListener(OnClickLeveUp);

    //数据更新时同时更新界面
    PlayerMode.Date.AddEventLissent(UpdataInfo);
    //PlayerMode.Date.AddEventLissent(roleView.UpdateInfo);
    //PlayerMode.Date.updateEvent += roleView.UpdateInfo;
}
private void OnClickBack()
{
    HeadPanel();
}
private void OnClickLeveUp()
{
    //通过事件模块，改变数据。
    PlayerMode.Date.LeveUp();
}

//界面事件监听，逻辑处理
//界面更新
private void UpdataInfo(PlayerMode date)
{
    if(roleView!=null)
        roleView.UpdateInfo(date);
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
</feed>