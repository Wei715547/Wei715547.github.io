<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Wei715547.github.io</id>
    <title>Wei: Development technology accumulation</title>
    <updated>2020-08-19T03:45:34.185Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Wei715547.github.io"/>
    <link rel="self" href="https://Wei715547.github.io/atom.xml"/>
    <subtitle>年月增长，我宜强盛。
用于Unity+开发的技术积累</subtitle>
    <logo>https://Wei715547.github.io/images/avatar.png</logo>
    <icon>https://Wei715547.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Wei: Development technology accumulation</rights>
    <entry>
        <title type="html"><![CDATA[Shader-高光反射(顶点/像素)]]></title>
        <id>https://Wei715547.github.io/post/shader-gao-guang-fan-she-ding-dian-xiang-su/</id>
        <link href="https://Wei715547.github.io/post/shader-gao-guang-fan-she-ding-dian-xiang-su/">
        </link>
        <updated>2020-08-18T03:51:59.000Z</updated>
        <content type="html"><![CDATA[<code>
高光反射 Specular = 直射光*pow(max(cos夹角,0)*高光参数) ，夹角：反射光与视野方向夹角。(夹角越小高光越强,大于90度时即没有高光)；pox(a,b):a的b次方，高光参数取值（1~10）高光参数越大可以看到高光的夹角范围越小
<p>在顶点函数中计算<br>
Shader &quot;Custom/HightLightRefalxRander_Vertex&quot;<br>
{<br>
Properties<br>
{<br>
_Diffuse(&quot;DiffuseColor&quot;, Color) = (1,1,1,1)<br>
//外部可调节高光属性<br>
_Specular(&quot;_SpecularColor&quot;,Color) = (1,1,1,1)//高光颜色<br>
_Gloss(&quot;Gloss&quot;,Range(8,100)) = 10//高光参数</p>
<pre><code>}
	SubShader
{
   Pass
{
	Tags {&quot;Lighting&quot; = &quot;ForwardBase&quot;} //定义LightMode,获取UNITY内部光照变量
	CGPROGRAM
	fixed4 _Diffuse;
    int _Gloss;
    fixed4 _Specular;
</code></pre>
<p>#include &quot;Lighting.cginc&quot;<br>
#pragma vertex vert//声明顶点着色器<br>
#pragma fragment frag//声明片段着色器</p>
<pre><code>struct a2v {//从应用程序传递到顶点函数的语义POSITION:顶点坐标，NURMAL:法线(模型空间下)，TEXCOORD0-n:纹理坐标，COLOR:顶点颜色
	float4 vertex:POSITION;//获取顶点坐标
	float3 normal:NORMAL;

};
struct v2f {//从顶点函数传递到片原函数的语义SV_POSITION:(剪裁空间中的顶点坐标-系统直接使用)，COLOR0/COLOR1:可以传递一组值(4个)，TEXCOORD0~7:传递纹理坐标
			//f2s片原函数传递给系统：SV_Target:颜色值-输出到屏幕上的颜色(缓存颜色)
	float4 position:SV_POSITION;
	fixed3 color : COLOR1;
};

v2f vert(a2v v)//顶点之间片段颜色采用插值计算填充
{
	v2f f;
	f.position = UnityObjectToClipPos(v.vertex);//将坐标从模型空间转换到剪裁空间
	fixed3 amblent = UNITY_LIGHTMODEL_AMBIENT.rgb;//获取系统环境光
	//fixed3 norDir = normalize(unity_WorldToObject(v.normal));//法线方向从世界空间转到模型空间(弃用的方法) 
	fixed3 N = UnityObjectToWorldNormal(v.normal);//法线方向从世界空间转到模型空间 
	fixed3 lightDir = normalize(_WorldSpaceLightPos0.xyz);//第一个直射光的位置，对于顶点来说光的位置即是光的方向
	fixed3 diffuse = _LightColor0.rgb * max(dot(N,lightDir),0) * _Diffuse.rgb;//根据漫反射公式：直射光颜色 * cos夹角(光与法线)获取颜色 dot(a,b):点乘获取两向量的夹角

	fixed3 reflectDir = normalize(reflect(-lightDir,N));//计算反射光方向
	fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - UnityObjectToWorldNormal(v.vertex));//计算视点方向(世界坐标下相机位置-顶点位置)
	fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(dot(reflectDir, viewDir), 0), _Gloss);//夹角：反射光与视野方向夹角

	f.color = diffuse + amblent + specular;//+:颜色得加(亮度增强),*:融合
	return f;
}


fixed4 frag(v2f f) :SV_Target//片原函数，片段在屏幕上像素颜色，返回颜色值
{
return fixed4(f.color,1);//返回法线
}
	ENDCG
}

}
	FallBack &quot;Diffuse&quot;
</code></pre>
<p>}<br>
—————————————————————————————————<br>
在片原函数中计算<br>
Shader &quot;Custom/HightLightRefalxRander_Fragment&quot;<br>
{<br>
Properties<br>
{<br>
_Diffuse(&quot;DiffuseColor&quot;, Color) = (1,1,1,1)<br>
_Specular(&quot;_SpecularColor&quot;,Color) = (1,1,1,1)<br>
_Gloss(&quot;Gloss&quot;,Range(8,100)) = 10//高光参数<br>
}<br>
SubShader<br>
{<br>
Pass<br>
{<br>
Tags {&quot;Lighting&quot; = &quot;ForwardBase&quot;} //定义LightMode,获取UNITY内部光照变量<br>
CGPROGRAM<br>
fixed4 _Diffuse;<br>
int _Gloss;<br>
fixed4 _Specular;<br>
#include &quot;Lighting.cginc&quot;<br>
#pragma vertex vert//声明顶点着色器<br>
#pragma fragment frag//声明片段着色器</p>
<pre><code>struct a2v {//从应用程序传递到顶点函数的语义POSITION:顶点坐标，NURMAL:法线(模型空间下)，TEXCOORD0-n:纹理坐标，COLOR:顶点颜色
	float4 vertex:POSITION;//获取顶点坐标
	float3 normal:NORMAL;

};
struct v2f {//从顶点函数传递到片原函数的语义SV_POSITION:(剪裁空间中的顶点坐标-系统直接使用)，COLOR0/COLOR1:可以传递一组值(4个)，TEXCOORD0~7:传递纹理坐标
			//f2s片原函数传递给系统：SV_Target:颜色值-输出到屏幕上的颜色(缓存颜色)
	float4 position:SV_POSITION;
	fixed3 worldNormal : TEXCOORD0;//传递法线方向
	float3 worldView :TEXCOORD1;//传递顶点坐标
};

v2f vert(a2v v)//顶点之间片段颜色采用插值计算填充
{
	v2f f;
	f.position = UnityObjectToClipPos(v.vertex);//将坐标从模型空间转换到剪裁空间
	f.worldNormal = UnityObjectToWorldNormal(v.normal);//向片原函数传递法线方向
	f.worldView = UnityObjectToWorldNormal(v.vertex);//向片原函数传递顶点坐标
	return f;
}


fixed4 frag(v2f f) :SV_Target//片原函数，片段在屏幕上像素颜色，返回颜色值
{
	fixed3 amblent = UNITY_LIGHTMODEL_AMBIENT.rgb;//获取系统环境光
	//fixed3 norDir = normalize(unity_WorldToObject(v.normal));//法线方向从世界空间转到模型空间(弃用的方法) 
	fixed3 N = f.worldNormal;//法线方向从世界空间转到模型空间 
	fixed3 lightDir = normalize(_WorldSpaceLightPos0.xyz);//第一个直射光的位置，对于顶点来说光的位置即是光的方向
	fixed3 diffuse = _LightColor0.rgb * max(dot(N,lightDir),0) * _Diffuse.rgb;//根据漫反射公式：直射光颜色 * cos夹角(光与法线)获取颜色 dot(a,b):点乘获取两向量的夹角

	//fixed3 reflectDir = normalize(reflect(-lightDir,N));//计算反射光方向
	fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - f.worldView);//计算视点方向(世界坐标下相机位置-顶点位置)
	//fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(dot(reflectDir, viewDir), 0), _Gloss);//夹角：反射光与视野方向夹角
	fixed3 harfDir = normalize(viewDir + lightDir);//平行光与视野方向平分项
	fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(dot(N, harfDir), 0), _Gloss);//Blinn-Phong光照模型Specular = 直射光*pow(max(cos夹角,0)*高光参数) ，夹角：法线与x方向夹角,x:平行光与视野方向的平分项。		
    

	fixed3 tempColor = diffuse + amblent + specular;//+:颜色得加(亮度增强),*:融合
return fixed4(tempColor,1);//返回法线
}
	ENDCG
}

}
	FallBack &quot;Diffuse&quot;
</code></pre>
<p>}</p>
<code/>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shader-顶点漫反射(*自身)(+环境光)-逐像素反射]]></title>
        <id>https://Wei715547.github.io/post/shader-ding-dian-man-fan-she-zi-shen-huan-jing-guang/</id>
        <link href="https://Wei715547.github.io/post/shader-ding-dian-man-fan-she-zi-shen-huan-jing-guang/">
        </link>
        <updated>2020-08-17T08:30:49.000Z</updated>
        <content type="html"><![CDATA[<code>
逐顶点漫反射：顶点之间片段颜色采用插值计算填充
<p>Shader &quot;Custom/Shader04&quot;<br>
{<br>
Properties<br>
{<br>
_Diffuse(&quot;DiffuseColor&quot;, Color) = (1,1,1,1)</p>
<pre><code>}
	SubShader
{
   Pass
{
	Tags {&quot;Lighting&quot; = &quot;ForwardBase&quot;} //定义LightMode,获取UNITY内部光照变量
	CGPROGRAM
	fixed4 _Diffuse;
</code></pre>
<p>#include &quot;Lighting.cginc&quot;//引入UNITY内置文件，获取光照变量 _LightColor0:第一个直射光的颜色，_WorldSpaceLightPos0.xyz<br>
// Physically based Standard lighting model, and enable shadows on all light types<br>
//#pragma surface surf Standard fullforwardshadows<br>
#pragma vertex vert//声明顶点着色器<br>
#pragma fragment frag//声明片段着色器<br>
// Use shader model 3.0 target, to get nicer looking lighting<br>
//#pragma target 3.0</p>
<pre><code>struct a2v {//从应用程序传递到顶点函数的语义POSITION:顶点坐标，NURMAL:法线(模型空间下)，TEXCOORD0-n:纹理坐标，COLOR:顶点颜色
	float4 vertex:POSITION;//获取顶点坐标
	float3 normal:NORMAL;

};
struct v2f {//从顶点函数传递到片原函数的语义SV_POSITION:(剪裁空间中的顶点坐标-系统直接使用)，COLOR0/COLOR1:可以传递一组值(4个)，TEXCOORD0~7:传递纹理坐标
			//f2s片原函数传递给系统：SV_Target:颜色值-输出到屏幕上的颜色(缓存颜色)
	float4 position:SV_POSITION;
	fixed3 color : COLOR1;
};

v2f vert(a2v v)//顶点之间片段颜色采用插值计算填充
{
	v2f f;
	f.position = UnityObjectToClipPos(v.vertex);//将坐标从模型空间转换到剪裁空间
	//f.temp = v.normal;
	fixed3 amblent = UNITY_LIGHTMODEL_AMBIENT.rgb;//获取系统环境光
	//fixed3 norDir = normalize(unity_WorldToObject(v.normal));//法线方向从世界空间转到模型空间(弃用的方法) 
	fixed3 N = UnityObjectToWorldNormal(v.normal);//法线方向从世界空间转到模型空间 
	fixed3 lightDir = normalize(_WorldSpaceLightPos0.xyz);//第一个直射光的位置，对于顶点来说光的位置即是光的方向
	fixed3 diffuse = _LightColor0.rgb*max(dot(N,lightDir),0)* _Diffuse.rgb;//根据漫反射公式：直射光颜色 * cos夹角(光与法线)获取颜色 dot(a,b):点乘获取两向量的夹角
	f.color = diffuse+amblent;//+:颜色得加(亮度增强),*:融合
	return f;
}


fixed4 frag(v2f f) :SV_Target//片原函数，片段在屏幕上像素颜色，返回颜色值
{
return fixed4(f.color,1);//返回法线
}
	ENDCG
}

}
	FallBack &quot;Diffuse&quot;
</code></pre>
<p>}<br>
——————————————————————————————————<br>
逐像素漫反射：逐个像素计算漫反射计算量大<br>
Shader &quot;Custom/PixivsRander&quot;<br>
{<br>
Properties<br>
{<br>
_Diffuse(&quot;DiffuseColor&quot;, Color) = (1,1,1,1)</p>
<pre><code>}
	SubShader
{
   Pass
{
	Tags {&quot;Lighting&quot; = &quot;ForwardBase&quot;} //定义LightMode,获取UNITY内部光照变量
	CGPROGRAM
	fixed4 _Diffuse;
</code></pre>
<p>#include &quot;Lighting.cginc&quot;//引入UNITY内置文件，获取光照变量 _LightColor0:第一个直射光的颜色，_WorldSpaceLightPos0.xyz<br>
// Physically based Standard lighting model, and enable shadows on all light types<br>
//#pragma surface surf Standard fullforwardshadows<br>
#pragma vertex vert//声明顶点着色器<br>
#pragma fragment frag//声明片段着色器<br>
// Use shader model 3.0 target, to get nicer looking lighting<br>
//#pragma target 3.0</p>
<pre><code>struct a2v {//从应用程序传递到顶点函数的语义POSITION:顶点坐标，NURMAL:法线(模型空间下)，TEXCOORD0-n:纹理坐标，COLOR:顶点颜色
	float4 vertex:POSITION;//获取顶点坐标
	float3 normal:NORMAL;

};
struct v2f {//从顶点函数传递到片原函数的语义SV_POSITION:(剪裁空间中的顶点坐标-系统直接使用)，COLOR0/COLOR1:可以传递一组值(4个)，TEXCOORD0~7:传递纹理坐标
			//f2s片原函数传递给系统：SV_Target:颜色值-输出到屏幕上的颜色(缓存颜色)
	float4 position:SV_POSITION;
	fixed3 wordNormalDir : COLOR1;//向片原函数传递法线
};

v2f vert(a2v v)
{
	v2f f;
	f.position = UnityObjectToClipPos(v.vertex);//将坐标从模型空间转换到剪裁空间
	f.wordNormalDir = UnityObjectToWorldNormal(v.normal);
	return f;
}


fixed4 frag(v2f f) :SV_Target//片原函数，片段在屏幕上像素颜色，返回颜色值
{
	fixed3 amblent = UNITY_LIGHTMODEL_AMBIENT.rgb;//获取系统环境光		
	fixed3 lightDir = normalize(_WorldSpaceLightPos0.xyz);//第一个直射光的位置，对于顶点来说光的位置即是光的方向
	//fixed3 diffuse = _LightColor0.rgb * max(dot(f.wordNormalDir,lightDir),0) * _Diffuse.rgb;//根据漫反射公式：直射光颜色 * cos夹角(光与法线)获取颜色 dot(a,b):点乘获取两向量的夹角
    fixed3 harfLambert =dot(f.wordNormalDir, lightDir)*0.5+0.5;//半兰伯特光照模型:直射光颜色 * (cos夹角(光与法线)*0.5+0.5):使背光面不完全为黑色
	fixed3 diffuse = _LightColor0.rgb * harfLambert * _Diffuse.rgb;
	fixed3 tempColor = diffuse + amblent;//+:颜色得加(亮度增强),*:融合
	return fixed4(tempColor,1);//返回法线
}
	ENDCG
}

}
	FallBack &quot;Diffuse&quot;
</code></pre>
<p>}</p>
</code>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ShaderLab-系统语义]]></title>
        <id>https://Wei715547.github.io/post/shaderlab-xi-tong-yu-yi/</id>
        <link href="https://Wei715547.github.io/post/shaderlab-xi-tong-yu-yi/">
        </link>
        <updated>2020-08-16T08:03:03.000Z</updated>
        <content type="html"><![CDATA[<code>
Shader "Custom/FW03exeable"
{
	SubShader
	{
		Pass
	{
		 CGPROGRAM
// Upgrade NOTE: excluded shader from DX11; has structs without semantics (struct v2f members temp)
#pragma exclude_renderers d3d11
		 #pragma vertex vert//声明顶点着色器
		 #pragma fragment frag//声明片段着色器
<pre><code>	 //定义结构体-方便传值
	 struct a2v {//从应用程序传递到顶点函数的语义POSITION:顶点坐标，NURMAL:法线(模型空间下)，TEXCOORD0-n:纹理坐标，COLOR:顶点颜色
			float4 vertex:POSITION;//获取顶点坐标
			float3 nol:NORMAL;//获取法线方向
			//float4 textcoord:TEXTCOORD0;//获取纹理坐标
		};
	struct v2f {//从顶点函数传递到片原函数的语义SV_POSITION:(剪裁空间中的顶点坐标-系统直接使用)，COLOR0/COLOR1:可以传递一组值(4个)，TEXCOORD0~7:传递纹理坐标
				//f2s片原函数传递给系统：SV_Target:颜色值-输出到屏幕上的颜色(缓存颜色)
			float4 position:SV_POSITION;
			fixed3 temp:COLOR0;	//可用于传递值
		};

	  v2f vert(a2v v)
	  {
		  v2f f;
		  f.position = UnityObjectToClipPos(v.vertex);
		  f.temp = v.nol;
		  return f;
	  }
	 

	fixed4 frag(v2f f) :SV_Target//片原函数，片段在屏幕上像素颜色，返回颜色值
	{
	return fixed4(f.temp,1);//返回法线
	}
   ENDCG
		}

}
	FallBack &quot;Diffuse&quot;
</code></pre>
<p>}<br>
</code><br>
光照模型公式：计算某个点的光照效果<br>
标准光照模型：<br>
1.自发光<br>
2.高光反射 Specular = 直射光*pow(max(cos夹角,0)*高光参数) ，夹角：反射光与视野方向夹角。(夹角越小高光越强,大于90度时即没有高光)；pox(a,b):a的b次方，高光参数取值（1~10）高光参数越大可以看到高光的夹角范围越小<br>
3.漫反射 Diffuse = 直射光颜色 * cos夹角(光与法线)<br>
4.环境光<br>
——————————————————————————————————————<br>
UnityCG.cginc中一些常用函数<br>
摄像机方向<br>
float3 WorldSpaceViewDir(Float4 v)//根据模型空间下的顶点坐标 -》世界空间下从这一点到相机的观察方向（返回值需要归一化）<br>
float3 UnityWorldSpaceViewDir(float4 v)//世界空间中的顶点坐标-》世界空间从这一顶点到摄像机的方向<br>
float3 ObjSpaceViewDir(float4 v)//模型空间中的顶点坐标-》模型空间下这个点到摄像机的观察方向<br>
光源方向<br>
float3 WorldSpaceLightDir(Float4 v)//根据模型空间下的顶点坐标 -》世界空间下从这一点到光源的方向（返回值需要归一化）<br>
float3 UnityWorldSpaceLightDir(float4 v)//世界空间中的顶点坐标-》世界空间从这一顶点到光源的方向<br>
float3 ObjSpaceLightDir(float4 v)//模型空间中的顶点坐标-》模型空间下这个点到光源的观察方向<br>
方向转换<br>
float3 UnityObjectToWorldNormal(float3 norm)//把法线方向 从模型空间转到世界空间<br>
float3 UnityObjectToWorldDir(float3 dir)//把方向 从模型空间转到世界空间<br>
float3 UnityWorldToObjectDir(float3 dir)//把方向 从世界空间转到模型空间</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shader框架]]></title>
        <id>https://Wei715547.github.io/post/shader-kuang-jia/</id>
        <link href="https://Wei715547.github.io/post/shader-kuang-jia/">
        </link>
        <updated>2020-08-15T15:28:26.000Z</updated>
        <content type="html"><![CDATA[<code>
Shader "Custom/FW"
{
	Properties//公开属性
	{
		//_MainTex ("Texture", 2D) = "white" {}
		_Colorcosm("_Colorc",Color) = (1,1,1,1)//属性类型（“属性名字”，属性类型）= 属性值
		_Vector("_Vectorc",Vector) = (1,2,3,4)//float4
		_Int("_Intc",Int) = 2333 //float
		_Float("_Floatc",Float) = 7.5//float
		_Range("_Range",Range(1,11)) = 7//范围值
		_2D("Texture",2D) = "white"{}//sampler2D
		_Cube("Cube",Cube) = "red"{}//samplerCube
		_3D("Texture",3D) = "black"{}//sampler3D
	}
		SubShader//子着色器可以写多个
	{
<pre><code>	Pass//着色器具体绘制方式，同样可以有多个，（尽量写在一个中只提交一次）
	{
		CGPROGRAM//CG语言代码
		//在CG语言中国对公开的属性进行声明
		fixed4 _Color//颜色0~1可用fixed存储
		float4 _Vector
		float _Int
		float _Float
		float _Range
		sampler2D _2D
		samplerCube _Cube
		sampler3D _3D
		#pragma vertex vert//声明顶点着色器
		#pragme fragment frag//声明片段着色器
		//数据类型：float(32位)/half(16万 -60000~+60000)/fixed(11 -2~+2)-不同精度的浮点
		//Integer-整型，sampler-2D贴图，sampleCUBE-六面3D贴图

		 //返回值(坐标) 方法名（参数（坐标）:POSITON(语义)）:SV_POSOTION(返回值语义)
	 //顶点函数：将模型坐标从模型空间(建模时原点坐标)转化到剪裁空间(栅格化)
	  float4 vert(float4 pos:POSITION) :SV_POSITION
	  {
	//通过矩阵将模型空间坐标转化为屏幕剪裁空间下的坐标
	//float4 pos = mul(UNITY_MATRIX_MVP,/*UNITY宏*/pos);//4*4矩阵相乘返回转化后的坐标
	return UnityObjectToClipPos(pos);
	 }

	float4 frag() :SV_Target//片原函数，片段在屏幕上像素颜色，返回颜色值
	{
	return float4 (0.5,1,1,1);//返回白色
	}
		ENDCG
	}
}
	//CostomEditer &quot;&quot;//材质面板自定义样式的脚本路径

	FallBack &quot;Diffuse&quot;//以上SubShader都不支持时执行此路径的Shader，还是不支持时继续找此路径Shader里边的FallBack(都不支持变为粉色)
</code></pre>
<p>}</p>
</code>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式(3)-Builder]]></title>
        <id>https://Wei715547.github.io/post/she-ji-mo-shi-3-builder/</id>
        <link href="https://Wei715547.github.io/post/she-ji-mo-shi-3-builder/">
        </link>
        <updated>2020-08-14T06:18:04.000Z</updated>
        <content type="html"><![CDATA[<p><a href = "https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/builder.html">建造者模式</a></p>
<p>using System;</p>
<p>namespace 设计模式_建造者模式<br>
{<br>
class Program<br>
{</p>
<pre><code>    public abstract class House
    {

    }
    public abstract class Door
    {

    }
    public abstract class Wall
    {

    }
    public abstract class Windins
    {

    }
    public abstract class Floor
    {

    }
    public abstract class HouseCeiling
    {

    }

    public abstract class Builder
    {
        public abstract void BuilderDoor();
        public abstract void BuilderWall();
        public abstract void BuilderWindows();
        public abstract void BuilderFloor();
        public abstract void BuilderHouseCeiling();

        public abstract House GetHouse();
    }

    //客户程序
    static void Main(string[] args)
    {
        House house = GameManager.CreateHouse(new RomaHouseBuilder());
    }

    public class RomanHouse:House
    {

    }

    public class RomaHouseBuilder : Builder
    {
        public override void BuilderDoor()
        {
            throw new NotImplementedException();
        }

        public override void BuilderFloor()
        {
            throw new NotImplementedException();
        }

        public override void BuilderHouseCeiling()
        {
            throw new NotImplementedException();
        }

        public override void BuilderWall()
        {
            throw new NotImplementedException();
        }

        public override void BuilderWindows()
        {
            throw new NotImplementedException();
        }

        public override House GetHouse()
        {
            throw new NotImplementedException();
        }
    }

}
</code></pre>
<p>}</p>
<p>using System;<br>
using System.Collections.Generic;<br>
using System.Text;<br>
using static 设计模式_建造者模式.Program;</p>
<p>namespace 设计模式_建造者模式<br>
{<br>
class GameManager<br>
{<br>
public static House CreateHouse(Builder builder)<br>
{<br>
builder.BuilderDoor();<br>
builder.BuilderDoor();</p>
<pre><code>        builder.BuilderWall();
        builder.BuilderWall();

        builder.BuilderWindows();
        builder.BuilderWindows();

        builder.BuilderFloor();
        builder.BuilderHouseCeiling();

        return builder.GetHouse();
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式(2)-Absstract Factory]]></title>
        <id>https://Wei715547.github.io/post/she-ji-mo-shi-2-absstract-factory/</id>
        <link href="https://Wei715547.github.io/post/she-ji-mo-shi-2-absstract-factory/">
        </link>
        <updated>2020-08-13T15:38:52.000Z</updated>
        <content type="html"><![CDATA[<p><a href= "https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/abstract_factory.html">抽象工厂</a></p>
<p>using System;</p>
<p>namespace 设计模式_抽象工厂<br>
{<br>
class Program<br>
{<br>
public abstract class Road<br>
{</p>
<pre><code>    }
    public abstract class Building
    {

    }
    public abstract class Tunnel
    {

    }
    public abstract class Jungle
    {

    }

    public abstract class FacilitiesFactory
    {
        public abstract Road CreateRoad();
        public abstract Building CreateBuilding();
        public abstract Tunnel CreateTunnel();
        public abstract Jungle CreateJungle();

    }

    //客户程序-GameManager
    class GameManager
    {
        FacilitiesFactory facilitiesFactory;

        public GameManager(FacilitiesFactory facilitiesFactory)
        {
            this.facilitiesFactory = facilitiesFactory;
        }

        public void BuildGameFacilities()
        {
            Road road = facilitiesFactory.CreateRoad();
            Building building = facilitiesFactory.CreateBuilding();
            Tunnel tunnel = facilitiesFactory.CreateTunnel();
            Jungle jungle = facilitiesFactory.CreateJungle();
        }


    }

    static void Main(string[] args)
    {
        GameManager gameManager = new GameManager(new MDFacilitiesFactory ());

        gameManager.BuildGameFacilities();
        
    }
    #region 一种工厂和抽象子类
    public class MDFacilitiesFactory:FacilitiesFactory
    {
        public override Road CreateRoad()
        {
            return new MDRoad();
        }
        public override Building CreateBuilding()
        {
            return new MDBuilding();
        }
        public override Tunnel CreateTunnel()
        {
            return new MDTunnel();
        }
        public override Jungle CreateJungle()
        {
            return new MDJungle();
        }

    }

    public  class MDRoad:Road
    {

    }
    public  class MDBuilding:Building
    {

    }
    public  class MDTunnel:Tunnel
    {

    }
    public  class MDJungle:Jungle
    {

    }
</code></pre>
<p>#endregion<br>
}<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式(1)Singleton]]></title>
        <id>https://Wei715547.github.io/post/she-ji-mo-shi-1singleton/</id>
        <link href="https://Wei715547.github.io/post/she-ji-mo-shi-1singleton/">
        </link>
        <updated>2020-08-12T15:29:22.000Z</updated>
        <content type="html"><![CDATA[<p><a href= "https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/singleton.html">单例模式</a></p>
<p>using System;</p>
<p>namespace 设计模式_单例模式<br>
{<br>
class Program<br>
{<br>
/// <summary><br>
/// 单例模式（不适应与多线程）<br>
/// </summary><br>
public class Singleton<br>
{<br>
private static Singleton insrence;</p>
<pre><code>        private Singleton() { }

        public  static Singleton Instence
        {
            get 
            { 
                if (insrence==null)
                {
                    insrence = new Singleton(); 
                }
                return insrence;
            }
        }
    }
    
    /// &lt;summary&gt;
    /// 适用于多线程
    /// &lt;/summary&gt;
    public class SingletonTrs
    {
        private static volatile SingletonTrs instence;//volatile:保证代码编译后严格按照此执行顺序

        private static object lockHelper = new object();
        private SingletonTrs() { }

        public static SingletonTrs Instence
        {
            get
            {
                //双重检查-多线程访问时保证只生成一个单例
                if (instence == null)
                {
                    lock (lockHelper)
                    {
                        if (instence == null)
                        {
                            instence = new SingletonTrs();
                        }
                    }
                }
                return instence;
            }

        }
    }
    /// &lt;summary&gt;
    /// 适用于多线程
    /// &lt;/summary&gt;
    class Singleton3
    {
        public static readonly Singleton3 Instence = new Singleton3();//内联初始化
        private Singleton3() { }
    }
    /// &lt;summary&gt;
    /// 同上
    /// &lt;/summary&gt;
    class Singletog33
    {
        public static readonly Singletog33 Instence;

        static Singletog33()//放在静态构造器，先于静态属性执行(只会被一个线程执行) 缺点：无法传递参数
        {
            Instence = new Singletog33();
        }
        private Singletog33() { }
    }

    static void Main(string[] args)
    {
        
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[XML]]></title>
        <id>https://Wei715547.github.io/post/xml/</id>
        <link href="https://Wei715547.github.io/post/xml/">
        </link>
        <updated>2020-08-12T08:40:51.000Z</updated>
        <content type="html"><![CDATA[<p>using System;<br>
using System.IO;<br>
using System.Xml;<br>
namespace XML<br>
{<br>
class Program<br>
{<br>
static void Main(string[] args)<br>
{<br>
//string flePath = @&quot;D:\715\CSharp\xml.txt&quot;;<br>
//1.创建XML对象<br>
XmlDocument xmlDoc = new XmlDocument();<br>
//2.创建第一行文件信息，加入doc中<br>
XmlDeclaration doc = xmlDoc.CreateXmlDeclaration(&quot;1.0&quot;, &quot;utf-8&quot;, null);//版本，编码格式<br>
xmlDoc.AppendChild(doc);<br>
//3.创建根节点<br>
XmlElement books = xmlDoc.CreateElement(&quot;Books&quot;);<br>
books.SetAttribute(&quot;书目&quot;, &quot;2.0&quot;);<br>
xmlDoc.AppendChild(books);//将根节点添加到XML表中</p>
<pre><code>        //4.创建根节点的子节点
        XmlElement book1 = xmlDoc.CreateElement(&quot;Book&quot;);
        books.AppendChild(book1);
        //创建子节点的子节点
        XmlElement name1 = xmlDoc.CreateElement(&quot;Name&quot;);
        XmlElement price1 = xmlDoc.CreateElement(&quot;Price&quot;);
        name1.InnerText = &quot;Wei&quot;;
        price1.InnerText = &quot;170&quot;;
        book1.AppendChild(name1);
        book1.AppendChild(price1);

        //根节点的另一个子节点
        XmlElement book2 = xmlDoc.CreateElement(&quot;Book&quot;);
        books.AppendChild(book2);

        XmlElement name2 = xmlDoc.CreateElement(&quot;Name&quot;);
        name2.InnerText = &quot;ZZ&quot;;
        XmlElement price2 = xmlDoc.CreateElement(&quot;Price&quot;);
        price2.InnerText = &quot;150&quot;;
        book2.AppendChild(name2);
        book2.AppendChild(price2);


        xmlDoc.Save(@&quot;D:\715\CSharp\xml.txt&quot;);
        Console.WriteLine(&quot;保持成功&quot;);
        Console.ReadLine();

        /*//追加XML文档
        XmlDocument xmlDoc = new XmlDocument();
        XmlElement root;
        if(File.Exists(@&quot;D:\715\CSharp\xml2.txt&quot;))
        {
            //如存在则加载XML文档
            xmlDoc.Load(@&quot;D:\715\CSharp\xml2.txt&quot;);
            //获取根节点
            root = xmlDoc.DocumentElement;
            
        }
        else
        {
            XmlDeclaration doc = xmlDoc.CreateXmlDeclaration(&quot;1.0&quot;, &quot;utf-8&quot;, null);//版本，编码格式
            xmlDoc.AppendChild(doc);
            //3.创建根节点
            root = xmlDoc.CreateElement(&quot;Books&quot;);
            root.SetAttribute(&quot;书目&quot;, &quot;2.0&quot;);
            xmlDoc.AppendChild(root);//将根节点添加到XML表中
        }

        XmlElement book2 = xmlDoc.CreateElement(&quot;Book&quot;);
        root.AppendChild(book2);

        XmlElement name2 = xmlDoc.CreateElement(&quot;Name&quot;);
        name2.InnerText = &quot;ZL&quot;;
        XmlElement price2 = xmlDoc.CreateElement(&quot;Price&quot;);
        price2.InnerText = &quot;30000&quot;;
        book2.AppendChild(name2);
        book2.AppendChild(price2);
        xmlDoc.Save(@&quot;D:\715\CSharp\xml2.txt&quot;);*/

        /*//读取XML文档
        XmlDocument xmlDoc = new XmlDocument();
        //加载文档获取根节点
        xmlDoc.Load(@&quot;D:\715\CSharp\xml2.txt&quot;);
        XmlElement root = xmlDoc.DocumentElement;
        //获取子节点 返回子节点的集合
        XmlNodeList xnl = root.ChildNodes;

        foreach (XmlNode node in xnl)
        {
            Console.WriteLine(node.InnerText );
        }*/

        /*//Xpath:获取节点属性
        XmlDocument xmlDoc = new XmlDocument();
        xmlDoc.Load(@&quot;D:\715\CSharp\xml2.xml&quot;);
        XmlNodeList nodes = xmlDoc.SelectNodes(&quot;/Books/Book&quot;);

        foreach (XmlNode node in nodes)
        {
            Console.WriteLine(node.Attributes[&quot;W&quot;].Value);
        }*/

        /*//删除节点
        XmlDocument xmlDoc = new XmlDocument();
        xmlDoc.Load(@&quot;D:\715\CSharp\xml2.txt&quot;);
        XmlNode sel = xmlDoc.SelectSingleNode(&quot;/Books/Book&quot;);
        sel.RemoveAll();
        xmlDoc.Save(@&quot;D:\715\CSharp\xml2.xml&quot;);*/

    }
}
</code></pre>
<p>}<br>
<img src="https://Wei715547.github.io/post-images/1597221722705.PNG" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shader Graph]]></title>
        <id>https://Wei715547.github.io/post/shader-graph/</id>
        <link href="https://Wei715547.github.io/post/shader-graph/">
        </link>
        <updated>2020-08-09T08:18:59.000Z</updated>
        <content type="html"><![CDATA[<p>插件：<br>
<img src="https://Wei715547.github.io/post-images/1596961449787.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1596961454813.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1596961458633.PNG" alt="" loading="lazy"></p>
<p>1.模型描边Shader<br>
<img src="https://Wei715547.github.io/post-images/1596962700788.PNG" alt="" loading="lazy"><br>
2.溶解<br>
<img src="https://Wei715547.github.io/post-images/1597055626206.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1597056634207.PNG" alt="" loading="lazy"><br>
3.水面<br>
<img src="https://Wei715547.github.io/post-images/1596962706638.PNG" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DIV-pox]]></title>
        <id>https://Wei715547.github.io/post/div-pox/</id>
        <link href="https://Wei715547.github.io/post/div-pox/">
        </link>
        <updated>2020-08-08T15:12:01.000Z</updated>
        <content type="html"><![CDATA[<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>无标题文档</title>
<style type="text/css">
div{
	height:300px;
	width:300px;
}
div.div1{
	background-color: #F30;
	top:100px;
	left:100px;
	position:absolute;<!--绝对位置-->
	z-index:3;
}
div.div2{
	background-color: #6F0;
	top: 130px;
	left:130px;
	position:absolute;
	z-index:2;
}
div.div3{
	background-color: #00F;
	top:160px;
	left:160px;
	position:absolute;
	z-index:1;
}
div.div5{
<pre><code>right: 0px;
bottom: 0px;
position: fixed;
background-color: #FFC
</code></pre>
<p>}<br>
</style></p>
</head>
<body>
	<div class="div1"></div>
    <div class="div2"></div>
    <div class="div3"></div>
    <br />
    <div class="div5"></div>
    <br /><br /><br /><br /><br /><br /><br /><br />
    <br /><br /><br /><br /><br /><br /><br /><br />
    <br /><br /><br /><br /><br /><br /><br /><br />
    <br /><br /><br /><br /><br /><br /><br /><br />
    <br /><br /><br /><br /><br /><br /><br /><br />
    <br /><br /><br /><br /><br /><br /><br /><br />
    <br /><br /><br /><br /><br /><br /><br /><br />
</body>
</html>
<p>布局：</p>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>无标题文档</title>
<style type="text/css">
	.divIndex{
		width:900px;
		height:2000px;
		background-color: #9F6; 
		margin: 0px auto;<!--两个参数是时，上下：左右-->
	}
	.divLog{
			width:900px;
			height:100px;
			background-color: #F90
		}
	.divContent{
		width:900px;
		height:300px;
		background-color:#3FF	
	}
	.divLeft{
		width:300px;
		height:300px;
		background-color:#F9C;
		float:left;
	}
	.divRight{
		width:600px;
		height:300px;
		background-color:#CCC;
		float:left
	}
</style>
</head>
<body>
	<div class="divIndex">
    	<div class="divLog">
        </div>
        <div class="divContent">
        <div class="divLeft"></div>
        <div class="divRight"></div>
        </div>
    </div>
</body>
</html>
<p>实例：</p>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>综合布局</title>
<style type="text/css">
*{
	margin:0px;
	font-size:12px;
}
	div.divIndex{
		height: 380px;
		width:290px;
		background-color:#F8F8F8;
		margin:0px auto;
	}
	.div1{
		width: 290px;
		height:35px;
		background-color:#6FF;
		
		color:#FFF;
		text-align:center
	}
	div.div1 p{
		padding: 8px;
		font-size:17px;
	}
	#table1{
		width: 290px;
	}
	td.td1{
		font-weight: bolder;
	}
	td.td2{
		color:#246082;
		padding:5px;
		border-bottom-style: dashed;
		border-bottom:qpx dashed #123456;
	}
	td.td3{
		font-weight: bolder;
		color:#F00;
		border-bottom:1px dashed #cccccc;
		text-align:right;
	}
	div.divTable{
		margin:0px auto;
	}
</style>
</head>
<body>
	<div class="divIndex">
    	<table id="table1" >
        	<tr>
            	<td> <div class="div1"><p>.Net信息</p></div>
            </tr>
            <tr>
            	<td>
                <div class="divTable">
                	<table width="290px">
                    	<tr>
                        	<td width="92" class="td1">WEI</td>
                            <td width="157"></td>
                        </tr>
                        <tr>
                        	<td class="td2">北京--2020年9-9</td>
                            <td class="td3">预约报名中</td>
                        </tr>
                        <tr>
                        	<td class="td2">北京--2020年9-9</td>
                            <td class="td3">预约报名中</td>
                        </tr>
                        <tr>
                        	<td class="td2">北京--2020年9-9</td>
                            <td class="td3">预约报名中</td>
                        </tr>
                        <tr>
                        	<td class="td1">WEI</td>
                            <td></td>
                        </tr>
                        <tr>
                        	<td class="td2">北京--2020年9-9</td>
                            <td class="td3">预约报名中</td>
                        </tr>
                        <tr>
                        	<td class="td2">北京--2020年9-9</td>
                            <td class="td3">预约报名中</td>
                        </tr>
                        <tr>
                        	<td class="td2">北京--2020年9-9</td>
                            <td class="td3">预约报名中</td>
                        </tr>
                    </table>
                    </div>
                </td>
            </tr>
        </table>
    </div>
</body>
</html>
]]></content>
    </entry>
</feed>