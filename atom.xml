<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Wei715547.github.io</id>
    <title>WeiBlog</title>
    <updated>2021-03-05T08:47:22.060Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Wei715547.github.io"/>
    <link rel="self" href="https://Wei715547.github.io/atom.xml"/>
    <subtitle>年月增长，我宜强盛。
用于Unity+开发的技术积累</subtitle>
    <logo>https://Wei715547.github.io/images/avatar.png</logo>
    <icon>https://Wei715547.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, WeiBlog</rights>
    <entry>
        <title type="html"><![CDATA[Blender材质节点(更新ing)]]></title>
        <id>https://Wei715547.github.io/post/blender-cai-zhi-jie-dian/</id>
        <link href="https://Wei715547.github.io/post/blender-cai-zhi-jie-dian/">
        </link>
        <updated>2021-01-23T05:35:19.000Z</updated>
        <content type="html"><![CDATA[<p><strong>一、输入</strong><br>
<strong>1.物体信息</strong><br>
位置：模型中心到世界原点的距离<br>
颜色：物体属性中视图显示中的物体颜色与材质无关<br>
物体编号<br>
材质编号<br>
随机：物体生成时随机产生的0~1之间的值<br>
变化不同位置产生颜色变化示例<br>
<img src="https://Wei715547.github.io/post-images/1611381548318.PNG" alt="" loading="lazy"><br>
<strong>2.属性</strong>：可获取顶点颜色<br>
<img src="https://Wei715547.github.io/post-images/1611383219732.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1611383224559.PNG" alt="" loading="lazy"><br>
<strong>3.倒角</strong>：Cycles适用，在视图显示中产生倒角效果（使用连接至着色器法相）<br>
<strong>4.顶点颜色</strong>：低点颜色与Alpha通道，多用于遮罩<br>
<img src="https://Wei715547.github.io/post-images/1611466142579.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1611466149778.PNG" alt="" loading="lazy"><br>
<strong>6.黑体节点</strong>：色温黑体辐射K，可用于Cycles光源色温标准输出，自发光物体发光颜色<br>
<img src="https://Wei715547.github.io/post-images/1611475715838.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1611477570439.PNG" alt="" loading="lazy"><br>
<strong>7.波长</strong><br>
<img src="https://Wei715547.github.io/post-images/1611479151358.PNG" alt="" loading="lazy"><br>
<strong>8.映射</strong>：纹理空间在模型面上的投影，包括，位置旋转缩放<br>
类型：点，先计算缩放然后旋转位置<br>
纹理，先计算位置然后旋转缩放<br>
矢量，不计算位置<br>
法向，归一化后的矢量<br>
<img src="https://Wei715547.github.io/post-images/1611808408345.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1611808414557.PNG" alt="" loading="lazy"><br>
<strong>9.矢量变换</strong>：对矢量(点包含位置)进行不同空间坐标系下的转换：物体、世界、相机(屏幕剪切空间)<br>
<img src="https://Wei715547.github.io/post-images/1611833642696.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1611841772393.PNG" alt="" loading="lazy"><br>
<strong>10.钳制</strong>：对数值范围进行限制<br>
<img src="https://Wei715547.github.io/post-images/1611890049132.PNG" alt="" loading="lazy"><br>
<strong>11.映射范围</strong>：从a,b映射到c,d。包含：线性，阶梯，平滑等插值类型<br>
<img src="https://Wei715547.github.io/post-images/1611892237631.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1611892245272.PNG" alt="" loading="lazy"><br>
<strong>12.透明着色器</strong><br>
<img src="https://Wei715547.github.io/post-images/1611893692097.PNG" alt="" loading="lazy"><br>
<strong>13.线框</strong>显示网格线框<br>
<img src="https://Wei715547.github.io/post-images/1611978489940.PNG" alt="" loading="lazy"><br>
<strong>14.白噪波纹理</strong>：随机值生成1-4D<br>
<img src="https://Wei715547.github.io/post-images/1611981742064.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1611981746778.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1611981752413.PNG" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[卡通Shader]]></title>
        <id>https://Wei715547.github.io/post/qia-tong-shader/</id>
        <link href="https://Wei715547.github.io/post/qia-tong-shader/">
        </link>
        <updated>2021-01-22T15:02:01.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://Wei715547.github.io/post-images/1611328235122.PNG" alt="" loading="lazy"><br>
Shader &quot;Shader103.5/Rimlight&quot;<br>
{<br>
Properties<br>
{<br>
_MainTex(&quot;Base texture&quot;, 2D) = &quot;white&quot; {}<br>
_RampTex(&quot;Ramp texture&quot;, 2D) = &quot;white&quot; {}</p>
<pre><code>	_AmbientStrength(&quot;Ambient Strength&quot;,Range(0,1.0)) = 0.1
	_DiffStrength(&quot;Diff Strength&quot;,Range(0,1.0)) = 0.1
	_SpecStrength(&quot;Spec Strength&quot;,Range(0,5.0)) = 0.1
	_RimStrength(&quot;Rim Strength&quot;,Range(0,1.0)) = 0.1
	_RimAmount(&quot;Rim Amount&quot;,Range(0,1.0)) = 0.1

	_SpecPow(&quot;Specular Pow&quot;,int) = 0.5
	_Brightness(&quot;Brightness&quot;,Range(0,1.0)) = 0.5
	_TintColor(&quot;Tint Color&quot;,Color) = (1.0,1.0,1.0,1.0)
	_OutlineAmount(&quot;OutlineAmount&quot;,Range(0,1.0)) = 0.1
	_OutlineColor(&quot;OutlineColor&quot;,Color) = (0,0,0,0)
}

SubShader
{
	Tags
	{
		&quot;LightMode&quot; = &quot;ForwardBase&quot;
		&quot;PassFlags&quot; = &quot;OnlyDirectional&quot;
	}
	Pass
	{
		CGPROGRAM
		#pragma vertex vert
		#pragma fragment frag
		#include &quot;UnityLightingCommon.cginc&quot; // for _LightColor0
		#include &quot;UnityCG.cginc&quot;

		struct appdata
		{
			float4 vertex : POSITION;
			float3 normal : NORMAL;
			float2 uv: TEXCOORD0;
		};

		struct v2f
		{
			float4 vertex : SV_POSITION;
			float3 normal : NORMAL;
			float2 uv: TEXCOORD0;
			float3 viewDir : TEXCOORD1;
		};

		v2f vert(appdata v)
		{
			v2f o;
			o.uv = v.uv;
			o.vertex = UnityObjectToClipPos(v.vertex);
			o.normal = UnityObjectToWorldNormal(v.normal);
			o.viewDir = normalize(_WorldSpaceCameraPos.xyz - mul(unity_ObjectToWorld, v.vertex).xyz);
			return o;
		}

		sampler2D _MainTex;
		sampler2D _RampTex;

		float _AmbientStrength;
		float _SpecStrength;
		float _DiffStrength;
		float _RimStrength;
		float _RimAmount;

		float4 _TintColor;
		float4 _RimColor;
		float _SpecPow;
		float _Brightness;
		float _OutlineAmount;
		float4 _OutlineColor;

		float4 frag(v2f i) : SV_Target
		{
			float4 baseColor = tex2D(_MainTex, i.uv) ;
			float3 normal = normalize(i.normal);
			//ambient
			float3 ambient = _LightColor0 * _AmbientStrength;

			//diffuse
			float NdotL = dot(i.normal, _WorldSpaceLightPos0);
			float2 uv = float2((NdotL * 0.5 + 0.5), 0);
			float3 ramp = tex2D(_RampTex, uv);

			float3 diff = (NdotL &lt; 0) ? 0 : 1 * _LightColor0 * _DiffStrength;// 把(NdotL &lt; 0) ? 0 : 1 改成ramp 如果需要用自己的texture

			//specular
			float3 reflectDir = reflect(-_WorldSpaceLightPos0, normal);
			float spec = pow(max(dot(i.viewDir, reflectDir), 0.0), _SpecPow);
			float3 specSmooth = smoothstep(0.005, 0.01, spec) * _LightColor0 * _SpecStrength;

			//rimlight
			float NdotV = 1 - dot(i.normal, i.viewDir);
			float rimSmooth = max(0,NdotL) * smoothstep(_RimAmount - 0.01, _RimAmount + 0.01, NdotV) ;
			float3 rimlight = rimSmooth * _LightColor0 * _RimStrength;

			////Solid color outline
			float4 final_color;
			if (NdotV &lt; _OutlineAmount) {
				final_color = float4((diff + ambient + specSmooth + rimlight), 1.0) * _Brightness * baseColor * _TintColor;
			}
			else {
				final_color = _OutlineColor;
			}

			//final color
			//float4 final_color = float4((diff + ambient+ specSmooth + rimlight),1.0) * _Brightness * baseColor * _TintColor;
			
			return final_color;
		}
		ENDCG
	}
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leet Code1~500持续更新]]></title>
        <id>https://Wei715547.github.io/post/leet-code1~500-chi-xu-geng-xin/</id>
        <link href="https://Wei715547.github.io/post/leet-code1~500-chi-xu-geng-xin/">
        </link>
        <updated>2021-01-02T12:12:34.000Z</updated>
        <content type="html"><![CDATA[<p><a href ="https://leetcode-cn.com/problemset/all/"><strong>LeetCode题库</strong></a><br>
<strong>排序查找算法、冒泡/选择/插入/快排/二分查找</strong><br>
/// <summary><br>
/// 冒泡排序<br>
/// </summary><br>
/// <param name="array"></param><br>
public static void BubbleSort(int [] nums)<br>
{<br>
for (int i = 0; i &lt; nums.Length; i++)<br>
{<br>
for (int j = 0; j &lt; nums.Length-1-i; j++)<br>
{<br>
if (nums[j] &gt; nums[j + 1])<br>
Swap(ref nums[j], ref nums[j + 1]);<br>
}<br>
}<br>
}<br>
/// <summary><br>
/// 选择排序：默认第一个为最小值，在后面找到更小的时就和默认最小的交换。再默认第二个为最小往下循环。<br>
/// </summary><br>
/// <param name="array"></param><br>
static void ChooseSort(int[] array)<br>
{<br>
for (int i = 0; i &lt; array.Length-1; i++)<br>
{<br>
int minnum = array[i];<br>
int minindex = i;<br>
for (int j = i+1; j &lt; array.Length; j++)<br>
{<br>
if(array[j]&lt;minnum)<br>
{<br>
minnum = array[j];<br>
minindex = j;<br>
}<br>
}<br>
if(minindex!=i)<br>
{<br>
int temp = array[i];<br>
array[i] = minnum;<br>
array[minindex] = temp;<br>
}<br>
}<br>
}<br>
/// <summary><br>
/// 直插排序<br>
/// </summary><br>
/// <param name="array"></param><br>
public static void InsertSort2(int[] nums)<br>
{<br>
int index, value;<br>
for (int i = 1; i &lt; nums.Length; i++)<br>
{<br>
value = nums[i];<br>
index = i-1;<br>
while(index&gt;=0&amp;&amp;nums[index]&gt;value)<br>
{<br>
nums[index+1] = nums[index];<br>
index -= 1;<br>
}<br>
nums[index+1] = value;<br>
}<br>
}<br>
//快速排序<br>
static void Qsort(int[] array,int left,int right)<br>
{<br>
if(left&lt;right)<br>
{<br>
int i = left;<br>
int j = right + 1;<br>
int provt = array[i];<br>
do<br>
{<br>
do i++; while (array[i] &lt; provt &amp;&amp; i &lt; array.Length-1);<br>
do j--; while (array[j] &gt; provt &amp;&amp; j &gt;= 0);<br>
if(i&lt;j)<br>
{<br>
Swap(ref array[i], ref array[j]);<br>
}<br>
} while (i&lt;j);<br>
Swap(ref array[left], ref array[j]);<br>
Qsort(array, left, j - 1);<br>
Qsort(array, j + 1, right);<br>
}<br>
}<br>
//二分查找<br>
static int BinarySearch_R(int[] dateArray, int x, int left, int right)<br>
{<br>
if (left &lt;= right)<br>
{<br>
int mind = (left + right) / 2;<br>
if (x &lt; dateArray[mind])<br>
return BinarySearch_R(dateArray, x, left, mind - 1);<br>
else if (x &gt; dateArray[mind])<br>
return BinarySearch_R(dateArray, x, mind + 1, right);<br>
else if (x == dateArray[mind])<br>
return mind;<br>
}<br>
return -1;<br>
}<br>
<strong>/// 三数之和</strong><br>
public static List&lt;List<int>&gt; ThreeSum(int[] nums)<br>
{<br>
List&lt;List<int>&gt; res = new List&lt;List<int>&gt;();//返回值<br>
Array.Sort<int>(nums);//对数组进行排序<br>
if (nums == null || nums[0] &gt;= 0 || nums.Length &lt; 3) return res;//数组为空，排序后最小值大于0，长度小于3，则没有结果返回空列表<br>
for (int i = 0; i &lt; nums.Length-2; i++)//外部总循环次数小于长度减2，由于包含satrt与end两个位置指针<br>
{<br>
if(i<mark>0||nums[i]!=nums[i-1])//首次循环或不重复时执行<br>
{<br>
int start = i + 1;//左指针较小的值，结果小于0时右移<br>
int end = nums.Length - 1;//右指针较大的值，结果大于0时向左移<br>
while(start&lt;end)//内循环左指针小于右指针<br>
{<br>
if (nums[i] + nums[start] + nums[end] == 0)//满足条件将结果加入返回列表<br>
{<br>
res.Add(new List<int> { nums[i], nums[start], nums[end] });<br>
start++;//左指针右移<br>
end--;//右指针左移//寻找其他满足条件的组合<br>
while (start &lt; end &amp;&amp; nums[start] == nums[start - 1])//保证不与之前的值重复<br>
start++;<br>
while (start &lt; end &amp;&amp; nums[end] == nums[end + 1])//保证不与之前的值重复<br>
end--;<br>
}else if(nums[i] + nums[start] + nums[end]&lt;0)//小于0，start右移到更大的数<br>
{<br>
start++;<br>
}else//大于0，end左移到更小的数<br>
{<br>
end--;<br>
}<br>
}<br>
}<br>
}<br>
return res;<br>
}<br>
/// <summary><br>
** /// 19:删除链表d第n个节点**<br>
/// </summary><br>
/// <param name="head"></param><br>
/// <param name="n"></param><br>
/// <returns></returns><br>
public ListNode RemoveNthFromEnd(ListNode head, int n)<br>
{<br>
if (head == null || head.next == null) return null;<br>
ListNode dummy = new ListNode();<br>
dummy.next = head;<br>
ListNode l = dummy;<br>
ListNode r = dummy;<br>
for (int i = 0; i &lt; n; i++)<br>
{<br>
r = r.next;<br>
}<br>
while(r.next!=null)<br>
{<br>
l = l.next;<br>
r = r.next;<br>
}<br>
l.next = l.next.next;<br>
return dummy.next;<br>
}<br>
<strong>20.有效括号(B站面试题)</strong><br>
/// <summary><br>
/// 有效括号<br>
/// </summary><br>
class LeetCode20<br>
{<br>
public static bool IsValid(string s)<br>
{<br>
Stack<char> st = new Stack<char>();<br>
foreach (char c in s)<br>
{<br>
if(c</mark>'('||c=='['||c=='{')<br>
{<br>
st.Push(c);<br>
}else<br>
{<br>
if (st.Count == 0)<br>
return false;<br>
else<br>
{<br>
char temp = st.Pop();<br>
if (c == ')')<br>
{<br>
if (temp != '(')<br>
return false;<br>
}<br>
else if (c == ']')<br>
{<br>
if (temp != '[')<br>
return false;<br>
}<br>
else if (c == '}')<br>
{<br>
if (temp != '{')<br>
return false;<br>
}<br>
}<br>
}<br>
}<br>
return st.Count == 0;<br>
}<br>
}<br>
/// <summary><br>
/// 移除元素：给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。<br>
/// </summary><br>
class LC27<br>
{<br>
//将与val相等的值都移动到数组最右边，<br>
public static int RemoveEle(int [] nums,int value)<br>
{<br>
if (nums == null || nums.Length == 0)<br>
return 0;<br>
int l = 0;<br>
int r = nums.Length - 1;<br>
while(l&lt;r)<br>
{<br>
while(l&lt;r&amp;&amp;nums[l]!=value)//左指针找与val相等的值<br>
{<br>
l++;<br>
}<br>
while(l&lt;r&amp;&amp;nums[r]==value)//右指针找与val不相等的值<br>
{<br>
r--;<br>
}<br>
int temp = nums[l];<br>
nums[l] = nums[r];<br>
nums[r] = temp;<br>
}<br>
return nums[l] == value ? l : l + 1;//最后一个与val相等的值先被左指针找到，左指针位置的索引即移除val后的，前面元素的长度(数组从0开始)。<br>
最后与val相等的值先被右指针找到，则l指向的即是不重复元素的中一个元素，数组索引值比实际长度小1，即返回l+1<br>
}<br>
}<br>
<strong>————————————————————————————————————</strong><br>
<strong>48.旋转图像</strong><br>
class LC48<br>
{<br>
public static void rotate(int[][] matrix)<br>
{<br>
int n = matrix[0].Length;<br>
if (n == 0 || n == 1) return;</p>
<pre><code>        for (int start = 0, end = n - 1; start &lt; end; start++, end--)
        { //控制旋转层数（不断缩小圈的范围）
            int s = start; int e = end;
            while (s &lt; end)
            { //完成一圈的旋转
                int temp = matrix[start][s]; //temp&lt;-左上角值
                matrix[start][s] = matrix[e][start]; //左上角&lt;-左下角
                matrix[e][start] = matrix[end][e];  //左下角&lt;-右下角
                matrix[end][e] = matrix[s][end];  //右下角&lt;-右上角
                matrix[s][end] = temp; //右上角&lt;-temp
                s++; e--; //向右平移该层的圈
            }
        }
    }
}
</code></pre>
<p><strong>————————————————————————————————————</strong><br>
<strong>49.字母异为词分组</strong><br>
class LC49<br>
{<br>
public static List&lt;List<string>&gt; GroupAnagrams(string[] strs)<br>
{<br>
//可变字符串：存储排序后的字符数组转为字符串<br>
StringBuilder key = new StringBuilder();<br>
//字典：键：排序后相同的字符(串有相同字符组成)，值：由相同字符组成的字符串数组<br>
Dictionary&lt;string, List<string>&gt; strsGroupDict = new Dictionary&lt;string, List<string>&gt;();<br>
//遍历字符串数组中每个字符串<br>
foreach (string s in strs)<br>
{<br>
char[] temp = s.ToCharArray();//字符串转为字符数组，用于排序<br>
Array.Sort(temp);//调用数组类静态排序方法<br>
key.Clear();//添加前先请空可变字符串<br>
foreach (char c in temp)//将字符数组的每个字符添加到可变字符串<br>
{<br>
key.Append(c);<br>
}<br>
if (!strsGroupDict.ContainsKey(key.ToString()))//判断字典的键中是否包含此排序后的字符串<br>
{<br>
//不包含则新建键值对，键：此排序后的字符串，值：新建字符串可变数组(存储由相同字符组成的字符串)<br>
strsGroupDict.Add(key.ToString(), new List<string>());<br>
}<br>
//创建后/或已经存在键的情况下，将当前字符添加到可变数组中<br>
strsGroupDict[key.ToString()].Add(s);<br>
}<br>
return new List&lt;List<string>&gt;(strsGroupDict.Values);//返回数组类表，即字典的所有值<br>
}<br>
}<br>
<strong>LC53.最大子数组和</strong><br>
/// <summary><br>
/// 给定一个整数数组 nums ，<br>
/// 找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>
/// </summary><br>
class LC53最大子数组和<br>
{<br>
public int MaxSubArray(int[] nums)<br>
{<br>
if (nums == null || nums.Length == 0)<br>
return 0;</p>
<pre><code>        int res = nums[0];
        int sum = 0;
        foreach (int n in nums)
        {
            if (sum &gt; 0)//都为正数时所有元素和即为最大
                sum += n;//连续数相加的最大值，小于0时说明有负数加入，
            else//都为负数时即得到最大的负数
                sum = n;//出现和小于0有负数加入，找到下一个从正数开始的元素
            res = Math.Max(res, sum);//每次填入一个数时会取res，sum最大的值
        }
        return res;
    }
}
/// &lt;summary&gt;
    /// 动态规划
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;nums&quot;&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public static int Maxsubarray2(int[] nums)
    {
        List&lt;int&gt; memolist = new List&lt;int&gt;();//动态规划列表
        memolist.Add(nums[0]);
        for (int i = 1; i &lt; nums.Length; i++)            
            memolist.Add(Math.Max(nums[i] + memolist[i - 1], nums[i]));//判断当前元素计入子数组和后，与当前元素值比较，取大值决定计入总和还是从当前开始
        memolist.Sort((a, b) =&gt; a &gt; b?-1:1);//取动态规划数组中的最大值返回，避免首位就值最大
        return memolist[0];
    }
</code></pre>
<p><strong>//128.最长连续序列</strong><br>
public static int LongestConsecutive(int[] nums)<br>
{<br>
if (nums == null || nums.Length == 0) return 0;</p>
<pre><code>        Array.Sort(nums);//排序后去重
        HashSet&lt;int&gt; set = new HashSet&lt;int&gt;();//使用集合不要求在原数组中连续
        for (int i = 0; i &lt; nums.Length; i++)
        {
            set.Add(nums[i]);
        }

        List&lt;int&gt; reslist = new List&lt;int&gt;();//结果列表，长度即为返回值
        int res = 1;//数组长度大于0则至少返回1；
        foreach (int n in set)
        {
            if (reslist.Count!=0 &amp;&amp; reslist[reslist.Count - 1] + 1 == n)//不为空且连续时，计入返回列表
            {
                reslist.Add(n);
                res = Math.Max(res, reslist.Count);//取返回列表长度最大值
            }
            else
            {
                reslist.Clear();//不连续时清空，重新计入
                reslist.Add(n);
            }
        }
        return res;
    }
</code></pre>
<p><strong>//134.加油站</strong><br>
public int CanCompleteCircuit(int[] gas, int[] cost)<br>
{<br>
int allgas = 0;<br>
int allcast = 0;<br>
for (int i = 0; i &lt; gas.Length; i++)<br>
{<br>
allgas += gas[i];<br>
allcast += cost[i];<br>
}<br>
if (allgas &lt; allcast) return -1;<br>
int gascurten = 0;<br>
int start = 0;<br>
for (int i = 0; i &lt; gas.Length; i++)<br>
{<br>
gascurten = gascurten + gas[i] - cost[i];<br>
if (gascurten &lt; 0)<br>
{<br>
gascurten = 0;<br>
start = i + 1;<br>
}<br>
}<br>
return start;<br>
}<br>
<strong>//152.乘积最大子数组</strong><br>
public static int MaxSubProduct(int[]nums)<br>
{<br>
List<int> memomax = new List<int>();<br>
List<int> memomin = new List<int>();<br>
memomax.Add(nums[0]);<br>
memomin.Add(nums[0]);<br>
for (int i = 1; i &lt; nums.Length; i++)<br>
{<br>
memomax.Add(Math.Max(Math.Max(nums[i]*memomax[i - 1], nums[i]*memomin[i-1]), nums[i]));<br>
memomin.Add(Math.Min( Math.Min(nums[i] * memomin[i - 1],nums[i]*memomax[i-1]), nums[i]));<br>
}<br>
memomax.Sort();<br>
return memomax[memomax.Count - 1];<br>
}<br>
<strong>// 153. 寻找旋转排序数组中的最小值</strong><br>
:假设按照升序排序的数组在预先未知的某个点上进行了旋转。例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] 。<br>
public int FindMin(int[] nums)<br>
{<br>
//长度为1或未旋转时返回首位<br>
if (nums.Length == 1 || nums[nums.Length - 1] &gt; nums[0]) return nums[0];<br>
//二分查找<br>
int left = 0;<br>
int right = nums.Length - 1;</p>
<pre><code>        while(left&lt;right)
        {
            int mid = left + (right - left) / 2;//中间值索引

            if (nums[mid] &gt; nums[mid + 1])//中间值恰好为旋转前的末尾最大值，则mid+1即为最小值
                return nums[mid + 1];
            else if (nums[mid] &lt; nums[mid - 1])//中间值恰好指向旋转前的最小值，则返回m
                return nums[mid];
            else if (nums[mid] &gt; nums[left])//其他情况mid落在旋转后的两端数组中间时
                left = mid + 1;//mid比left大则落在左半边，最小值在右边
            else
                right = mid - 1;//mid比left小则落在右半边，最小值在左边
        }
        return nums[0];//语法条件返回值无意义
    }
</code></pre>
<p><strong>class LC54螺旋矩阵</strong><br>
{<br>
public List<int> SpiralOrder(int[][] matrix)<br>
{<br>
if (matrix == null || matrix.Length == 0) return new List<int>();</p>
<pre><code>        //数组边界值
        int top = 0,left = 0;
        int bottom = matrix.Length - 1, right = matrix[0].Length - 1;

        int direction = 1;//1,2,3,4：右下左上
        List&lt;int&gt; res = new List&lt;int&gt;();
        while (left &lt;= right &amp;&amp; top &lt;= bottom)
        {
            switch (direction)
            {
                case 1://右移
                        for (int i = left; i &lt;= right; i++)//从左到右遍历
                            res.Add(matrix[top][i]);//第一行从左到右加入返回列表
                        top += 1;//第一行遍历结束加一到下一行
                        direction = 2;
                    break;
                case 2://下移
                        for (int i = top; i &lt;= bottom; i++)//从上到下遍历
                            res.Add(matrix[i][right]);//最后一列从上到下
                        right -= 1;//左后一列遍历后减1，下次遍历前一列
                        direction = 3;
                    break;
                case 3://左移
                        for (int i = right; i &gt;=left ; i--)//从右到左遍历
                            res.Add(matrix[bottom][i]);//最后一行从右到左遍历
                        bottom -= 1;//遍历结束，下次从右到左遍历上一行
                        direction = 4;
                    break;
                case 4://上移
                        for (int i = bottom; i &gt;=top ; i--)//从下到上遍历
                            res.Add(matrix[i][left]);//第一列从下到上遍历，
                        left += 1;//下次从下到上遍历下一列
                        direction = 1;
                    break;
            }
        }
        return res;
    }
}
</code></pre>
<p>** // 55.跳跃游戏** ,贪心算法：maxjunp初始为最大索引，当前一个索引与此数组索引值相加大于maxump时则一定可以到达maxjump,maxjump一道前一个索引位置，最后判断maxjump是否等于0则返回true否则说明中间断开返回false<br>
public bool Jump(int [] nums)<br>
{<br>
int maxjump = nums.Length;<br>
for (int i = nums.Length-2; i &gt;=0 ; i--)<br>
{<br>
if (i + nums[i] &gt;= maxjump)<br>
maxjump = i;<br>
}<br>
return maxjump == 0 ? true : false;<br>
}</p>
<p><strong>class LC62不同路径</strong><br>
{<br>
/// <summary><br>
/// 动态规划，dp[m,n] = dp[m-1,n]+dp[m,n-1];<br>
/// </summary><br>
/// <param name="m"></param><br>
/// <param name="n"></param><br>
/// <returns></returns><br>
public int UniquePaths(int m, int n)<br>
{<br>
int[,] dp = new int[m,n];<br>
dp[0,0] = 1;<br>
for (int i = 0; i &lt; m; i++)<br>
{<br>
for (int j = 0; j &lt; n; j++)<br>
{<br>
if (i - 1 &gt;= 0 &amp;&amp; i - 1 &lt; m)<br>
dp[i, j] += dp[i - 1,j];<br>
if (j - 1 &gt;= 0 &amp;&amp; j - 1 &lt; n)<br>
dp[i, j] += dp[i, j - 1];<br>
}<br>
}<br>
return dp[m - 1, n - 1];</p>
<pre><code>    }
}
public int UniquePath2(int m, int n)
    {
        int[,] dp = new int[m, n];
        for (int i = 0; i &lt; m; i++)
            dp[i, 0] = 1;
        for (int i = 0; i &lt; n; i++)
            dp[0, n] = 1;
        for (int i = 1; i &lt; m; i++)
        {
            for (int j = 1; j &lt; n; j++)
            {
                dp[i, j] = dp[i, j - 1] + dp[i - 1, j];
            }
        }
        return dp[m - 1, n - 1];
    }
</code></pre>
<p><strong>66.加一</strong><br>
public int[] PlusOne(int[] digits)<br>
{<br>
for (int i = digits.Length - 1; i &gt;= 0; i--)<br>
{<br>
if (digits[i] != 9)<br>
{<br>
digits[i] += 1;<br>
return digits;<br>
}<br>
else<br>
digits[i] = 0;<br>
}<br>
List<int> res = new List<int>(digits);<br>
res.Insert(0, 1);<br>
return res.ToArray();<br>
}<br>
<strong>70.爬楼梯</strong><br>
public int ClimbStairs(int n)<br>
{<br>
if (n &lt; 2) return 1;<br>
int[] res = new int[n];<br>
res[0] = 1;<br>
res[1] = 2;<br>
for (int i = 2; i &lt; n; i++)<br>
{<br>
res[i] = res[i - 1] + res[i - 2];<br>
}<br>
return res[n - 1];<br>
}<br>
<strong>//73,矩阵置0</strong><br>
public void SetZeroes(int[][] matrix)<br>
{<br>
bool firstoColContentZero = false;<br>
bool firstoRowContentZero = false;<br>
//检测第一列是否有0<br>
for (int i = 0; i &lt; matrix.Length; i++)<br>
{<br>
if (matrix[i][0] == 0)<br>
firstoColContentZero = true;<br>
}<br>
//检查第一行是否有0<br>
for (int i = 0; i &lt; matrix[0].Length; i++)<br>
{<br>
if (matrix[0][i] == 0)<br>
firstoRowContentZero = true;<br>
}<br>
//使用第一行与第一列标记0<br>
for (int i = 1; i &lt; matrix.Length; i++)<br>
{<br>
for (int j = 1; j &lt; matrix[0].Length; j++)<br>
{<br>
if(matrix[i][j]==0)<br>
{<br>
matrix[i][0] = 0;<br>
matrix[0][j] = 0;<br>
}<br>
}<br>
}<br>
//使用第一行列中的0处理矩阵中的元素<br>
for (int i = 1; i &lt; matrix.Length; i++)<br>
{<br>
for (int j = 1; j &lt; matrix[0].Length; j++)<br>
{<br>
if (matrix[i][0] == 0 || matrix[0][j] == 0)<br>
matrix[i][j] = 0;<br>
}<br>
}<br>
//首行存在0，本行全部置为0<br>
if(firstoRowContentZero)<br>
{<br>
for (int i = 0; i &lt; matrix[0].Length; i++)<br>
{<br>
matrix[0][i] = 0;<br>
}<br>
}<br>
//首列存在0，本列全部置为0<br>
if(firstoColContentZero)<br>
{<br>
for (int i = 0; i &lt; matrix.Length; i++)<br>
{<br>
matrix[i][0] = 0;<br>
}<br>
}<br>
}<br>
<strong>//83.删除链表重复元素</strong><br>
public ListNode DeleteDuplicates(ListNode head)<br>
{<br>
if (head == null) return head;<br>
HashSet<int> set = new HashSet<int>();<br>
ListNode res = new ListNode();<br>
res.next = head;<br>
ListNode pov = new ListNode();<br>
pov.next = head;<br>
while (head != null)<br>
{<br>
if (!set.Contains(head.val))<br>
{<br>
set.Add(head.val);<br>
head = head.next;<br>
pov = pov.next;<br>
}<br>
else<br>
{<br>
pov.next = head.next;<br>
head = head.next;<br>
}<br>
}<br>
return res.next;<br>
}<br>
//链表为排好序的链表<br>
public ListNode DeleteDuplicates2(ListNode head)<br>
{<br>
if (head == null || head.next == null) return head;<br>
ListNode res = new ListNode();<br>
res.next = head;<br>
while (head != null &amp;&amp; head.next != null)<br>
{<br>
if (head.val == head.next.val)<br>
{<br>
head.next = head.next.next;<br>
}<br>
else<br>
head = head.next;<br>
}<br>
return res.next;<br>
}<br>
<strong>class LC74搜索矩阵</strong><br>
{<br>
/// <summary><br>
/// 二分法，一维，二维数组索引转换<br>
/// </summary><br>
/// <param name="matrix"></param><br>
/// <param name="target"></param><br>
/// <returns></returns><br>
public bool SearchMatrix(int[][] matrix, int target)<br>
{<br>
if (matrix == null || matrix.Length == 0) return false;</p>
<pre><code>        int row = matrix.Length;
        int col = matrix[0].Length;
        int l = 0;
        int r = row * col - 1;
        while(l&lt;=r)
        {
            int mid = l + (r - l) / 2;
            int ele = matrix[mid / col][mid % col];//一维索引二维
            if (ele == target)
                return true;
            else if (ele &gt; target)
                r = mid;
            else
                l = mid + 1;
        }
        return false;
    }
}
</code></pre>
<p><strong>————————————————————————————————————</strong><br>
<strong>78/90.子集</strong><br>
/// <summary><br>
/// 子集<br>
/// </summary><br>
class LC78<br>
{<br>
/// <summary><br>
/// SubsetI<br>
/// </summary><br>
/// <param name="nums"></param><br>
/// <returns></returns><br>
public static List&lt;List<int>&gt; Subset(int[] nums)<br>
{<br>
List&lt;List<int>&gt; res = new List&lt;List<int>&gt;();<br>
res.Add(new List<int> { });<br>
foreach (int  n in nums)<br>
{<br>
int resLength = res.Count;<br>
for (int i = 0; i &lt; resLength; i++)<br>
{<br>
List<int> cur = new List<int>(res[i]);<br>
cur.Add(n);<br>
res.Add(cur);<br>
}<br>
}<br>
return res;<br>
}<br>
/// <summary><br>
/// SubsetII<br>
/// </summary><br>
/// <param name="nums"></param><br>
/// <returns></returns><br>
public static List&lt;List<int >&gt; SubsetsWithDup(int [] nums)<br>
{<br>
List&lt;List<int>&gt; res = new List&lt;List<int>&gt;();<br>
res.Add(new List<int> {});<br>
Array.Sort<int>(nums);<br>
foreach (int n in nums)<br>
{<br>
int resLength = res.Count;<br>
for (int i = 0; i &lt; resLength; i++)<br>
{<br>
List<int> cur = new List<int>(res[i]);<br>
cur.Add(n);<br>
res.Add(cur);<br>
}<br>
}<br>
List&lt;List<int>&gt; resLast = new List&lt;List<int>&gt;();</p>
<pre><code>        foreach (List&lt;int&gt; list in res)
        {
            if (!Contants(resLast, list))
            {
                resLast.Add(list);
            }
        }
        return resLast;

    }
    public static bool Contants(List&lt;List&lt;int&gt;&gt; res,List&lt;int&gt; slist)
    {
        if (res.Count == 0) return false;
        bool conts = false;
        foreach (var item in res)
        {
            if (CpList(item, slist))
                conts = true;
        }
        return conts;
    }

    public static bool CpList(List&lt;int&gt; l1,List&lt;int&gt; l2)
    {
        bool res = true;
        if (l1.Count != l2.Count)
            return false;
        else
        {                
            for (int i = 0; i &lt; l1.Count; i++)
            {
                if (l1[i] != l2[i])
                    res = false;
            }
        }

        return res;
    }
}
</code></pre>
<p><strong>//121.买股票的最佳时机</strong><br>
public int MaxProfit(int[] prices)<br>
{<br>
if (prices == null || prices.Length == 0) return 0;<br>
int minp = prices[0];<br>
int maxp = 0;<br>
for (int i = 1; i &lt; prices.Length; i++)<br>
{<br>
if (prices[i] &lt; minp)<br>
minp = prices[i];<br>
else if (prices[i] - minp &gt; maxp)<br>
maxp = prices[i] - minp;<br>
}<br>
return maxp;<br>
}<br>
<strong>//122.买股票的最佳时机II</strong><br>
public static int MaxProfitII(int[] prices)<br>
{<br>
if (prices == null || prices.Length == 0) return 0;</p>
<pre><code>        int allprice = 0;
        int lop = prices[0], top = prices[0];
        int i = 0;
        while(i&lt;prices.Length-1)
        {
            while (i&lt;prices.Length-1 &amp;&amp; prices[i] &gt;= prices[i + 1])
                i += 1;
            lop = i;
            while (i &lt; prices.Length - 1 &amp;&amp; prices[i] &lt; prices[i + 1])
                i += 1;
            top = i;
            allprice += prices[top] - prices[lop];
        }
        return allprice;
    }
</code></pre>
<p><strong>class _141环形链表</strong><br>
{<br>
public bool HasCycle(ListNode head)<br>
{<br>
if (head == null || head.next == null)<br>
{<br>
return false;<br>
}</p>
<pre><code>        ListNode slow = head;
        ListNode fast = head.next;
        while (slow != fast)
        {
            if (fast == null || fast.next == null)
            {
                return false;
            }
            slow = slow.next;
            fast = fast.next.next;
        }
        return true;
    }
}
</code></pre>
<p><strong>//160.相交链表</strong><br>
public ListNode GetIntersectionNode(ListNode headA, ListNode headB)<br>
{<br>
if (headA == null || headB == null) return null;<br>
HashSet<ListNode> list = new HashSet<ListNode>();<br>
while(headA!=null)<br>
{<br>
list.Add(headA);<br>
headA = headA.next;<br>
}<br>
while(headB!=null)<br>
{<br>
if (!list.Contains(headB))<br>
{<br>
list.Add(headB);<br>
headB = headB.next;<br>
}<br>
else<br>
return headB;<br>
}<br>
return null;<br>
}<br>
<strong>class LC162寻找峰值</strong><br>
{<br>
/// <summary><br>
/// 峰值元素是指其值大于左右相邻值的元素。二分法<br>
/// </summary><br>
/// <param name="nums"></param><br>
/// <returns></returns><br>
public static int FindPeakElement(int[] nums)<br>
{<br>
if (nums == null || nums.Length == 0) return -1;</p>
<pre><code>        int l = 0;
        int r = nums.Length - 1;
        while (l&lt;r)
        {
            int mid = (r + l) / 2;
            //中间值右边的数小于mid则极值在左边，反之极值在右边
            if (nums[mid] &gt; nums[mid + 1])
                r = mid;
            else 
                l = mid + 1;
        }
        return l;
    }
}
</code></pre>
<p>#region 查找最大重复值<br>
//static Dictionary&lt;int, int&gt; dic = new Dictionary&lt;int, int&gt;();</p>
<pre><code>    //方法1：利用字典统计数组元素出现的次数。元素作为键，值存储数显次数。
    static int SearchMaxRepet1(int[] array)
    {
        Dictionary&lt;int, int&gt; dic = new Dictionary&lt;int, int&gt;();
        int hrefLength = array.Length / 2;

        for (int i = 0; i &lt; array.Length; i++)
        {
            if (!dic.ContainsKey(array[i]))
                dic.Add(array[i], 0);
        }

        for (int i = 0; i &lt; array.Length; i++)
        {
            dic[array[i]] += 1;
        }
        foreach (int k in dic.Keys)
        {
            if (dic[k] &gt; hrefLength)
                return k;
        }
        return -1;
    }
    //方法2：排序发，排序后重复最多的值补丁集中在数组中间。
    static int SearchMaxRepet2(int[] array)
    {
        QSort(new List&lt;int&gt;(array),0,array.Length-1);
        return array[array.Length / 2];
    }
    //分治法
    static int SearchMaxRepet3(int[] nums)
    {
        return GetMajority(nums, 0, nums.Length - 1);
    }
    /// &lt;summary&gt;
    /// 分治法，获取众数
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;nums&quot;&gt;&lt;/param&gt;
    /// &lt;param name=&quot;left&quot;&gt;&lt;/param&gt;
    /// &lt;param name=&quot;right&quot;&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    static int GetMajority(int [] nums,int left,int right)
    {
        if (left == right)//分为只有衣蛾元素时返回
            return nums[left];

        int mid = left + (right - left) / 2;//师爷咱们还是对半分
        int leftMajority = GetMajority(nums, 0, mid);//左半边的中数
        int rightMajority = GetMajority(nums, mid+1, right);//右半边的中数

        if (leftMajority == rightMajority)//左右众数相同 则返回其中任意一个
            return leftMajority;
        //不相同则，则遍历数组统计该递归层左右那边众数出现的次数多
        int leftCount = 0;
        int rightCount = 0;
        for (int i = left; i &lt;=right; i++)
        {
            if (nums[i] == leftMajority)
                leftCount++;
            else if (nums[i] == rightMajority)
                rightCount++;
        }

        return leftCount &gt; rightCount ? leftMajority : rightMajority;
    }
    #endregion
</code></pre>
<p><strong>————————————————————————————————————</strong><br>
<strong>179.最大数(网易面试题)</strong><br>
/// <summary><br>
///179： 给定一组非负整数 nums，重新排列它们每个数字的顺序（每个数字不可拆分）使之组成一个最大的整数。<br>
/// 用List对string进行排序<br>
/// </summary><br>
/// <param name="nums"></param><br>
/// <returns></returns><br>
public static string LargestNum2(int[] nums)<br>
{<br>
if (nums == null) return &quot;&quot;;<br>
if (nums.Length == 1) return nums[0].ToString();</p>
<pre><code>        List&lt;string&gt; numsList = new List&lt;string&gt;();
        for (int i = 0; i &lt; nums.Length; i++)
        {
            numsList.Add(nums[i].ToString());
        }                       
        numsList.Sort((a, b) =&gt; { return (b + a).CompareTo(a + b); });
    
        if (numsList[0].Equals(&quot;0&quot;)) return &quot;0&quot;;
        else return  string.Join(&quot;&quot;,numsList.ToArray());
    }
</code></pre>
<p>/// </summary><br>
///字符依次前后相加对比，结果大的放在前面<br>
/// <param name="nums"></param><br>
/// <returns></returns><br>
/// <summary><br>
<strong>179.普通方法</strong><br>
public static string LargestNum(int[] nums)<br>
{<br>
if (nums == null) return &quot;&quot;;<br>
if (nums.Length == 1) return nums[0].ToString();<br>
string[] st = new string[nums.Length];<br>
//StringBuilder s = new StringBuilder();<br>
for (int i = 0; i &lt; nums.Length; i++)<br>
{<br>
st[i] = nums[i].ToString();<br>
}<br>
for (int i = 0; i &lt; st.Length; i++)<br>
{<br>
for (int j = i+1; j &lt; st.Length; j++)<br>
{<br>
if((st[i]+st[j]).CompareTo(st[j]+st[i])&lt;0)<br>
//s1.CompareTo(s2):<br>
//s1&gt;s2: 1<br>
//s1=s2: 0<br>
//s1&lt;s2: -1<br>
{<br>
Swap(ref st[i], ref st[j]);<br>
}<br>
}<br>
}<br>
/<em>foreach (string item in st)<br>
{<br>
s.Append(item);<br>
}<br>
return s.ToString();</em>/<br>
if (nums[0].Equals(&quot;0&quot;)) return &quot;0&quot;;<br>
else return string.Join(&quot;-&quot;, st);//使用字符连接字符串数组，返回连接后的字符<br>
}<br>
<strong>187.重复的DNA序列</strong><br>
public static List<string> FindRepeatedDnaSequences2(string s)<br>
{<br>
List<string> res = new List<string>();<br>
if (s == null || s.Length &lt; 11) return res;<br>
Dictionary&lt;string, int&gt; dic = new Dictionary&lt;string, int&gt;();<br>
//StringBuilder ele = new StringBuilder();<br>
int i = 0;<br>
while(i+10&lt;=s.Length)<br>
{<br>
/<em>ele.Clear();<br>
ele.Append(s.Substring(i, 10));</em>/<br>
string ele = s.Substring(i, 10);<br>
if (!dic.ContainsKey(ele.ToString()))<br>
dic.Add(ele.ToString(), 1);<br>
else if(!res.Contains(ele))<br>
res.Add(ele.ToString());<br>
i++;<br>
}<br>
return res;<br>
}<br>
<strong>//200.岛屿数量</strong><br>
/// <summary><br>
/// 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。<br>
/// </summary><br>
/// <param name="grid"></param><br>
/// <returns> 岛屿数量，遍历二维数值，找到1后岛屿数量加1，然后深度优先DFS将与1上下左右相连的1递归变为0。之后继续遍历数组找1</returns><br>
public static int CountIsland(char[][]grid)<br>
{<br>
if (grid == null || grid.Length == 0)<br>
return 0;<br>
int row = grid.Length;<br>
int col = grid[0].Length;<br>
int count = 0;<br>
for (int i = 0; i &lt; row; i++)<br>
{<br>
for (int j = 0; j &lt; col; j++)<br>
{<br>
if (grid[i][j] == '1')<br>
{<br>
count++;<br>
DFS(grid, i, j);<br>
}<br>
}<br>
}<br>
return count;<br>
}<br>
static void DFS(char[][] grid,int i,int j)<br>
{<br>
if(i&lt;0||j&lt;0||i&gt;=grid.Length||j&gt;=grid[0].Length||grid[i][j]=='0')<br>
{<br>
return;<br>
}<br>
grid[i][j] = '0';<br>
DFS(grid, i + 1, j);<br>
DFS(grid, i - 1, j);<br>
DFS(grid, i, j + 1);<br>
DFS(grid, i, j - 1);<br>
}<br>
<strong>//695.岛屿最大面积</strong><br>
public int MaxIsLandAre(int[][]grid)<br>
{<br>
if (grid == null || grid.Length == 0)<br>
return 0;<br>
int res = 0;<br>
for (int i = 0; i &lt; grid.Length; i++)<br>
{<br>
for (int j = 0; j &lt; grid[0].Length; j++)<br>
{<br>
if(grid[i][j]==1)<br>
{<br>
int curentAre = DFS2(grid,i,j);<br>
res = Math.Max(res, curentAre);<br>
}<br>
}<br>
}<br>
return res;<br>
}<br>
public int DFS2(int[][]grid,int i,int j)<br>
{<br>
if (i &lt; 0 || j &lt; 0 || i &gt;= grid.Length || j &gt;= grid[0].Length || grid[i][j] ==0)<br>
{<br>
return 0;<br>
}<br>
grid[i][j] = 0;<br>
int are = 1;<br>
are += DFS2(grid, i + 1, j);<br>
are += DFS2(grid, i , j+1);<br>
are += DFS2(grid, i - 1, j);<br>
are += DFS2(grid, i , j-1);<br>
return are;</p>
<pre><code>    }
}
</code></pre>
<p>//219：重复元素2：数组中存在相同元素，且索引值之差绝对值之多为k(小于等于)<br>
public bool ContainsNearbyDuplicate(int[] nums, int k)<br>
{<br>
Dictionary&lt;int, int&gt; dic = new Dictionary&lt;int, int&gt;();<br>
for (int i = 0; i &lt; nums.Length; i++)<br>
{<br>
if (dic.ContainsKey(nums[i]) &amp;&amp; (i - dic[nums[i]] &lt;= k))<br>
return true;<br>
else<br>
dic[nums[i]] = i;<br>
}<br>
return false;<br>
}<br>
//198<br>
public int Rob(int[] nums)<br>
{<br>
if (nums.Length == 0) return 0;<br>
if (nums.Length == 1) return nums[0];</p>
<pre><code>        int p2 = nums[0];
        int p1 = Math.Max(nums[0], nums[1]);
        for (int i = 2; i &lt; nums.Length; i++)
        {
            int temp = Math.Max(nums[i] + p2,p1);
            p2 = p1;
            p1 = temp;
        }
        return p1;
    }
</code></pre>
<p><strong>206.反转链表</strong><br>
class LC206<br>
{<br>
public static ListNode ReversList(ListNode head)<br>
{<br>
ListNode dummy = new ListNode();<br>
dummy.next = head;<br>
while(head!=null||head.next!=null)<br>
{<br>
ListNode next = head.next;<br>
ListNode temp = dummy.next;<br>
head.next = head.next.next;<br>
dummy.next = next;<br>
next.next = temp;<br>
}<br>
return dummy.next;</p>
<pre><code>    }
    public static ListNode ReversList2(ListNode head)
    {
        if (head == null || head.next == null)
            return head;
        //返回末尾节点
        ListNode res = ReversList2(head.next);
        //节点指向反转：递归栈先入后出，先返回最后递归层的末尾节点
        head.next.next = head;
        head.next = null;

        return res;
    }
}
</code></pre>
<p><strong>————————————————————————————————————</strong><br>
/// <summary><br>
<strong>209.长度最小的子数组</strong><br>
/// 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，<br>
/// 并返回其长度。如果不存在符合条件的子数组，返回 0。<br>
/// </summary><br>
class LC209<br>
{<br>
/// <summary><br>
/// 暴力法，可能输出的值即为1~数组最大长度，长度为n时如存在连续n个数的和&gt;=s，则返回长度n<br>
/// </summary><br>
/// <param name="s"></param><br>
/// <param name="nums"></param><br>
/// <returns></returns><br>
public static int MinSubArrayLen1(int s, int[] nums)<br>
{<br>
if (nums == null || nums.Length == 0)<br>
return 0;<br>
int size = 1;<br>
while(size&lt;=nums.Length)<br>
{<br>
for (int i = 0; i &lt; nums.Length-size+1;i++)<br>
{<br>
int total = 0;<br>
for (int j = i; j &lt; i+size; j++)<br>
{<br>
total += nums[j];<br>
}<br>
if (total &gt;= s)<br>
return size;<br>
}<br>
size++;<br>
}<br>
return 0;<br>
}<br>
/// <summary><br>
/// 滑动窗口法/双指针法<br>
/// </summary><br>
/// <param name="s"></param><br>
/// <param name="nums"></param><br>
/// <returns></returns><br>
public static int MinSubArrayLen2(int s, int[] nums)<br>
{<br>
if (nums == null || nums.Length == 0)<br>
return 0;<br>
int i = 0;//左指针<br>
int j = 0;//右指针<br>
int result = nums.Length + 1;//返回结果默不可能比数组长度长，不变则不存在返回0<br>
int total = 0;//窗口内数字的和<br>
while (j&lt;nums.Length)<br>
{<br>
total += nums[j];//计算窗口内数字和<br>
j++;//右指针滑动<br>
while(total&gt;=s)//当窗口内数字和&gt;=给定值时，更新返回值取最小长度<br>
{<br>
result = Math.Min(result, j - i);</p>
<pre><code>                total -= nums[i];//左指针开始移动，
                i++;
                //和仍大于等于给定时时继续移动，小于则退出循环，移动有指针
            }
        }//j移动到末尾时循环结束
        return result == nums.Length + 1 ? 0 : result;//长度未更新则不存在返回0，更新则为最小值
    }
}
</code></pre>
<p><strong>————————————————————————————————————</strong><br>
<strong>217.重复元素</strong><br>
/// <summary><br>
/// 给定一个整数数组，判断是否存在重复元素。<br>
/// 如果任意一值在数组中出现至少两次，函数返回 true 。<br>
/// 如果数组中每个元素都不相同，则返回 false<br>
/// </summary><br>
class LC217重复元素<br>
{<br>
/// <summary><br>
/// 排序法，排序后存在两个相邻的数相同即存在重复的数<br>
/// </summary><br>
/// <param name="nums"></param><br>
/// <returns></returns><br>
public static bool ContainsDuplicate(int[] nums)<br>
{<br>
if (nums == null || nums.Length == 0)<br>
return false;<br>
Array.Sort(nums);<br>
//方式1<br>
/<em>int i = 0;<br>
int j = i + 1;<br>
while(j&lt;nums.Length)<br>
{<br>
if (nums[i] == nums[j])<br>
return true;<br>
i++;<br>
j++;<br>
}</em>/<br>
//方式2<br>
int prev = nums[0];<br>
for (int i = 1; i &lt; nums.Length; i++)<br>
{<br>
if (nums[i] == prev)<br>
return true;<br>
else<br>
prev = nums[i];<br>
}<br>
return false;<br>
}</p>
<pre><code>    /// &lt;summary&gt;
    /// Set法，集合无法添加重复的元素，
    /// 添加完成后集合长度与原数组长度不相等即存在重复的元素
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;nums&quot;&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public static bool ContainsDuplicate2(int [] nums)
    {
        HashSet&lt;int&gt; set = new HashSet&lt;int&gt;(nums);
        return nums.Length == set.Count ? false : true;
    }
    /// &lt;summary&gt;
    /// 字典法，通过字典统计各元素出现的次数，存在次数大于1,
    /// 即有值重复出现
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;nums&quot;&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public static bool ContainsDuplicate3(int[] nums)
    {
        Dictionary&lt;int, int&gt; dic = new Dictionary&lt;int, int&gt;();
        foreach (int  n in nums)
        {
            if(!dic.ContainsKey(n))
            {
                dic.Add(n, 1);
            }else
            {
                dic[n] += 1;
            }
        }
        foreach (var item in dic.Values)
        {
            if (item &gt; 1)
                return true;
        }
        return false;
    }
}
</code></pre>
<p><strong>//125.回文字符串</strong><br>
public static bool IsPalindrome(string s)<br>
{<br>
string str = Regex.Replace(s, &quot;[^A-Za-z0-9]&quot;, &quot;&quot;).ToLower();<br>
Console.WriteLine(str);<br>
char[] array = str.ToCharArray();<br>
Array.Reverse(array);<br>
return str.Equals(new string(array));<br>
}<br>
<strong>————————————————————————————————————</strong><br>
<strong>234.回文链表</strong><br>
/// <summary><br>
/// 请判断一个链表是否为回文链表。回文正反相同的，1；121；1221.<br>
/// </summary><br>
class LC234回文链表<br>
{<br>
/// <summary><br>
/// 双指针法，由于链表中不能向前移动，所以先将链表中的数，加到数组中<br>
/// 然后左右指针向中间一定进行对比<br>
/// </summary><br>
/// <param name="head"></param><br>
/// <returns></returns><br>
public static bool IsPalindrome(ListNode head)<br>
{<br>
if (head == null || head.next == null)<br>
return true;<br>
List<int> list = new List<int>();<br>
while (head != null)<br>
{<br>
list.Add(head.val);<br>
head = head.next;<br>
}<br>
int l = 0;<br>
int r = list.Count - 1;<br>
while(l&lt;r)<br>
{<br>
if (!list[l].Equals(list[r]))//Equals比较的是值==比较的是索引可能不同<br>
return false;<br>
l++;<br>
r--;<br>
}<br>
return true;<br>
}</p>
<pre><code>    /// &lt;summary&gt;
    /// 递归双指针法，全局变量指向头结点，递归到最后一个节点，
    /// 比较最后一个节点与当前p指向的头结点，不想同则返回false，相同p向后移动，返回true
    /// 回到上一层递归对比最后一个节点之前的节点，与当前p值不同则返回false，相同p继续向后移返回true
    /// 继续回到上一层递归及其没有出现不等则返回true
    /// &lt;/summary&gt;
    static ListNode p = new ListNode();
    public static bool IsPalindrome2(ListNode head)
    {
        p = head;
        return Recursion(head);
    }
    public static bool Recursion(ListNode head)
    {
        if (head == null)
            return true;
        if (!Recursion(head.next))
            return false;

        if (p.val != head.val)
            return false;
        p = p.next;
        return true;
    }
    /// &lt;summary&gt;
    /// 栈，将链表节点压入栈，弹出反序链表对比正序链表值是否一致。
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;head&quot;&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public static bool IsPalindrome3(ListNode head)
    {
        if (head == null || head.next == null)
            return true;
        ListNode temp = head;
        Stack&lt;int&gt; stack = new Stack&lt;int&gt;();
        while(temp!=null)//链表节点压入栈
        {
            stack.Push(temp.val);
            temp = temp.next;
        }
        while (head != null &amp;&amp; stack.Count != 0)//正反序对比
        {
            if (head.val != stack.Pop())
                return false;
            head = head.next;
        }
        return true;
    }
}
</code></pre>
<p><strong>238.除自身外数组的乘积</strong><br>
class LC238除自身外数组的乘积<br>
{<br>
public int[] ProductExceptSelf(int[] nums)<br>
{<br>
int[] res = new int[nums.Length];</p>
<pre><code>        int pr = 1;
        for (int i = 0; i &lt; nums.Length; i++)
        {
            res[i] = pr;//返回数组保存除当前索引值外左边所有元素的乘积  
            pr *= nums[i];
        }
        pr = 1;
        for (int i = nums.Length-1; i &gt;=0; i--)
        {
            res[i] *= pr;//返回数组当前索引值(即除自身外所有元素乘积=左边所有元素乘积*右边所有元素乘积)
            pr *= nums[i];
        }
        return res;


    }
}
</code></pre>
<p><strong>———————————————————————————————————————</strong><br>
<strong>268丢失的数字</strong><br>
/// <summary><br>
/// 给定一个包含 [0, n] 中 n 个数的数组 nums ，<br>
/// 找出 [0, n] 这个范围内没有出现在数组中的那个数。<br>
/// </summary><br>
class LC268丢失的数字<br>
{<br>
/// <summary><br>
/// 排序法 [0,n]，排序后数组与索引值不相等即，缺失索引位置的值<br>
/// </summary><br>
/// <param name="nums"></param><br>
/// <returns></returns><br>
public int MissingNumber(int[] nums)<br>
{<br>
Array.Sort(nums);<br>
for (int i = 0; i &lt; nums.Length; i++)<br>
{<br>
if (i != nums[i])<br>
return i;<br>
}<br>
return nums.Length;<br>
}<br>
/// <summary><br>
/// 集合法，加入集合后，直接遍历判断集合不包含[0,n]中的那个值，<br>
/// </summary><br>
/// <param name="nums"></param><br>
/// <returns></returns><br>
public static int MissingNumber2(int[] nums)<br>
{<br>
HashSet<int> set = new HashSet<int>();<br>
foreach (int  n in nums)<br>
set.Add(n);<br>
for (int i = 0; i &lt; nums.Length; i++)<br>
{<br>
if (!set.Contains(i))<br>
return i;<br>
}<br>
return nums.Length;<br>
}<br>
/// <summary><br>
/// 数学法，[0,n]之和为“n*(n+1)/2“减去数组之和即为等于缺失的数值<br>
/// </summary><br>
/// <param name="nums"></param><br>
/// <returns></returns><br>
public int MissingNumber3(int[] nums)<br>
{<br>
int sum = 0;<br>
for (int i = 0; i &lt; nums.Length; i++)<br>
{<br>
sum += nums[i];<br>
}<br>
return (nums.Length * (nums.Length + 1)) / 2 - sum;<br>
}<br>
}<br>
<strong>class LC283移动0</strong><br>
{<br>
public static void MoveZeroes(int [] nums)<br>
{<br>
int index = 0;<br>
for (int i = 0; i &lt; nums.Length; i++)//遍历数组将不为0的数放在前面<br>
{<br>
if(nums[i]!=0)<br>
{<br>
nums[index] = nums[i];<br>
index++;<br>
}<br>
}<br>
//以上遍历完成后index后面的元素都应该是0<br>
for (int i = index; i &lt; nums.Length; i++)<br>
{<br>
nums[i] = 0;<br>
}<br>
}<br>
}<br>
<strong>//328.奇偶链表</strong><br>
public ListNode OddEvenList(ListNode head)<br>
{<br>
if (head == null||head.next==null) return head;</p>
<pre><code>        ListNode odd = head;
        ListNode even = head.next;
        ListNode evenHead = head.next;
        while (even != null&amp;&amp;even.next!=null)
        {
            odd.next = odd.next.next;
            odd = odd.next;
            even.next = even.next.next;
            even = even.next;
        }
        odd.next = evenHead;
        return head;
    }
</code></pre>
<p><strong>344.反转字符串</strong><br>
/// <summary><br>
///系统函数<br>
/// </summary><br>
/// <param name="s"></param><br>
public void ReverseString(char[] s)<br>
{<br>
Array.Reverse<char>(s);<br>
}<br>
/// <summary><br>
/// 双指针<br>
/// </summary><br>
/// <param name="s"></param><br>
public void ReverseString2(char[] s)<br>
{<br>
if (s == null || s.Length == 0) return;</p>
<pre><code>        int l = 0;
        int r = s.Length - 1;
        while(l&lt;r)
        {
            char temp = s[l];
            s[l] = s[r];
            s[r] = temp;
            l += 1;
            r -= 1;
        }
    }
    /// &lt;summary&gt;
    /// 递归法
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;s&quot;&gt;&lt;/param&gt;
    public void ReverseString3(char[] s)
    {
        if (s == null || s.Length == 0) return;//为空或长度为0返回

        Recursion(s, 0, s.Length - 1);//递归函数

    }
    private void Recursion(char[] s,int l,int r)
    {
        if (l &gt;= r) return;//左右指针相等或相交时返回

        Recursion(s, l + 1, r - 1);//左右两端对称的字符在同一递归层中，
        //递归返回时，交换同递归层中的左右字符完成反转
        char temp = s[l];
        s[l] = s[r];
        s[r] = temp;            
    }
</code></pre>
<p><strong>class LC349相交数组</strong><br>
{<br>
public int[] Intersection(int[] nums1, int[] nums2)<br>
{<br>
List<int> res = new List<int>();<br>
if (nums1 == null || nums1 == null || nums1.Length == 0 || nums2.Length == 0) return res .ToArray();<br>
HashSet<int> set1 = new HashSet<int>(nums1);<br>
HashSet<int> set2 = new HashSet<int>(nums2);</p>
<pre><code>        foreach (var item in set1)
        {
            if (set2.Contains(item))
                res.Add(item);
        }
        return res.ToArray();            
    }        
}
</code></pre>
<p><strong>class LC485.最大连续1的个数</strong><br>
{<br>
public static int FindMaxConsecutiveOnes(int [] nums)<br>
{<br>
int res = 0;<br>
int count = 0;<br>
for (int i = 0; i &lt; nums.Length; i++)<br>
{<br>
if (nums[i] == 1)<br>
count++;<br>
else<br>
{<br>
res = Math.Max(res, count);<br>
count = 0;<br>
}<br>
}<br>
return Math.Max(res,count);<br>
}<br>
}<br>
<strong>496.下一个更大元素_I</strong><br>
/// <summary><br>
/// 给定两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。<br>
/// 找到 nums1 中每个元素在 nums2 中的下一个比其大的值。<br>
/// 输入: nums1 = [4,1,2], nums2 = [1,3,4,2].<br>
/// 输出: [-1,3,-1]<br>
/// </summary><br>
class LC496下一个更大元素_I<br>
{<br>
public int[] NextGreaterElement(int[] nums1, int[] nums2)<br>
{<br>
List<int> res = new List<int>();<br>
Stack<int> stack = new Stack<int>();//nums2栈<br>
for (int i = 0; i &lt; nums2.Length; i++)//nums2装入栈中<br>
{<br>
stack.Push(nums2[i]);<br>
}</p>
<pre><code>        foreach (int n in nums1)//遍历数组1
        {
            Stack&lt;int&gt; temp = new Stack&lt;int&gt;();//临时栈，储存nums2弹出的元素
            bool isFind = false;//默认是否在nums2中找到nums1中的目标值
            int max = -1;//默认右边未找到比n大的值
            while(stack.Count!=0&amp;&amp;!isFind)//nums2不为空并且还2未找到n，进入循环
            {
                int top = stack.Pop();//栈顶元素(最右边的元素)
                if (top &gt; n)//弹出值比目标n大，更新最大值
                    max = top;
                else if (top == n)//与n相等则找到了n
                    isFind = true;
                temp.Push(top);//临时栈中存储nums2弹出的值，最后在返回给nums2栈，保持其不变
            }                
            res.Add(max);//max加入返回数组，未更新则右边没有比n大的值，更新则max保存的即是右边第一个比n大的值
            while (temp.Count != 0)//将临时栈的元素返还给nums2栈，使其保持不变，用于选择下一个num1中比n大的值
                stack.Push(temp.Pop());
        }
        return res.ToArray();//遍历完nums1后返回结果类表转数组
    }
    
}
</code></pre>
<p><strong>class LC509斐波那契数</strong><br>
{<br>
/// <summary><br>
/// 斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。<br>
/// 该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：<br>
/// </summary><br>
/// <param name="n"></param><br>
/// <returns></returns><br>
public int Fib(int n)<br>
{<br>
if (n &lt; 2) return n == 1 ? 1 : 0;</p>
<pre><code>        int sum = Fib(n - 1) + Fib(n - 2);
        return sum;
    }
    /// &lt;summary&gt;
    /// 动态规划：
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;n&quot;&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public int Fib2(int n)
    {
        if (n &lt; 2) return n == 1 ? 1 : 0;

        int[] res = new int[n + 1];
        res[0] = 0;
        res[1] = 1;
        for (int i = 2; i &lt; res.Length; i++)
        {
            res[i] = res[i - 1] + res[i - 2];
        }
        return res[n];
    }
    //动态规划，空间复杂度优化
    public int Fib3(int n)
    {
        if (n &lt;= 1) return n;

        int prev1 = 0;
        int prev2 = 1;
        int res = 0;
        for (int i = 2; i &lt;= n; i++)
        {
            res = prev1 + prev2;
            prev1 = prev2;
            prev2 = res;
        }
        return res;
    }
}
</code></pre>
<p><strong>//680.回文字符串II,允许删除一个字符实现回文字符串</strong><br>
public static bool IsPalindrome2(string s)<br>
{<br>
int left = 0;<br>
int right = s.Length - 1;<br>
while(left&lt;right)<br>
{<br>
if(s[left]!=s[right])<br>
{<br>
return IsPs(s.Remove(left,1)) || IsPs(s.Remove(right,1));<br>
}<br>
left++;<br>
right--;<br>
}<br>
return true;<br>
}<br>
public static bool IsPs(string s)<br>
{<br>
/<em>int left = 0;<br>
int right = s.Length - 1;<br>
while (left &lt; right)<br>
{<br>
if (s[left] != s[right])<br>
{<br>
return false;<br>
}<br>
left++;<br>
right--;<br>
}<br>
return true;</em>/</p>
<pre><code>        char[] sarray = s.ToCharArray();
        Array.Reverse(sarray);

        return s.Equals(new string(sarray));
    }
</code></pre>
<p><strong>class LC720词典中最长的单词</strong><br>
{<br>
/// <summary><br>
/// 暴力法，<br>
/// </summary><br>
/// <param name="words"></param><br>
/// <returns></returns><br>
public static string LongestWord(string[] words)<br>
{<br>
//边界条件<br>
if (words == null || words.Length == 0) return &quot;&quot;;</p>
<pre><code>        string res = &quot;&quot;;//返回值
        //将字符串数组存入集合方便快速查找
        HashSet&lt;string&gt; wordset = new HashSet&lt;string&gt;(words);
        //遍历集合
        foreach (string  word in wordset)
        {
            //如果当前单词的长度大于，预存的结果。或长度相同时排序较小，这可能成为新的res
            if (word.Length &gt; res.Length||(word.Length==res.Length&amp;&amp;word.CompareTo(res)&lt;0))
            {
                bool isword = true;//默认可以是新的res
                for (int i = 0; i &lt; word.Length; i++)//遍历新word的每个word[0~i+1]顺序组合都在字典中存在
                {
                    if(!wordset.Contains(word.Substring(0,i+1)))//有不存在的则不能成为新res，退出循环
                    {
                        isword = false;
                        break;
                    }
                }
                if (isword==true)//遍历后认为true则瞒住条件
                    res = word;//替换当前res
            }                    
        }
        return res;//返回res
    }
}
</code></pre>
<p><strong>881.救生艇</strong><br>
/// <summary><br>
/// 第 i 个人的体重为 people[i]，每艘船可以承载的最大重量为 limit。<br>
/// 每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。<br>
/// 返回载到每一个人所需的最小船数。(保证每个人都能被船载)。<br>
/// </summary><br>
class LC881救生艇<br>
{<br>
public int NumRescueBoats(int[] people, int limit)<br>
{<br>
if (people == null || people.Length == 0) return 0;</p>
<pre><code>        Array.Sort&lt;int&gt;(people);
        int res = 0;
        int l = 0;
        int r = people.Length - 1;
        while(l&lt;=r)
        {
            if (people[l] + people[r] &lt;= limit)
                l += 1;
            r -= 1;
            res += 1;
        }
        return res;
    }
}
</code></pre>
<p><strong>989数组形式的整数加法</strong><br>
public static List<int> AddToArrayForm(int[] A, int K)<br>
{<br>
int ans = 0;<br>
for (int i = 0; i &lt; A.Length; i++)<br>
{<br>
ans = ans * 10 + A[i];<br>
}<br>
ans += K;<br>
List<int> res = new List<int>();<br>
while(ans&gt;0)<br>
{<br>
res.Add(ans % 10);<br>
ans /= 10;<br>
}<br>
res.Reverse();<br>
return res;<br>
}<br>
<strong>——————————————————————————————————</strong><br>
<strong>class LC1456定长子串中元音最大的数目</strong><br>
{<br>
/// <summary><br>
/// 滑动窗口法<br>
/// </summary><br>
/// <param name="s"></param><br>
/// <param name="k"></param><br>
/// <returns></returns><br>
public int MaxVowels(string s, int k)<br>
{<br>
if (s == null || s.Length == 0||s.Length&lt;k) return -1;<br>
HashSet<char> set = new HashSet<char>(new char[] { 'a', 'e', 'i', 'o', 'u' });<br>
int res = 0;<br>
int count = 0;<br>
for (int i = 0; i &lt; k; i++)<br>
{<br>
if (set.Contains(s[i]))<br>
count += 1;<br>
}<br>
res = Math.Max(res, count);<br>
for (int i = k; i &lt; s.Length; i++)<br>
{<br>
if (set.Contains(s[i - k]))<br>
count -= 1;<br>
if (set.Contains(s[i]))<br>
count += 1;<br>
res = Math.Max(res, count);<br>
}<br>
return res;<br>
}<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C#游戏服务器/客户端(TCP/UDP无连接转发位置同步)/Google.Protobuf消息解析]]></title>
        <id>https://Wei715547.github.io/post/cyou-xi-fu-wu-qi-ke-hu-duan-googleprotobuf-xiao-xi-jie-xi/</id>
        <link href="https://Wei715547.github.io/post/cyou-xi-fu-wu-qi-ke-hu-duan-googleprotobuf-xiao-xi-jie-xi/">
        </link>
        <updated>2021-01-02T03:06:58.000Z</updated>
        <content type="html"><![CDATA[<p>基本客户端请求，服务端反馈实现<br>
<strong>服务端</strong><br>
<img src="https://Wei715547.github.io/post-images/1609562480036.png" alt="" loading="lazy"><br>
<strong>Server代码</strong><br>
<code><br>
using System;<br>
using System.Collections.Generic;<br>
using System.Net.Sockets;<br>
using System.Text;<br>
using System.Net;<br>
using Game_Socket_Server.Controller;<br>
using GameSocketServerProtocol;</p>
<p>namespace Game_Socket_Server<br>
{/// <summary><br>
/// 服务器类<br>
/// </summary><br>
class Server<br>
{<br>
private Socket socket;<br>
private UDPServer us;<br>
//客户端列表<br>
private List<Client> clientList = new List<Client>();<br>
//所有房间<br>
private List<Room> roomList = new List<Room>();<br>
//控制类管理器<br>
private ControllerManager controllerManager;<br>
/// <summary><br>
/// 服务端构造<br>
/// </summary><br>
/// <param name="prot">传入端口号</param><br>
public Server(int prot)<br>
{<br>
controllerManager = new ControllerManager(this);<br>
socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);<br>
socket.Bind(new IPEndPoint(IPAddress.Any, prot));//绑定端口<br>
socket.Listen(10);//监听队列长度<br>
StartAccept();//开支接收客户端连接<br>
us = new UDPServer(6667, this, controllerManager);<br>
}</p>
<pre><code>    void StartAccept()
    {
        //开始异步接收客户端Socket
        socket.BeginAccept(AcceptCallBack,null);
    }
    void AcceptCallBack(IAsyncResult iar)
    {
        Socket client = socket.EndAccept(iar);//返回异步操作结果中接收到连入的客户端Socket
        clientList.Add(new Client(client,this,us));//加入客户端List
        StartAccept();//继续异步监听
    }

    public Client CientFromUserName(string user)
    {
        foreach (Client  c in clientList)
        {
            if (c.GetUserInfo.Username == user)
                return c;
        }
        return null;
    }

    /// &lt;summary&gt;
    /// 处理客户端发来的请求
    /// &lt;/summary&gt;  
    /// &lt;param name=&quot;pack&quot;&gt;包&lt;/param&gt;
    /// &lt;param name=&quot;client&quot;&gt;客户端&lt;/param&gt;
    public void HandleRequest(MainPack pack,Client client)
    {
        //通过controllerManager找到对应的，请求控制类
        controllerManager.HandleRequest(pack, client);
    }

    public MainPack CreateRoom(Client client,MainPack pack)
    {
        try
        {
            Room room = new Room(this, client, pack.Roompack[0]);
            roomList.Add(room);
            foreach (PlayerPack p in room.GetPlayerInfo())
            {
                pack.Playerpack.Add(p);
            }
            pack.Returncode = ReturnCode.Succeed;
            return pack;
        }catch
        {
            pack.Returncode = ReturnCode.Fall;
            return pack;
        }            
    }
    public MainPack FindRoom()
    {
        MainPack pack = new MainPack();
        pack.Actioncode = ActionCode.FindRoom;
        try
        {
            if(roomList.Count==0)
            {
                pack.Returncode = ReturnCode.NotRoom;
                return pack;
            }
            foreach (Room room in roomList)
            {
                pack.Roompack.Add(room.GetRoomInfo);
            }
            pack.Returncode = ReturnCode.Succeed;
        }catch
        {
            pack.Returncode = ReturnCode.Fall;
        }
        return pack;
    }

    public MainPack JoinRoom(Client client,MainPack pack)
    {
        foreach (Room r in roomList)
        {
            //客户端加入str房间
            if(r.GetRoomInfo.Roomname.Equals(pack.Str))
            {
                if(r.GetRoomInfo.State==0)
                {
                    //房间可加入
                    r.Join(client);
                    pack.Roompack.Add(r.GetRoomInfo);
                    foreach (PlayerPack p in r.GetPlayerInfo())
                    {
                        pack.Playerpack.Add(p);
                    }
                    pack.Returncode = ReturnCode.Succeed;
                    return pack;
                }else
                {
                    //房间不可加入
                    pack.Returncode = ReturnCode.Fall;
                    return pack;
                }
            }
        }
        //当前无房间可加入
        pack.Returncode = ReturnCode.NotRoom;
        return pack;
    }
    public MainPack Exit(Client client,MainPack pack)
    {
        if(client.GetRoom==null)
        {
            pack.Returncode = ReturnCode.Fall;
            return pack;
        }
        client.GetRoom.Exit(this, client);
        pack.Returncode = ReturnCode.Succeed;
        return pack;
    }
    public void Chat(Client client,MainPack pack)
    {
        pack.Str = client.UserName+&quot;：&quot;+ pack.Str;
        client.GetRoom.Broadcast(client, pack);
    }
    public void RemoveClient(Client client)
    {
        clientList.Remove(client);
    }
    public void RemoveRoom(Room room)
    {
        roomList.Remove(room);
    }
}
</code></pre>
<p>}</p>
<p><strong>服务端UDP转发类</strong></p>
<p>using Game_Socket_Server.Controller;<br>
using Game_Socket_Server.Tool;<br>
using GameSocketServerProtocol;<br>
using System;<br>
using System.Collections.Generic;<br>
using System.Net;<br>
using System.Net.Sockets;<br>
using System.Text;<br>
using System.Threading;</p>
<p>namespace Game_Socket_Server<br>
{<br>
class UDPServer<br>
{<br>
Socket udpServer;//UDPSocket<br>
IPEndPoint bindEP;//本地监听IP<br>
EndPoint remotEP;//远程IP</p>
<pre><code>    Server server;//TCPServer

    ControllerManager controllerManager;//控制管理器调用对应事件防范

    Byte[] buffer = new Byte[1024];//消息接收容器
    Thread receiveThread;//接收线程
    /// &lt;summary&gt;
    /// UDP转发服务器构造
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;port&quot;&gt;监听端口号&lt;/param&gt;
    /// &lt;param name=&quot;server&quot;&gt;TCP服务器&lt;/param&gt;
    /// &lt;param name=&quot;controllerManager&quot;&gt;控制管理器&lt;/param&gt;
    public UDPServer(int port, Server server, ControllerManager controllerManager)
    {
        this.server = server;
        this.controllerManager = controllerManager;
        udpServer = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
        bindEP = new IPEndPoint(IPAddress.Any, port);//监听本地IP端口
        remotEP = (EndPoint)bindEP;//初始远程IP为默认本地,
        udpServer.Bind(bindEP);
        receiveThread = new Thread(ReceiveMag);
        receiveThread.Start();
        Console.WriteLine(&quot;UDP服务器以创建&quot;);

    }
    ~UDPServer()
    {
        if (receiveThread != null)
        {
            receiveThread.Abort();
            receiveThread = null;
        }
    }
    /// &lt;summary&gt;
    /// 服务器UDP接收端建立后即开始接收
    /// &lt;/summary&gt;
    private void ReceiveMag()
    {
        while (true)
        {
            int len = udpServer.ReceiveFrom(buffer, ref remotEP);//UDP接收方法，数据写入buffer，返回另一端通信地址
            MainPack pack = (MainPack)MainPack.Descriptor.Parser.ParseFrom(buffer, 0, len);
            Handlerequest(pack, remotEP);
        }
    }
    /// &lt;summary&gt;
    /// UDP无连接，通过返回客户端地址进行通信
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;buffer&quot;&gt;接收客户端发来的数据&lt;/param&gt;
    /// &lt;param name=&quot;remotEP&quot;&gt;返回到到客户端地址&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public void Handlerequest(MainPack pack, EndPoint ipEndPoint)
    {
        Client client = server.CientFromUserName(pack.User);//通过包中的用户名找到对应的客户端类，对其通信地址赋值
        if(client.IEP==null)
        {
            client.IEP = ipEndPoint;
        }
        controllerManager.HandleRequest(pack, client,true);
    }
    public void SendTo(MainPack pack,EndPoint point)
    {
        byte[] buff = Message.PackDateUDP(pack);
        udpServer.SendTo(buff, buff.Length, SocketFlags.None, point);
    }
}
</code></pre>
<p>}</p>
<p><strong>ControllerManager代码</strong></p>
<p>using System;<br>
using System.Collections.Generic;<br>
using System.Reflection;<br>
using System.Text;<br>
using GameSocketServerProtocol;</p>
<p>namespace Game_Socket_Server.Controller<br>
{<br>
class ControllerManager<br>
{<br>
private Dictionary&lt;RequestCode, BaseController&gt; controlDict = new Dictionary&lt;RequestCode, BaseController&gt;();<br>
private Server server;<br>
public ControllerManager(Server server)<br>
{<br>
this.server = server;<br>
UserController userController = new UserController();<br>
controlDict.Add(userController.GetRequestCode, userController);<br>
RoomController roomController = new RoomController();<br>
controlDict.Add(roomController.GetRequestCode, roomController);<br>
}</p>
<pre><code>    /// &lt;summary&gt;
    /// 服务端消息处理方法，默认处理TCP消息
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;pack&quot;&gt;&lt;/param&gt;
    /// &lt;param name=&quot;client&quot;&gt;&lt;/param&gt;
    /// &lt;param name=&quot;isUDP&quot;&gt;是否为UDP数据报&lt;/param&gt;
    public void HandleRequest(MainPack pack,Client client,bool isUDP = false)
    {
        //根据Requestcode请求类型获取对应的请求类型控制器，如User-UserController
        if (controlDict.TryGetValue(pack.Requestcode,out BaseController controller))
        {
            string mothooname = pack.Actioncode.ToString();//解析具体请求类型中的方法如：User中的Logon
            //通过反射特性获取，处理该请求类型控制器中的方法，如UserController中的Logon
            MethodInfo method = controller.GetType().GetMethod(mothooname);
            if(method == null)
            {
                Console.WriteLine(&quot;没有找到对应的事件处理方法&quot;);
                return;
            }                
            //方法不为空，存在处理方法
            Console.WriteLine(&quot;客户端&quot;+mothooname+&quot;请求&quot;);
            object[] obj;
            if (isUDP)
            {
                obj = new object[] { client, pack };
                method.Invoke(controller, obj);//UDP只负责转发，不需要对客户端进行反馈
            }
            else
            {
                //方法的统一参数，(服务器Socket，客户端Socket，数据包MainPack)
                obj = new object[] { server, client, pack };
                //方法处理后返回的数据包
                object ret = method.Invoke(controller, obj);//通过反射调用请求控制器中处理该请求的方法，返回处理后的的包

                if (ret != null)//请求处理返回的数据包不为空（需要给客户端反馈时）
                {
                    client.Send(ret as MainPack);//将处理结果发给客户端
                }
                //ret为空时即服务器对此请求不需要回复
            }

        }else
        {
            Console.WriteLine(&quot;没有找到对应的Ccontroller处理&quot;);
        }
    }
}
}
</code></pre>
<p>}</p>
<p><strong>Client代码</strong></p>
<p>using System;<br>
using System.Collections.Generic;<br>
using System.Net.Sockets;<br>
using System.Net;<br>
using System.Text;<br>
using Game_Socket_Server.Tool;<br>
using Game_Socket_Server.DAO;<br>
using GameSocketServerProtocol;</p>
<p>namespace Game_Socket_Server<br>
{<br>
class Client<br>
{<br>
private Socket socket;//与远程客户端通信的Socket<br>
private Message message;//消息类<br>
private UserDate userDate;//用户数据类，连接数据库读取写入<br>
private Server server;//服务器<br>
private UDPServer us;//UDPServer<br>
private EndPoint remoetEP;<br>
//private int hp = 100;<br>
public Room GetRoom//自动属性，客户端所在房间<br>
{<br>
get;set;<br>
}<br>
public string UserName//自动属性，用户名<br>
{<br>
get;set;<br>
}<br>
/<em>public int HP<br>
{<br>
get { return hp; }<br>
set { hp = value; }<br>
}</em>/<br>
public UserInfo GetUserInfo<br>
{<br>
get;set;<br>
}<br>
public class UserInfo<br>
{<br>
public string Username<br>
{<br>
get;set;<br>
}<br>
public int Hp<br>
{<br>
get;<br>
set;<br>
}<br>
public PosPack Pos<br>
{<br>
get;set;<br>
}<br>
}</p>
<pre><code>    public EndPoint IEP
    {
        get { return remoetEP; }
        set { remoetEP = value; }
    }

    public UserDate GetUserDate//外部获取用户数据公开属性
    {
        get
        {
            return userDate;
        }
    }
    public Client(Socket socket,Server server,UDPServer us)
    {
        this.server = server;
        this.socket = socket;
        this.us = us;
        message = new Message();
        userDate = new UserDate();
        GetUserInfo = new UserInfo();
        StartReceiveMsg();
    }
    /// &lt;summary&gt;
    /// 客户端异步接收字节流数据
    /// &lt;/summary&gt;
    void StartReceiveMsg()
    {
        //异步接收方法(用于接收的字节数组，开始接收位，可用于接收的长度，Sock标记，回调函数，null)
        socket.BeginReceive(message.Buffer,message.StartIndex,message.Remsize,SocketFlags.None,ReceiveCallBak,null);
        
    }
    void ReceiveCallBak(IAsyncResult iar)
    {
        try
        {
            //如socket为空，或未连接，则返回
            if (socket == null || socket.Connected == false) return;
            //接收到的字节流长度
            int len = socket.EndReceive(iar);
            if (len == 0)//为空则返回
            {
                Close();
                return;
            }
            //不为空时开始解析消息
            message.ReadBuffer(len,HandleRequest);
            StartReceiveMsg();
        }
        catch {
            Close();
        }
    }
    /// &lt;summary&gt;
    /// 客户端发送数据方法
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;pack&quot;&gt;包转字节流&lt;/param&gt;
    public void Send(MainPack pack)
    {
        if (socket == null || socket.Connected == false) return;
        try
        {
            socket.Send(Message.PackDate(pack));
        }
        catch
        { }
    }
    //UDP转发方法，UDP无连接，通过收到的客户端地址发送数据。
    public void SendTo(MainPack pack)
    {
        if (IEP == null) return;
        us.SendTo(pack, IEP);

    }
    //处理客户端发来的请求
    private void HandleRequest(MainPack pack)
    {
        server.HandleRequest(pack, this);
    }

    private void Close()
    {
        Console.WriteLine(&quot;客户端断开&quot;);
        if(GetRoom!=null)
        {
            GetRoom.Exit(server, this);
        }
        server.RemoveClient(this);
        socket.Close();
        
    }
}
</code></pre>
<p>}</p>
<p><strong>Message处理类代码</strong></p>
<p>using System;<br>
using System.Collections.Generic;<br>
using System.Linq;<br>
using System.Text;<br>
using GameSocketServerProtocol;<br>
using Google.Protobuf;</p>
<p>namespace Game_Socket_Server.Tool<br>
{<br>
/// <summary><br>
/// 消息处理类，主要方法，将字节数组解析为MainPack包，将包转为字节数组。<br>
/// </summary><br>
class Message<br>
{<br>
/// <summary><br>
/// 字节数组容器<br>
/// </summary><br>
private byte[] buffer = new byte[1024];<br>
/// <summary><br>
///<br>
/// </summary><br>
private int startIndex;<br>
public byte[] Buffer<br>
{<br>
get<br>
{<br>
return buffer;<br>
}<br>
}</p>
<pre><code>    public int StartIndex
    {
        get
        {
            return startIndex;
        }
    }

    public int Remsize
    {
        get
        {
            return buffer.Length - startIndex;
        }
    }

    /// &lt;summary&gt;
    /// 数据解析，字节流转为MainPack包
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;len&quot;&gt;读取的长度&lt;/param&gt;
    public void ReadBuffer(int len,Action&lt;MainPack&gt; HandleRequest)
    {
        startIndex += len;            
        while (true)//循环解析消息
        {
            if(startIndex&lt;=4) return;//包头一个int类型长度&lt;=4 包体无数据不需解析
            int count = BitConverter.ToInt32(buffer,0);//读取4位返回一个int值
            if (startIndex &gt;= (count + 4))
            {
                //接收数据包
                MainPack pack = (MainPack)MainPack.Descriptor.Parser.ParseFrom(buffer, 4, count);//byte[]容器，偏移(从第几位开始读)，读多少位。
                HandleRequest(pack);
                //读取之后清理解析过的位
                Array.Copy(buffer, count + 4, buffer, 0, startIndex - count - 4);
                startIndex -= (count + 4);
            }
            else
            {
                break;
            }
        }            
    }
    public static byte[] PackDate(MainPack pack)
    {
        byte[] date = pack.ToByteArray();//包体
        byte[] head = BitConverter.GetBytes(date.Length);//包头
        return head.Concat(date).ToArray();
    }
    //UDP MainPack打包不需要包头
    public static byte[] PackDateUDP(MainPack pack)
    {
        return pack.ToByteArray();
    }
}
</code></pre>
<p>}</p>
<p><strong>MainPack，build之前代码(生成GameSocketServerProtocol.cs引入服务端/客户端使用)</strong></p>
<p>syntax = &quot;proto3&quot;;<br>
package GameSocketServerProtocol;<br>
//客户端请求类型枚举<br>
enum RequestCode<br>
{<br>
RequestNone=0;<br>
//用户请求<br>
User = 1;<br>
//房间请求<br>
Room = 2;<br>
//游戏请求<br>
Game = 3;<br>
}<br>
//客户端请求事件类型<br>
enum ActionCode<br>
{<br>
ActionNone=0;<br>
//注册<br>
Logon = 1;<br>
//登录<br>
Login = 2;<br>
//创建房间<br>
CreateRoom = 3;<br>
//查询房间<br>
FindRoom = 4;<br>
//玩家列表：服务器发给客户端解析<br>
PlayerList = 5;<br>
//加入房间<br>
JoinRoom = 6;<br>
//离开<br>
Exit = 7;<br>
//聊天<br>
Chat = 8;<br>
//开始游戏<br>
StartGame = 9;<br>
//服务端发送来的开始游戏<br>
Staring = 10;<br>
//更新位置<br>
UpState = 11;<br>
//离开游戏<br>
ExitGame = 12;<br>
//更新角色和玩家列表<br>
UpDatePlayerList = 13;<br>
//开火<br>
Fire = 14;<br>
}<br>
//服务器返回类型<br>
enum ReturnCode<br>
{<br>
ReturnNone=0;<br>
//成功<br>
Succeed = 1;<br>
//失败<br>
Fall = 2;<br>
//未找到房间<br>
NotRoom = 3;<br>
}</p>
<p>message MainPack<br>
{<br>
RequestCode requestcode=1;<br>
ActionCode actioncode=2;<br>
ReturnCode returncode=3;<br>
//注册/登录信息包<br>
LoginPack loginpack=4;<br>
//防止发送空包占用空间的字符串，也可传输客户端聊天消息等<br>
string str = 5;<br>
//房间列表<br>
repeated RoomPack roompack = 6;<br>
//玩家列表<br>
repeated PlayerPack playerpack = 7;<br>
//子弹位置<br>
BulletPack bulletpack = 8;<br>
//用户名<br>
string user = 9;<br>
}</p>
<p>message LoginPack<br>
{<br>
//用户名<br>
string username=1;<br>
//密码<br>
string password=2;<br>
}<br>
message RoomPack<br>
{<br>
//房间名<br>
string roomname = 1;<br>
//房间最大人数<br>
int32 maxnum = 2;<br>
//房间当前人数<br>
int32 curnum = 3;<br>
//房间状态<br>
int32 state = 4;<br>
}<br>
message PlayerPack<br>
{<br>
//玩家名称<br>
string playername = 1;<br>
//玩家ID<br>
string playerID = 2;<br>
//玩家血量<br>
int32 hp = 3;<br>
//位置信息<br>
PosPack pospack = 4;<br>
}<br>
message PosPack<br>
{<br>
//玩家2D坐标<br>
float PosX = 1;<br>
float PosY = 2;<br>
float RotZ = 3;	<br>
float GunRotZ = 4;	<br>
}<br>
message BulletPack<br>
{<br>
float PosX = 1;<br>
float PosY = 2;<br>
float RotZ = 3;	<br>
//鼠标位置<br>
float MousePosX = 4;<br>
float MousePosY = 5;<br>
}</p>
</code>
<p><img src="https://Wei715547.github.io/post-images/1609573638953.png" alt="" loading="lazy"><br>
<strong>客户端代码</strong><br>
<strong>GameFace</strong><br>
<code><br>
using GameSocketServerProtocol;<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class GameFace : MonoBehaviour<br>
{<br>
private ClientManeger clientManeger;<br>
private RequestManager requestManager;<br>
private UIManager uiManager;<br>
PlayerManager playerManager;</p>
<pre><code>public string UserName//客户端登录时赋值
{
    get;set;    
}

private static GameFace face;

public static GameFace Face
{
    get
    {
        if (face == null)
            face = GameObject.Find(&quot;GameFace&quot;).GetComponent&lt;GameFace&gt;();
        return face;
    }
}
// Start is called before the first frame update
void Start()
{
    //face = this;
    uiManager = new UIManager(this);
    clientManeger = new ClientManeger(this);
    requestManager = new RequestManager(this);
    playerManager = new PlayerManager(this);
    uiManager.OnInit();
    clientManeger.OnInit();
    requestManager.OnInit();
    playerManager.OnInit();
}
private void OnDestroy()
{
    clientManeger.OnDestory();
    requestManager.OnDestory();
    uiManager.OnDestory();
}
public void Send(MainPack pack)
{
    clientManeger.Send(pack);
}
public void SendTo(MainPack pack)
{
    pack.User = UserName;//向包中加入用户名，用于服务端UDP对本客户端通信地址赋值
    clientManeger.SendTo(pack);
}
public void HandleResoonse(MainPack pack)
{
    //处理
    Debug.Log(&quot;服务器返回&quot;+pack.Returncode.ToString());
    requestManager.HandleResponse(pack);
}
public void AddRequest(BaseRequest request)
{
    requestManager.AddRequest(request);
}
public void RemoveReqest(ActionCode action)
{
    requestManager.RemoveRequest(action);
}

public void ShowMessage(string message,bool sync=false)
{
    uiManager.ShowMessage(message,sync);
}
/*public void SetSelfID(string id)
{
    playerManager.CurPlayerID = id;
}*/
public void AddPlayer(MainPack packs)
{
    playerManager.AddPlayer(packs);
}
public void RemovePlayer(string id)
{
    playerManager.RemovePlayer(id);
}
public void GameExit()
{
    playerManager.GameExit();
    uiManager.PopPaneal();
    uiManager.PopPaneal();
    requestManager.RemoveRequest(ActionCode.UpState);
    requestManager.RemoveRequest(ActionCode.Fire);
}
public void UpPos(MainPack pack)
{
    playerManager.UpPos(pack);
}
public void SpawnBullet(MainPack pack)
{
    playerManager.SpawnBullet(pack);
}
</code></pre>
<p>}</p>
<p><strong>BaseRequest基类</strong><br>
using GameSocketServerProtocol;<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class BaseRequest : MonoBehaviour<br>
{<br>
protected RequestCode requestCode;<br>
protected ActionCode actionCode;<br>
protected GameFace face;<br>
public ActionCode GetActionCode<br>
{<br>
get { return actionCode; }<br>
}<br>
public virtual void Awake()<br>
{<br>
face = GameFace.Face;<br>
}<br>
public virtual void Start()<br>
{<br>
face.AddRequest(this);<br>
Debug.Log(actionCode.ToString());<br>
}<br>
public virtual void OnDesttroy()<br>
{<br>
face.RemoveReqest(actionCode);<br>
}</p>
<pre><code>public virtual void OnResponse(MainPack pack)
{

}
//基类TCP发送
public virtual void SendRequest(MainPack pack)
{
    face.Send(pack);
}
//基类UDP发送
public virtual void SendRequestUDP(MainPack pack)
{
    face.SendTo(pack);
}
</code></pre>
<p>}<br>
<strong>ClientManager</strong><br>
using GameSocketServerProtocol;<br>
using System;<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using System.Net.Sockets;<br>
using UnityEngine;</p>
<p>public class ClientManeger : BaseManager<br>
{<br>
private Socket socket;<br>
private Message message;<br>
public ClientManeger(GameFace face) : base(face)  { }</p>
<pre><code>public override void OnInit()
{
    base.OnInit();
    message = new Message();
    InitSocket();//初始化TCP通信
    InitUDP();//初始化UDP通信
}
public override void OnDestory()
{
    base.OnDestory();
    message = null;
    CloseSocket();
}/// &lt;summary&gt;
/// 初始化Socket
/// &lt;/summary&gt;
private void InitSocket()
{
    socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
    try
    {
        socket.Connect(&quot;127.0.0.1&quot;, 6666);
        //连接成功
        face.ShowMessage(&quot;连接成功&quot;);
        StartReceive();
    }
    catch(Exception e)
    {
        Debug.LogWarning(e);
        //连接错误
        face.ShowMessage(&quot;连接失败&quot;);
    }
}
/// &lt;summary&gt;
/// 关闭Socket
/// &lt;/summary&gt;
private void CloseSocket()
{
    if(socket.Connected&amp;&amp;socket!=null)
    {
        socket.Close();
    }
}
private void StartReceive()
{
    socket.BeginReceive(message.Buffer, message.StartIndex, message.Remsize, SocketFlags.None, RecelveClientBack,null);

}

private void RecelveClientBack(IAsyncResult iar)
{
    try
    {
        if (socket == null || socket.Connected == false) return;
        int len = socket.EndReceive(iar);
        if(len==0)
        {
            CloseSocket();
            return;
        }
        message.ReadBuffer(len,HandleResoonse);
        StartReceive();
    }catch(Exception e)
    {
        Debug.Log(e.Message);
    }
}
private void HandleResoonse(MainPack pack)
{
    face.HandleResoonse(pack);
}

public void Send(MainPack pack)
{
    socket.Send(Message.PackDate(pack));
}

//UDP通信**————————————————————————————**
private Socket udpClient;//Socket
private IPEndPoint iPEndPoint;//服务器地址
private EndPoint EPoint;//
private Byte[] buffer = new Byte[1024];

private void InitUDP()
{
    udpClient = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
    iPEndPoint = new IPEndPoint(IPAddress.Parse(ip), 6667);
    EPoint = iPEndPoint;
    try
    {
        udpClient.Connect(EPoint);
    }
    catch 
    {
        Debug.Log(&quot;UPD连接失败&quot;);
        return;
    }
    aucThread = new Thread(ReceiveMsg);
    aucThread.Start();
}
private void ReceiveMsg()
{
    //同步循环接收
    Debug.Log(&quot;UDP开始接收&quot;);
    while(true)
    {
        int len = udpClient.ReceiveFrom(buffer, ref EPoint);
        MainPack pack = (MainPack)MainPack.Descriptor.Parser.ParseFrom(buffer, 0, len);
        Debug.Log(&quot;接收数据&quot; + pack.Actioncode + pack.User);
        HandleResoonse(pack);//收到MainPack包的处理方法与TCP一致，
        //通过RequestManager找到对应的Reeuest,调用对应UDP通信类型的处理方法(根据包中的数据同步位置/其他操作)
    }
}
//UDP发送数据方法
public void SendTo(MainPack pack)
{
    byte[] sendbuffer = Message.PackDateUDP(pack);
    //服务端地址固定，首次连接后即可发送
    udpClient.Send(sendbuffer, sendbuffer.Length, SocketFlags.None);//使用Send必须先连接“110”行代码
    //SendTo需要目的地址EndPoint
}
</code></pre>
<p>}<br>
<strong>RequestManager</strong><br>
using GameSocketServerProtocol;<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class RequestManager : BaseManager<br>
{<br>
public RequestManager(GameFace face):base(face) { }</p>
<pre><code>private Dictionary&lt;ActionCode, BaseRequest&gt; requestDict = new Dictionary&lt;ActionCode, BaseRequest&gt;();

public void AddRequest(BaseRequest request)
{
    requestDict.Add(request.GetActionCode, request);
    Debug.Log(&quot;新请求：&quot; + request.GetActionCode.ToString());
}
public void RemoveRequest(ActionCode action)
{
    requestDict.Remove(action);
}
public void HandleResponse(MainPack pack)
{
    if (requestDict.TryGetValue(pack.Actioncode, out BaseRequest request))
    {
        //基类回应请求方法，已在子类中重写
        request.OnResponse(pack);
    }else
    {
        Debug.Log(&quot;未找到对应处理&quot;);
    }        
}
</code></pre>
<p>}<br>
</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[BaseMVC_UI]]></title>
        <id>https://Wei715547.github.io/post/basemvc_ui/</id>
        <link href="https://Wei715547.github.io/post/basemvc_ui/">
        </link>
        <updated>2020-12-13T11:28:39.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://Wei715547.github.io/post-images/1607863048846.jpg" alt="" loading="lazy"><br>
<strong>M：数据模型</strong>//此例两界面共用一个数据模型<br>
using System;<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.Events;<br>
/// <summary><br>
/// 数据模型<br>
/// </summary><br>
public class PlayerMode<br>
{<br>
#region//数据层<br>
private string playername;<br>
public string Playername<br>
{<br>
get<br>
{<br>
return playername;<br>
}<br>
}<br>
private int lev;<br>
public int Lev<br>
{<br>
get<br>
{<br>
return lev;<br>
}<br>
}</p>
<pre><code>private int money;
public int Money
{
    get
    {
        return money;
    }
}

private int power;
public int Power
{
    get
    {
        return power;
    }
}


private int hp;
public int Hp
{
    get { return hp; }
}
private int atk;
public int Atk
{
    get { return atk; }
}
private int def;
public int Def
{
    get { return def; }
}
private int miss;
public int Miss
{
    get { return miss; }
}

//通过事件与外部联系
public event Action&lt;PlayerMode&gt; updateEvent;

//数据模型类单例，达到数据唯一，与获取数据
private static PlayerMode date;
public static PlayerMode Date
{
    get
    {
        if(date==null)
        {
            date = new PlayerMode();
            date.Init();
        }
        return date;
    }
}
#endregion

//初始化
public void Init()
{
    playername = PlayerPrefs.GetString(&quot;Playername&quot;, &quot;Wei&quot;);//PlayerPrefs类场景中存储值
    lev = PlayerPrefs.GetInt(&quot;Lev&quot;, 17);
    money = PlayerPrefs.GetInt(&quot;Money&quot;, 100);
    power = PlayerPrefs.GetInt(&quot;Power&quot;, 100);

    hp = PlayerPrefs.GetInt(&quot;Hp&quot;, 100);
    atk = PlayerPrefs.GetInt(&quot;Atk&quot;, 100);
    def = PlayerPrefs.GetInt(&quot;Def&quot;, 100);
    miss = PlayerPrefs.GetInt(&quot;Miss&quot;, 100);
}
//更新
public void LeveUp()
{
    lev += 1;

    hp += 10;
    atk += 10;
    def += 10;
    miss += 10;

    SaveDate();//更新后保存数据

    
}
//保存
public void SaveDate()
{
    PlayerPrefs.SetString(&quot;Playername&quot;, playername);
    PlayerPrefs.SetInt(&quot;Lev&quot;, lev);
    PlayerPrefs.SetInt(&quot;Money&quot;, money);
    PlayerPrefs.SetInt(&quot;Power&quot;, power);

    PlayerPrefs.SetInt(&quot;Hp&quot;, hp);
    PlayerPrefs.SetInt(&quot;Atk&quot;, atk);
    PlayerPrefs.SetInt(&quot;Def&quot;, def);
    PlayerPrefs.SetInt(&quot;Miss&quot;, miss);

    UpdateInfo();
}
//外部注册事件
public void AddEventLissent(Action&lt;PlayerMode&gt; function)
{
    updateEvent += function;
}
//外部取消注册事件
public void RemoveEventLissent(Action&lt;PlayerMode&gt; function)
{
    updateEvent -= function;
}
//通知更新数据的方法（调用数据更新时执行的事件）
public void UpdateInfo()
{
    updateEvent?.Invoke(this);
}
</code></pre>
<h2 id="">}</h2>
<p><strong>V：界面脚本</strong>//获取控件，更新控件数据<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.UI;<br>
//VM<br>
public class PlayerMainView : MonoBehaviour<br>
{<br>
//获取控件<br>
public Button btnRole;<br>
public Button btnSkill;</p>
<pre><code>public Text txtName;
public Text txtLev;
public Text txtMoney;
public Text txtPower;

//提供面板更新相关方法给外部
public void UpdateInfo(PlayerMode date)
{
    txtName.text = date.Playername;
    txtLev.text = &quot;Lv:&quot; + date.Lev.ToString();
    txtMoney.text = date.Money.ToString();
    txtPower.text = date.Power.ToString();
}
</code></pre>
<p>}</p>
<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.UI;<br>
//VR<br>
public class PlayerRoleView : MonoBehaviour<br>
{<br>
//获取控件<br>
public Button btnBack;<br>
public Button btnLeveUp;</p>
<pre><code>public Text txtHp;
public Text txtAtk;
public Text txtDef;
public Text txtMiss;

//提供面板更新相关方法给外部
public void UpdateInfo(PlayerMode date)
{
    txtHp.text = date.Hp.ToString();
    txtAtk.text = date.Atk.ToString();
    txtDef.text = date.Def.ToString();
    txtMiss.text = date.Miss.ToString();
}
</code></pre>
<h2 id="-2">}</h2>
<p><strong>C：界面控制脚本</strong>//显隐，初始化，界面逻辑，数据更新时调用的事件<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
/// <summary><br>
/// 处理主界面业务逻辑<br>
/// </summary><br>
public class MainController : MonoBehaviour<br>
{<br>
//能够在Controller中获取View界面<br>
private PlayerMainView mainView;</p>
<pre><code>private static MainController contorller;

public static MainController Controller
{
    get
    {
        return contorller;
    }
}
//界面显示隐藏
public static void ShowPanel()
{
    if(contorller==null)
    {
        GameObject res = Resources.Load&lt;GameObject&gt;(&quot;UI/MainPanel&quot;);
        GameObject obj = Instantiate(res);
        obj.transform.SetParent(GameObject.Find(&quot;Canvas&quot;).transform);
        contorller = obj.GetComponent&lt;MainController&gt;();
    }
}
public static void HeadPanel()
{
    contorller.gameObject.SetActive(false);
}

private void Start()
{
    //获取挂载同一物体上的View脚本
    mainView = this.GetComponent&lt;PlayerMainView&gt;();
    //第一次界面更新
    mainView.UpdateInfo(PlayerMode.Date);

    mainView.btnRole.onClick.AddListener(OnRoleBtnClick);

    //数据更新时同时更新界面
    PlayerMode.Date.AddEventLissent(UpdateInfo);
}

private void OnRoleBtnClick()
{
    RoleController.ShowPanel();
}

//界面事件监听，逻辑处理
//界面更新
private void UpdateInfo(PlayerMode date)
{
    if(mainView!=null)
        mainView.UpdateInfo(date);
}
</code></pre>
<p>}</p>
<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
/// <summary><br>
/// 处理属性界面业务逻辑<br>
/// </summary><br>
public class RoleController : MonoBehaviour<br>
{<br>
//能够在Controller中获取View界面<br>
private PlayerRoleView roleView;</p>
<pre><code>private static RoleController contorller;

public static RoleController Controller
{
    get
    {
        return contorller;
    }
}
//界面显示隐藏
public static void ShowPanel()
{
    if (contorller == null)
    {
        GameObject res = Resources.Load&lt;GameObject&gt;(&quot;UI/RolePanel&quot;);
        GameObject obj = Instantiate(res);
        obj.transform.SetParent(GameObject.Find(&quot;Canvas&quot;).transform);
        contorller = obj.GetComponent&lt;RoleController&gt;();
    }
}
public static void HeadPanel()
{
    contorller.gameObject.SetActive(false);
}

private void Start()
{
    //获取挂载同一物体上的View脚本
    roleView = this.GetComponent&lt;PlayerRoleView&gt;();
    //第一次界面更新
    roleView.UpdateInfo(PlayerMode.Date);

    roleView.btnBack.onClick.AddListener(OnClickBack);
    roleView.btnLeveUp.onClick.AddListener(OnClickLeveUp);

    //数据更新时同时更新界面
    PlayerMode.Date.AddEventLissent(UpdataInfo);
    //PlayerMode.Date.AddEventLissent(roleView.UpdateInfo);
    //PlayerMode.Date.updateEvent += roleView.UpdateInfo;
}
private void OnClickBack()
{
    HeadPanel();
}
private void OnClickLeveUp()
{
    //通过事件模块，改变数据。
    PlayerMode.Date.LeveUp();
}

//界面事件监听，逻辑处理
//界面更新
private void UpdataInfo(PlayerMode date)
{
    if(roleView!=null)
        roleView.UpdateInfo(date);
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Particle System]]></title>
        <id>https://Wei715547.github.io/post/particle-system/</id>
        <link href="https://Wei715547.github.io/post/particle-system/">
        </link>
        <updated>2020-12-09T11:07:27.000Z</updated>
        <content type="html"><![CDATA[<p><a href = "https://docs.unity3d.com/Manual/PartSysMainModule.html"><strong>Main</strong></a><br>
<img src="https://Wei715547.github.io/post-images/1607512192204.jpg" alt="" loading="lazy"><br>
<strong>单一粒子</strong><br>
<strong>Firefly</strong><br>
<img src="https://Wei715547.github.io/post-images/1607513562693.png" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1607514533865.png" alt="" loading="lazy"><br>
<strong>Sparks</strong><br>
<img src="https://Wei715547.github.io/post-images/1607515384766.png" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1607515390739.png" alt="" loading="lazy"><br>
<strong>组合粒子</strong><br>
<strong>Fire</strong><br>
<img src="https://Wei715547.github.io/post-images/1607515642296.PNG" alt="" loading="lazy"><br>
BackGround/Front<br>
<img src="https://Wei715547.github.io/post-images/1607673107804.png" alt="" loading="lazy"><br>
Start<br>
<img src="https://Wei715547.github.io/post-images/1607673641050.png" alt="" loading="lazy"><br>
<strong>Cartoon Boom</strong><br>
<img src="https://Wei715547.github.io/post-images/1607515820679.png" alt="" loading="lazy"><br>
<strong>Her</strong><br>
<img src="https://Wei715547.github.io/post-images/1607515954518.PNG" alt="" loading="lazy"><br>
<strong>Sub PTS</strong><br>
<img src="https://Wei715547.github.io/post-images/1607516146807.PNG" alt="" loading="lazy"><br>
<strong>DrawLine</strong><br>
<img src="https://Wei715547.github.io/post-images/1607517065579.PNG" alt="" loading="lazy"><br>
<cood><br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>[RequireComponent(typeof(ParticleSystem))]<br>
[ExecuteInEditMode]<br>
public class ParticleSystemLine : MonoBehaviour<br>
{<br>
/// <summary><br>
/// 粒子系统<br>
/// </summary><br>
private ParticleSystem mParticleSystem;<br>
/// <summary><br>
/// 线的材质<br>
/// </summary><br>
public Material mMaterial;<br>
/// <summary><br>
/// 粒子数组<br>
/// </summary><br>
private ParticleSystem.Particle[] particles;<br>
/// <summary><br>
/// LineRenderer数组<br>
/// </summary><br>
private List<LineRenderer> linePool = new List<LineRenderer>();<br>
/// <summary><br>
/// 当前存活的粒子<br>
/// </summary><br>
private int numParticlesAlive;<br>
/// <summary><br>
/// 连线距离<br>
/// </summary><br>
public float MinDist = 5;<br>
/// <summary><br>
/// 线的宽度<br>
/// </summary><br>
public float LineWidth = 0.1f;</p>
<pre><code>/// &lt;summary&gt;
/// 已经使用的LineRender位置
/// &lt;/summary&gt;
private int index = 0;

//public AnimationCurve LineWidthOverLifetime = AnimationCurve.Constant(0,1,1);
void Start()
{
    mParticleSystem = GetComponent&lt;ParticleSystem&gt;();
    //初始化粒子数组
    particles = new ParticleSystem.Particle[mParticleSystem.main.maxParticles];
}

void LateUpdate()
{
    //获取粒子数据
    numParticlesAlive = mParticleSystem.GetParticles(particles);

    //两个粒子的距离小于MinDist就连线
    for(int i = 0;i &lt; numParticlesAlive; i++)
    {
        for (int j = i + 1; j &lt; numParticlesAlive; j++)
        {
            //粒子直接距离的平方
            float SqrDis = (particles[j].position - particles[i].position).sqrMagnitude;

            if (SqrDis &lt; MinDist * MinDist)
            {
                ParticleSystem.Particle particle = particles[j];
                ParticleSystem.Particle cur_particle = particles[i];
                //获取粒子的颜色
                Color sColor = cur_particle.GetCurrentColor(mParticleSystem);
                Color eColor = particle.GetCurrentColor(mParticleSystem);
                //计算宽度
                //float width = LineWidth*LineWidthOverLifetime.Evaluate(cur_particle.remainingLifetime/cur_particle.startLifetime);
                //绘制线
                DrawLine(cur_particle.position, particle.position, sColor, eColor, LineWidth);

            }
        }
    }

    mParticleSystem.SetParticles(particles, numParticlesAlive);
    for(int i=index;i&lt;linePool.Count;i++)
    {
        linePool[i].gameObject.SetActive(false);
    }
    index = 0;
}

/// &lt;summary&gt;
/// 绘制线条
/// &lt;/summary&gt;
/// &lt;param name=&quot;startPos&quot;&gt;&lt;/param&gt;
/// &lt;param name=&quot;endPos&quot;&gt;&lt;/param&gt;
/// &lt;param name=&quot;startColor&quot;&gt;&lt;/param&gt;
/// &lt;param name=&quot;endColor&quot;&gt;&lt;/param&gt;
/// &lt;param name=&quot;width&quot;&gt;&lt;/param&gt;
void DrawLine(Vector3 startPos,Vector3 endPos,Color startColor,Color endColor,float width = 0.1f)
{
    LineRenderer line;

    if(linePool.Count==index)
    {
        GameObject go = new GameObject(&quot;tempLine&quot;);
        go.transform.parent = transform;
        line = go.AddComponent&lt;LineRenderer&gt;();
        line.useWorldSpace = true;
        line.material = mMaterial;
        linePool.Add(line);
        index++;
    }
    else
    {
        line = linePool[index++];
        line.gameObject.SetActive(true);
    }

    //点的数量
    line.positionCount = 2;
    
    //设置线的位置
    line.SetPosition(0,startPos);
    line.SetPosition(1,endPos);

    //线的颜色
    line.startColor = startColor;
    line.endColor = endColor;

    //线的宽度
    line.startWidth = width;
    line.endWidth = width;
}
</code></pre>
<p>}<br>
</cood></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++泛型/STL]]></title>
        <id>https://Wei715547.github.io/post/cfan-xing-stl/</id>
        <link href="https://Wei715547.github.io/post/cfan-xing-stl/">
        </link>
        <updated>2020-11-28T12:20:41.000Z</updated>
        <content type="html"><![CDATA[<p><strong>函数模板</strong><br>
与普通函数区别：<br>
1.普通函数调用存在隐式类型转换<br>
2.自动类型推导调用时，不发生隐式类型转换<br>
3.显示指定类型调用可以发生隐式类型转换<br>
与普通函数重名时：<br>
1,.默认调用普通函数<br>
2.通过空模板参数类表(Max&lt;&gt;)强制调用函数模板<br>
3.函数模板可发生重载(参数个数不同)<br>
4.函数模板可产生更好的匹配时优先调用函数模板<br>
例：普通函数：void Fun(int a,int b){}<br>
函数模板：template<class T> viod Fun (T a,T b){};<br>
调用Fun(a,b)//a,b为char类型时普通函数需隐式转换int为char，函数模板只需将T制定为char类型，即优先调用函数模板。<br>
模板局限性：如自定义类型对比（解决方法1.在自定义类型中重置内置运算符，2.利用具体化模板实现代码）=&gt;template &lt;&gt; bool Compare(Person p1,Person p2)<br>
{<br>
if(p1.name ==p2.name&amp;&amp;p1.age == p2.age)<br>
return true;<br>
else<br>
return false;<br>
};<br>
声明格式：<br>
template <class T>//或写成<typename T>与class无区别<br>
//需要不同类型参数时&lt;typename T1,typename T2&gt;u77<br>
返回值 函数名 （形参表）<br>
{<br>
函数体；<br>
}<br>
template <class T><br>
T Max(T Inpute1, T Inpuet2)<br>
{<br>
return (Inpute1 &gt; Inpute2) ? Inpute1 : Inpute2;<br>
}<br>
使用：<br>
1.自动类型推导<br>
Max(a,b);<br>
2.显示指定类型<br>
Max<int>(a,b);<br>
<strong>类模板</strong>//与函数模板区别：1.没有自动类型推导，<br>
2.在模板参数列表中可以有默认参数template <typename T = int>//未指定类型是默认为int</p>
<p>template <typename T><br>
class 类名<br>
{<br>
类定义；<br>
}<br>
template &lt;class T1,class T2&gt;<br>
class Person<br>
{<br>
public:<br>
Person(T1 name,T2 age)<br>
{<br>
this-&gt;Name = name;<br>
this-&gt;Age =age;<br>
}<br>
void ShowPerson(T1 name,T2 age);<br>
private:<br>
T1 Name;<br>
T2 Age;<br>
}<br>
在类外定义成员函数时：<br>
template <typename T><br>
返回值类型 类名<T>::函数名(T x,T y)<br>
{<br>
函数体；<br>
}<br>
template &lt;typename T1, typenme T2&gt;<br>
void Person&lt;T1,T2&gt;::ShowPerson(T1 name,T2 age)<br>
{<br>
cout&lt;&lt;name&lt;&lt;age&lt;&lt;endl;<br>
}<br>
类模板声明对象：<br>
类名&lt;泛型数据类型&gt; 对象名；<br>
Person&lt;string,int&gt; p (&quot;Wei&quot;,17);</p>
<p><strong>类模板对象作为函数参数</strong><br>
1.指定传入类型<br>
void PrintPerson(Person&lt;string ,int&gt; &amp;p)<br>
{<br>
p.ShowPerson(p.name,p.age);<br>
}<br>
2.参数模板化<br>
template &lt;class T1,class T2&gt;<br>
void PrintPerson(Person&lt;T1 ,T3&gt; &amp;p)<br>
{<br>
p.ShowPerson(p.name,p.age);<br>
}<br>
3.整个类模板化<br>
template <class T><br>
void PrintPerson(T &amp;p)<br>
{<br>
p.ShowPerson(p.name,p.age);<br>
}</p>
<p><strong>类模板与继承</strong><br>
1.当子类继承的父类为一个类模板时，子类在声明时必须指定父类中T的类型。<br>
template <class T><br>
class Base<br>
{<br>
T m;<br>
}<br>
class Son :public Base<int>//指定父类T类型<br>
{</p>
<p>};<br>
2.如果不指定 ，编译器无法为子类分配内存。<br>
3.如想灵活指定父类T类型，则需将子类也定义为类模板。<br>
template &lt;class T1, class T2&gt;//子类也定义为类模板<br>
class Son :public Base<T2><br>
{<br>
T1 obj;<br>
};<br>
Son&lt;int,char&gt; s1;<br>
——————————————————————————————————————<br>
<strong>STL</strong></p>
<p><strong>Vector</strong>:单端数组，动态拓展：开辟一块更大的空间拷贝数据，释放原来空间。<br>
迭代器：v.begin()//指向容器首位置<br>
v.end()//指向容器最后一位的下一个位置<br>
v.rend()//首位的前一位置<br>
v.rbegin()//指向最后一位元素<br>
支持随机访问<br>
构造函数：<br>
vector<T> v;//              默认构造函数<br>
vector(v.begin(),v.end())//         将v的首末拷贝到本身<br>
vector(n,elem)//            将n个elem拷贝给本身<br>
vector(const vector &amp;vec)//         拷贝构造函数<br>
赋值操作：<br>
operator=<br>
v.assign(v1.begin(), v1.end())<br>
v.assign(n,elem);<br>
容量大小方法：<br>
empty()//判断容易是否为空；<br>
capacity()//容器容量<br>
size()//容器中元素的个数<br>
resize(int num)//重新制定容器的长度为num<br>
resize(int num elem)//重新定义容器长度，并默认以elem填充<br>
插入/删除方法：<br>
push_back(ele);//在尾部插入数据<br>
pop_back()//在尾部删除数据<br>
insert(const_iterator  pos, ele)//在迭代器所指向位置插入ele<br>
insert(const_iterator  pos, int count, ele)//在迭代器所指向位置插入count个ele<br>
erase(const_iterator pos);//删除迭代器所指向的元素<br>
erase(const_iterator start, const_iterator end)//清除迭代器s-e之间的元素<br>
clear();//清空元素</p>
<p>#include <iostream><br>
#include &quot;pch.cpp&quot;<br>
#include<vector><br>
#include<algorithm><br>
using namespace std;</p>
<p>int main()<br>
{<br>
//cout &lt;&lt; &quot;WEI&quot; &lt;&lt; endl;<br>
Fun1();<br>
return 0;</p>
<p>}<br>
void Fun1()<br>
{<br>
//创建Vector容器<br>
vector<int> v;</p>
<pre><code>//向容器中插入数据
v.push_back(10);
v.push_back(20);
v.push_back(30);
v.push_back(40);
v.push_back(50);

////通过迭代器访问容器中的数据
//vector&lt;int &gt;::iterator itBegin = v.begin();//起始迭代器，指向容器第一个元素
//vector&lt;int &gt;::iterator itEnd = v.end();//结束迭代器，指向最后一个元素的下一个位置

////遍历方式
//while (itBegin != itEnd)
//{
//	cout &lt;&lt; *itBegin &lt;&lt; endl;
//	itBegin++;
//}

//遍历方式二
for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)
{
	cout &lt;&lt; *it &lt;&lt; endl;
}

//第三种 STL提供的遍历算法
for_each (v.begin(), v.end(), MyPrint);
</code></pre>
<h2 id="void-myprintint-varcout-var-endl">}<br>
void MyPrint(int var)<br>
{<br>
cout &lt;&lt; var &lt;&lt; endl;<br>
}</h2>
<p><strong>C++链表List</strong><br>
优点：可在任意位置插入大量元素，修改指针即可不需要移动大量元素；动态内存分配，不会造成内存浪费和溢出<br>
缺点：空间(占用空间比较大)，时间(遍历速度慢)的额外消耗较大；插入和删除操作不会造成原来的迭代器失效，这在vector中是不成立的（数组装满后会开辟新的更大的空间拷贝源数据，但迭代器仍指向原地址）<br>
//遍历方法<br>
void MyList::printList(const list<int>&amp; L)<br>
{<br>
for (list<int>::const_iterator it = L.begin(); it!= L.end(); it++)<br>
{<br>
cout &lt;&lt; *it &lt;&lt; &quot; &quot;;<br>
}<br>
cout &lt;&lt; endl;<br>
}<br>
void MyList::List()<br>
{<br>
//创建Lis容器<br>
list<int> Li; //默认构造</p>
<pre><code>	//添加数据
	Li.push_back(10);
	Li.push_back(20);
	Li.push_back(30);
	Li.push_back(40);

	//遍历容器
	printList(Li);

	//区间构造
	list&lt;int&gt; L2(Li.begin(), Li.end());
	printList(L2);

	//拷贝构造
	list&lt;int &gt; L3 (L2);
	printList(L3);

	//N个ELE构造
	list&lt;int&gt; L4(10, 999);
	printList(L4);

    //**赋值 **=
	list&lt;int&gt; L5;
	L5 = L4;
	//区间
	list&lt;int&gt; L6;
	L6.assign(L4.begin(), L4.end());
	//n*Ele
	list&lt;int&gt; L7;
	L7.assign(5, 7);

	//交换
	printList(L6);
	printList(L7);
	L7.swap(L6);
	printList(L6);
	printList(L7);

    //**list大小操作**
	cout&lt;&lt;L7.size()&lt;&lt;endl;//返回容器元素个数
	cout &lt;&lt; L7.empty()&lt;&lt;endl;//容器是否为空
	L7.resize(7);//重新定义容器长度，多则0填充，少则从末尾删除
	printList(L7);
	L7.resize(10, 777);//重新定义容器长度，多则ele填充，少则从末尾删除
	printList(L7);

    //**插入/删除**
	list&lt;int&gt; insDle(5,7);
	//头插
	insDle.push_front(3);
	insDle.push_front(2);
	insDle.push_front(1);
	//尾插
	insDle.push_back(7);
	insDle.push_back(8);
	insDle.push_back(9);
	printList(insDle);
	//尾删除
	insDle.pop_back();
	//头部删除
	insDle.pop_front();
	printList(insDle);

	//insert插入
	list&lt;int&gt;::iterator it = insDle.begin();
	insDle.insert(++it, 23);
	printList(insDle);
	//删除
	it = insDle.begin();
	insDle.erase(it);
	printList(insDle);
	//移除所有同样的元素
	insDle.remove(7);
	printList(insDle);
	//清空
	insDle.clear();
	printList(insDle);
    //数据存取
	L7.front();
	L7.back();
	list&lt;int&gt;::iterator Linklist_it = L7.begin();
	Linklist_it++;//支持双向
	Linklist_it--;//不支持--则为单相访问
	//Linklist_it = Linklist_it + 1;//可以这样写着表示可以支持随机访问，链表不支持随机访问。

	//链表反转/排序
	printList(L7);
	L7.reverse();
	printList(L7);
	//排序
	list&lt;int&gt; ls;
	ls.push_back(3);
	ls.push_back(1);
	ls.push_back(2);
	//所有不支持随机访问到迭代器的容器，不支持标准算法
	//容器内部会提供对应的一些算法
	ls.sort();//默认升生序排序
	//MyList l;
	//ls.sort(l.MyCompare);
	printList(ls);
}
}
例：两数之和LC
list&lt;int&gt; TowAddList(list&lt;int&gt;* l1, list&lt;int&gt;* l2)
</code></pre>
<p>{<br>
list<int> res;<br>
list<int>::iterator pos1 = l1-&gt;begin();<br>
list<int>::iterator pos2 = l2-&gt;begin();<br>
int digit = 0;<br>
while (pos1!=l1-&gt;end()||pos2!=l2-&gt;end())<br>
{<br>
int total = digit;<br>
if (pos1 != l1-&gt;end())<br>
{<br>
total += *pos1;<br>
pos1++;<br>
}<br>
if (pos2 != l2-&gt;end())<br>
{<br>
total += *pos2;<br>
pos2++;<br>
}<br>
digit = total / 10;<br>
res.push_back(total % 10);<br>
}<br>
if (digit != 0)<br>
{<br>
res.push_back(digit);<br>
}<br>
return res;<br>
}<br>
—————————————————————————————————————————<br>
<strong>哈希表/(键值对)</strong><br>
map/multimap：元素为pair键值对，底层容器由二叉树实现<br>
优点：根据key可以快速找到value<br>
map不允许有重复的key<br>
multimap允许有重复的key<br>
class MyTable<br>
{<br>
public:<br>
void MapText()<br>
{<br>
//默认构造<br>
map&lt;int, string&gt; m1;//map会根据键的值进行默认的排序，与先后插入顺序无关<br>
m1.insert(pair&lt;int, string&gt;(1, &quot;A&quot;));<br>
m1.insert(pair&lt;int, string&gt;(3, &quot;C&quot;));<br>
m1.insert(map&lt;int, string&gt;::value_type(2,&quot;B&quot;));<br>
//m1.insert(pair&lt;int, string&gt;(3, &quot;C&quot;));<br>
m1.insert(pair&lt;int, string&gt;(7, &quot;W&quot;));<br>
printMap(m1);</p>
<pre><code>		//拷贝构造
		map&lt;int, string&gt;m2(m1);
		printMap(m2);
		//赋值
		map&lt;int, string&gt; m3 = m2;
		m3.erase(7);
		m3.insert(pair&lt;int ,string&gt;(11, &quot;Z&quot;));
		printMap(m3);

		//大小和交换
		cout &lt;&lt; m1.size()&lt;&lt;endl;
		cout &lt;&lt; m1.empty()&lt;&lt;endl;

		m2.swap(m3);
		printMap(m2);
		printMap(m3);

		//插入/删除
		map&lt;int, string&gt; m7;
		m7.insert(pair&lt;int ,string&gt;(1, &quot;A&quot;));			
		m7.insert(pair(2, &quot;B&quot;));
		m7.insert(make_pair(3, &quot;C&quot;));
		m7.insert(map&lt;int, string&gt;::value_type(7, &quot;W&quot;));
		m7[5] = &quot;Z&quot;;//不存在Key时，会创建该键值为类型默认值，不建议使用，可以用来读取键中的值
		printMap(m7);

		//删除
		m7.erase(m7.begin());
		m7.erase(3);//按照key删除
		//m7.erase(m7.begin(), m7.end());
		//m7.clear();
		m7.insert(pair(17, &quot;Z&quot;));
		printMap(m7);

		//查找,返回值为迭代器，未找到2时返回容器的end()
		map&lt;int, string&gt;::iterator pos = m7.find(7);
		if (pos != m7.end())
			cout &lt;&lt; (*pos).first &lt;&lt;&quot; &quot;&lt;&lt;(*pos).second &lt;&lt; endl;
		//统计,1/0，multimap允许键重复适用此方法
		int n = m7.count(7);
		cout &lt;&lt; n &lt;&lt; endl;
	}
	void printMap(map&lt;int, string&gt; m)
	{
		for (map&lt;int, string&gt;::iterator it = m.begin(); it != m.end(); it++)
		{
			cout &lt;&lt; &quot;KEY: &quot;&lt;&lt;(*it).first &lt;&lt;&quot; &quot;&lt;&lt; &quot;Value:&quot;&lt;&lt;(*it).second&lt;&lt;endl;
		}
		cout &lt;&lt; endl;
	}
};

//改为降序排序的仿函数
</code></pre>
<p>class MyMapSort<br>
{<br>
public:<br>
bool operator() (int a,int b)<br>
{<br>
//降序：第一个数大于第二个数<br>
return a &gt; b;<br>
}<br>
};<br>
void textmap()<br>
{<br>
map&lt;int, int,MyMapSort&gt; m;//默认按照键从小到大排序<br>
m.insert(pair(1, 1));<br>
m.insert(pair(3, 3));<br>
m.insert(pair(2, 2));</p>
<pre><code>//m.insert(pair(3, 3));
m.insert(pair(4, 4));
m.insert(pair(5, 5));

for (map&lt;int,int, MyMapSort&gt;::iterator it = m.begin(); it!=m.end(); it++)
{
	cout &lt;&lt; &quot;key:&quot; &lt;&lt; (*it).first &lt;&lt; &quot; &quot; &lt;&lt; (*it).second &lt;&lt; endl;
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++运算符重载]]></title>
        <id>https://Wei715547.github.io/post/cyun-suan-fu-chong-zai/</id>
        <link href="https://Wei715547.github.io/post/cyun-suan-fu-chong-zai/">
        </link>
        <updated>2020-11-26T10:39:57.000Z</updated>
        <content type="html"><![CDATA[<h3 id="45-运算符重载">4.5 运算符重载</h3>
<p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>
<h4 id="451-加号运算符重载">4.5.1 加号运算符重载</h4>
<p>作用：实现两个自定义数据类型相加的运算</p>
<pre><code class="language-C++">class Person {
public:
	Person() {};
	Person(int a, int b)
	{
		this-&gt;m_A = a;
		this-&gt;m_B = b;
	}
	//成员函数实现 + 号运算符重载
	Person operator+(const Person&amp; p) {
		Person temp;
		temp.m_A = this-&gt;m_A + p.m_A;
		temp.m_B = this-&gt;m_B + p.m_B;
		return temp;
	}


public:
	int m_A;
	int m_B;
};

//全局函数实现 + 号运算符重载
//Person operator+(const Person&amp; p1, const Person&amp; p2) {
//	Person temp(0, 0);
//	temp.m_A = p1.m_A + p2.m_A;
//	temp.m_B = p1.m_B + p2.m_B;
//	return temp;
//}

//运算符重载 可以发生函数重载 
Person operator+(const Person&amp; p2, int val)  
{
	Person temp;
	temp.m_A = p2.m_A + val;
	temp.m_B = p2.m_B + val;
	return temp;
}

void test() {

	Person p1(10, 10);
	Person p2(20, 20);

	//成员函数方式
	Person p3 = p2 + p1;  //相当于 p2.operaor+(p1)
	cout &lt;&lt; &quot;mA:&quot; &lt;&lt; p3.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p3.m_B &lt;&lt; endl;


	Person p4 = p3 + 10; //相当于 operator+(p3,10)
	cout &lt;&lt; &quot;mA:&quot; &lt;&lt; p4.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p4.m_B &lt;&lt; endl;

}

int main() {

	test();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p>
</blockquote>
<blockquote>
<p>总结2：不要滥用运算符重载</p>
</blockquote>
<hr>
<h4 id="452-左移运算符重载">4.5.2 左移运算符重载</h4>
<p>作用：可以输出自定义数据类型</p>
<pre><code class="language-C++">class Person {
	friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p);//友元：全局运算符重载函数访问类的私有成员

public:

	Person(int a, int b)
	{
		this-&gt;m_A = a;
		this-&gt;m_B = b;
	}

	//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果
	//void operator&lt;&lt;(Person&amp; p){
	//}

private:
	int m_A;
	int m_B;
};

//全局函数实现左移重载
//ostream对象只能有一个
ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p) {
	out &lt;&lt; &quot;a:&quot; &lt;&lt; p.m_A &lt;&lt; &quot; b:&quot; &lt;&lt; p.m_B;
	return out;
}

void test() {

	Person p1(10, 20);

	cout &lt;&lt; p1 &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; //链式编程
}

int main() {

	test();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p>
</blockquote>
<hr>
<h4 id="453-递增运算符重载">4.5.3 递增运算符重载</h4>
<p>作用： 通过重载递增运算符，实现自己的整型数据</p>
<pre><code class="language-C++">
class MyInteger {

	friend ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint);

public:
	MyInteger() {
		m_Num = 0;
	}
	//前置++
	MyInteger&amp; operator++() {
		//先++
		m_Num++;
		//再返回
		return *this;
	}

	//后置++
	MyInteger operator++(int) {
		//先返回
		MyInteger temp = *this; //记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；
		m_Num++;
		return temp;
	}

private:
	int m_Num;
};


ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint) {
	out &lt;&lt; myint.m_Num;
	return out;
}


//前置++ 先++ 再返回
void test01() {
	MyInteger myInt;
	cout &lt;&lt; ++myInt &lt;&lt; endl;
	cout &lt;&lt; myInt &lt;&lt; endl;
}

//后置++ 先返回 再++
void test02() {

	MyInteger myInt;
	cout &lt;&lt; myInt++ &lt;&lt; endl;
	cout &lt;&lt; myInt &lt;&lt; endl;
}

int main() {

	test01();
	//test02();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结： 前置递增返回引用，后置递增返回值</p>
</blockquote>
<h4 id="454-赋值运算符重载">4.5.4 赋值运算符重载</h4>
<p>c++编译器至少给一个类添加4个函数</p>
<ol>
<li>默认构造函数(无参，函数体为空)</li>
<li>默认析构函数(无参，函数体为空)</li>
<li>默认拷贝构造函数，对属性进行值拷贝</li>
<li>赋值运算符 operator=, 对属性进行值拷贝</li>
</ol>
<p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">class Person
{
public:

	Person(int age)
	{
		//将年龄数据开辟到堆区
		m_Age = new int(age);
	}

	//重载赋值运算符 
	Person&amp; operator=(Person &amp;p)
	{
		if (m_Age != NULL)
		{
			delete m_Age;
			m_Age = NULL;
		}
		//编译器提供的代码是浅拷贝
		//m_Age = p.m_Age;

		//提供深拷贝 解决浅拷贝的问题
		m_Age = new int(*p.m_Age);

		//返回自身
		return *this;
	}


	~Person()
	{
		if (m_Age != NULL)
		{
			delete m_Age;
			m_Age = NULL;
		}
	}

	//年龄的指针
	int *m_Age;

};


void test01()
{
	Person p1(18);

	Person p2(20);

	Person p3(30);

	p3 = p2 = p1; //赋值操作

	cout &lt;&lt; &quot;p1的年龄为：&quot; &lt;&lt; *p1.m_Age &lt;&lt; endl;

	cout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; *p2.m_Age &lt;&lt; endl;

	cout &lt;&lt; &quot;p3的年龄为：&quot; &lt;&lt; *p3.m_Age &lt;&lt; endl;
}

int main() {

	test01();

	//int a = 10;
	//int b = 20;
	//int c = 30;

	//c = b = a;
	//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;
	//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;
	//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h4 id="455-关系运算符重载">4.5.5 关系运算符重载</h4>
<p>**作用：**重载关系运算符，可以让两个自定义类型对象进行对比操作</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">class Person
{
public:
	Person(string name, int age)
	{
		this-&gt;m_Name = name;
		this-&gt;m_Age = age;
	};

	bool operator==(Person &amp; p)
	{
		if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)
		{
			return true;
		}
		else
		{
			return false;
		}
	}

	bool operator!=(Person &amp; p)
	{
		if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)
		{
			return false;
		}
		else
		{
			return true;
		}
	}

	string m_Name;
	int m_Age;
};

void test01()
{
	//int a = 0;
	//int b = 0;

	Person a(&quot;孙悟空&quot;, 18);
	Person b(&quot;孙悟空&quot;, 18);

	if (a == b)
	{
		cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;
	}

	if (a != b)
	{
		cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;
	}
}


int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h4 id="456-函数调用运算符重载">4.5.6 函数调用运算符重载</h4>
<ul>
<li>函数调用运算符 ()  也可以重载</li>
<li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li>
<li>仿函数没有固定写法，非常灵活</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">class MyPrint
{
public:
	void operator()(string text)
	{
		cout &lt;&lt; text &lt;&lt; endl;
	}

};
void test01()
{
	//重载的（）操作符 也称为仿函数
	MyPrint myFunc;
	myFunc(&quot;hello world&quot;);
}


class MyAdd
{
public:
	int operator()(int v1, int v2)
	{
		return v1 + v2;
	}
};

void test02()
{
	MyAdd add;
	int ret = add(10, 10);
	cout &lt;&lt; &quot;ret = &quot; &lt;&lt; ret &lt;&lt; endl;

	//匿名对象调用  
	cout &lt;&lt; &quot;MyAdd()(100,100) = &quot; &lt;&lt; MyAdd()(100, 100) &lt;&lt; endl;
}

int main() {

	test01();
	test02();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++构造/析构]]></title>
        <id>https://Wei715547.github.io/post/cgou-zao-xi-gou/</id>
        <link href="https://Wei715547.github.io/post/cgou-zao-xi-gou/">
        </link>
        <updated>2020-11-24T11:22:50.000Z</updated>
        <content type="html"><![CDATA[<h3 id="42-对象的初始化和清理">4.2 对象的初始化和清理</h3>
<ul>
<li>生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全</li>
<li>C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。</li>
</ul>
<h4 id="421-构造函数和析构函数">4.2.1 构造函数和析构函数</h4>
<p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p>
<p>​	一个对象或者变量没有初始状态，对其使用后果是未知</p>
<p>​	同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p>
<p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p>
<p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p>
<p><strong>编译器提供的构造函数和析构函数是空实现。</strong></p>
<ul>
<li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li>
<li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li>
</ul>
<p><strong>构造函数语法：</strong><code>类名(){}</code></p>
<ol>
<li>构造函数，没有返回值也不写void</li>
<li>函数名称与类名相同</li>
<li>构造函数可以有参数，因此可以发生重载</li>
<li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li>
</ol>
<p><strong>析构函数语法：</strong> <code>~类名(){}</code></p>
<ol>
<li>析构函数，没有返回值也不写void</li>
<li>函数名称与类名相同,在名称前加上符号  ~</li>
<li>析构函数不可以有参数，因此不可以发生重载</li>
<li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li>
</ol>
<pre><code class="language-C++">class Person
{
public:
	//构造函数
	Person()
	{
		cout &lt;&lt; &quot;Person的构造函数调用&quot; &lt;&lt; endl;
	}
	//析构函数
	~Person()
	{
		cout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl;
	}

};

void test01()
{
	Person p;
}

int main() {
	
	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h4 id="422-构造函数的分类及调用">4.2.2 构造函数的分类及调用</h4>
<p>两种分类方式：</p>
<p>​	按参数分为： 有参构造和无参构造</p>
<p>​	按类型分为： 普通构造和拷贝构造</p>
<p>三种调用方式：</p>
<p>​	括号法</p>
<p>​	显示法</p>
<p>​	隐式转换法</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">//1、构造函数分类
// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数
// 按照类型分类分为 普通构造和拷贝构造

class Person {
public:
	//无参（默认）构造函数
	Person() {
		cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;
	}
	//有参构造函数
	Person(int a) {
		age = a;
		cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;
	}
	//拷贝构造函数
	Person(const Person&amp; p) {
		age = p.age;
		cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;
	}
	//析构函数
	~Person() {
		cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;
	}
public:
	int age;
};

//2、构造函数的调用
//调用无参构造函数
void test01() {
	Person p; //调用无参构造函数
}

//调用有参的构造函数
void test02() {

	//2.1  括号法，常用
	Person p1(10);
	//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明
	//Person p2();

	//2.2 显式法
	Person p2 = Person(10); 
	Person p3 = Person(p2);
	//Person(10)单独写就是匿名对象  当前行结束之后，马上析构

	//2.3 隐式转换法
	Person p4 = 10; // Person p4 = Person(10); 
	Person p5 = p4; // Person p5 = Person(p4); 

	//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明
	//Person p5(p4);
}

int main() {

	test01();
	//test02();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h4 id="423-拷贝构造函数调用时机">4.2.3 拷贝构造函数调用时机</h4>
<p>C++中拷贝构造函数调用时机通常有三种情况</p>
<ul>
<li>使用一个已经创建完毕的对象来初始化一个新对象</li>
<li>值传递的方式给函数参数传值</li>
<li>以值方式返回局部对象</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">class Person {
public:
	Person() {
		cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;
		mAge = 0;
	}
	Person(int age) {
		cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;
		mAge = age;
	}
	Person(const Person&amp; p) {
		cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;
		mAge = p.mAge;
	}
	//析构函数在释放内存之前调用
	~Person() {
		cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;
	}
public:
	int mAge;
};

//1. 使用一个已经创建完毕的对象来初始化一个新对象
void test01() {

	Person man(100); //p对象已经创建完毕
	Person newman(man); //调用拷贝构造函数
	Person newman2 = man; //拷贝构造

	//Person newman3;
	//newman3 = man; //不是调用拷贝构造函数，赋值操作
}

//2. 值传递的方式给函数参数传值
//相当于Person p1 = p;
void doWork(Person p1) {}
void test02() {
	Person p; //无参构造函数
	doWork(p);
}

//3. 以值方式返回局部对象
Person doWork2()
{
	Person p1;
	cout &lt;&lt; (int *)&amp;p1 &lt;&lt; endl;
	return p1;
}

void test03()
{
	Person p = doWork2();
	cout &lt;&lt; (int *)&amp;p &lt;&lt; endl;
}


int main() {

	//test01();
	//test02();
	test03();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h4 id="424-构造函数调用规则">4.2.4 构造函数调用规则</h4>
<p>默认情况下，c++编译器至少给一个类添加3个函数</p>
<p>1．默认构造函数(无参，函数体为空)</p>
<p>2．默认析构函数(无参，函数体为空)</p>
<p>3．默认拷贝构造函数，对属性进行值拷贝</p>
<p>构造函数调用规则如下：</p>
<ul>
<li>
<p>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造</p>
</li>
<li>
<p>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</p>
</li>
</ul>
<p>示例：</p>
<pre><code class="language-C++">class Person {
public:
	//无参（默认）构造函数
	Person() {
		cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;
	}
	//有参构造函数
	Person(int a) {
		age = a;
		cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;
	}
	//拷贝构造函数
	Person(const Person&amp; p) {
		age = p.age;
		cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;
	}
	//析构函数
	~Person() {
		cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;
	}
public:
	int age;
};

void test01()
{
	Person p1(18);
	//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作
	Person p2(p1);

	cout &lt;&lt; &quot;p2的年龄为： &quot; &lt;&lt; p2.age &lt;&lt; endl;
}

void test02()
{
	//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造
	Person p1; //此时如果用户自己没有提供默认构造，会出错
	Person p2(10); //用户提供的有参
	Person p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供

	//如果用户提供拷贝构造，编译器不会提供其他构造函数
	Person p4; //此时如果用户自己没有提供默认构造，会出错
	Person p5(10); //此时如果用户自己没有提供有参，会出错
	Person p6(p5); //用户自己提供拷贝构造
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h4 id="425-深拷贝与浅拷贝">4.2.5 深拷贝与浅拷贝</h4>
<p>深浅拷贝是面试经典问题，也是常见的一个坑</p>
<p>浅拷贝：简单的赋值拷贝操作</p>
<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">class Person {
public:
	//无参（默认）构造函数
	Person() {
		cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;
	}
	//有参构造函数
	Person(int age ,int height) {
		
		cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;

		m_age = age;
		m_height = new int(height);
		
	}
	//拷贝构造函数  
	Person(const Person&amp; p) {
		cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;
		//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题
		m_age = p.m_age;
		m_height = new int(*p.m_height);
		
	}

	//析构函数
	~Person() {
		cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;
		if (m_height != NULL)
		{
			delete m_height;
		}
	}
public:
	int m_age;
	int* m_height;
};

void test01()
{
	Person p1(18, 180);

	Person p2(p1);

	cout &lt;&lt; &quot;p1的年龄： &quot; &lt;&lt; p1.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p1.m_height &lt;&lt; endl;

	cout &lt;&lt; &quot;p2的年龄： &quot; &lt;&lt; p2.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p2.m_height &lt;&lt; endl;
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Graphic Raycaster：检测所有Canvas上的UI]]></title>
        <id>https://Wei715547.github.io/post/graphic-raycasterjian-ce-suo-you-canvas-shang-de-ui/</id>
        <link href="https://Wei715547.github.io/post/graphic-raycasterjian-ce-suo-you-canvas-shang-de-ui/">
        </link>
        <updated>2020-11-14T12:31:11.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://Wei715547.github.io/post-images/1605357183735.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1605357192515.PNG" alt="" loading="lazy"></p>
<p>The Graphic Raycaster is used to raycast against a Canvas. The Raycaster looks at all Graphics on the canvas and determines if any of them have been hit.</p>
]]></content>
    </entry>
</feed>