<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Wei715547.github.io</id>
    <title>Wei: Development technology accumulation</title>
    <updated>2020-06-27T04:19:53.412Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Wei715547.github.io"/>
    <link rel="self" href="https://Wei715547.github.io/atom.xml"/>
    <subtitle>年月增长，我宜强盛。
用于Unity+开发的技术积累</subtitle>
    <logo>https://Wei715547.github.io/images/avatar.png</logo>
    <icon>https://Wei715547.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Wei: Development technology accumulation</rights>
    <entry>
        <title type="html"><![CDATA[Attribute]]></title>
        <id>https://Wei715547.github.io/post/attribute/</id>
        <link href="https://Wei715547.github.io/post/attribute/">
        </link>
        <updated>2020-06-27T04:19:31.000Z</updated>
        <content type="html"><![CDATA[<p>默认情况下，Inspector窗口会显示所有的公共字段，Attribute可以叠加发生作用<br>
1.HideInInspector：隐藏字段<br>
2.SerializeFiled：把私有字段在Inspector中显示<br>
3.Header：对公共字段进行分组 （【Header（&quot;描述&quot;）】）<br>
4.Space：给各个字段分组之间添加一个空行<br>
5.Textarea：可以在输入框内输出多行，超出范围会出现滚动条<br>
6.Range：给字段定数值范围，以滑动条的形式呈现 （【Range（0,1）】）<br>
7.Tooltip：为字段添加提示信息，鼠标悬停字段处即可出现<br>
8.ContextMenu：为方法提供可执行方式，在Inspector窗口右键点击脚本即可看到方法<br>
9.DisallowMultipleComponent：指定脚本不能重复添加<br>
10.RequireComponent：在一个类中绑定另一个类，实现同步</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[获取NetBox网络服务器上的AB包与Lua脚本]]></title>
        <id>https://Wei715547.github.io/post/huo-qu-netbox-wang-luo-fu-wu-qi-shang-de-ab-bao-yu-lua-jiao-ben/</id>
        <link href="https://Wei715547.github.io/post/huo-qu-netbox-wang-luo-fu-wu-qi-shang-de-ab-bao-yu-lua-jiao-ben/">
        </link>
        <updated>2020-06-22T07:12:21.000Z</updated>
        <content type="html"><![CDATA[<p>//AB包（UnityWebRequest request 异步执行）<br>
[LuaCallCSharp]<br>
public  void LoadResource(string resName,string filePath)<br>
{<br>
StartCoroutine(LoadResourceCorotine(resName,filePath));<br>
}</p>
<pre><code>IEnumerator LoadResourceCorotine(string resName,string filePath)
{
    UnityWebRequest request = UnityWebRequestAssetBundle.GetAssetBundle(@&quot;http://localhost/AssetBundles/&quot; + filePath); 
    yield return request.SendWebRequest();
    AssetBundle ab = (request.downloadHandler as DownloadHandlerAssetBundle).assetBundle;

    GameObject gameObject = ab.LoadAsset&lt;GameObject&gt;(resName);
    prefabDict.Add(resName, gameObject); 
}

/////////////////////////////////////////////////////////////////////////
</code></pre>
<p>// Lua脚本(加载场景时同时加载NetBox上的Lua脚本保存到本地(本地存在时直接覆盖源文件))<br>
public void LoadGameMethod()<br>
{<br>
StartCoroutine(LoadResourceCorotine());<br>
StartCoroutine(StartLoading_4(2));<br>
}</p>
<pre><code>IEnumerator LoadResourceCorotine()
{
    UnityWebRequest request = UnityWebRequest.Get(@&quot;http://localhost/fish.lua.txt&quot;);
    yield return request.SendWebRequest();
    string str = request.downloadHandler.text;//获取下载的脚本文本
    File.WriteAllText(@&quot;D:\715\XluaProjects\PlayerGamePackage\fish.lua.txt&quot;, str);存储到本地

    UnityWebRequest request1 = UnityWebRequest.Get(@&quot;http://localhost/fishDispose.lua.txt&quot;);
    yield return request1.SendWebRequest();
    string str1 = request1.downloadHandler.text;
    File.WriteAllText(@&quot;D:\715\XluaProjects\PlayerGamePackage\fishDispose.lua.txt&quot;, str1);
}</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[空类应用于后期热更新]]></title>
        <id>https://Wei715547.github.io/post/kong-lei-ying-yong-yu-hou-qi-re-geng-xin/</id>
        <link href="https://Wei715547.github.io/post/kong-lei-ying-yong-yu-hou-qi-re-geng-xin/">
        </link>
        <updated>2020-06-21T15:36:59.000Z</updated>
        <content type="html"><![CDATA[<p>//空类<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using XLua;<br>
[Hotfix]<br>
public class HotFixEmpty : MonoBehaviour<br>
{<br>
// Start is called before the first frame update<br>
[LuaCallCSharp]<br>
void Start()<br>
{</p>
<pre><code>}

// Update is called once per frame
[LuaCallCSharp]
void Update()
{
    
}
[LuaCallCSharp]
private void OnTriggerEnter(Collider other)
{
    
}
[LuaCallCSharp]
private void BehaviourMethod()
{

}
</code></pre>
<p>}</p>
<p>xxx.lua.txt<br>
--*************************************************************<br>
--9.0新的类</p>
<p>xlua.private_accessible(CS.HotFixEmpty)<br>
xlua.hotfix(CS.HotFixEmpty,'Start',function(self)<br>
self:Invoke(&quot;BehaviourMethod&quot;,8)<br>
end)</p>
<p>xlua.hotfix(CS.HotFixEmpty,'Update',function(self)<br>
self.transform:Translate(-self.transform.right<em>4</em>UnityEngine.Time.deltaTime,UnityEngine.Space.World)<br>
end)</p>
<p>xlua.hotfix(CS.HotFixEmpty,'OnTriggerEnter',function(self,other)<br>
if other.tag~=&quot;Untagged&quot; and other.tag~=&quot;Wall&quot; then<br>
UnityEngine.Object.Destroy(other.gameObject)<br>
end<br>
end)</p>
<p>xlua.hotfix(CS.HotFixEmpty,'BehaviourMethod',function(self)<br>
CS.Gun.Instance.level = CS.Gun.Instance.level+1<br>
if CS.Gun.Instance.level==4 then<br>
CS.Gun.Instance.level=1<br>
end<br>
canCreateNewFish = true<br>
CS.Gun.Instance.changeAudio = true<br>
UnityEngine.Object.Destroy(self.gameObject)<br>
end)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[XLua补丁调用本地AssetBundle资源]]></title>
        <id>https://Wei715547.github.io/post/xlua-bu-ding-diao-yong-ben-di-assetbundle-zi-yuan/</id>
        <link href="https://Wei715547.github.io/post/xlua-bu-ding-diao-yong-ben-di-assetbundle-zi-yuan/">
        </link>
        <updated>2020-06-20T13:59:52.000Z</updated>
        <content type="html"><![CDATA[<pre><code>C#中加载AB包与获取AB包中Object的静态方法

public static Dictionary&lt;string, GameObject&gt; prefabDict = new Dictionary&lt;string, GameObject&gt;();//根据对象名称存储对象的静态字典集合

[LuaCallCSharp]
public static void LoadResource(string resName,string filePath)
{
    AssetBundle ab = AssetBundle.LoadFromFile(@&quot;D:\715\XluaProjects\FishingJoy\AssetBundles\&quot;+filePath);//本AB地资源路径
    GameObject gameObject = ab.LoadAsset&lt;GameObject&gt;(resName);
    prefabDict.Add(resName, gameObject);//键值存到字典集合
}
[LuaCallCSharp]
public static GameObject GetGameObject(string goName)
{
    return prefabDict[goName];//根据打包前的对象名获取字典中对应的对象
}
</code></pre>
<p>/////////////////////////////////////////////////////////////////////////////</p>
<p>--****************************************************<br>
--6.0Fish生成方式</p>
<p>--利用C#类中的静态方法加载AB资源（此处静态方法放在HotFixScript热更新脚本中）</p>
<p>xlua.hotfix(CS.CreateFish,'Start',function(self)//更新HotFixScript中的Start方法<br>
CS.HotFixScript.LoadResource('level3fish3','gamaobjectenemy.ab')//加载AB包将新的对象加载放入字典集合<br>
end)</p>
<p>xlua.private_accessible(CS.CreateFish)<br>
xlua.hotfix(CS.CreateFish,'Update',function(self)</p>
<pre><code>self:CreateALotOfFish()

--单种鱼的生成
    if self.ItemtimeVal &gt;= 0.5 then
</code></pre>
<p>--<em><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>Lua中生成随机数的处理</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em><br>
--位置随机数<br>
self.num = UnityEngine.Mathf.Floor(UnityEngine.Random.Range(0, 4))--Lua只有一种数值类型此处取浮点型下界<br>
--游戏物体随机数<br>
self.ItemNum = UnityEngine.Mathf.Floor(UnityEngine.Random.Range(1, 101))</p>
<pre><code>		local halfLength=self.fishList.Length/2

		local littlefishTypeIndex = UnityEngine.Mathf.Floor(UnityEngine.Random.Range(0,halfLength))
		local bigfishTypeIndex = UnityEngine.Mathf.Floor(UnityEngine.Random.Range(halfLength,self.fishList.Length))
		local itemTypeIndex = UnityEngine.Mathf.Floor(UnityEngine.Random.Range(0,self.item.Length))
		
        --产生气泡
        if self.ItemNum &lt; 20 then

            self:CreateGameObject(self.item[3])
			
        end


        if self.ItemNum &lt;= 42 then
			for i=0,2,1 do
				self:CreateGameObject(self.fishList[littlefishTypeIndex]);
			end
			self:CreateGameObject(self.item[itemTypeIndex])
        
        --第二种鱼30% 43-72
        elseif self.ItemNum &gt;= 43 and self.ItemNum &lt; 72 then
			for i=0,1,1 do
				self:CreateGameObject(self.fishList[bigfishTypeIndex]);
			end
			self:CreateGameObject(self.item[itemTypeIndex])
</code></pre>
<p>--<em><strong><strong><strong><strong><strong><strong><strong><strong><strong>加载本地AB包中的资源</strong></strong></strong></strong></strong></strong></strong></strong></strong></em>********<br>
--2.0新的鱼/AB包<br>
elseif self.ItemNum &gt;= 73 and self.ItemNum &lt; 83 then<br>
newFish = CS.HotFixScript.GetGameObject('level3fish3')--Lua中无泛型类，不需指定类型，直接声明字段接收静态方法返回的对象<br>
self:CreateGameObject(newFish)<br>
--*********************************************************************<br>
elseif self.ItemNum &gt;= 84 and self.ItemNum &lt; 86 then<br>
self:CreateGameObject(self.boss)</p>
<pre><code>        elseif self.ItemNum &gt;= 87 and self.ItemNum &lt;= 88 then
        
            self:CreateGameObject(self.boss2)
        

        elseif self.ItemNum ==100 then
        

            self:CreateGameObject(self.boss3)

        else
        
            self:CreateGameObject(self.item[0]);

        end

        self.ItemtimeVal = 0;

    else
        self.ItemtimeVal = self.ItemtimeVal + UnityEngine.Time.deltaTime;
    end
</code></pre>
<p>end)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[补丁开发过程]]></title>
        <id>https://Wei715547.github.io/post/bu-ding-kai-fa-guo-cheng/</id>
        <link href="https://Wei715547.github.io/post/bu-ding-kai-fa-guo-cheng/">
        </link>
        <updated>2020-06-18T09:33:15.000Z</updated>
        <content type="html"><![CDATA[<p>Process-&gt;在所有可能出现问题的类上打上[Hotfix]标签，在所有Lua调用C#的方法打上[LuaCallCSharp]，在所有C#调用Lua的方法打上[CSharpCallLua]-&gt;打包发布-&gt;修改时只需要更新Lua文件，修改资源是（声音，模型，贴图，UI）只需要更新AB包。用户只需要下载Lua文件和AB包</p>
<p>using UnityEngine;<br>
using XLua;</p>
<p>namespace XLuaTest<br>
{<br>
[Hotfix]//在需要修复的类前加上[Hotfix]特性<br>
public class HotfixTest : MonoBehaviour<br>
{<br>
LuaEnv luaenv = new LuaEnv();//Lua虚拟运行环境</p>
<pre><code>    private int tick = 0;

    // Use this for initialization
    void Start()
    {
    }

    // Update is called once per frame
    [LuaCallCSharp]
    void Update()
    {
        if (++tick % 50 == 0)
        {
            Debug.Log(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;Update in C#, tick = &quot; + tick);
        }
    }

    void OnGUI()
    {
        if (GUI.Button(new Rect(10, 10, 300, 80), &quot;Hotfix&quot;))
        {//要修改的类名，要修复的类中的方法，作为替换的Lua中的方法
            luaenv.DoString(@&quot;
            xlua.hotfix(CS.XLuaTest.HotfixTest, 'Update', function(self)
                local a = CS.UnityEngine.GameObject.Find('Main Camera')
                CS.UnityEngine.Debug.Log(a.name)
                --[[self.tick = self.tick + 1
                if (self.tick % 50) == 0 then
                    print('&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;Update in lua, tick = ' .. self.tick)
                end--]]
            end)
        &quot;);
        }
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[XLua虚拟环境/Lua脚本调用方式]]></title>
        <id>https://Wei715547.github.io/post/xlua-xu-ni-huan-jing-lua-jiao-ben-diao-yong-fang-shi/</id>
        <link href="https://Wei715547.github.io/post/xlua-xu-ni-huan-jing-lua-jiao-ben-diao-yong-fang-shi/">
        </link>
        <updated>2020-06-18T09:19:29.000Z</updated>
        <content type="html"><![CDATA[<p>此处在本地执行，实际应从服务器中下在Lua补丁程序<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using XLua;<br>
using System.IO;<br>
public class HotFixScript : MonoBehaviour<br>
{<br>
private LuaEnv LuaEnv;<br>
// Start is called before the first frame update<br>
void Awake()//修改C#类的Start方法时，此处应在Awake中调用<br>
{<br>
LuaEnv = new LuaEnv();<br>
LuaEnv.AddLoader(MyLoader);<br>
LuaEnv.DoString(&quot;require'fish'&quot;);//fish中的Lua程序包含所有要更新的方法逻辑代码（Lua补丁程序）<br>
}</p>
<pre><code>private byte[] MyLoader(ref string filePath)
{
    string absPath = @&quot;D:\715\XluaProjects\PlayerGamePackage\&quot; + filePath + &quot;.lua.txt&quot;;
    return System.Text.Encoding.UTF8.GetBytes(File.ReadAllText(absPath));
}
private void OnDisable()
{
    //在销毁前将委托置为空（避免报错）
    //(Hotfix底层实际已委托形式实现，将Lua的方法注册到委托中，委托不为空时执行Lua中更新的方法)
    LuaEnv.DoString(&quot;require'fishDispose'&quot;);
}
private void OnDestroy()
{
    LuaEnv.Dispose();
}
</code></pre>
<p>}<br>
/////////////////////////////////////////////////////////////<br>
//fish.lua.txt<br>
--1.修复CL间距<br>
local UnityEngine=CS.UnityEngine<br>
xlua.hotfix(CS.Treasour,'CreatePrize',function(self)<br>
for i=0,4,1 do<br>
local go = UnityEngine.GameObject.Instantiate(self.gold,self.transform.position+UnityEngine.Vector3(-10+i<em>40,0,0),self.transform.rotation)<br>
go.transform.SetParent(go.transform,self.cavas)<br>
local go = UnityEngine.GameObject.Instantiate(self.diamands,self.transform.position+UnityEngine.Vector3(0,40,0)+UnityEngine.Vector3(-10+i</em>40,0,0),self.transform.rotation)<br>
go.transform.SetParent(go.transform,self.cavas)<br>
end<br>
end)</p>
<pre><code>--2.修复Attack方法
</code></pre>
<p>xlua.private_accessible(CS.Gun)--要访问类中的私有变量时<br>
xlua.hotfix(CS.Gun,'Attack',function(self)<br>
if UnityEngine.Input.GetMouseButtonDown(0) then<br>
if self.gold&lt;1+(self.gunLevel-1)<em>2 or gold ==0 than<br>
return<br>
end<br>
self.bullectAudio.clip = self.bullectAudios[self.gunLevel-1]<br>
--self.bullectAudio.Play(self)成员变量调用内部方法方式1<br>
self.bullectAudio:Play()--方式2<br>
if self.Butterfly then<br>
UnityEngine.GameObject.Instantiate(self.Bullects[self.gunLevel-1],self.attackPos.position,self.attackPos.rotation</em>UnityEngine.Quaternion.Euler(0,0,20))<br>
UnityEngine.GameObject.Instantiate(self.Bullects[self.gunLevel-1],self.attackPos.position,self.attackPos.rotation*UnityEngine.Quaternion.Euler(0,0,-20))<br>
end</p>
<pre><code>	UnityEngine.GameObject.Instantiate(self.Bullects[self.gunLevel-1],self.attackPos.position,self.attackPos.rotation)

	if not self.canShootForFree then
		self:GoldChange(-1,-(self.gunLevel-1)*2)--一般情况下引用非静态方法时，使用成员变量+：来引用
	end
	self.attackCD = 0
	self.attack = false
end
</code></pre>
<p>end)<br>
--*******************************************************************<br>
--4.Prace<br>
local util = require 'util'--加载XLua自带方法集<br>
xlua.private_accessible(CS.Boss)--可访问类的私有变量<br>
util.hotfix_ex(CS.Boss,'Start',function(self)--在C#脚本的基础上附加代码（谨慎使用次饭饭执较慢）<br>
self.Start(self)--执行原C#中的方法<br>
self.m_reduceGold = self.m_reduceGold-20<br>
end)</p>
<p>xlua.private_accessible(CS.DeffendBoss)<br>
util.hotfix_ex(CS.DeffendBoss,'Start',function(self)<br>
self.Start(self)<br>
self.m_reduceDiamond = self.m_reduceDiamond-5<br>
end)</p>
<p>xlua.private_accessible(CS.InvisibleBoss)<br>
util.hotfix_ex(CS.InvisibleBoss,'Start',function(self)<br>
self.Start(self)<br>
self.m_reduceDiamond = self.m_reduceDiamond-5<br>
end)</p>
<p>--************************************<br>
--5.0处理CL产生负值<br>
util.hotfix_ex(CS.Gun,'GoldChange',function(self,number)--修改存在参数的方法时，将自身与参数都写入函数<br>
self.GoldChange(self,number)</p>
<pre><code>if self.gold&lt;-number then
	self.gold = 0
	return
end
</code></pre>
<p>end)</p>
<p>util.hotfix_ex(CS.Gun,'DiamandsChange',function(self,number)<br>
self.DiamandsChange(self,number)</p>
<pre><code>if self.diamands&lt;-number then
	self.diamands = 0
	return
end
</code></pre>
<p>end)<br>
\\\\\\\\\\\\\\\\\\\\\\\\\\<br>
\fishDispose.lua.txt</p>
<p>xlua.hotfix(CS.Treasour,'CreatePrize',nil)</p>
<p>xlua.hotfix(CS.Gun,'Attack',nil)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[XLua迁入工程，Hotfis环境配置]]></title>
        <id>https://Wei715547.github.io/post/xlua-qian-ru-gong-cheng-hotfis-huan-jing-pei-zhi/</id>
        <link href="https://Wei715547.github.io/post/xlua-qian-ru-gong-cheng-hotfis-huan-jing-pei-zhi/">
        </link>
        <updated>2020-06-18T08:16:39.000Z</updated>
        <content type="html"><![CDATA[<p>工程路径名不包含中文<br>
<img src="https://Wei715547.github.io/post-images/1592472285876.png" alt="" loading="lazy"><br>
补丁创建完成后将XLua附带示例文件删除在进行打包</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[创建AssetBundles/从AssetBundles中加载文件到场景]]></title>
        <id>https://Wei715547.github.io/post/chuang-jian-assetbundles/</id>
        <link href="https://Wei715547.github.io/post/chuang-jian-assetbundles/">
        </link>
        <updated>2020-06-15T09:21:12.000Z</updated>
        <content type="html"><![CDATA[<p>//此脚本放在“Asset/Editor”<br>
using System.IO;<br>
using UnityEditor;</p>
<p>public class CreateAB<br>
{<br>
[MenuItem(&quot;Assets/Build AssetBundles&quot;)]<br>
static void BuildAllAssetBuundles()<br>
{<br>
string dir = &quot;AssetBundles&quot;;<br>
if (Directory.Exists (dir)==false)<br>
{<br>
Directory.CreateDirectory(dir);<br>
}<br>
BuildPipeline.BuildAssetBundles(dir, BuildAssetBundleOptions.None, BuildTarget.StandaloneWindows64);<br>
}<br>
}</p>
<p>////////////////////////////////////////////////////////<br>
//加载<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using System.IO;<br>
using UnityEngine;<br>
using UnityEngine.Networking;<br>
public class LoadFormFile : MonoBehaviour<br>
{<br>
IEnumerator Start()//异步加载使用协同程序调用<br>
//private void Start()<br>
{<br>
//string path1 = &quot;AssetBundles / mt.wei&quot;;<br>
string path = &quot;AssetBundles/tree.wei&quot;;<br>
//示例：通过本地路径加载AB包<br>
/<em>AssetBundle ab1 = AssetBundle.LoadFromFile(&quot;AssetBundles/mt.wei&quot;);//存在依赖包时，所依赖的资源包也需要加载<br>
AssetBundle ab = AssetBundle.LoadFromFile(&quot;AssetBundles/tree.wei&quot;);//文件路径<br>
GameObject tree = ab.LoadAsset<GameObject>(&quot;Tree 02&quot;);//预制件名称<br>
GameObject go = Instantiate(tree);<br>
go.transform.SetParent(this.transform );</em>/</p>
<pre><code>    //遍历生成AB报中所有物体并生成
    /*Object[] obj = ab.LoadAllAssets();
    foreach (Object item in obj)
    {
        Instantiate(item);
    }*/


    //第一种方式:通过内存加载AB包的方式：AssetBundle.LoadFromMemoryAsync
    //异步加载
    /*AssetBundleCreateRequest request = AssetBundle.LoadFromMemoryAsync(File.ReadAllBytes(path));
    yield return request;
    AssetBundle ab = request.assetBundle;*/

    //同步加载
    //AssetBundle ab = AssetBundle.LoadFromMemory(File.ReadAllBytes(path));

    //第二种方式：通过本地文件加载AB包：
    //异步加载
    /*AssetBundleCreateRequest request = AssetBundle.LoadFromFileAsync(path);
    yield return request;
    AssetBundle ab = request.assetBundle;*/
    //同步加载（示例）
    //AssetBundle ab = AssetBundle.LoadFromFile(path);

    ////////////网络加载////////////

    //第三种方式：WWW.LoadFromCacheOrDownload（异步加载(IEnumerator)）
    /*WWW www = WWW.LoadFromCacheOrDownload(@&quot;file:///D:\715\3DFreeWord\AssetBundles\tree.wei&quot;,1);
    yield return www;
    AssetBundle ab = www.assetBundle;*/


    //第四种方式：UnityWebRequest（异步执行(IEnumerator)）
    string uri = @&quot;file:///D:\715\3DFreeWord\AssetBundles\tree.wei&quot;;
    UnityWebRequest request = UnityWebRequestAssetBundle.GetAssetBundle(uri);
    yield return request.Send();
    //AssetBundle ab = DownloadHandlerAssetBundle.GetContent(request);//获取方式一
    AssetBundle ab = (request.downloadHandler as DownloadHandlerAssetBundle).assetBundle;//获取方式二


    //使用里面的资源
    GameObject tree = ab.LoadAsset&lt;GameObject&gt;(&quot;Tree 02&quot;);
    GameObject go = Instantiate(tree/*, transform.position,Quaternion.identity*/);
    go.transform.position = this.transform.position;
</code></pre>
<p>//通过Mainfest获取所有的依赖包<br>
AssetBundle mainfestAB = AssetBundle.LoadFromFile(&quot;AssetBundles/AssetBundles&quot;);//加载AssetBundles文件<br>
AssetBundleManifest mainfest = mainfestAB.LoadAsset<AssetBundleManifest>(&quot;AssetBundleManifest&quot;);//通过AssetBundles获取AssetBundles.manifest文件<br>
/<em>foreach (string name in mainfest.GetAllAssetBundles())//获取所有的AB包，返回包名。<br>
{<br>
print(name);<br>
}</em>/<br>
string[] strs = mainfest.GetAllDependencies(&quot;tree.wei&quot;);//获取某个AB包所依赖的包，返回包名。<br>
foreach (string name in strs)<br>
{<br>
print(name);<br>
AssetBundle.LoadFromFile(&quot;AssetBundles/&quot; + name);//加载所有的依赖包<br>
}<br>
}<br>
}<br>
<img src="https://Wei715547.github.io/post-images/1592216098868.jpg" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1592216105421.jpg" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Save Point]]></title>
        <id>https://Wei715547.github.io/post/save-point/</id>
        <link href="https://Wei715547.github.io/post/save-point/">
        </link>
        <updated>2020-06-13T08:06:34.000Z</updated>
        <content type="html"><![CDATA[<p>//Prefab脚本<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class SavePoint : MonoBehaviour<br>
{<br>
private LayerMask player;<br>
private Light signlLight;<br>
// Start is called before the first frame update<br>
void Start()<br>
{<br>
player = LayerMask.NameToLayer(&quot;Player&quot;);<br>
signlLight = GetComponentInChildren<Light>();<br>
}</p>
<pre><code>//玩家触碰到Point时调用GM中的方法
private void OnTriggerEnter2D(Collider2D collision)
{
    if (collision.gameObject .layer ==player )
    {
        signlLight.color = Color.green;
        this.gameObject.GetComponent&lt;SpriteRenderer&gt;().material.color = Color.green;
        Debug.Log(&quot;Save&quot;);
        
        GameManager.instance.SavePoint();
    }
}
</code></pre>
<p>}</p>
<p>//GameManager<br>
public Vector2 playerPos ;//存储玩家位置，(通关/返回主界面时职位Vector2.zero<br>
//instance.playerPos = Vector2.zero;//通关后位置初始化)<br>
/存档点位置更新<br>
public void SavePoint()<br>
{<br>
instance.playerPos = instance.playerMove.transform.position;//玩家位置赋值给GM中的Pos<br>
}<br>
//GM中的Save/Load<br>
public GameData Save()<br>
{<br>
GameData date = new GameData();<br>
date.scence = SceneManager.GetActiveScene().buildIndex;<br>
date.deathCount = instance.deathCount;<br>
date.bgmValue = UIManager.instence.GetBGMValue();<br>
date.fxValue = UIManager.instence.GetFXValue();</p>
<pre><code>    if (instance.playerPos == Vector2.zero)
    {
        date.posx = 0;
        date.posy = 0;
    }

    else
    {
        date.posx = instance.playerPos.x;
        date.posy = instance.playerPos.y;
    }

    return date;

}

public void Load(GameData date)
{
    instance.playerPos = new Vector2(date.posx, date.posy);

    SceneManager.LoadScene(date .scence );
    //UIManager.instence.ShowLoadPanel(date.scence);
    instance.deathCount = date.deathCount;
    UIManager.UpdataDeathUI(instance.deathCount);
    GameManager.instance.time = 0;
    UIManager.instence.SetBGMValue(date.bgmValue);
    UIManager.instence.SetFXValue(date.fxValue);
}

//Player控制脚本
Start
{
//玩家未接触到存档点GM中默认Pos=0；此时将默认未值赋值给GM中的Pos。
    //（通关之后GM中的Pos会被PlayerWin()方法赋值为默认值）
    if ( GameManager.instance.playerPos==Vector2.zero)
    {
        GameManager.instance.playerPos = playerPos;
    }else//玩家触碰到存档点时，将GM中的位置赋值给玩家物体的Pos。
    {
        transform.position = GameManager.instance.playerPos;
    }
    }</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[单例]]></title>
        <id>https://Wei715547.github.io/post/dan-li/</id>
        <link href="https://Wei715547.github.io/post/dan-li/">
        </link>
        <updated>2020-06-12T08:02:53.000Z</updated>
        <content type="html"><![CDATA[<p>3.单例模式---在被调用的脚本中，公开声明一个静态的该脚本实例，在初始化时使&quot;实例=this&quot;<br>
便于在其他脚本中直接调用该脚本与其中的方法。<br>
<img src="https://Wei715547.github.io/post-images/1589271341241.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1589271396945.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1589963622098.PNG" alt="" loading="lazy"></p>
<p>两脚本有碰撞，触发关系时可直接利用<br>
(碰撞)collsion.gameObject.GetComponent&lt;被调用脚本名&gt;().方法名();<br>
(触发)collsion.GetComponent&lt;被调用脚本名&gt;().方法名();<br>
或SendMessage（以”方法名“调用物体中继承 MonoBehaviour 脚本的方法.）<br>
(碰撞)collision.gameObject.SendMessage(&quot;方法名&quot;);<br>
(触发)collsion.SendMessage(&quot;方法名&quot;);<br>
调用对方脚本中的方法<br>
<img src="https://Wei715547.github.io/post-images/1589272112653.PNG" alt="" loading="lazy"></p>
<p>//4.单例模式<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using UnityEngine.SceneManagement;<br>
public class GameManager : MonoBehaviour<br>
{<br>
public static GameManager instance;<br>
SceneFader fader;<br>
// Start is called before the first frame update<br>
void Awake()<br>
{<br>
if (instance!=null )<br>
{<br>
Destroy(gameObject);<br>
return;<br>
}<br>
instance = this;<br>
DontDestroyOnLoad(gameObject);</p>
<pre><code>}

//在外部将其他脚本通过此静态方法注册到GameManager中的变量（引用），（可在GameManager中调用其他脚本中的方法）
 /*   void Awake()//被调用的脚本
{
    ani = GetComponent&lt;Animator&gt;();
    FaderID = Animator.StringToHash(&quot;Fade&quot;);
    ////将脚本指定为GameManager的变量，使其中的方法可以在gamemanager中调用
    GameManager.RegisterCceneFader(this);
}*/
public static void RegisterCceneFader(SceneFader obj)
{
    instance.fader = obj;
}

public static void PlayerDied()
{
    instance.fader.FadeOut();//调用其他脚本中的方法
    instance.Invoke(&quot;RestartScence&quot;, 1.5f);
}

public void RestartScence()
{
    SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);
    
}
</code></pre>
<p>}</p>
<p>复杂时可使用事件的广播，监听</p>
]]></content>
    </entry>
</feed>