<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Wei715547.github.io</id>
    <title>Wei: Development technology accumulation</title>
    <updated>2020-06-29T03:08:25.469Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Wei715547.github.io"/>
    <link rel="self" href="https://Wei715547.github.io/atom.xml"/>
    <subtitle>年月增长，我宜强盛。
用于Unity+开发的技术积累</subtitle>
    <logo>https://Wei715547.github.io/images/avatar.png</logo>
    <icon>https://Wei715547.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Wei: Development technology accumulation</rights>
    <entry>
        <title type="html"><![CDATA[Sort]]></title>
        <id>https://Wei715547.github.io/post/sort/</id>
        <link href="https://Wei715547.github.io/post/sort/">
        </link>
        <updated>2020-06-28T03:11:56.000Z</updated>
        <content type="html"><![CDATA[<p>直插排序<br>
<img src="https://Wei715547.github.io/post-images/1593314284836.jpg" alt="" loading="lazy"><br>
static void InsertSort(int[] dateArray)<br>
{<br>
for (int i = 1; i &lt; dateArray .Length ; i++)<br>
{<br>
int iValue = dateArray[i];<br>
bool isInsert = false;<br>
//从第二个元素开始拿到i位置元素，和前面的元素对比<br>
//如比I大，就让其向后移动，（保证前面的元素从小到大排序）<br>
for (int j = i - 1; j &gt;= 0; j--)<br>
{<br>
if (dateArray [j]&gt;iValue)<br>
{<br>
dateArray[j + 1] = dateArray[j];<br>
}else//在前面发现一比i小的值就停止移动<br>
{<br>
dateArray[j + 1] = iValue;<br>
isInsert = true;<br>
break;<br>
}<br>
}<br>
if (isInsert ==false)//前面的值都比i大将i放到最前面<br>
{<br>
dateArray[0] = iValue;<br>
}<br>
}<br>
}</p>
<pre><code>    冒泡排序
    static void BubbleSort(int[] dateArray)
    {
        for (int i = 0; i &lt; dateArray .Length-1 ; i++)//总循环次数
        {
            for (int j = 0; j &lt; dateArray.Length-1-i; j++)//循环n次后后n个数已经最大不需在进入比较
            {
                if (dateArray [j]&gt;dateArray [j+1])
                {
                    int temp = dateArray[j];
                    dateArray[j] = dateArray[j + 1];
                    dateArray[j + 1] = temp;
                }
            }
        }
    }
</code></pre>
<p><img src="https://Wei715547.github.io/post-images/1593315435960.jpg" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1593315539844.jpg" alt="" loading="lazy"><br>
选择排序<br>
static void SelectSort(int[] dateArray)<br>
{<br>
for (int i = 0; i &lt; dateArray .Length ; i++)<br>
{<br>
int mindate = dateArray[i];<br>
int minIndex = i;<br>
for (int j = i+1; j &lt; dateArray.Length ; j++)<br>
{<br>
if (dateArray [j]&lt;mindate )<br>
{<br>
mindate = dateArray[j];<br>
minIndex = j;<br>
}<br>
}<br>
if (minIndex !=i)<br>
{<br>
int temp = dateArray[i];<br>
dateArray[i] = mindate;<br>
dateArray[minIndex] = temp;<br>
}<br>
}<br>
}</p>
<pre><code>    快速排序
    /// &lt;summary&gt;
    /// 对数组范围内的数据进行排序
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;dateArray&quot;&gt;要排序的数组&lt;/param&gt;
    /// &lt;param name=&quot;left&quot;&gt;开始索引&lt;/param&gt;
    /// &lt;param name=&quot;right&quot;&gt;结束索引&lt;/param&gt;
    static void QuickSort(int [] dateArray,int left,int right)
    {
        if (left &lt;right )
        {
            int x = dateArray[left];//基准数，把比它小或等于它的放在它左边，然后把比它大的放在右边
            int i = left;
            int j = right;

            while (true &amp;&amp; i &lt; j)
            {
                //从后往前比较，（从右往左找一个小于/等于x的数字）
                while (true &amp;&amp; i &lt; j)
                {
                    if (dateArray[j] &lt; x)//找到了一个小于基准数的数字，把它放在x左边（i位置）
                    {
                        dateArray[i] = dateArray[j];
                        break;
                    }
                    else
                    {
                        j--;
                    }
                }
                //从前往后找一个（左到右找一个比x大的数字，放在放在基准位置（j）
                while (true &amp;&amp; i &lt; j)
                {
                    if (dateArray[i] &gt; x)
                    {
                        dateArray[j] = dateArray[i];
                        break;
                    }
                    else
                    {
                        i++;
                    }
                }
            }
            dateArray[i] = x;
            QuickSort(dateArray, left, i - 1);
            QuickSort(dateArray, i + 1, right);
        }
    }</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自定义String,Array]]></title>
        <id>https://Wei715547.github.io/post/zi-ding-yi-stringarray/</id>
        <link href="https://Wei715547.github.io/post/zi-ding-yi-stringarray/">
        </link>
        <updated>2020-06-28T01:53:18.000Z</updated>
        <content type="html"><![CDATA[<p>using System;<br>
using System.Collections.Generic;<br>
using System.Text;</p>
<p>namespace 串<br>
{<br>
class StringDS<br>
{<br>
private char[] date;<br>
public StringDS(char[] array )<br>
{<br>
date = new char[array.Length];<br>
for (int i = 0; i &lt; date.Length; i++)<br>
{<br>
date[i] = array[i];<br>
}<br>
}<br>
public StringDS(string str)<br>
{<br>
date = new char[str.Length];<br>
for (int i = 0; i &lt; date.Length; i++)<br>
{<br>
date[i] = str[i];<br>
}<br>
}</p>
<pre><code>    //索引器
    public char this[int index]
    {
        get { return date[index]; }
    }

    public int GetLength()
    {
        return date.Length;
    }

    /// &lt;summary&gt;
    /// 如果两字符相同返回0
    /// 如果当前字符小于s,返回-1
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;s&quot;&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public int Compare(StringDS s)
    {
        //取得长度较小的字符串长度
        int len = this.GetLength() &lt; s.GetLength() ? this.GetLength() : s.GetLength();
        int index = -1;
        for (int i = 0; i &lt; len; i++)
        {
            if (this[i]!=s[i])
            {
                index = i;
                break;
            }
        }
        if(index !=-1)
        {
            if (this[index ] &gt; s[index ])
                return 1;
            else
                return -1;
        }else
        {
            if (this.GetLength()==s.GetLength ())
            {
                return 0;
            }else
            {
                if (this.GetLength() &gt; s.GetLength())
                    return 1;
                else
                    return -1;
            }
        }
    }
    /// &lt;summary&gt;
    /// 截取字符串
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;index&quot;&gt;&lt;/param&gt;
    /// &lt;param name=&quot;length&quot;&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public StringDS SubString(int index,int length)
    {
        char[] newDate = new char[length];
        for (int i = 0; i &lt; length; i++)
        {
            newDate[i] = date[i+index ];
        }
        return new StringDS ( newDate);
    }
    public override string ToString()
    {
        /*string s=&quot;&quot;;
        foreach (char  item in date)
        {
            s += item;
        }
        return s;*/
        return new string(date);
        
    }
    public static StringDS Concat(StringDS a,StringDS b)
    {
        char [] newDate = new char[a.GetLength() + b.GetLength()];
        for (int i = 0; i &lt; a.GetLength (); i++)
        {
            newDate[i] = a[i];
        }
        for (int i = a.GetLength (); i &lt; newDate .Length; i++)
        {
            newDate[i] = b[i - a.GetLength()];
        }
        return new StringDS(newDate);
    }

    public int IndexOf(StringDS str)
    {
        for (int i = 0; i &lt;= this .GetLength ()-str .GetLength (); i++)
        {
            bool isEqual = true;
            for (int j = i; j &lt; i+str.GetLength (); j++)
            {
                if (this [j]!=str [j-i])
                {
                    isEqual = false;
                }
            }
            if (isEqual )
            {
                return i;
            }else
            {
                continue;
            }
        }
        return -1;
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Attribute]]></title>
        <id>https://Wei715547.github.io/post/attribute/</id>
        <link href="https://Wei715547.github.io/post/attribute/">
        </link>
        <updated>2020-06-27T04:19:31.000Z</updated>
        <content type="html"><![CDATA[<p>默认情况下，Inspector窗口会显示所有的公共字段，Attribute可以叠加发生作用<br>
1.HideInInspector：隐藏字段<br>
2.SerializeFiled：把私有字段在Inspector中显示<br>
3.Header：对公共字段进行分组 （【Header（&quot;描述&quot;）】）<br>
4.Space：给各个字段分组之间添加一个空行<br>
5.Textarea：可以在输入框内输出多行，超出范围会出现滚动条<br>
6.Range：给字段定数值范围，以滑动条的形式呈现 （【Range（0,1）】）<br>
7.Tooltip：为字段添加提示信息，鼠标悬停字段处即可出现<br>
8.ContextMenu：为方法提供可执行方式，在Inspector窗口右键点击脚本即可看到方法<br>
9.DisallowMultipleComponent：指定脚本不能重复添加<br>
10.RequireComponent：在一个类中绑定另一个类，实现同步</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[获取NetBox网络服务器上的AB包与Lua脚本]]></title>
        <id>https://Wei715547.github.io/post/huo-qu-netbox-wang-luo-fu-wu-qi-shang-de-ab-bao-yu-lua-jiao-ben/</id>
        <link href="https://Wei715547.github.io/post/huo-qu-netbox-wang-luo-fu-wu-qi-shang-de-ab-bao-yu-lua-jiao-ben/">
        </link>
        <updated>2020-06-22T07:12:21.000Z</updated>
        <content type="html"><![CDATA[<p>//AB包（UnityWebRequest request 异步执行）<br>
[LuaCallCSharp]<br>
public  void LoadResource(string resName,string filePath)<br>
{<br>
StartCoroutine(LoadResourceCorotine(resName,filePath));<br>
}</p>
<pre><code>IEnumerator LoadResourceCorotine(string resName,string filePath)
{
    UnityWebRequest request = UnityWebRequestAssetBundle.GetAssetBundle(@&quot;http://localhost/AssetBundles/&quot; + filePath); 
    yield return request.SendWebRequest();
    AssetBundle ab = (request.downloadHandler as DownloadHandlerAssetBundle).assetBundle;

    GameObject gameObject = ab.LoadAsset&lt;GameObject&gt;(resName);
    prefabDict.Add(resName, gameObject); 
}

/////////////////////////////////////////////////////////////////////////
</code></pre>
<p>// Lua脚本(加载场景时同时加载NetBox上的Lua脚本保存到本地(本地存在时直接覆盖源文件))<br>
public void LoadGameMethod()<br>
{<br>
StartCoroutine(LoadResourceCorotine());<br>
StartCoroutine(StartLoading_4(2));<br>
}</p>
<pre><code>IEnumerator LoadResourceCorotine()
{
    UnityWebRequest request = UnityWebRequest.Get(@&quot;http://localhost/fish.lua.txt&quot;);
    yield return request.SendWebRequest();
    string str = request.downloadHandler.text;//获取下载的脚本文本
    File.WriteAllText(@&quot;D:\715\XluaProjects\PlayerGamePackage\fish.lua.txt&quot;, str);存储到本地

    UnityWebRequest request1 = UnityWebRequest.Get(@&quot;http://localhost/fishDispose.lua.txt&quot;);
    yield return request1.SendWebRequest();
    string str1 = request1.downloadHandler.text;
    File.WriteAllText(@&quot;D:\715\XluaProjects\PlayerGamePackage\fishDispose.lua.txt&quot;, str1);
}</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[空类应用于后期热更新]]></title>
        <id>https://Wei715547.github.io/post/kong-lei-ying-yong-yu-hou-qi-re-geng-xin/</id>
        <link href="https://Wei715547.github.io/post/kong-lei-ying-yong-yu-hou-qi-re-geng-xin/">
        </link>
        <updated>2020-06-21T15:36:59.000Z</updated>
        <content type="html"><![CDATA[<p>//空类<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using XLua;<br>
[Hotfix]<br>
public class HotFixEmpty : MonoBehaviour<br>
{<br>
// Start is called before the first frame update<br>
[LuaCallCSharp]<br>
void Start()<br>
{</p>
<pre><code>}

// Update is called once per frame
[LuaCallCSharp]
void Update()
{
    
}
[LuaCallCSharp]
private void OnTriggerEnter(Collider other)
{
    
}
[LuaCallCSharp]
private void BehaviourMethod()
{

}
</code></pre>
<p>}</p>
<p>xxx.lua.txt<br>
--*************************************************************<br>
--9.0新的类</p>
<p>xlua.private_accessible(CS.HotFixEmpty)<br>
xlua.hotfix(CS.HotFixEmpty,'Start',function(self)<br>
self:Invoke(&quot;BehaviourMethod&quot;,8)<br>
end)</p>
<p>xlua.hotfix(CS.HotFixEmpty,'Update',function(self)<br>
self.transform:Translate(-self.transform.right<em>4</em>UnityEngine.Time.deltaTime,UnityEngine.Space.World)<br>
end)</p>
<p>xlua.hotfix(CS.HotFixEmpty,'OnTriggerEnter',function(self,other)<br>
if other.tag~=&quot;Untagged&quot; and other.tag~=&quot;Wall&quot; then<br>
UnityEngine.Object.Destroy(other.gameObject)<br>
end<br>
end)</p>
<p>xlua.hotfix(CS.HotFixEmpty,'BehaviourMethod',function(self)<br>
CS.Gun.Instance.level = CS.Gun.Instance.level+1<br>
if CS.Gun.Instance.level==4 then<br>
CS.Gun.Instance.level=1<br>
end<br>
canCreateNewFish = true<br>
CS.Gun.Instance.changeAudio = true<br>
UnityEngine.Object.Destroy(self.gameObject)<br>
end)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[XLua补丁调用本地AssetBundle资源]]></title>
        <id>https://Wei715547.github.io/post/xlua-bu-ding-diao-yong-ben-di-assetbundle-zi-yuan/</id>
        <link href="https://Wei715547.github.io/post/xlua-bu-ding-diao-yong-ben-di-assetbundle-zi-yuan/">
        </link>
        <updated>2020-06-20T13:59:52.000Z</updated>
        <content type="html"><![CDATA[<pre><code>C#中加载AB包与获取AB包中Object的静态方法

public static Dictionary&lt;string, GameObject&gt; prefabDict = new Dictionary&lt;string, GameObject&gt;();//根据对象名称存储对象的静态字典集合

[LuaCallCSharp]
public static void LoadResource(string resName,string filePath)
{
    AssetBundle ab = AssetBundle.LoadFromFile(@&quot;D:\715\XluaProjects\FishingJoy\AssetBundles\&quot;+filePath);//本AB地资源路径
    GameObject gameObject = ab.LoadAsset&lt;GameObject&gt;(resName);
    prefabDict.Add(resName, gameObject);//键值存到字典集合
}
[LuaCallCSharp]
public static GameObject GetGameObject(string goName)
{
    return prefabDict[goName];//根据打包前的对象名获取字典中对应的对象
}
</code></pre>
<p>/////////////////////////////////////////////////////////////////////////////</p>
<p>--****************************************************<br>
--6.0Fish生成方式</p>
<p>--利用C#类中的静态方法加载AB资源（此处静态方法放在HotFixScript热更新脚本中）</p>
<p>xlua.hotfix(CS.CreateFish,'Start',function(self)//更新HotFixScript中的Start方法<br>
CS.HotFixScript.LoadResource('level3fish3','gamaobjectenemy.ab')//加载AB包将新的对象加载放入字典集合<br>
end)</p>
<p>xlua.private_accessible(CS.CreateFish)<br>
xlua.hotfix(CS.CreateFish,'Update',function(self)</p>
<pre><code>self:CreateALotOfFish()

--单种鱼的生成
    if self.ItemtimeVal &gt;= 0.5 then
</code></pre>
<p>--<em><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>Lua中生成随机数的处理</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em><br>
--位置随机数<br>
self.num = UnityEngine.Mathf.Floor(UnityEngine.Random.Range(0, 4))--Lua只有一种数值类型此处取浮点型下界<br>
--游戏物体随机数<br>
self.ItemNum = UnityEngine.Mathf.Floor(UnityEngine.Random.Range(1, 101))</p>
<pre><code>		local halfLength=self.fishList.Length/2

		local littlefishTypeIndex = UnityEngine.Mathf.Floor(UnityEngine.Random.Range(0,halfLength))
		local bigfishTypeIndex = UnityEngine.Mathf.Floor(UnityEngine.Random.Range(halfLength,self.fishList.Length))
		local itemTypeIndex = UnityEngine.Mathf.Floor(UnityEngine.Random.Range(0,self.item.Length))
		
        --产生气泡
        if self.ItemNum &lt; 20 then

            self:CreateGameObject(self.item[3])
			
        end


        if self.ItemNum &lt;= 42 then
			for i=0,2,1 do
				self:CreateGameObject(self.fishList[littlefishTypeIndex]);
			end
			self:CreateGameObject(self.item[itemTypeIndex])
        
        --第二种鱼30% 43-72
        elseif self.ItemNum &gt;= 43 and self.ItemNum &lt; 72 then
			for i=0,1,1 do
				self:CreateGameObject(self.fishList[bigfishTypeIndex]);
			end
			self:CreateGameObject(self.item[itemTypeIndex])
</code></pre>
<p>--<em><strong><strong><strong><strong><strong><strong><strong><strong><strong>加载本地AB包中的资源</strong></strong></strong></strong></strong></strong></strong></strong></strong></em>********<br>
--2.0新的鱼/AB包<br>
elseif self.ItemNum &gt;= 73 and self.ItemNum &lt; 83 then<br>
newFish = CS.HotFixScript.GetGameObject('level3fish3')--Lua中无泛型类，不需指定类型，直接声明字段接收静态方法返回的对象<br>
self:CreateGameObject(newFish)<br>
--*********************************************************************<br>
elseif self.ItemNum &gt;= 84 and self.ItemNum &lt; 86 then<br>
self:CreateGameObject(self.boss)</p>
<pre><code>        elseif self.ItemNum &gt;= 87 and self.ItemNum &lt;= 88 then
        
            self:CreateGameObject(self.boss2)
        

        elseif self.ItemNum ==100 then
        

            self:CreateGameObject(self.boss3)

        else
        
            self:CreateGameObject(self.item[0]);

        end

        self.ItemtimeVal = 0;

    else
        self.ItemtimeVal = self.ItemtimeVal + UnityEngine.Time.deltaTime;
    end
</code></pre>
<p>end)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[补丁开发过程]]></title>
        <id>https://Wei715547.github.io/post/bu-ding-kai-fa-guo-cheng/</id>
        <link href="https://Wei715547.github.io/post/bu-ding-kai-fa-guo-cheng/">
        </link>
        <updated>2020-06-18T09:33:15.000Z</updated>
        <content type="html"><![CDATA[<p>Process-&gt;在所有可能出现问题的类上打上[Hotfix]标签，在所有Lua调用C#的方法打上[LuaCallCSharp]，在所有C#调用Lua的方法打上[CSharpCallLua]-&gt;打包发布-&gt;修改时只需要更新Lua文件，修改资源是（声音，模型，贴图，UI）只需要更新AB包。用户只需要下载Lua文件和AB包</p>
<p>using UnityEngine;<br>
using XLua;</p>
<p>namespace XLuaTest<br>
{<br>
[Hotfix]//在需要修复的类前加上[Hotfix]特性<br>
public class HotfixTest : MonoBehaviour<br>
{<br>
LuaEnv luaenv = new LuaEnv();//Lua虚拟运行环境</p>
<pre><code>    private int tick = 0;

    // Use this for initialization
    void Start()
    {
    }

    // Update is called once per frame
    [LuaCallCSharp]
    void Update()
    {
        if (++tick % 50 == 0)
        {
            Debug.Log(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;Update in C#, tick = &quot; + tick);
        }
    }

    void OnGUI()
    {
        if (GUI.Button(new Rect(10, 10, 300, 80), &quot;Hotfix&quot;))
        {//要修改的类名，要修复的类中的方法，作为替换的Lua中的方法
            luaenv.DoString(@&quot;
            xlua.hotfix(CS.XLuaTest.HotfixTest, 'Update', function(self)
                local a = CS.UnityEngine.GameObject.Find('Main Camera')
                CS.UnityEngine.Debug.Log(a.name)
                --[[self.tick = self.tick + 1
                if (self.tick % 50) == 0 then
                    print('&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;Update in lua, tick = ' .. self.tick)
                end--]]
            end)
        &quot;);
        }
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[XLua虚拟环境/Lua脚本调用方式]]></title>
        <id>https://Wei715547.github.io/post/xlua-xu-ni-huan-jing-lua-jiao-ben-diao-yong-fang-shi/</id>
        <link href="https://Wei715547.github.io/post/xlua-xu-ni-huan-jing-lua-jiao-ben-diao-yong-fang-shi/">
        </link>
        <updated>2020-06-18T09:19:29.000Z</updated>
        <content type="html"><![CDATA[<p>此处在本地执行，实际应从服务器中下在Lua补丁程序<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using XLua;<br>
using System.IO;<br>
public class HotFixScript : MonoBehaviour<br>
{<br>
private LuaEnv LuaEnv;<br>
// Start is called before the first frame update<br>
void Awake()//修改C#类的Start方法时，此处应在Awake中调用<br>
{<br>
LuaEnv = new LuaEnv();<br>
LuaEnv.AddLoader(MyLoader);<br>
LuaEnv.DoString(&quot;require'fish'&quot;);//fish中的Lua程序包含所有要更新的方法逻辑代码（Lua补丁程序）<br>
}</p>
<pre><code>private byte[] MyLoader(ref string filePath)
{
    string absPath = @&quot;D:\715\XluaProjects\PlayerGamePackage\&quot; + filePath + &quot;.lua.txt&quot;;
    return System.Text.Encoding.UTF8.GetBytes(File.ReadAllText(absPath));
}
private void OnDisable()
{
    //在销毁前将委托置为空（避免报错）
    //(Hotfix底层实际已委托形式实现，将Lua的方法注册到委托中，委托不为空时执行Lua中更新的方法)
    LuaEnv.DoString(&quot;require'fishDispose'&quot;);
}
private void OnDestroy()
{
    LuaEnv.Dispose();
}
</code></pre>
<p>}<br>
/////////////////////////////////////////////////////////////<br>
//fish.lua.txt<br>
--1.修复CL间距<br>
local UnityEngine=CS.UnityEngine<br>
xlua.hotfix(CS.Treasour,'CreatePrize',function(self)<br>
for i=0,4,1 do<br>
local go = UnityEngine.GameObject.Instantiate(self.gold,self.transform.position+UnityEngine.Vector3(-10+i<em>40,0,0),self.transform.rotation)<br>
go.transform.SetParent(go.transform,self.cavas)<br>
local go = UnityEngine.GameObject.Instantiate(self.diamands,self.transform.position+UnityEngine.Vector3(0,40,0)+UnityEngine.Vector3(-10+i</em>40,0,0),self.transform.rotation)<br>
go.transform.SetParent(go.transform,self.cavas)<br>
end<br>
end)</p>
<pre><code>--2.修复Attack方法
</code></pre>
<p>xlua.private_accessible(CS.Gun)--要访问类中的私有变量时<br>
xlua.hotfix(CS.Gun,'Attack',function(self)<br>
if UnityEngine.Input.GetMouseButtonDown(0) then<br>
if self.gold&lt;1+(self.gunLevel-1)<em>2 or gold ==0 than<br>
return<br>
end<br>
self.bullectAudio.clip = self.bullectAudios[self.gunLevel-1]<br>
--self.bullectAudio.Play(self)成员变量调用内部方法方式1<br>
self.bullectAudio:Play()--方式2<br>
if self.Butterfly then<br>
UnityEngine.GameObject.Instantiate(self.Bullects[self.gunLevel-1],self.attackPos.position,self.attackPos.rotation</em>UnityEngine.Quaternion.Euler(0,0,20))<br>
UnityEngine.GameObject.Instantiate(self.Bullects[self.gunLevel-1],self.attackPos.position,self.attackPos.rotation*UnityEngine.Quaternion.Euler(0,0,-20))<br>
end</p>
<pre><code>	UnityEngine.GameObject.Instantiate(self.Bullects[self.gunLevel-1],self.attackPos.position,self.attackPos.rotation)

	if not self.canShootForFree then
		self:GoldChange(-1,-(self.gunLevel-1)*2)--一般情况下引用非静态方法时，使用成员变量+：来引用
	end
	self.attackCD = 0
	self.attack = false
end
</code></pre>
<p>end)<br>
--*******************************************************************<br>
--4.Prace<br>
local util = require 'util'--加载XLua自带方法集<br>
xlua.private_accessible(CS.Boss)--可访问类的私有变量<br>
util.hotfix_ex(CS.Boss,'Start',function(self)--在C#脚本的基础上附加代码（谨慎使用次饭饭执较慢）<br>
self.Start(self)--执行原C#中的方法<br>
self.m_reduceGold = self.m_reduceGold-20<br>
end)</p>
<p>xlua.private_accessible(CS.DeffendBoss)<br>
util.hotfix_ex(CS.DeffendBoss,'Start',function(self)<br>
self.Start(self)<br>
self.m_reduceDiamond = self.m_reduceDiamond-5<br>
end)</p>
<p>xlua.private_accessible(CS.InvisibleBoss)<br>
util.hotfix_ex(CS.InvisibleBoss,'Start',function(self)<br>
self.Start(self)<br>
self.m_reduceDiamond = self.m_reduceDiamond-5<br>
end)</p>
<p>--************************************<br>
--5.0处理CL产生负值<br>
util.hotfix_ex(CS.Gun,'GoldChange',function(self,number)--修改存在参数的方法时，将自身与参数都写入函数<br>
self.GoldChange(self,number)</p>
<pre><code>if self.gold&lt;-number then
	self.gold = 0
	return
end
</code></pre>
<p>end)</p>
<p>util.hotfix_ex(CS.Gun,'DiamandsChange',function(self,number)<br>
self.DiamandsChange(self,number)</p>
<pre><code>if self.diamands&lt;-number then
	self.diamands = 0
	return
end
</code></pre>
<p>end)<br>
\\\\\\\\\\\\\\\\\\\\\\\\\\<br>
\fishDispose.lua.txt</p>
<p>xlua.hotfix(CS.Treasour,'CreatePrize',nil)</p>
<p>xlua.hotfix(CS.Gun,'Attack',nil)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[XLua迁入工程，Hotfis环境配置]]></title>
        <id>https://Wei715547.github.io/post/xlua-qian-ru-gong-cheng-hotfis-huan-jing-pei-zhi/</id>
        <link href="https://Wei715547.github.io/post/xlua-qian-ru-gong-cheng-hotfis-huan-jing-pei-zhi/">
        </link>
        <updated>2020-06-18T08:16:39.000Z</updated>
        <content type="html"><![CDATA[<p>工程路径名不包含中文<br>
<img src="https://Wei715547.github.io/post-images/1592472285876.png" alt="" loading="lazy"><br>
补丁创建完成后将XLua附带示例文件删除在进行打包</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[创建AssetBundles/从AssetBundles中加载文件到场景]]></title>
        <id>https://Wei715547.github.io/post/chuang-jian-assetbundles/</id>
        <link href="https://Wei715547.github.io/post/chuang-jian-assetbundles/">
        </link>
        <updated>2020-06-15T09:21:12.000Z</updated>
        <content type="html"><![CDATA[<p>//此脚本放在“Asset/Editor”<br>
using System.IO;<br>
using UnityEditor;</p>
<p>public class CreateAB<br>
{<br>
[MenuItem(&quot;Assets/Build AssetBundles&quot;)]<br>
static void BuildAllAssetBuundles()<br>
{<br>
string dir = &quot;AssetBundles&quot;;<br>
if (Directory.Exists (dir)==false)<br>
{<br>
Directory.CreateDirectory(dir);<br>
}<br>
BuildPipeline.BuildAssetBundles(dir, BuildAssetBundleOptions.None, BuildTarget.StandaloneWindows64);<br>
}<br>
}</p>
<p>////////////////////////////////////////////////////////<br>
//加载<br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using System.IO;<br>
using UnityEngine;<br>
using UnityEngine.Networking;<br>
public class LoadFormFile : MonoBehaviour<br>
{<br>
IEnumerator Start()//异步加载使用协同程序调用<br>
//private void Start()<br>
{<br>
//string path1 = &quot;AssetBundles / mt.wei&quot;;<br>
string path = &quot;AssetBundles/tree.wei&quot;;<br>
//示例：通过本地路径加载AB包<br>
/<em>AssetBundle ab1 = AssetBundle.LoadFromFile(&quot;AssetBundles/mt.wei&quot;);//存在依赖包时，所依赖的资源包也需要加载<br>
AssetBundle ab = AssetBundle.LoadFromFile(&quot;AssetBundles/tree.wei&quot;);//文件路径<br>
GameObject tree = ab.LoadAsset<GameObject>(&quot;Tree 02&quot;);//预制件名称<br>
GameObject go = Instantiate(tree);<br>
go.transform.SetParent(this.transform );</em>/</p>
<pre><code>    //遍历生成AB报中所有物体并生成
    /*Object[] obj = ab.LoadAllAssets();
    foreach (Object item in obj)
    {
        Instantiate(item);
    }*/


    //第一种方式:通过内存加载AB包的方式：AssetBundle.LoadFromMemoryAsync
    //异步加载
    /*AssetBundleCreateRequest request = AssetBundle.LoadFromMemoryAsync(File.ReadAllBytes(path));
    yield return request;
    AssetBundle ab = request.assetBundle;*/

    //同步加载
    //AssetBundle ab = AssetBundle.LoadFromMemory(File.ReadAllBytes(path));

    //第二种方式：通过本地文件加载AB包：
    //异步加载
    /*AssetBundleCreateRequest request = AssetBundle.LoadFromFileAsync(path);
    yield return request;
    AssetBundle ab = request.assetBundle;*/
    //同步加载（示例）
    //AssetBundle ab = AssetBundle.LoadFromFile(path);

    ////////////网络加载////////////

    //第三种方式：WWW.LoadFromCacheOrDownload（异步加载(IEnumerator)）
    /*WWW www = WWW.LoadFromCacheOrDownload(@&quot;file:///D:\715\3DFreeWord\AssetBundles\tree.wei&quot;,1);
    yield return www;
    AssetBundle ab = www.assetBundle;*/


    //第四种方式：UnityWebRequest（异步执行(IEnumerator)）
    string uri = @&quot;file:///D:\715\3DFreeWord\AssetBundles\tree.wei&quot;;
    UnityWebRequest request = UnityWebRequestAssetBundle.GetAssetBundle(uri);
    yield return request.Send();
    //AssetBundle ab = DownloadHandlerAssetBundle.GetContent(request);//获取方式一
    AssetBundle ab = (request.downloadHandler as DownloadHandlerAssetBundle).assetBundle;//获取方式二


    //使用里面的资源
    GameObject tree = ab.LoadAsset&lt;GameObject&gt;(&quot;Tree 02&quot;);
    GameObject go = Instantiate(tree/*, transform.position,Quaternion.identity*/);
    go.transform.position = this.transform.position;
</code></pre>
<p>//通过Mainfest获取所有的依赖包<br>
AssetBundle mainfestAB = AssetBundle.LoadFromFile(&quot;AssetBundles/AssetBundles&quot;);//加载AssetBundles文件<br>
AssetBundleManifest mainfest = mainfestAB.LoadAsset<AssetBundleManifest>(&quot;AssetBundleManifest&quot;);//通过AssetBundles获取AssetBundles.manifest文件<br>
/<em>foreach (string name in mainfest.GetAllAssetBundles())//获取所有的AB包，返回包名。<br>
{<br>
print(name);<br>
}</em>/<br>
string[] strs = mainfest.GetAllDependencies(&quot;tree.wei&quot;);//获取某个AB包所依赖的包，返回包名。<br>
foreach (string name in strs)<br>
{<br>
print(name);<br>
AssetBundle.LoadFromFile(&quot;AssetBundles/&quot; + name);//加载所有的依赖包<br>
}<br>
}<br>
}<br>
<img src="https://Wei715547.github.io/post-images/1592216098868.jpg" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1592216105421.jpg" alt="" loading="lazy"></p>
]]></content>
    </entry>
</feed>