<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Wei715547.github.io</id>
    <title>Weiwei的个人网站</title>
    <updated>2020-05-16T08:05:02.739Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Wei715547.github.io"/>
    <link rel="self" href="https://Wei715547.github.io/atom.xml"/>
    <subtitle>7</subtitle>
    <logo>https://Wei715547.github.io/images/avatar.png</logo>
    <icon>https://Wei715547.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Weiwei的个人网站</rights>
    <entry>
        <title type="html"><![CDATA[ObjectPool(对象池)]]></title>
        <id>https://Wei715547.github.io/post/objectpooldui-xiang-chi/</id>
        <link href="https://Wei715547.github.io/post/objectpooldui-xiang-chi/">
        </link>
        <updated>2020-05-16T07:54:47.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://Wei715547.github.io/post-images/1589615693691.PNG" alt="" loading="lazy"><br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;</p>
<p>public class ObjectPool : MonoBehaviour<br>
{<br>
public static ObjectPool instence;//单例模式用于外部调用</p>
<pre><code>public GameObject shado;//要生成的预制体（可通过资源管理类获取）

//要生成的预制体集合
private List&lt;GameObject&gt; playerShado = new List&lt;GameObject&gt;();

private int InstentCount = 5;//在对象池中默认生成多少个

private void Awake()
{
    instence = this;
    Init();//初始生成
}

public void Init()
{
    for (int i = 0; i &lt; InstentCount ; i++)
    {
        //生成默认个数预制体(go.SetActive(false);，并添加到目标预制体List中
        InstantceObject(shado,ref playerShado );
    }
}
//生成与添加入集合的方法
//（返回值GameObject便于外部调用时，如果对象池中同类物体都处于占用激活状态，则再生成新的预制体并添加到集合中）
private GameObject InstantceObject(GameObject prefab, ref List&lt;GameObject &gt; addlist  )
{
    GameObject go = Instantiate(prefab, transform);
    go.SetActive(false);
    addlist.Add(go);
    return go;
}

//外部调用方法
public GameObject GetShado()
{
    //遍历集合中的物体知否激活/占用，没有则返回应用该物体。
    for (int i = 0; i &lt; InstentCount ; i++)
    {
        if(playerShado [i].activeInHierarchy==false )
        {
            return playerShado[i];
        }
    }
    //如List中的物体均处于占用状态，(对象池中同类物体不够)则生成新的对象返回并添加到List集合(对象池)中
    return InstantceObject(shado ,ref playerShado );
}

//gameObject.SetActive(false)写在预制体/外部脚本上
</code></pre>
<p>}</p>
<p>例：生成残影<br>
<img src="https://Wei715547.github.io/post-images/1589616178256.PNG" alt="" loading="lazy"><br>
残影预制体脚本<br>
<img src="https://Wei715547.github.io/post-images/1589616264550.PNG" alt="" loading="lazy"><br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using DG.Tweening;</p>
<p>public class PlayerShado : MonoBehaviour<br>
{<br>
[SerializeField]<br>
private bool reset;</p>
<pre><code>private void FixedUpdate()
{
    if (reset)
    {
        transform.GetComponent&lt;SpriteRenderer&gt;().DOColor(new Color(transform.GetComponent&lt;SpriteRenderer&gt;().color.r,
          transform.GetComponent&lt;SpriteRenderer&gt;().color.g, transform.GetComponent&lt;SpriteRenderer&gt;().color.b, 0), 0.2f).OnComplete(() =&gt;
          {
              gameObject.SetActive(false);   
          });
        reset = false;
        print(&quot;FixedUpdate&quot;);
    }
}
//物体未启用时执行（在Update后执行）
private void OnDisable()
{
    transform.GetComponent&lt;SpriteRenderer&gt;().color = new Color(transform.GetComponent&lt;SpriteRenderer&gt;().color.r,
            transform.GetComponent&lt;SpriteRenderer&gt;().color.g, transform.GetComponent&lt;SpriteRenderer&gt;().color.b, 1);
    reset = true;
    print(&quot;Onsisable&quot;);

}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2D多段跳]]></title>
        <id>https://Wei715547.github.io/post/2d-duo-duan-tiao/</id>
        <link href="https://Wei715547.github.io/post/2d-duo-duan-tiao/">
        </link>
        <updated>2020-05-16T03:32:18.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://Wei715547.github.io/post-images/1589614659174.PNG" alt="" loading="lazy"><br>
public int jumpForce;<br>
public int jumptimes = 2;<br>
private int jumpCount;</p>
<pre><code>    public void JumpMax()
{
    if (ani.GetBool(&quot;Heart&quot;)) return;
    
    if (Physics2D.OverlapCircle(foot.position, 0.2f, ground))
    {
        jumpCount = jumptimes ;
        ani.SetBool(&quot;Jumping&quot;, false);
    }
    if (Input.GetButtonDown(&quot;Jump&quot;) &amp;&amp; Physics2D.OverlapCircle(foot.position, 0.2f, ground))
    {
        au.PlayOneShot(jump, 1f);
        playerR.velocity = new Vector2(playerR.velocity.x, jumpForce );
        ani.SetBool(&quot;Jumping&quot;, true);
        ani.SetBool(&quot;Idle&quot;, false);
        ani.SetBool(&quot;Down&quot;, false);
        jumpCount--;
    }else if(Input.GetButtonDown(&quot;Jump&quot;)&amp;&amp; jumpCount &gt; 0&amp;&amp; !Physics2D.OverlapCircle(foot.position, 0.2f, ground))
    {
        au.PlayOneShot(jump, 1f);
        playerR.velocity = new Vector2(playerR.velocity.x, jumpForce );
        ani.SetBool(&quot;Jumping&quot;, true);
        ani.SetBool(&quot;Idle&quot;, false);
        ani.SetBool(&quot;Down&quot;, false);
        jumpCount--;
    }
}    public void JumpMax()
{
    if (ani.GetBool(&quot;Heart&quot;)) return;
    
    if (Physics2D.OverlapCircle(foot.position, 0.2f, ground))
    {
        jumpCount = jumptimes ;
        ani.SetBool(&quot;Jumping&quot;, false);
    }
    if (Input.GetButtonDown(&quot;Jump&quot;) &amp;&amp; Physics2D.OverlapCircle(foot.position, 0.2f, ground))
    {
        au.PlayOneShot(jump, 1f);
        playerR.velocity = new Vector2(playerR.velocity.x, jumpForce );
        ani.SetBool(&quot;Jumping&quot;, true);
        ani.SetBool(&quot;Idle&quot;, false);
        ani.SetBool(&quot;Down&quot;, false);
        jumpCount--;
    }else if(Input.GetButtonDown(&quot;Jump&quot;)&amp;&amp; jumpCount &gt; 0&amp;&amp; !Physics2D.OverlapCircle(foot.position, 0.2f, ground))
    {
        au.PlayOneShot(jump, 1f);
        playerR.velocity = new Vector2(playerR.velocity.x, jumpForce );
        ani.SetBool(&quot;Jumping&quot;, true);
        ani.SetBool(&quot;Idle&quot;, false);
        ani.SetBool(&quot;Down&quot;, false);
        jumpCount--;
    }
}</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[泛型集合List,Dictionary]]></title>
        <id>https://Wei715547.github.io/post/fan-xing-ji-he-listdictionary/</id>
        <link href="https://Wei715547.github.io/post/fan-xing-ji-he-listdictionary/">
        </link>
        <updated>2020-05-15T11:59:59.000Z</updated>
        <content type="html"><![CDATA[<p>List<User> userList = new List<User>();</p>
<p>//增删查改<br>
//增加数据<br>
public void AddDate(User user)<br>
{<br>
userList.Add(user);<br>
//Save();<br>
Console.WriteLine(&quot;添加用户成功！&quot;);<br>
}<br>
//删除数据<br>
public void RemoveByName(string name)<br>
{<br>
for (int i = 0; i &lt; userList .Count ; i++)<br>
{<br>
if (userList [i].Name ==name)<br>
{<br>
userList.Remove(userList[i]);<br>
}<br>
}<br>
}</p>
<pre><code>    public void RemoveByAddress(string address)
    {
        for (int i = 0; i &lt; userList.Count; i++)
        {
            if (userList[i].Address  == address )
            {
                userList.Remove(userList[i]);
            }
        }
    }

    //修改数据
    public void ChangeDate(string name)
    {
        bool ex = false;
        for (int i = 0; i &lt; userList .Count ; i++)
        {
            if (userList[i].Name == name )
            {
                ex = true;
            }
        }
        if (ex)
        {
            for (int i = 0; i &lt; userList.Count; i++)
            {
                if (userList[i].Name == name)
                {
                    Console.WriteLine(&quot;请重新输入用户名称：&quot;);
                    string namec = Console.ReadLine();
                    Console.WriteLine(&quot;请重新输入用户年龄：&quot;);
                    int agec = int.Parse(Console.ReadLine());
                    Console.WriteLine(&quot;请重新输入地址：&quot;);
                    string addressc = Console.ReadLine();
                    userList[i].Name = namec;
                    userList[i].Age = agec;
                    userList[i].Address = addressc;
                    Console.WriteLine(&quot;修改成功&quot;);
                }
            } 
        }
        else
        {
            Console.WriteLine(&quot;不存在该用户！&quot;);
        }
    }
    //查询数据
    public void ShowAll()
    {
        if (userList.Count != 0)
        {
            for (int i = 0; i &lt; userList.Count; i++)
            {
                Console.WriteLine(userList[i]);
            }
        }
        else Console.WriteLine(&quot;当前为空&quot;); 
    }
}


static void Main(string[] args)
    {
        //创建字典泛型集合
        Dictionary&lt;string, string&gt; dic = new Dictionary&lt;string, string&gt;();
        //        键，值

        //往集合中添加数据
        dic.Add(&quot;baidu&quot;, &quot;百度网&quot;);
        dic.Add(&quot;qq&quot;, &quot;腾讯网&quot;);
        dic.Add(&quot;taobao&quot;, &quot;淘宝网&quot;);

        //不可添加同键名的数据
        //dic.Add(&quot;taobao&quot;, &quot;马云&quot;);

        //查询数据---集合名[键名]
        Console.WriteLine(dic[&quot;qq&quot;]);
        Console.WriteLine(dic .Count );
        //删除数据---集合名.Remove(键名);
        dic.Remove(&quot;baidu&quot;);
        //修改数据---集合名[键名] = 新值;
        dic[&quot;qq&quot;] = &quot;马化腾&quot;;

        //遍历字典集合
        foreach (var item in dic .Keys )
        {
            Console.WriteLine(&quot;{0}:{1}&quot;,item ,dic[item]);
        }
        Console.ReadLine();
    }</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Photon联机案例]]></title>
        <id>https://Wei715547.github.io/post/photon-lian-ji-an-li/</id>
        <link href="https://Wei715547.github.io/post/photon-lian-ji-an-li/">
        </link>
        <updated>2020-05-14T11:08:46.000Z</updated>
        <content type="html"><![CDATA[<p>导入Photon2插件......<br>
<img src="https://Wei715547.github.io/post-images/1589454704733.PNG" alt="" loading="lazy"><br>
using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using Photon.Pun;<br>
using UnityEngine.UI;<br>
using Photon.Realtime;</p>
<p>public class NetworkLuncher : MonoBehaviourPunCallbacks//继承回调行为类<br>
{<br>
public GameObject nameUI;<br>
public GameObject loginUI;<br>
public InputField name;<br>
public InputField roomName;</p>
<pre><code>// Start is called before the first frame update
void Start()
{
    //链接服务器
    PhotonNetwork.ConnectUsingSettings();
}

//链接到服务器后执行
public override void OnConnectedToMaster()
{
    nameUI.SetActive(true);
}

//输入名字的确认按钮
public void PlayButton()
{
    nameUI.SetActive(false);
    PhotonNetwork.NickName = name.text;
    loginUI.SetActive(true);

}

//创建房间加入房间按钮
public void JoinOrCreatButton()
{
    //如果没有输入=》退出方法在此输入
    if (roomName .text .Length &lt;2)
    {
        return;
    }

    loginUI.SetActive(false);

    //服务器房间设置：房间类型，最大玩家数
    RoomOptions options = new RoomOptions { MaxPlayers = 4 };
    //加入/创建房间
    PhotonNetwork.JoinOrCreateRoom(roomName .text, options, default);
}

//进入到服务器房间后执行
public override void OnJoinedRoom()
{
    //进入房间后进入下一场景
    PhotonNetwork.LoadLevel(1);
}
</code></pre>
<p>}</p>
<p><img src="https://Wei715547.github.io/post-images/1589454961930.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1589454980911.PNG" alt="" loading="lazy"></p>
<pre><code>//按下准备开始按钮
(using Photon.Pun;)
public void StrtPlay()
{
    readyPanel.SetActive(false);

    //生成预制体玩家
    PhotonNetwork.Instantiate(&quot;Player&quot;, new Vector3(1, 1, 0), Quaternion.identity, 0);
}
</code></pre>
<p>//控制本地角色<br>
using Photon.Pun;<br>
public class PlayerCT : MonoBehaviourPun<br>
<img src="https://Wei715547.github.io/post-images/1589455187033.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1589455406349.PNG" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[后台场景加载（进度条）]]></title>
        <id>https://Wei715547.github.io/post/hou-tai-chang-jing-jia-zai-jin-du-tiao/</id>
        <link href="https://Wei715547.github.io/post/hou-tai-chang-jing-jia-zai-jin-du-tiao/">
        </link>
        <updated>2020-05-14T03:17:17.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://Wei715547.github.io/post-images/1589426492371.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1589426497960.PNG" alt="" loading="lazy"><br>
using System.Collections;<br>
using UnityEngine;<br>
using UnityEngine.SceneManagement;<br>
using UnityEngine.UI;</p>
<p>public class InPanel : MonoBehaviour<br>
{<br>
public GameObject Load;<br>
public Slider sl;<br>
public Text text,next;</p>
<pre><code>private void Awake()
{
    Load.SetActive(false);

}

void Update()
{
    if (Input .GetKeyDown (KeyCode.E ))
    {

        StartCoroutine(LoadLeve());
       
    }
    
}

IEnumerator LoadLeve()
{
    Load.SetActive(true);

    AsyncOperation operation = SceneManager.LoadSceneAsync(SceneManager.GetActiveScene().buildIndex + 1);

    operation.allowSceneActivation = false;

    while (!operation.isDone )
    {
        sl.value = operation.progress;
        text.text = operation.progress * 100 + &quot;%&quot;;

        if (operation .progress &gt;=0.9f)
        {
            sl.value = 1;
            text.text = &quot;100%&quot;;
            next.text = &quot;Pass Any Ket To Next&quot;;
            if (Input. anyKeyDown)
            {
                operation.allowSceneActivation = true;
            }
        }
        yield return null;
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unity---一个脚本调用另一个脚本中方法的几种方法]]></title>
        <id>https://Wei715547.github.io/post/unity-yi-ge-jiao-ben-diao-yong-ling-yi-ge-jiao-ben-zhong-fang-fa-de-ji-chong-fang-fa/</id>
        <link href="https://Wei715547.github.io/post/unity-yi-ge-jiao-ben-diao-yong-ling-yi-ge-jiao-ben-zhong-fang-fa-de-ji-chong-fang-fa/">
        </link>
        <updated>2020-05-12T07:39:30.000Z</updated>
        <content type="html"><![CDATA[<p>1.将要被调用的脚本对象，直接拖到调用者脚本上<br>
之后通过GetComponent&lt;被调用脚本名&gt;().方法名();<br>
直接获取对象上挂载的脚本来调用目标方法。<br>
<img src="https://Wei715547.github.io/post-images/1589269952547.PNG" alt="" loading="lazy"></p>
<p>2.在Hierarchy面板查找目标脚本<br>
FindObjectOfType&lt;脚本名&gt;().方法名();---返回第一个被加载目标脚本</p>
<p>FindObjectsOfType&lt;脚本名&gt;().方法名();---返回所有被加载目标脚本数组<br>
<img src="https://Wei715547.github.io/post-images/1589270757762.PNG" alt="" loading="lazy"></p>
<p>3.单例模式---在被调用的脚本中，公开声明一个静态的该脚本实例，在初始化时使&quot;实例=this&quot;<br>
便于在其他脚本中直接调用该脚本与其中的方法。<br>
<img src="https://Wei715547.github.io/post-images/1589271341241.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1589271396945.PNG" alt="" loading="lazy"></p>
<p>两脚本有碰撞，触发关系时可直接利用<br>
(碰撞)collsion.gameObject.GetComponent&lt;被调用脚本名&gt;().方法名();<br>
(触发)collsion.GetComponent&lt;被调用脚本名&gt;().方法名();<br>
或SendMessage（以”方法名“调用物体中继承 MonoBehaviour 脚本的方法.）<br>
(碰撞)collision.gameObject.SendMessage(&quot;方法名&quot;);<br>
(触发)collsion..SendMessage(&quot;方法名&quot;);<br>
调用对方脚本中的方法<br>
<img src="https://Wei715547.github.io/post-images/1589272112653.PNG" alt="" loading="lazy"></p>
<p>复杂时可使用事件的广播，监听</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[委托，事件，Lamda表达式（对方法的传递/调用）]]></title>
        <id>https://Wei715547.github.io/post/wei-tuo-shi-jian-lamda-biao-da-shi-dui-fang-fa-de-chuan-di-diao-yong/</id>
        <link href="https://Wei715547.github.io/post/wei-tuo-shi-jian-lamda-biao-da-shi-dui-fang-fa-de-chuan-di-diao-yong/">
        </link>
        <updated>2020-05-12T04:19:15.000Z</updated>
        <content type="html"><![CDATA[<p>using System;</p>
<p>namespace 委托<br>
{<br>
class Program<br>
{<br>
//委托类型：定义了委托实例可以调用哪类方法，<br>
//具体来说，委托类型定义了方法的返回值类型了参数<br>
//delegate 要调用方法的返回值类型 委托类型名 (参数)</p>
<pre><code>    //例：定义一个带参数，无返回值的委托
    //（创建的委托必须与索要传递的方法，返回值/参数类型相同）
    public delegate void SayHelloDlg(string content);

    //SayHelloDlg类型的事件
    public static event SayHelloDlg SayHelloEvent;


    //主函数
    static void Main(string[] args)
    {
        //委托的声明
        //委托类型名 = 目标方法
        SayHelloDlg dlg = SayHello;
        //委托的使用方法
        //dlg.Invoke(&quot;老王&quot;);
        dlg(&quot;老王&quot;);            
        //委托的解释：将方法以变量形式传递，并以方法形式执行。(以委托来调用方法，解耦)
        //SayHelloDlg dlg = new SayHelloDlg(SayHello);

        //(多播委托)委托链
        dlg += SayBay;//添加
        dlg(&quot;老八&quot;);  //（实际+,-,+=,-+编译成 System.Delegate的Combine和Remove两个静态方法）
        dlg -= SayBay;//注销
        dlg(&quot;老八&quot;);
        //如果调用的方法有返回值，那么接收的返回值是调用的最后一个方法的返回值，前面调用的方法返回值就被舍弃了。


        //匿名函数
        SayHelloDlg dlg1 = delegate (string name)
        {
            Console.WriteLine(&quot;{0},是匿名函数&quot;, name);
        };

        dlg1(&quot;老七&quot;);


        //lamda语句
        SayHelloDlg dlg2 = (name) =&gt;
         {
             Console.WriteLine(&quot;{0},是lamda语句&quot;, name);
         };

        dlg2(&quot;老四&quot;);

        //事件

        //注册事件
        SayHelloEvent += Program_SayHelloEvent;
        //SayHelloEvent -= Program_SayHelloEvent; 

        if (SayHelloEvent != null)
        {
            SayHelloEvent(&quot;小八&quot;);//调用事件
        }
    }

    private static void Program_SayHelloEvent(string content)
    {
        Console.WriteLine(&quot;{0},是事件&quot;, content);
    }



    public static void SayHello(string name)
    {
        Console.WriteLine(&quot;{0},你好啊&quot;, name);
    }

    //表达式形式
    //public static void SayHello(string name) =&gt; Console.WriteLine(&quot;{0},你好啊&quot;, name);


    public static void SayBay(string name)
    {
        Console.WriteLine(&quot;{0},再见啊&quot;,name);
    }
}
</code></pre>
<p>}</p>
<p><img src="https://Wei715547.github.io/post-images/1589257645974.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1589257654429.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1589257662607.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1589257671087.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1589257676945.PNG" alt="" loading="lazy"><br>
<img src="https://Wei715547.github.io/post-images/1589257683327.PNG" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DG Tweening]]></title>
        <id>https://Wei715547.github.io/post/dg-tweening/</id>
        <link href="https://Wei715547.github.io/post/dg-tweening/">
        </link>
        <updated>2020-05-11T12:17:14.000Z</updated>
        <content type="html"><![CDATA[<p>using System.Collections;<br>
using System.Collections.Generic;<br>
using UnityEngine;<br>
using DG.Tweening;<br>
using UnityEngine.UI;<br>
public class InDoor : MonoBehaviour<br>
{</p>
<pre><code>public GameObject InDoorPanel;

private void Start()
{
    InDoorPanel.GetComponent&lt;Image&gt;().color = new Color(InDoorPanel.GetComponent&lt;Image&gt;().color.r, 
        InDoorPanel.GetComponent&lt;Image&gt;().color.g, InDoorPanel.GetComponent&lt;Image&gt;().color.b, 0);
    InDoorPanel.transform.position = new Vector3(InDoorPanel.transform.position.x,
        -100, InDoorPanel.transform.position.z);
    //InDoorPanel.transform.localScale= Vector3.zero;
    InDoorPanel.SetActive(false);
}

private void OnTriggerEnter2D(Collider2D collision)
{
    if (collision.tag == &quot;Player&quot;)
    {
        InDoorPanel.SetActive(true);
        InDoorPanel.GetComponent&lt;Image&gt;().DOColor(new Color(InDoorPanel.GetComponent&lt;Image&gt;().color.r, 
            InDoorPanel.GetComponent&lt;Image&gt;().color.g, InDoorPanel.GetComponent&lt;Image&gt;().color.b, 0.7f), 0.3f);
        InDoorPanel.transform.DOMoveY(110, 0.3f);
        //InDoorPanel.transform.DOScale(Vector3.one, 0.3f);
    }
}

private void OnTriggerExit2D(Collider2D collision)
{
    if (collision.tag == &quot;Player&quot;)
    {
        InDoorPanel.GetComponent&lt;Image&gt;().DOColor(new Color(InDoorPanel.GetComponent&lt;Image&gt;().color.r, 
            InDoorPanel.GetComponent&lt;Image&gt;().color.g, InDoorPanel.GetComponent&lt;Image&gt;().color.b, 0), 0.3f);
        InDoorPanel.transform.DOMoveY(-100, 0.3f).OnComplete(() =&gt; InDoorPanel.SetActive(false));
        //InDoorPanel.transform.DOScale(Vector3.zero, 0.3f);
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最高分排序]]></title>
        <id>https://Wei715547.github.io/post/zui-gao-fen-pai-xu/</id>
        <link href="https://Wei715547.github.io/post/zui-gao-fen-pai-xu/">
        </link>
        <updated>2020-05-10T04:36:59.000Z</updated>
        <content type="html"><![CDATA[<p>public  void SaveScore (int score)<br>
{<br>
List<int> list = bestScoreArr.ToList();//先将数组转化为List<br>
//系统:Linq方法(using System.Linq;)<br>
list.Sort((x, y) =&gt; (-x.CompareTo(y)));//调用List的Sort方法，从大到小对list进行排序[（-x）(从小到大改为x<br>
bestScoreArr = list.ToArray();//将排好序的list转给数组</p>
<pre><code>    //50  20  10 加入传score为60，则将60排在低 bestScoreArr[0]

    int index = -1;
    for (int i = 0; i &lt; bestScoreArr .Count() ; i++)
    {
        if (score &gt;bestScoreArr [i])//score依次与数组中的数进行对比，当比一个数大时，记录这个数的索引将后面的数都向后移。
        {
            index = i;
        }
    }
    if (index == -1) return;//score比数组中的值都小，不需保存，退出方法。

    for (int i = bestScoreArr .Length -1; i &gt;index ; i--)//从后向前将index之后的数据依次向后移
    {
        bestScoreArr[i] = bestScoreArr[i - 1];

    }
    bestScoreArr[index] = score;//将score填入空出位。
    Save();//保存。
}
//获取最大值方法(Linq)
public int GetBestScore()
{
    return bestScoreArr.Max();
}
</code></pre>
<p>//要存储的游戏数据类<br>
public class GameDate<br>
{<br>
public  static bool IsAgainGame =false ;</p>
<pre><code>private bool isFirstGame;
private bool isMusicOn;

private int[] bestScoreArr;
public void SetBestScoreArr(int[] bestScoreArr)
{
    this.bestScoreArr = bestScoreArr;
}
 public int [] GetBestScoreArr()
{
    return bestScoreArr;
}
//（其他......get;set方法省略）

private int selectSkin;
private bool[] skinUnlocked;
private int diamondCount;
</code></pre>
<p>}</p>
<pre><code>/// &lt;summary&gt;
/// 储存数据
/// &lt;/summary&gt;
private void Save()
{
    try
    {
        BinaryFormatter bf = new BinaryFormatter();
        using (FileStream fs = File.Create(Application.persistentDataPath + &quot;/DameData.data&quot;))

        {
            data.SetBestScoreArr(bestScoreArr);
            data.SetDiamondCount(diamondCount);
            data.SetIsFirstGame(isFirstGame);
            data.SetMusicOn(isMusicOn);
            data.SetSelectSkin(selectSkin);
            data.SetSkinUnlocked(skinUnlocked);
            bf.Serialize(fs, data);

        }
    }
    catch (System.Exception e)
    {
        Debug.Log(e.Message);

    }
}
/// &lt;summary&gt;
/// 读取数据
///using System.Runtime.Serialization.Formatters.Binary;
///using System.IO;
/// &lt;/summary&gt;
private void Read()
{
    try
    {
        BinaryFormatter bf = new BinaryFormatter();
        using (FileStream fs = File .Open (Application.persistentDataPath + &quot;/DameData.data&quot;,FileMode.Open ))
        {
            data = (GameDate )bf.Deserialize(fs);
        }
    }
    catch (System.Exception e)
    {
        Debug.Log(e.Message);
    }
}</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ray]]></title>
        <id>https://Wei715547.github.io/post/ray/</id>
        <link href="https://Wei715547.github.io/post/ray/">
        </link>
        <updated>2020-05-09T11:48:20.000Z</updated>
        <content type="html"><![CDATA[<p>void Update()<br>
{<br>
if (Input.GetMouseButtonDown(1))<br>
{<br>
Ray ray = Camera .main .ScreenPointToRay ( Input.mousePosition);<br>
RaycastHit hit;<br>
if (!Physics.Raycast(ray, out hit))<br>
{<br>
//hit.collider .gameObject //射线打到的物体<br>
return;<br>
}<br>
navMeshAgent.destination = hit.point ;//碰撞点<br>
}</p>
<pre><code>}
![](https://Wei715547.github.io/post-images/1589025091557.jpg)
![](https://Wei715547.github.io/post-images/1589025123139.jpg)</code></pre>
]]></content>
    </entry>
</feed>